'use strict';

var path = require('path');
var chalk = require('chalk');
var webpack = require('webpack');
var ESLintPlugin = require('eslint-webpack-plugin');
var ForkTsCheckerWebpackPlugin = require('fork-ts-checker-webpack-plugin');
var HtmlWebpackPlugin = require('html-webpack-plugin');
var webpack$1 = require('@module-federation/enhanced/webpack');
var cliCommon = require('@backstage/cli-common');
var ModuleScopePlugin = require('react-dev-utils/ModuleScopePlugin');
var runScriptWebpackPlugin = require('run-script-webpack-plugin');
var ReactRefreshPlugin = require('@pmmmwh/react-refresh-webpack-plugin');
var index = require('./index-DmUbBCFk.cjs.js');
var fs = require('fs-extra');
var getPackages = require('@manypkg/get-packages');
var nodeExternals = require('webpack-node-externals');
var pickBy = require('lodash/pickBy');
var entryPoints = require('./entryPoints-CoHH4lBA.cjs.js');
var run = require('./run-CSt1n0F1.cjs.js');
var MiniCssExtractPlugin = require('mini-css-extract-plugin');
var svgrTemplate = require('./svgrTemplate-BTjBQ3by.cjs.js');
var yn = require('yn');
var config = require('@backstage/config');
var chokidar = require('chokidar');
var PQueue = require('p-queue');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var chalk__default = /*#__PURE__*/_interopDefaultCompat(chalk);
var webpack__default = /*#__PURE__*/_interopDefaultCompat(webpack);
var ESLintPlugin__default = /*#__PURE__*/_interopDefaultCompat(ESLintPlugin);
var ForkTsCheckerWebpackPlugin__default = /*#__PURE__*/_interopDefaultCompat(ForkTsCheckerWebpackPlugin);
var HtmlWebpackPlugin__default = /*#__PURE__*/_interopDefaultCompat(HtmlWebpackPlugin);
var ModuleScopePlugin__default = /*#__PURE__*/_interopDefaultCompat(ModuleScopePlugin);
var ReactRefreshPlugin__default = /*#__PURE__*/_interopDefaultCompat(ReactRefreshPlugin);
var fs__default = /*#__PURE__*/_interopDefaultCompat(fs);
var nodeExternals__default = /*#__PURE__*/_interopDefaultCompat(nodeExternals);
var pickBy__default = /*#__PURE__*/_interopDefaultCompat(pickBy);
var MiniCssExtractPlugin__default = /*#__PURE__*/_interopDefaultCompat(MiniCssExtractPlugin);
var yn__default = /*#__PURE__*/_interopDefaultCompat(yn);
var chokidar__default = /*#__PURE__*/_interopDefaultCompat(chokidar);
var PQueue__default = /*#__PURE__*/_interopDefaultCompat(PQueue);

class LinkedPackageResolvePlugin {
  constructor(targetModules, packages) {
    this.targetModules = targetModules;
    this.packages = packages;
  }
  apply(resolver) {
    resolver.hooks.resolve.tapAsync(
      "LinkedPackageResolvePlugin",
      (data, context, callback) => {
        const pkg = this.packages.find(
          (pkge) => data.path && cliCommon.isChildPath(pkge.dir, data.path)
        );
        if (!pkg) {
          callback();
          return;
        }
        const modulesLocation = path.resolve(
          this.targetModules,
          pkg.packageJson.name
        );
        const newContext = data.context?.issuer ? {
          ...data.context,
          issuer: data.context.issuer.replace(pkg.dir, modulesLocation)
        } : data.context;
        resolver.doResolve(
          resolver.hooks.resolve,
          {
            ...data,
            context: newContext,
            path: data.path && data.path.replace(pkg.dir, modulesLocation)
          },
          `resolve ${data.request} in ${modulesLocation}`,
          context,
          callback
        );
      }
    );
  }
}

const { EsbuildPlugin } = require("esbuild-loader");
const optimization = (options) => {
  const { isDev } = options;
  return {
    minimize: !isDev,
    minimizer: [
      new EsbuildPlugin({
        target: "ES2022",
        format: "iife",
        exclude: "remoteEntry.js"
      }),
      // Avoid iife wrapping of module federation remote entry as it breaks the variable assignment
      new EsbuildPlugin({
        target: "ES2022",
        format: void 0,
        include: "remoteEntry.js"
      })
    ],
    runtimeChunk: "single",
    splitChunks: {
      automaticNameDelimiter: "-",
      cacheGroups: {
        default: false,
        // Put all vendor code needed for initial page load in individual files if they're big
        // enough, if they're smaller they end up in the main
        packages: {
          chunks: "initial",
          test(module) {
            return Boolean(
              module?.resource?.match(/[\\/]node_modules[\\/](.*?)([\\/]|$)/)
            );
          },
          name(module) {
            const packageName = module.resource.match(
              /[\\/]node_modules[\\/](.*?)([\\/]|$)/
            )[1];
            return packageName.replace("@", "");
          },
          filename: isDev ? "module-[name].js" : "static/module-[name].[chunkhash:8].js",
          priority: 10,
          minSize: 1e5,
          minChunks: 1,
          maxAsyncRequests: Infinity,
          maxInitialRequests: Infinity
        },
        // filename is not included in type, but we need it
        // Group together the smallest modules
        vendor: {
          chunks: "initial",
          test: /[\\/]node_modules[\\/]/,
          name: "vendor",
          priority: 5,
          enforce: true
        }
      }
    }
  };
};

const transforms = (options) => {
  const { isDev, isBackend } = options;
  function insertBeforeJssStyles(element) {
    const head = document.head;
    const firstJssNode = head.querySelector("style[data-jss]");
    if (!firstJssNode) {
      head.appendChild(element);
    } else {
      head.insertBefore(element, firstJssNode);
    }
  }
  const loaders = [
    {
      test: /\.(tsx?)$/,
      exclude: /node_modules/,
      use: [
        {
          loader: require.resolve("swc-loader"),
          options: {
            jsc: {
              target: "es2022",
              externalHelpers: !isBackend,
              parser: {
                syntax: "typescript",
                tsx: !isBackend,
                dynamicImport: true
              },
              transform: {
                react: isBackend ? void 0 : {
                  runtime: "automatic",
                  refresh: isDev
                }
              }
            }
          }
        }
      ]
    },
    {
      test: /\.(jsx?|mjs|cjs)$/,
      exclude: /node_modules/,
      use: [
        {
          loader: require.resolve("swc-loader"),
          options: {
            jsc: {
              target: "es2022",
              externalHelpers: !isBackend,
              parser: {
                syntax: "ecmascript",
                jsx: !isBackend,
                dynamicImport: true
              },
              transform: {
                react: isBackend ? void 0 : {
                  runtime: "automatic",
                  refresh: isDev
                }
              }
            }
          }
        }
      ]
    },
    {
      test: /\.(js|mjs|cjs)$/,
      resolve: {
        fullySpecified: false
      }
    },
    {
      test: [/\.icon\.svg$/],
      use: [
        {
          loader: require.resolve("swc-loader"),
          options: {
            jsc: {
              target: "es2022",
              externalHelpers: !isBackend,
              parser: {
                syntax: "ecmascript",
                jsx: !isBackend,
                dynamicImport: true
              }
            }
          }
        },
        {
          loader: require.resolve("@svgr/webpack"),
          options: { babel: false, template: svgrTemplate.svgrTemplate }
        }
      ]
    },
    {
      test: [
        /\.bmp$/,
        /\.gif$/,
        /\.jpe?g$/,
        /\.png$/,
        /\.frag$/,
        /\.vert$/,
        { and: [/\.svg$/, { not: [/\.icon\.svg$/] }] },
        /\.xml$/,
        /\.ico$/
      ],
      type: "asset/resource",
      generator: {
        filename: "static/[name].[hash:8].[ext]"
      }
    },
    {
      test: /\.(eot|woff|woff2|ttf)$/i,
      type: "asset/resource",
      generator: {
        filename: "static/[name].[hash][ext][query]"
      }
    },
    {
      test: /\.ya?ml$/,
      use: require.resolve("yml-loader")
    },
    {
      include: /\.(md)$/,
      type: "asset/resource",
      generator: {
        filename: "static/[name].[hash][ext][query]"
      }
    },
    {
      test: /\.css$/i,
      use: [
        isDev ? {
          loader: require.resolve("style-loader"),
          options: {
            insert: insertBeforeJssStyles
          }
        } : MiniCssExtractPlugin__default.default.loader,
        {
          loader: require.resolve("css-loader"),
          options: {
            sourceMap: true
          }
        }
      ]
    }
  ];
  const plugins = new Array();
  if (!isDev) {
    plugins.push(
      new MiniCssExtractPlugin__default.default({
        filename: "static/[name].[contenthash:8].css",
        chunkFilename: "static/[name].[id].[contenthash:8].css",
        insert: insertBeforeJssStyles
        // Only applies to async chunks
      })
    );
  }
  return { loaders, plugins };
};

function hasReactDomClient() {
  try {
    require.resolve("react-dom/client");
    return true;
  } catch {
    return false;
  }
}

const BUILD_CACHE_ENV_VAR = "BACKSTAGE_CLI_EXPERIMENTAL_BUILD_CACHE";
function resolveBaseUrl(config, moduleFederation) {
  const baseUrl = config.getOptionalString("app.baseUrl");
  const defaultBaseUrl = moduleFederation?.mode === "remote" ? `http://localhost:${process.env.PORT ?? "3000"}` : "http://localhost:3000";
  try {
    return new URL(baseUrl ?? "/", defaultBaseUrl);
  } catch (error) {
    throw new Error(`Invalid app.baseUrl, ${error}`);
  }
}
function resolveEndpoint(config, moduleFederation) {
  const url = resolveBaseUrl(config, moduleFederation);
  return {
    host: config.getOptionalString("app.listen.host") ?? url.hostname,
    port: config.getOptionalNumber("app.listen.port") ?? Number(url.port) ?? (url.protocol === "https:" ? 443 : 80)
  };
}
async function readBuildInfo() {
  const timestamp = Date.now();
  let commit;
  try {
    commit = await run.runPlain("git", "rev-parse", "HEAD");
  } catch (error) {
  }
  let gitVersion;
  try {
    gitVersion = await run.runPlain("git", "describe", "--always");
  } catch (error) {
  }
  if (commit === void 0 || gitVersion === void 0) {
    console.info(
      "NOTE: Did not compute git version or commit hash, could not execute the git command line utility"
    );
  }
  const { version: packageVersion } = await fs__default.default.readJson(
    index.paths.resolveTarget("package.json")
  );
  return {
    cliVersion: index.version,
    gitVersion: gitVersion ?? "unknown",
    packageVersion,
    timestamp,
    commit: commit ?? "unknown"
  };
}
async function createConfig(paths, options) {
  const {
    checksEnabled,
    isDev,
    frontendConfig,
    moduleFederation,
    publicSubPath = ""
  } = options;
  const { plugins, loaders } = transforms(options);
  const { packages } = await getPackages.getPackages(index.paths.targetDir);
  const externalPkgs = packages.filter((p) => !cliCommon.isChildPath(paths.root, p.dir));
  const validBaseUrl = resolveBaseUrl(frontendConfig, moduleFederation);
  let publicPath = validBaseUrl.pathname.replace(/\/$/, "");
  if (publicSubPath) {
    publicPath = `${publicPath}${publicSubPath}`.replace("//", "/");
  }
  if (isDev) {
    const { host, port } = resolveEndpoint(
      options.frontendConfig,
      options.moduleFederation
    );
    plugins.push(
      new ReactRefreshPlugin__default.default({
        overlay: {
          sockProtocol: "ws",
          sockHost: host,
          sockPort: port
        }
      })
    );
  }
  if (checksEnabled) {
    plugins.push(
      new ForkTsCheckerWebpackPlugin__default.default({
        typescript: { configFile: paths.targetTsConfig, memoryLimit: 4096 }
      }),
      new ESLintPlugin__default.default({
        context: paths.targetPath,
        files: ["**/*.(ts|tsx|mts|cts|js|jsx|mjs|cjs)"]
      })
    );
  }
  plugins.push(
    new webpack.ProvidePlugin({
      process: require.resolve("process/browser"),
      Buffer: ["buffer", "Buffer"]
    })
  );
  if (options.moduleFederation?.mode !== "remote") {
    plugins.push(
      new HtmlWebpackPlugin__default.default({
        meta: {
          "backstage-app-mode": options?.appMode ?? "public"
        },
        template: paths.targetHtml,
        templateParameters: {
          publicPath,
          config: frontendConfig
        }
      })
    );
    plugins.push(
      new HtmlWebpackPlugin__default.default({
        meta: {
          "backstage-app-mode": options?.appMode ?? "public",
          // This is added to be written in the later step, and finally read by the extra entry point
          "backstage-public-path": "<%= publicPath %>/"
        },
        minify: false,
        publicPath: "<%= publicPath %>",
        filename: "index.html.tmpl",
        template: `raw-loader!${paths.targetHtml}`
      })
    );
  }
  if (options.moduleFederation) {
    const isRemote = options.moduleFederation?.mode === "remote";
    plugins.push(
      new webpack$1.ModuleFederationPlugin({
        ...isRemote && {
          filename: "remoteEntry.js",
          exposes: {
            ".": paths.targetEntry
          }
        },
        name: options.moduleFederation.name,
        runtime: false,
        shared: {
          // React
          react: {
            singleton: true,
            requiredVersion: "*",
            eager: !isRemote
          },
          "react-dom": {
            singleton: true,
            requiredVersion: "*",
            eager: !isRemote
          },
          // React Router
          "react-router": {
            singleton: true,
            requiredVersion: "*",
            eager: !isRemote
          },
          "react-router-dom": {
            singleton: true,
            requiredVersion: "*",
            eager: !isRemote
          },
          // MUI v4
          "@material-ui/core/styles": {
            singleton: true,
            requiredVersion: "*",
            eager: !isRemote
          },
          "@material-ui/styles": {
            singleton: true,
            requiredVersion: "*",
            eager: !isRemote
          },
          // MUI v5
          "@mui/material/styles/": {
            singleton: true,
            requiredVersion: "*",
            eager: !isRemote
          },
          "@emotion/react": {
            singleton: true,
            requiredVersion: "*",
            eager: !isRemote
          }
        }
      })
    );
  }
  const buildInfo = await readBuildInfo();
  plugins.push(
    new webpack__default.default.DefinePlugin({
      "process.env.BUILD_INFO": JSON.stringify(buildInfo),
      "process.env.APP_CONFIG": webpack__default.default.DefinePlugin.runtimeValue(
        () => JSON.stringify(options.getFrontendAppConfigs()),
        true
      ),
      // This allows for conditional imports of react-dom/client, since there's no way
      // to check for presence of it in source code without module resolution errors.
      "process.env.HAS_REACT_DOM_CLIENT": JSON.stringify(hasReactDomClient())
    })
  );
  const reactRefreshFiles = [
    require.resolve(
      "@pmmmwh/react-refresh-webpack-plugin/lib/runtime/RefreshUtils.js"
    ),
    require.resolve("@pmmmwh/react-refresh-webpack-plugin/overlay/index.js"),
    require.resolve("react-refresh")
  ];
  const mode = isDev ? "development" : "production";
  const optimization$1 = optimization(options);
  if (mode === "production" && process.env.EXPERIMENTAL_MODULE_FEDERATION && process.env.FORCE_REACT_DEVELOPMENT) {
    console.log(
      chalk__default.default.yellow(
        `\u26A0\uFE0F  WARNING: Forcing react and react-dom into development mode. This build should not be used in production.`
      )
    );
    const reactPackageDirs = [
      `${path.dirname(require.resolve("react/package.json"))}/`,
      `${path.dirname(require.resolve("react-dom/package.json"))}/`
    ];
    optimization$1.nodeEnv = false;
    plugins.push(
      new webpack__default.default.DefinePlugin({
        "process.env.NODE_ENV": webpack__default.default.DefinePlugin.runtimeValue(
          ({ module }) => {
            if (reactPackageDirs.some((val) => module.resource.startsWith(val))) {
              return '"development"';
            }
            return `"${mode}"`;
          }
        )
      })
    );
  }
  const withCache = yn__default.default(process.env[BUILD_CACHE_ENV_VAR], { default: false });
  return {
    mode,
    profile: false,
    ...isDev ? {
      watchOptions: {
        ignored: /node_modules/
      }
    } : {},
    optimization: optimization$1,
    bail: false,
    performance: {
      hints: false
      // we check the gzip size instead
    },
    devtool: isDev ? "eval-cheap-module-source-map" : "source-map",
    context: paths.targetPath,
    entry: [
      require.resolve("@backstage/cli/config/webpack-public-path"),
      ...options.additionalEntryPoints ?? [],
      paths.targetEntry
    ],
    resolve: {
      extensions: [".ts", ".tsx", ".mjs", ".js", ".jsx", ".json", ".wasm"],
      mainFields: ["browser", "module", "main"],
      fallback: {
        ...pickBy__default.default(require("node-libs-browser")),
        module: false,
        dgram: false,
        dns: false,
        fs: false,
        http2: false,
        net: false,
        tls: false,
        child_process: false,
        /* new ignores */
        path: false,
        https: false,
        http: false,
        util: require.resolve("util/")
      },
      plugins: [
        new LinkedPackageResolvePlugin(paths.rootNodeModules, externalPkgs),
        new ModuleScopePlugin__default.default(
          [paths.targetSrc, paths.targetDev],
          [paths.targetPackageJson, ...reactRefreshFiles]
        )
      ]
    },
    module: {
      rules: loaders
    },
    output: {
      uniqueName: options.moduleFederation?.name,
      path: paths.targetDist,
      publicPath: options.moduleFederation?.mode === "remote" ? "auto" : `${publicPath}/`,
      filename: isDev ? "[name].js" : "static/[name].[fullhash:8].js",
      chunkFilename: isDev ? "[name].chunk.js" : "static/[name].[chunkhash:8].chunk.js",
      ...isDev ? {
        devtoolModuleFilenameTemplate: (info) => `file:///${path.resolve(info.absoluteResourcePath).replace(
          /\\/g,
          "/"
        )}`
      } : {}
    },
    experiments: {
      lazyCompilation: yn__default.default(process.env.EXPERIMENTAL_LAZY_COMPILATION)
    },
    plugins,
    ...withCache ? {
      cache: {
        type: "filesystem",
        buildDependencies: {
          config: [__filename]
        }
      }
    } : {}
  };
}
async function createBackendConfig(paths, options) {
  const { checksEnabled, isDev } = options;
  const { packages } = await getPackages.getPackages(index.paths.targetDir);
  const localPackageEntryPoints = packages.flatMap((p) => {
    const entryPoints$1 = entryPoints.readEntryPoints(p.packageJson);
    return entryPoints$1.map((e) => path.posix.join(p.packageJson.name, e.mount));
  });
  const moduleDirs = packages.map((p) => path.resolve(p.dir, "node_modules"));
  const externalPkgs = packages.filter((p) => !cliCommon.isChildPath(paths.root, p.dir));
  const { loaders } = transforms({ ...options, isBackend: true });
  const runScriptNodeArgs = new Array();
  if (options.inspectEnabled) {
    const inspect = typeof options.inspectEnabled === "string" ? `--inspect=${options.inspectEnabled}` : "--inspect";
    runScriptNodeArgs.push(inspect);
  } else if (options.inspectBrkEnabled) {
    const inspect = typeof options.inspectBrkEnabled === "string" ? `--inspect-brk=${options.inspectBrkEnabled}` : "--inspect-brk";
    runScriptNodeArgs.push(inspect);
  }
  if (options.require) {
    runScriptNodeArgs.push(`--require=${options.require}`);
  }
  return {
    mode: isDev ? "development" : "production",
    profile: false,
    ...isDev ? {
      watch: true,
      watchOptions: {
        ignored: /node_modules\/(?!\@backstage)/
      }
    } : {},
    externals: [
      nodeExternalsWithResolve({
        modulesDir: paths.rootNodeModules,
        additionalModuleDirs: moduleDirs,
        allowlist: ["webpack/hot/poll?100", ...localPackageEntryPoints]
      })
    ],
    target: "node",
    node: {
      /* eslint-disable-next-line no-restricted-syntax */
      __dirname: true,
      __filename: true,
      global: true
    },
    bail: false,
    performance: {
      hints: false
      // we check the gzip size instead
    },
    devtool: isDev ? "eval-cheap-module-source-map" : "source-map",
    context: paths.targetPath,
    entry: [
      "webpack/hot/poll?100",
      paths.targetRunFile ? paths.targetRunFile : paths.targetEntry
    ],
    resolve: {
      extensions: [".ts", ".mjs", ".js", ".json"],
      mainFields: ["main"],
      modules: [paths.rootNodeModules, ...moduleDirs],
      plugins: [
        new LinkedPackageResolvePlugin(paths.rootNodeModules, externalPkgs),
        new ModuleScopePlugin__default.default(
          [paths.targetSrc, paths.targetDev],
          [paths.targetPackageJson]
        )
      ]
    },
    module: {
      rules: loaders
    },
    output: {
      path: paths.targetDist,
      filename: isDev ? "[name].js" : "[name].[hash:8].js",
      chunkFilename: isDev ? "[name].chunk.js" : "[name].[chunkhash:8].chunk.js",
      ...isDev ? {
        devtoolModuleFilenameTemplate: (info) => `file:///${path.resolve(info.absoluteResourcePath).replace(
          /\\/g,
          "/"
        )}`
      } : {}
    },
    plugins: [
      new runScriptWebpackPlugin.RunScriptWebpackPlugin({
        name: "main.js",
        nodeArgs: runScriptNodeArgs.length > 0 ? runScriptNodeArgs : void 0,
        args: process.argv.slice(3)
        // drop `node backstage-cli backend:dev`
      }),
      new webpack__default.default.HotModuleReplacementPlugin(),
      ...checksEnabled ? [
        new ForkTsCheckerWebpackPlugin__default.default({
          typescript: { configFile: paths.targetTsConfig }
        }),
        new ESLintPlugin__default.default({
          files: ["**/*.(ts|tsx|mts|cts|js|jsx|mjs|cjs)"]
        })
      ] : []
    ]
  };
}
function nodeExternalsWithResolve(options) {
  let currentContext;
  const externals = nodeExternals__default.default({
    ...options,
    importType(request) {
      const resolved = require.resolve(request, {
        paths: [currentContext]
      });
      return `commonjs ${resolved}`;
    }
  });
  return ({ context, request }, callback) => {
    currentContext = context;
    return externals(context, request, callback);
  };
}

function resolveBundlingPaths(options) {
  const { entry, targetDir = index.paths.targetDir } = options;
  const resolveTargetModule = (pathString) => {
    for (const ext of ["mjs", "js", "ts", "tsx", "jsx"]) {
      const filePath = path.resolve(targetDir, `${pathString}.${ext}`);
      if (fs__default.default.pathExistsSync(filePath)) {
        return filePath;
      }
    }
    return path.resolve(targetDir, `${pathString}.js`);
  };
  let targetPublic = void 0;
  let targetHtml = path.resolve(targetDir, "public/index.html");
  if (fs__default.default.pathExistsSync(targetHtml)) {
    targetPublic = path.resolve(targetDir, "public");
  } else {
    targetHtml = path.resolve(targetDir, `${entry}.html`);
    if (!fs__default.default.pathExistsSync(targetHtml)) {
      targetHtml = index.paths.resolveOwn("templates/serve_index.html");
    }
  }
  const targetRunFile = path.resolve(targetDir, "src/run.ts");
  const runFileExists = fs__default.default.pathExistsSync(targetRunFile);
  return {
    targetHtml,
    targetPublic,
    targetPath: path.resolve(targetDir, "."),
    targetRunFile: runFileExists ? targetRunFile : void 0,
    targetDist: path.resolve(targetDir, options.dist ?? "dist"),
    targetAssets: path.resolve(targetDir, "assets"),
    targetSrc: path.resolve(targetDir, "src"),
    targetDev: path.resolve(targetDir, "dev"),
    targetEntry: resolveTargetModule(entry),
    targetTsConfig: index.paths.resolveTargetRoot("tsconfig.json"),
    targetPackageJson: path.resolve(targetDir, "package.json"),
    rootNodeModules: index.paths.resolveTargetRoot("node_modules"),
    root: index.paths.targetRoot
  };
}
async function resolveOptionalBundlingPaths(options) {
  const resolvedPaths = resolveBundlingPaths(options);
  if (await fs__default.default.pathExists(resolvedPaths.targetEntry)) {
    return resolvedPaths;
  }
  return void 0;
}

const DETECTED_MODULES_MODULE_NAME = "__backstage-autodetected-plugins__";
function readPackageDetectionConfig(config$1) {
  const packages = config$1.getOptional("app.experimental.packages");
  if (packages === void 0 || packages === null) {
    return void 0;
  }
  if (typeof packages === "string") {
    if (packages !== "all") {
      throw new Error(
        `Invalid app.experimental.packages mode, got '${packages}', expected 'all'`
      );
    }
    return {};
  }
  if (typeof packages !== "object" || Array.isArray(packages)) {
    throw new Error(
      "Invalid config at 'app.experimental.packages', expected object"
    );
  }
  const packagesConfig = new config.ConfigReader(
    packages,
    "app.experimental.packages"
  );
  return {
    include: packagesConfig.getOptionalStringArray("include"),
    exclude: packagesConfig.getOptionalStringArray("exclude")
  };
}
async function detectPackages(targetPath, { include, exclude }) {
  const pkg = await fs__default.default.readJson(
    path.resolve(targetPath, "package.json")
  );
  return Object.keys(pkg.dependencies ?? {}).flatMap((depName) => {
    if (exclude?.includes(depName)) {
      return [];
    }
    if (include && !include.includes(depName)) {
      return [];
    }
    try {
      const depPackageJson = require(require.resolve(
        `${depName}/package.json`,
        { paths: [targetPath] }
      ));
      if (["frontend-plugin", "frontend-plugin-module"].includes(
        depPackageJson.backstage?.role ?? ""
      )) {
        const exp = depPackageJson.exports;
        if (exp && typeof exp === "object" && "./alpha" in exp) {
          return [
            { name: depName, import: depName },
            { name: depName, export: "./alpha", import: `${depName}/alpha` }
          ];
        }
        return [{ name: depName, import: depName }];
      }
    } catch {
    }
    return [];
  });
}
const writeQueue = new PQueue__default.default({ concurrency: 1 });
async function writeDetectedPackagesModule(pkgs) {
  const requirePackageScript = pkgs?.map(
    (pkg) => `{ name: ${JSON.stringify(pkg.name)}, export: ${JSON.stringify(
      pkg.export
    )}, default: require('${pkg.import}').default }`
  ).join(",");
  await writeQueue.add(
    () => fs__default.default.writeFile(
      path.join(
        index.paths.targetRoot,
        "node_modules",
        `${DETECTED_MODULES_MODULE_NAME}.js`
      ),
      `window['__@backstage/discovered__'] = { modules: [${requirePackageScript}] };`
    )
  );
}
async function createDetectedModulesEntryPoint(options) {
  const { config, watch, targetPath } = options;
  const detectionConfig = readPackageDetectionConfig(config);
  if (!detectionConfig) {
    return [];
  }
  if (watch) {
    const watcher = chokidar__default.default.watch(path.resolve(targetPath, "package.json"));
    watcher.on("change", async () => {
      await writeDetectedPackagesModule(
        await detectPackages(targetPath, detectionConfig)
      );
      watch();
    });
  }
  await writeDetectedPackagesModule(
    await detectPackages(targetPath, detectionConfig)
  );
  return [DETECTED_MODULES_MODULE_NAME];
}

function getModuleFederationOptions(name, isModuleFederationRemote) {
  if (!isModuleFederationRemote && !process.env.EXPERIMENTAL_MODULE_FEDERATION) {
    return void 0;
  }
  console.log(
    chalk__default.default.yellow(
      `\u26A0\uFE0F  WARNING: Module federation is experimental and will receive immediate breaking changes in the future.`
    )
  );
  return {
    mode: isModuleFederationRemote ? "remote" : "host",
    // The default output mode requires the name to be a usable as a code
    // symbol, there might be better options here but for now we need to
    // sanitize the name.
    name: name.replaceAll("@", "").replaceAll("/", "__").replaceAll("-", "_")
  };
}

exports.createBackendConfig = createBackendConfig;
exports.createConfig = createConfig;
exports.createDetectedModulesEntryPoint = createDetectedModulesEntryPoint;
exports.getModuleFederationOptions = getModuleFederationOptions;
exports.hasReactDomClient = hasReactDomClient;
exports.resolveBaseUrl = resolveBaseUrl;
exports.resolveBundlingPaths = resolveBundlingPaths;
exports.resolveEndpoint = resolveEndpoint;
exports.resolveOptionalBundlingPaths = resolveOptionalBundlingPaths;
//# sourceMappingURL=moduleFederation-8XXecxLD.cjs.js.map
