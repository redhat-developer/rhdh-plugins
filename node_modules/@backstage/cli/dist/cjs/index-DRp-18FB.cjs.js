'use strict';

var chalk = require('chalk');
var inquirer = require('inquirer');
var tasks = require('./tasks-DtAiMv5G.cjs.js');
var oauthApp = require('@octokit/oauth-app');
var fs = require('fs-extra');
var yaml = require('yaml');
var cliCommon = require('@backstage/cli-common');
var path = require('path');
var differ = require('diff');
var config = require('./config-BMsjTUVf.cjs.js');
var catalogModel = require('@backstage/catalog-model');
var z = require('zod');
var integration = require('@backstage/integration');
var graphql = require('@octokit/graphql');
var parseGitUrl = require('git-url-parse');
var fetch = require('node-fetch');
require('handlebars');
require('ora');
require('util');
require('recursive-readdir');
require('child_process');
require('@backstage/errors');
require('./index-DmUbBCFk.cjs.js');
require('commander');
require('semver');
require('@backstage/config-loader');
require('@backstage/config');
require('@manypkg/get-packages');
require('@backstage/cli-node');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

function _interopNamespaceCompat(e) {
  if (e && typeof e === 'object' && 'default' in e) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var chalk__default = /*#__PURE__*/_interopDefaultCompat(chalk);
var inquirer__default = /*#__PURE__*/_interopDefaultCompat(inquirer);
var fs__namespace = /*#__PURE__*/_interopNamespaceCompat(fs);
var yaml__default = /*#__PURE__*/_interopDefaultCompat(yaml);
var path__namespace = /*#__PURE__*/_interopNamespaceCompat(path);
var differ__namespace = /*#__PURE__*/_interopNamespaceCompat(differ);
var z__default = /*#__PURE__*/_interopDefaultCompat(z);
var parseGitUrl__default = /*#__PURE__*/_interopDefaultCompat(parseGitUrl);
var fetch__default = /*#__PURE__*/_interopDefaultCompat(fetch);

const readYaml = async (file) => {
  return yaml__default.default.parse(await fs__namespace.readFile(file, "utf8"));
};
const updateConfigFile = async (file, config) => {
  const staticContent = "# Backstage override configuration for your local development environment \n";
  const content = fs__namespace.existsSync(file) ? yaml__default.default.stringify(
    { ...await readYaml(file), ...config },
    {
      indent: 2
    }
  ) : staticContent.concat(
    yaml__default.default.stringify(
      { ...config },
      {
        indent: 2
      }
    )
  );
  return await fs__namespace.writeFile(file, content, "utf8");
};

const { targetRoot: targetRoot$1, ownDir } = cliCommon.findPaths(__dirname);
const APP_CONFIG_FILE = path__namespace.join(targetRoot$1, "app-config.local.yaml");
const DISCOVERED_ENTITIES_FILE = path__namespace.join(
  targetRoot$1,
  "examples",
  "discovered-entities.yaml"
);
const PATCH_FOLDER = path__namespace.join(
  ownDir,
  "src",
  "commands",
  "onboard",
  "auth",
  "patches"
);

const { targetRoot } = cliCommon.findPaths(__dirname);
const patch = async (patchFile) => {
  const patchContent = await fs__namespace.readFile(
    path__namespace.join(PATCH_FOLDER, patchFile),
    "utf8"
  );
  const targetName = patchContent.split("\n")[0].replace("--- a", "");
  const targetFile = path__namespace.join(targetRoot, targetName);
  const oldContent = await fs__namespace.readFile(targetFile, "utf8");
  const newContent = differ__namespace.applyPatch(oldContent, patchContent);
  if (!newContent) {
    throw new Error(
      `Patch ${patchFile} was not applied correctly.
       Did you change ${targetName} manually before running this command?`
    );
  }
  return await fs__namespace.writeFile(targetFile, newContent, "utf8");
};

const validateCredentials = async (clientId, clientSecret) => {
  try {
    const app = new oauthApp.OAuthApp({
      clientId,
      clientSecret
    });
    await app.createToken({
      code: "%NOT-VALID-CODE%"
    });
  } catch (error) {
    if (error.response.status !== 200 && error.response.data.error !== "bad_verification_code") {
      throw new Error(`Validating GitHub Credentials failed.`);
    }
  }
};
const getConfig$2 = (answers) => {
  const { clientId, clientSecret, hasEnterprise, enterpriseInstanceUrl } = answers;
  return {
    auth: {
      providers: {
        github: {
          development: {
            clientId,
            clientSecret,
            ...hasEnterprise && {
              enterpriseInstanceUrl
            }
          }
        }
      }
    }
  };
};
const github$1 = async () => {
  tasks.Task.log(`
    To add GitHub authentication, you must create an OAuth App from the GitHub developer settings: ${chalk__default.default.blue(
    "https://github.com/settings/developers"
  )}
    The Homepage URL should point to Backstage's frontend, while the Authorization callback URL will point to the auth backend.

    Settings for local development:
    ${chalk__default.default.cyan(`
      Homepage URL: http://localhost:3000
      Authorization callback URL: http://localhost:7007/api/auth/github/handler/frame`)}

    You can find the full documentation page here: ${chalk__default.default.blue(
    "https://backstage.io/docs/auth/github/provider"
  )}
    `);
  const answers = await inquirer__default.default.prompt([
    {
      type: "input",
      name: "clientId",
      message: "What is your Client Id?",
      validate: (input) => input.length ? true : false
    },
    {
      type: "input",
      name: "clientSecret",
      message: "What is your Client Secret?",
      validate: (input) => input.length ? true : false
    },
    {
      type: "confirm",
      name: "hasEnterprise",
      message: "Are you using GitHub Enterprise?"
    },
    {
      type: "input",
      name: "enterpriseInstanceUrl",
      message: "What is your URL for GitHub Enterprise?",
      when: ({ hasEnterprise }) => hasEnterprise,
      validate: (input) => Boolean(new URL(input))
    }
  ]);
  const { clientId, clientSecret } = answers;
  const config = getConfig$2(answers);
  tasks.Task.log("Setting up GitHub Authentication for you...");
  await tasks.Task.forItem(
    "Validating",
    "credentials",
    async () => await validateCredentials(clientId, clientSecret)
  );
  await tasks.Task.forItem(
    "Updating",
    APP_CONFIG_FILE,
    async () => await updateConfigFile(APP_CONFIG_FILE, config)
  );
  const patches = await fs__namespace.readdir(PATCH_FOLDER);
  for (const patchFile of patches.filter((p) => p.includes("github"))) {
    await tasks.Task.forItem("Patching", patchFile, async () => {
      await patch(patchFile);
    });
  }
  return answers;
};

const getConfig$1 = (answers) => {
  const { clientId, clientSecret, hasAudience, audience } = answers;
  return {
    auth: {
      providers: {
        gitlab: {
          development: {
            clientId,
            clientSecret,
            ...hasAudience && {
              audience
            }
          }
        }
      }
    }
  };
};
const gitlab = async () => {
  tasks.Task.log(`
    To add GitLab authentication, you must create an Application from the GitLab Settings: ${chalk__default.default.blue(
    "https://gitlab.com/-/profile/applications"
  )}
    The Redirect URI should point to your Backstage backend auth handler.

    Settings for local development:
    ${chalk__default.default.cyan(`
        Name: Backstage (or your custom app name)
        Redirect URI: http://localhost:7007/api/auth/gitlab/handler/frame
        Scopes: read_api and read_user`)}

    You can find the full documentation page here: ${chalk__default.default.blue(
    "https://backstage.io/docs/auth/gitlab/provider"
  )}
    `);
  const answers = await inquirer__default.default.prompt([
    {
      type: "input",
      name: "clientId",
      message: "What is your Application Id?",
      validate: (input) => input.length ? true : false
    },
    {
      type: "input",
      name: "clientSecret",
      message: "What is your Application Secret?",
      validate: (input) => input.length ? true : false
    },
    {
      type: "confirm",
      name: "hasAudience",
      message: "Do you have a self-hosted instance of GitLab?"
    },
    {
      type: "input",
      name: "audience",
      message: "What is the URL for your GitLab instance?",
      when: ({ hasAudience }) => hasAudience,
      validate: (input) => Boolean(new URL(input))
    }
  ]);
  const config = getConfig$1(answers);
  tasks.Task.log("Setting up GitLab Authentication for you...");
  await tasks.Task.forItem(
    "Updating",
    APP_CONFIG_FILE,
    async () => await updateConfigFile(APP_CONFIG_FILE, config)
  );
  const patches = await fs__namespace.readdir(PATCH_FOLDER);
  for (const patchFile of patches.filter((p) => p.includes("gitlab"))) {
    await tasks.Task.forItem("Patching", patchFile, async () => {
      await patch(patchFile);
    });
  }
  return answers;
};

async function auth() {
  const answers = await inquirer__default.default.prompt([
    {
      type: "list",
      name: "provider",
      message: "Please select an authentication provider:",
      choices: ["GitHub", "GitLab"]
    }
  ]);
  const { provider } = answers;
  let providerAnswers;
  switch (provider) {
    case "GitHub": {
      providerAnswers = await github$1();
      break;
    }
    case "GitLab": {
      providerAnswers = await gitlab();
      break;
    }
    default:
      throw new Error(`Provider ${provider} not implemented yet.`);
  }
  tasks.Task.log();
  tasks.Task.log(`Done setting up ${provider} Authentication!`);
  tasks.Task.log();
  return {
    provider,
    answers: providerAnswers
  };
}

const getConfig = ({
  hasEnterprise,
  apiBaseUrl,
  host,
  token
}) => ({
  integrations: {
    github: [
      {
        host,
        token,
        ...hasEnterprise && {
          apiBaseUrl
        }
      }
    ]
  }
});
const github = async (providerAnswers) => {
  const answers = await inquirer__default.default.prompt([
    {
      type: "confirm",
      name: "hasEnterprise",
      message: "Are you using GitHub Enterprise?",
      when: () => typeof providerAnswers === "undefined"
    },
    {
      type: "input",
      name: "enterpriseInstanceUrl",
      message: "What is your URL for GitHub Enterprise?",
      when: ({ hasEnterprise }) => hasEnterprise,
      validate: (input) => Boolean(new URL(input))
    },
    {
      type: "input",
      name: "apiBaseUrl",
      message: "What is your GitHub Enterprise API path?",
      default: "/api/v3",
      when: ({ hasEnterprise }) => hasEnterprise || providerAnswers?.hasEnterprise
      // TODO(tudi2d): Fetch API using OAuth Token if Auth was set up
    }
  ]);
  const host = new URL(
    providerAnswers?.enterpriseInstanceUrl ?? answers?.enterpriseInstanceUrl ?? "http://github.com"
  );
  tasks.Task.log(`
      To create new repositories in GitHub using Software Templates you first need to create a personal access token: ${chalk__default.default.blue(
    `${host.origin}/settings/tokens/new`
  )}
  
      Select the following scopes:

      Reading software components:${chalk__default.default.cyan(`
            - "repo"`)}
            
      Reading organization data:${chalk__default.default.cyan(`
            - "read:org"
            - "read:user"
            - "user:email"`)}

      Publishing software templates:${chalk__default.default.cyan(`
            - "repo"
            - "workflow"    (if templates include GitHub workflows)
    `)}

      You can find the full documentation page here: ${chalk__default.default.blue(
    "https://backstage.io/docs/integrations/github/locations"
  )}
      `);
  const { token } = await inquirer__default.default.prompt([
    {
      type: "input",
      name: "token",
      message: "Please insert your personal access token to setup the GitHub Integration"
      // TODO(tudi2d): validate
    }
  ]);
  const config = getConfig({
    hasEnterprise: providerAnswers?.hasEnterprise ?? answers.hasEnterprise,
    apiBaseUrl: host.origin + answers.apiBaseUrl,
    host: host.hostname,
    token
  });
  tasks.Task.log("Setting up Software Templates using GitHub integration for you...");
  await tasks.Task.forItem(
    "Updating",
    APP_CONFIG_FILE,
    async () => await updateConfigFile(APP_CONFIG_FILE, config)
  );
};

const Integrations = ["GitHub" /* GITHUB */];
async function integrations(providerInfo) {
  const answers = await inquirer__default.default.prompt([
    {
      type: "confirm",
      name: "shouldUsePreviousProvider",
      message: `Do you want to keep using ${providerInfo?.provider} as your provider when setting up Software Templates?`,
      when: () => providerInfo?.provider && Object.values(Integrations).includes(
        providerInfo.provider
      )
    },
    {
      // TODO(tudi2d): Let's start with one, but it should be multiple choice in the future
      type: "list",
      name: "integration",
      message: "Please select an integration provider:",
      choices: Integrations,
      when: ({ shouldUsePreviousProvider }) => !shouldUsePreviousProvider
    }
  ]);
  if (answers.shouldUsePreviousProvider) {
    answers.integration = providerInfo.provider;
  }
  switch (answers.integration) {
    case "GitHub" /* GITHUB */: {
      const providerAnswers = providerInfo?.provider === "GitHub" ? providerInfo.answers : void 0;
      await github(providerAnswers);
      break;
    }
  }
  tasks.Task.log();
  tasks.Task.log(`Done setting up ${answers.integration} Integration!`);
  tasks.Task.log();
}

class DefaultAnalysisOutputs {
  #outputs = /* @__PURE__ */ new Map();
  produce(output) {
    this.#outputs.set(output.entity.metadata.name, output);
  }
  list() {
    return Array.from(this.#outputs).map(([_, output]) => output);
  }
}

class Discovery {
  #providers = [];
  #analyzers = [];
  addProvider(provider) {
    this.#providers.push(provider);
  }
  addAnalyzer(analyzer) {
    this.#analyzers.push(analyzer);
  }
  async run(url) {
    tasks.Task.log(`Running discovery for ${chalk__default.default.cyan(url)}`);
    const result = [];
    for (const provider of this.#providers) {
      const repositories = await provider.discover(url);
      if (repositories && repositories.length) {
        tasks.Task.log(
          `Discovered ${chalk__default.default.cyan(
            repositories.length
          )} repositories for ${chalk__default.default.cyan(provider.name())}`
        );
        for (const repository of repositories) {
          await tasks.Task.forItem("Analyzing", repository.name, async () => {
            const output = new DefaultAnalysisOutputs();
            for (const analyzer of this.#analyzers) {
              await analyzer.analyzeRepository({ repository, output });
            }
            output.list().filter((entry) => entry.type === "entity").forEach(({ entity }) => result.push(entity));
          });
        }
        tasks.Task.log(`Produced ${chalk__default.default.cyan(result.length || "no")} entities`);
      }
    }
    return {
      entities: result
    };
  }
}

class BasicRepositoryAnalyzer {
  name() {
    return BasicRepositoryAnalyzer.name;
  }
  async analyzeRepository(options) {
    const entity = {
      apiVersion: "backstage.io/v1alpha1",
      kind: "Component",
      metadata: {
        name: options.repository.name,
        ...options.repository.description ? { description: options.repository.description } : {}
      },
      spec: {
        type: "service",
        lifecycle: "production",
        owner: "user:guest"
      }
    };
    options.output.produce({
      type: "entity",
      path: "/",
      entity
    });
  }
}

class PackageJsonAnalyzer {
  name() {
    return PackageJsonAnalyzer.name;
  }
  async analyzeRepository(options) {
    const packageJson = await options.repository.file("package.json");
    if (!packageJson) {
      return;
    }
    const content = await readPackageJson(packageJson);
    if (!content) {
      return;
    }
    const name = sanitizeName(content?.name) ?? options.repository.name;
    const entity = {
      apiVersion: "backstage.io/v1alpha1",
      kind: "Component",
      metadata: {
        name,
        ...options.repository.description ? { description: options.repository.description } : {},
        tags: ["javascript"],
        annotations: {
          [catalogModel.ANNOTATION_SOURCE_LOCATION]: `url:${options.repository.url}`
        }
      },
      spec: {
        type: "website",
        lifecycle: "production",
        owner: "user:guest"
      }
    };
    const decorate = options.output.list().find((entry) => entry.entity.metadata.name === name);
    if (decorate) {
      decorate.entity.spec = {
        ...decorate.entity.spec,
        type: "website"
      };
      decorate.entity.metadata.tags = [
        ...decorate.entity.metadata.tags ?? [],
        "javascript"
      ];
      decorate.entity.metadata.annotations = {
        ...decorate.entity.metadata.annotations,
        [catalogModel.ANNOTATION_SOURCE_LOCATION]: `url:${options.repository.url}`
      };
      return;
    }
    options.output.produce({
      type: "entity",
      path: "/",
      entity
    });
  }
}
const packageSchema = z__default.default.object({
  name: z__default.default.string().optional()
});
function sanitizeName(name) {
  return name && name !== "root" ? name.replace(/[^a-z0-9A-Z]/g, "_").substring(0, 62) : void 0;
}
async function readPackageJson(file) {
  try {
    const text = await file.text();
    const result = packageSchema.safeParse(JSON.parse(text));
    if (!result.success) {
      return void 0;
    }
    return { name: result.data.name };
  } catch (e) {
    return void 0;
  }
}

class GithubFile {
  #path;
  #content;
  constructor(path, content) {
    this.#path = path;
    this.#content = content;
  }
  get path() {
    return this.#path;
  }
  async text() {
    return this.#content;
  }
}

class GithubRepository {
  #client;
  #repo;
  #org;
  constructor(client, repo, org) {
    this.#client = client;
    this.#repo = repo;
    this.#org = org;
  }
  get url() {
    return this.#repo.url;
  }
  get name() {
    return this.#repo.name;
  }
  get owner() {
    return this.#org;
  }
  get description() {
    return this.#repo.description ?? void 0;
  }
  async file(filename) {
    const content = await this.#getFileContent(filename);
    if (!content || content.isBinary || !content.text) {
      return void 0;
    }
    return new GithubFile(filename, content.text ?? "");
  }
  async #getFileContent(filename) {
    const query = `query RepoFiles($owner: String!, $name: String!, $expr: String!) {
      repository(owner: $owner, name: $name) {
        object(expression: $expr) {
          ...on Blob {
            text
            isBinary
          }
        }
      }
    }`;
    const response = await this.#client(
      query,
      {
        name: this.#repo.name,
        owner: this.#org,
        expr: `HEAD:${filename}`
      }
    );
    return response.repository.object;
  }
}

class GithubDiscoveryProvider {
  #envToken;
  #scmIntegrations;
  #credentialsProvider;
  static fromConfig(config) {
    const envToken = process.env.GITHUB_TOKEN || void 0;
    const scmIntegrations = integration.ScmIntegrations.fromConfig(config);
    const credentialsProvider = integration.DefaultGithubCredentialsProvider.fromIntegrations(scmIntegrations);
    return new GithubDiscoveryProvider(
      envToken,
      scmIntegrations,
      credentialsProvider
    );
  }
  constructor(envToken, integrations, credentialsProvider) {
    this.#envToken = envToken;
    this.#scmIntegrations = integrations;
    this.#credentialsProvider = credentialsProvider;
  }
  name() {
    return "GitHub";
  }
  async discover(url) {
    if (!url.startsWith("https://github.com/")) {
      return false;
    }
    const scmIntegration = this.#scmIntegrations.github.byUrl(url);
    if (!scmIntegration) {
      throw new Error(`No GitHub integration found for ${url}`);
    }
    const parsed = parseGitUrl__default.default(url);
    const { name, organization } = parsed;
    const org = organization || name;
    const client = graphql.graphql.defaults({
      baseUrl: scmIntegration.config.apiBaseUrl,
      headers: await this.#getRequestHeaders(url)
    });
    const { repositories } = await this.#getOrganizationRepositories(
      client,
      org
    );
    return repositories.filter((repo) => repo.url.startsWith(url)).map((repo) => new GithubRepository(client, repo, org));
  }
  async #getRequestHeaders(url) {
    const credentials = await this.#credentialsProvider.getCredentials({
      url
    });
    if (credentials.headers) {
      return credentials.headers;
    } else if (credentials.token) {
      return { authorization: `token ${credentials.token}` };
    }
    if (this.#envToken) {
      return { authorization: `token ${this.#envToken}` };
    }
    throw new Error(
      "No token available for GitHub, please configure your integrations or set a GITHUB_TOKEN env variable"
    );
  }
  async #getOrganizationRepositories(client, org) {
    const query = `query repositories($org: String!, $cursor: String) {
      repositoryOwner(login: $org) {
        login
        repositories(first: 50, after: $cursor) {
          nodes {
            name
            url
            description
            isArchived
            isFork
          }
          pageInfo {
            hasNextPage
            endCursor
          }
        }
      }
    }`;
    const result = [];
    let cursor = void 0;
    let hasNextPage = true;
    while (hasNextPage) {
      const response = await client(query, {
        org,
        cursor
      });
      const { repositories: connection } = response.repositoryOwner ?? {};
      if (!connection) {
        throw new Error(`Found no repositories for ${org}`);
      }
      for (const repository of connection.nodes ?? []) {
        if (repository && !repository.isArchived && !repository.isFork) {
          result.push(repository);
        }
      }
      cursor = connection.pageInfo.endCursor;
      hasNextPage = connection.pageInfo.hasNextPage;
    }
    return {
      repositories: result
    };
  }
}

class GitlabFile {
  #path;
  #content;
  constructor(path, content) {
    this.#path = path;
    this.#content = content;
  }
  get path() {
    return this.#path;
  }
  async text() {
    return this.#content;
  }
}

class GitlabProject {
  constructor(project, apiBaseUrl, headers) {
    this.project = project;
    this.apiBaseUrl = apiBaseUrl;
    this.headers = headers;
  }
  get url() {
    return this.project.web_url;
  }
  get name() {
    return this.project.name;
  }
  get owner() {
    return this.project.owner.username;
  }
  get description() {
    return this.project.description;
  }
  async file(filename) {
    const mainBranch = await this.#getMainBranch();
    const content = await this.#getFileContent(filename, mainBranch);
    return new GitlabFile(filename, content);
  }
  async #getFileContent(path, mainBranch) {
    const response = await fetch__default.default(
      `${this.apiBaseUrl}/projects/${this.project.id}/repository/files/${path}?ref=${mainBranch}`,
      { headers: this.headers }
    );
    const { content } = await response.json();
    return Buffer.from(content, "base64").toString("ascii");
  }
  async #getMainBranch() {
    const response = await fetch__default.default(
      `${this.apiBaseUrl}/projects/${this.project.id}/repository/branches`,
      { headers: this.headers }
    );
    const branches = await response.json();
    return branches.find((branch) => branch.default)?.name ?? "main";
  }
}

class GitlabDiscoveryProvider {
  #envToken;
  #scmIntegrations;
  #credentialsProvider;
  static fromConfig(config) {
    const envToken = process.env.GITLAB_TOKEN || void 0;
    const scmIntegrations = integration.ScmIntegrations.fromConfig(config);
    const credentialsProvider = integration.DefaultGitlabCredentialsProvider.fromIntegrations(scmIntegrations);
    return new GitlabDiscoveryProvider(
      envToken,
      scmIntegrations,
      credentialsProvider
    );
  }
  constructor(envToken, integrations, credentialsProvider) {
    this.#envToken = envToken;
    this.#scmIntegrations = integrations;
    this.#credentialsProvider = credentialsProvider;
  }
  name() {
    return "GitLab";
  }
  async discover(url) {
    const { origin, pathname } = new URL(url);
    const [, user] = pathname.split("/");
    const scmIntegration = this.#scmIntegrations.gitlab.byUrl(origin);
    if (!scmIntegration) {
      throw new Error(`No GitLab integration found for ${origin}`);
    }
    const headers = await this.#getRequestHeaders(origin);
    const response = await fetch__default.default(
      `${scmIntegration.config.apiBaseUrl}/users/${user}/projects`,
      { headers }
    );
    if (!response.ok) {
      throw new Error(`${response.status} ${response.statusText}`);
    }
    const projects = await response.json();
    return projects.map(
      (project) => new GitlabProject(project, scmIntegration.config.apiBaseUrl, headers)
    );
  }
  async #getRequestHeaders(url) {
    const credentials = await this.#credentialsProvider.getCredentials({
      url
    });
    if (credentials.headers) {
      return credentials.headers;
    } else if (credentials.token) {
      return { authorization: `Bearer ${credentials.token}` };
    }
    if (this.#envToken) {
      return { authorization: `Bearer ${this.#envToken}` };
    }
    throw new Error(
      "No token available for GitLab, please set a GITLAB_TOKEN env variable"
    );
  }
}

async function discover(providerInfo) {
  tasks.Task.log(`
    Would you like to scan for - and create - Software Catalog entities?

    You will need to select which SCM (Source Code Management) provider you are using, 
    and then which repository or organization you want to scan.

    This will generate a new file in the root of your app containing discovered entities,
    which will be included in the Software Catalog when you start up Backstage next time.

    Note that this command requires an access token, which can be either added through the integration config or
    provided as an environment variable.
  `);
  const answers = await inquirer__default.default.prompt([
    {
      type: "confirm",
      name: "shouldContinue",
      message: "Do you want to continue?"
    },
    {
      type: "list",
      name: "provider",
      message: "Please select which SCM provider you want to use:",
      choices: ["GitHub", "GitLab"],
      default: providerInfo?.provider,
      when: ({ shouldContinue }) => shouldContinue
    },
    {
      type: "input",
      name: "url",
      message: `Which repository do you want to scan?`,
      when: ({ shouldContinue }) => shouldContinue,
      filter: (input, { provider }) => {
        if (provider === "GitLab") {
          return `https://gitlab.com/${input}`;
        }
        if (provider === "GitHub") {
          return `https://github.com/${input}`;
        }
        return false;
      }
    }
  ]);
  if (!answers.shouldContinue) {
    tasks.Task.log(
      chalk__default.default.yellow(
        "If you change your mind, feel free to re-run this command."
      )
    );
    return;
  }
  const { fullConfig: config$1 } = await config.loadCliConfig({ args: [] });
  const discovery = new Discovery();
  if (answers.provider === "GitHub") {
    discovery.addProvider(GithubDiscoveryProvider.fromConfig(config$1));
  }
  if (answers.provider === "GitLab") {
    discovery.addProvider(GitlabDiscoveryProvider.fromConfig(config$1));
  }
  discovery.addAnalyzer(new BasicRepositoryAnalyzer());
  discovery.addAnalyzer(new PackageJsonAnalyzer());
  const { entities } = await discovery.run(answers.url);
  if (!entities.length) {
    tasks.Task.log(
      chalk__default.default.yellow(`
      We could not find enough information to be able to generate any Software Catalog entities for you.
      Perhaps you can try again with a different repository?`)
    );
    return;
  }
  await tasks.Task.forItem("Creating", DISCOVERED_ENTITIES_FILE, async () => {
    const payload = [];
    for (const entity of entities) {
      payload.push("---\n", yaml__default.default.stringify(entity));
    }
    await fs__namespace.default.writeFile(DISCOVERED_ENTITIES_FILE, payload.join(""));
  });
  await tasks.Task.forItem(
    "Updating",
    APP_CONFIG_FILE,
    async () => await updateConfigFile(APP_CONFIG_FILE, {
      catalog: {
        locations: [
          {
            type: "file",
            target: DISCOVERED_ENTITIES_FILE
          }
        ]
      }
    })
  );
}

async function command() {
  const answers = await inquirer__default.default.prompt([
    {
      type: "confirm",
      name: "shouldSetupAuth",
      message: "Do you want to set up Authentication for this project?",
      default: true
    },
    {
      type: "confirm",
      name: "shouldSetupScaffolder",
      message: "Do you want to use Software Templates in this project?",
      default: true
    },
    {
      type: "confirm",
      name: "shouldDiscoverEntities",
      message: "Do you want to discover entities and add them to the Software Catalog?",
      default: true
    }
  ]);
  const { shouldSetupAuth, shouldSetupScaffolder, shouldDiscoverEntities } = answers;
  if (!shouldSetupAuth && !shouldSetupScaffolder && !shouldDiscoverEntities) {
    tasks.Task.log(
      chalk__default.default.yellow(
        "If you change your mind, feel free to re-run this command."
      )
    );
    return;
  }
  let providerInfo;
  if (shouldSetupAuth) {
    providerInfo = await auth();
  }
  if (shouldSetupScaffolder) {
    await integrations(providerInfo);
  }
  if (shouldDiscoverEntities) {
    await discover(providerInfo);
  }
  tasks.Task.log();
  tasks.Task.log(
    `You can now start your app with ${chalk__default.default.inverse(
      chalk__default.default.italic("yarn dev")
    )}`
  );
  tasks.Task.log();
}

exports.command = command;
//# sourceMappingURL=index-DRp-18FB.cjs.js.map
