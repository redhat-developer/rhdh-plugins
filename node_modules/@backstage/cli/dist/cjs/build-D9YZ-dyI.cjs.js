'use strict';

var chalk = require('chalk');
var path = require('path');
var createDistWorkspace = require('./createDistWorkspace-DxOWPD6z.cjs.js');
var index = require('./index-DmUbBCFk.cjs.js');
var cliNode = require('@backstage/cli-node');
var parallel = require('./parallel-BszNaKyc.cjs.js');
var buildBackend = require('./buildBackend-CmtimF8a.cjs.js');
require('fs-extra');
require('p-limit');
require('os');
require('tar');
require('lodash/partition');
require('./run-CSt1n0F1.cjs.js');
require('child_process');
require('util');
require('@backstage/errors');
require('rollup');
require('@rollup/plugin-commonjs');
require('@rollup/plugin-node-resolve');
require('rollup-plugin-postcss');
require('rollup-plugin-esbuild');
require('@svgr/rollup');
require('rollup-plugin-dts');
require('@rollup/plugin-json');
require('@rollup/plugin-yaml');
require('rollup-pluginutils');
require('./svgrTemplate-BTjBQ3by.cjs.js');
require('./entryPoints-CoHH4lBA.cjs.js');
require('./productionPack-BWU8WkGs.cjs.js');
require('npm-packlist');
require('commander');
require('semver');
require('@backstage/cli-common');
require('worker_threads');
require('webpack');
require('eslint-webpack-plugin');
require('fork-ts-checker-webpack-plugin');
require('html-webpack-plugin');
require('@module-federation/enhanced/webpack');
require('react-dev-utils/ModuleScopePlugin');
require('run-script-webpack-plugin');
require('@pmmmwh/react-refresh-webpack-plugin');
require('@manypkg/get-packages');
require('webpack-node-externals');
require('./moduleFederation-8XXecxLD.cjs.js');
require('lodash/pickBy');
require('mini-css-extract-plugin');
require('yn');
require('@backstage/config');
require('chokidar');
require('p-queue');
require('react-dev-utils/FileSizeReporter');
require('react-dev-utils/formatWebpackMessages');
require('react-dev-utils/openBrowser');
require('webpack-dev-server');
require('./config-BMsjTUVf.cjs.js');
require('@backstage/config-loader');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var chalk__default = /*#__PURE__*/_interopDefaultCompat(chalk);

function createScriptOptionsParser(anyCmd, commandPath) {
  let rootCmd = anyCmd;
  while (rootCmd.parent) {
    rootCmd = rootCmd.parent;
  }
  let targetCmd = rootCmd;
  for (const name of commandPath) {
    targetCmd = targetCmd?.commands.find((c) => c.name() === name);
  }
  if (!targetCmd) {
    throw new Error(
      `Could not find package command '${commandPath.join(" ")}'`
    );
  }
  const cmd = targetCmd;
  const expectedScript = `backstage-cli ${commandPath.join(" ")}`;
  return (scriptStr) => {
    if (!scriptStr || !scriptStr.startsWith(expectedScript)) {
      return void 0;
    }
    const argsStr = scriptStr.slice(expectedScript.length).trim();
    const currentOpts = cmd._optionValues;
    const currentStore = cmd._storeOptionsAsProperties;
    const result = {};
    cmd._storeOptionsAsProperties = false;
    cmd._optionValues = result;
    cmd.parseOptions(argsStr.split(" "));
    cmd._storeOptionsAsProperties = currentOpts;
    cmd._optionValues = currentStore;
    return result;
  };
}
async function command(opts, cmd) {
  let packages = await cliNode.PackageGraph.listTargetPackages();
  if (opts.since) {
    const graph = cliNode.PackageGraph.fromPackages(packages);
    const changedPackages = await graph.listChangedPackages({
      ref: opts.since,
      analyzeLockfile: true
    });
    const withDevDependents = graph.collectPackageNames(
      changedPackages.map((pkg) => pkg.name),
      (pkg) => pkg.localDevDependents.keys()
    );
    packages = Array.from(withDevDependents).map((name) => graph.get(name));
  }
  const apps = new Array();
  const backends = new Array();
  const parseBuildScript = createScriptOptionsParser(cmd, ["package", "build"]);
  const options = packages.flatMap((pkg) => {
    const role = pkg.packageJson.backstage?.role ?? cliNode.PackageRoles.detectRoleFromPackage(pkg.packageJson);
    if (!role) {
      console.warn(`Ignored ${pkg.packageJson.name} because it has no role`);
      return [];
    }
    if (role === "frontend") {
      apps.push(pkg);
      return [];
    } else if (role === "backend") {
      backends.push(pkg);
      return [];
    }
    const outputs = createDistWorkspace.getOutputsForRole(role);
    if (outputs.size === 0) {
      console.warn(`Ignored ${pkg.packageJson.name} because it has no output`);
      return [];
    }
    const buildOptions = parseBuildScript(pkg.packageJson.scripts?.build);
    if (!buildOptions) {
      console.warn(
        `Ignored ${pkg.packageJson.name} because it does not have a matching build script`
      );
      return [];
    }
    return {
      targetDir: pkg.dir,
      packageJson: pkg.packageJson,
      outputs,
      logPrefix: `${chalk__default.default.cyan(path.relative(index.paths.targetRoot, pkg.dir))}: `,
      workspacePackages: packages,
      minify: opts.minify ?? buildOptions.minify
    };
  });
  console.log("Building packages");
  await createDistWorkspace.buildPackages(options);
  if (opts.all) {
    console.log("Building apps");
    await parallel.runParallelWorkers({
      items: apps,
      parallelismFactor: 1 / 2,
      worker: async (pkg) => {
        const buildOptions = parseBuildScript(pkg.packageJson.scripts?.build);
        if (!buildOptions) {
          console.warn(
            `Ignored ${pkg.packageJson.name} because it does not have a matching build script`
          );
          return;
        }
        await buildBackend.buildFrontend({
          targetDir: pkg.dir,
          configPaths: buildOptions.config ?? [],
          writeStats: Boolean(buildOptions.stats)
        });
      }
    });
    console.log("Building backends");
    await parallel.runParallelWorkers({
      items: backends,
      parallelismFactor: 1 / 2,
      worker: async (pkg) => {
        const buildOptions = parseBuildScript(pkg.packageJson.scripts?.build);
        if (!buildOptions) {
          console.warn(
            `Ignored ${pkg.packageJson.name} because it does not have a matching build script`
          );
          return;
        }
        await buildBackend.buildBackend({
          targetDir: pkg.dir,
          skipBuildDependencies: true,
          minify: opts.minify ?? buildOptions.minify
        });
      }
    });
  }
}

exports.command = command;
//# sourceMappingURL=build-D9YZ-dyI.cjs.js.map
