'use strict';

var parseGitUrl = require('git-url-parse');
var lodash = require('lodash');
var identity = require('@azure/identity');
var fetch = require('cross-fetch');
var authApp = require('@octokit/auth-app');
var rest = require('@octokit/rest');
var luxon = require('luxon');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var parseGitUrl__default = /*#__PURE__*/_interopDefaultCompat(parseGitUrl);
var fetch__default = /*#__PURE__*/_interopDefaultCompat(fetch);

function isValidHost(host) {
  const check = new URL("http://example.com");
  check.host = host;
  return check.host === host;
}
function isValidUrl(url) {
  try {
    new URL(url);
    return true;
  } catch {
    return false;
  }
}
function basicIntegrations(integrations, getHost) {
  return {
    list() {
      return integrations;
    },
    byUrl(url) {
      try {
        const parsed = typeof url === "string" ? new URL(url) : url;
        return integrations.find((i) => getHost(i) === parsed.host);
      } catch {
        return void 0;
      }
    },
    byHost(host) {
      return integrations.find((i) => getHost(i) === host);
    }
  };
}
function defaultScmResolveUrl(options) {
  const { url, base, lineNumber } = options;
  try {
    new URL(url);
    return url;
  } catch {
  }
  let updated;
  if (url.startsWith("/")) {
    const { href, filepath } = parseGitUrl__default.default(base);
    updated = new URL(href);
    const repoRootPath = lodash.trimEnd(
      updated.pathname.substring(0, updated.pathname.length - filepath.length),
      "/"
    );
    updated.pathname = `${repoRootPath}${url}`;
  } else {
    updated = new URL(url, base);
  }
  updated.search = new URL(base).search;
  if (lineNumber) {
    updated.hash = `L${lineNumber}`;
  }
  return updated.toString();
}

const AMAZON_AWS_HOST = "amazonaws.com";
function readAwsS3IntegrationConfig(config) {
  const endpoint = config.getOptionalString("endpoint");
  const s3ForcePathStyle = config.getOptionalBoolean("s3ForcePathStyle") ?? false;
  let host;
  let pathname;
  if (endpoint) {
    try {
      const url = new URL(endpoint);
      host = url.host;
      pathname = url.pathname;
    } catch {
      throw new Error(
        `invalid awsS3 integration config, endpoint '${endpoint}' is not a valid URL`
      );
    }
    if (pathname !== "/") {
      throw new Error(
        `invalid awsS3 integration config, endpoints cannot contain path, got '${endpoint}'`
      );
    }
  } else {
    host = AMAZON_AWS_HOST;
  }
  const accessKeyId = config.getOptionalString("accessKeyId");
  const secretAccessKey = config.getOptionalString("secretAccessKey")?.trim();
  const roleArn = config.getOptionalString("roleArn");
  const externalId = config.getOptionalString("externalId");
  return {
    host,
    endpoint,
    s3ForcePathStyle,
    accessKeyId,
    secretAccessKey,
    roleArn,
    externalId
  };
}
function readAwsS3IntegrationConfigs(configs) {
  const result = configs.map(readAwsS3IntegrationConfig);
  if (!result.some((c) => c.host === AMAZON_AWS_HOST)) {
    result.push({
      host: AMAZON_AWS_HOST
    });
  }
  return result;
}

class AwsS3Integration {
  constructor(integrationConfig) {
    this.integrationConfig = integrationConfig;
  }
  static factory = ({ config }) => {
    const configs = readAwsS3IntegrationConfigs(
      config.getOptionalConfigArray("integrations.awsS3") ?? []
    );
    return basicIntegrations(
      configs.map((c) => new AwsS3Integration(c)),
      (i) => i.config.host
    );
  };
  get type() {
    return "awsS3";
  }
  get title() {
    return this.integrationConfig.host;
  }
  get config() {
    return this.integrationConfig;
  }
  resolveUrl(options) {
    const resolved = defaultScmResolveUrl(options);
    return resolved;
  }
  resolveEditUrl(url) {
    return url;
  }
}

const AMAZON_AWS_CODECOMMIT_HOST = "console.aws.amazon.com";
function readAwsCodeCommitIntegrationConfig(config) {
  const accessKeyId = config.getOptionalString("accessKeyId");
  const secretAccessKey = config.getOptionalString("secretAccessKey")?.trim();
  const roleArn = config.getOptionalString("roleArn");
  const externalId = config.getOptionalString("externalId");
  const region = config.getString("region");
  const host = config.getOptionalString("host") || `${region}.${AMAZON_AWS_CODECOMMIT_HOST}`;
  return {
    host,
    accessKeyId,
    secretAccessKey,
    roleArn,
    externalId,
    region
  };
}
function readAwsCodeCommitIntegrationConfigs(configs) {
  return configs.map(readAwsCodeCommitIntegrationConfig);
}

class AwsCodeCommitIntegration {
  constructor(integrationConfig) {
    this.integrationConfig = integrationConfig;
  }
  static factory = ({
    config
  }) => {
    const configs = readAwsCodeCommitIntegrationConfigs(
      config.getOptionalConfigArray("integrations.awsCodeCommit") ?? []
    );
    return basicIntegrations(
      configs.map((c) => new AwsCodeCommitIntegration(c)),
      (i) => i.config.host
    );
  };
  get type() {
    return "awsCodeCommit";
  }
  get config() {
    return this.integrationConfig;
  }
  get title() {
    return this.integrationConfig.host;
  }
  resolveUrl(options) {
    const resolved = defaultScmResolveUrl(options);
    return resolved;
  }
  resolveEditUrl(url) {
    const parsedUrl = new URL(url);
    const pathMatch = parsedUrl.pathname.match(
      /^\/codesuite\/codecommit\/repositories\/([^\/]+)\//
    );
    if (!pathMatch) {
      throw new Error(``);
    }
    const [, repositoryName] = pathMatch;
    return replaceCodeCommitUrlType(url, repositoryName);
  }
}
function replaceCodeCommitUrlType(url, repositoryName, type) {
  const newString = `files/edit` ;
  return url.replace(
    new RegExp(
      `/codesuite/codecommit/repositories/${repositoryName}/(browse|files/edit)/`
    ),
    `/codesuite/codecommit/repositories/${repositoryName}/${newString}/`
  );
}

const VERSION_PREFIX_GIT_BRANCH = "GB";
class AzureUrl {
  /**
   * Parses an azure URL as copied from the browser address bar.
   *
   * Throws an error if the URL is not a valid azure repo URL.
   */
  static fromRepoUrl(repoUrl) {
    const url = new URL(repoUrl);
    let owner;
    let project;
    let repo;
    const parts = url.pathname.split("/").map((part) => decodeURIComponent(part));
    if (parts[2] === "_git") {
      owner = parts[1];
      project = repo = parts[3];
    } else if (parts[3] === "_git") {
      owner = parts[1];
      project = parts[2];
      repo = parts[4];
    } else if (parts[4] === "_git") {
      owner = `${parts[1]}/${parts[2]}`;
      project = parts[3];
      repo = parts[5];
    }
    if (!owner || !project || !repo) {
      throw new Error("Azure URL must point to a git repository");
    }
    const path = url.searchParams.get("path") ?? void 0;
    let ref;
    const version = url.searchParams.get("version");
    if (version) {
      const prefix = version.slice(0, 2);
      if (prefix !== "GB") {
        throw new Error("Azure URL version must point to a git branch");
      }
      ref = version.slice(2);
    }
    return new AzureUrl(url.origin, owner, project, repo, path, ref);
  }
  #origin;
  #owner;
  #project;
  #repo;
  #path;
  #ref;
  constructor(origin, owner, project, repo, path, ref) {
    this.#origin = origin;
    this.#owner = owner;
    this.#project = project;
    this.#repo = repo;
    this.#path = path;
    this.#ref = ref;
  }
  #baseUrl = (...parts) => {
    const url = new URL(this.#origin);
    url.pathname = parts.map((part) => encodeURIComponent(part)).join("/");
    return url;
  };
  /**
   * Returns a repo URL that can be used to navigate to the resource in azure.
   *
   * Throws an error if the URL is not a valid azure repo URL.
   */
  toRepoUrl() {
    let url;
    if (this.#project === this.#repo) {
      url = this.#baseUrl(this.#owner, "_git", this.#repo);
    } else {
      url = this.#baseUrl(this.#owner, this.#project, "_git", this.#repo);
    }
    if (this.#path) {
      url.searchParams.set("path", this.#path);
    }
    if (this.#ref) {
      url.searchParams.set("version", VERSION_PREFIX_GIT_BRANCH + this.#ref);
    }
    return url.toString();
  }
  /**
   * Returns the file download URL for this azure resource.
   *
   * Throws an error if the URL does not point to a file.
   */
  toFileUrl() {
    if (!this.#path) {
      throw new Error(
        "Azure URL must point to a specific path to be able to download a file"
      );
    }
    const url = this.#baseUrl(
      this.#owner,
      this.#project,
      "_apis",
      "git",
      "repositories",
      this.#repo,
      "items"
    );
    url.searchParams.set("api-version", "6.0");
    url.searchParams.set("path", this.#path);
    if (this.#ref) {
      url.searchParams.set("version", this.#ref);
    }
    return url.toString();
  }
  /**
   * Returns the archive download URL for this azure resource.
   *
   * Throws an error if the URL does not point to a repo.
   */
  toArchiveUrl() {
    const url = this.#baseUrl(
      this.#owner,
      this.#project,
      "_apis",
      "git",
      "repositories",
      this.#repo,
      "items"
    );
    url.searchParams.set("recursionLevel", "full");
    url.searchParams.set("download", "true");
    url.searchParams.set("api-version", "6.0");
    if (this.#path) {
      url.searchParams.set("scopePath", this.#path);
    }
    if (this.#ref) {
      url.searchParams.set("version", this.#ref);
    }
    return url.toString();
  }
  /**
   * Returns the API url for fetching commits from a branch for this azure resource.
   *
   * Throws an error if the URL does not point to a commit.
   */
  toCommitsUrl() {
    const url = this.#baseUrl(
      this.#owner,
      this.#project,
      "_apis",
      "git",
      "repositories",
      this.#repo,
      "commits"
    );
    url.searchParams.set("api-version", "6.0");
    if (this.#ref) {
      url.searchParams.set("searchCriteria.itemVersion.version", this.#ref);
    }
    return url.toString();
  }
  /**
   * Returns the name of the owner, a user or an organization.
   */
  getOwner() {
    return this.#owner;
  }
  /**
   * Returns the name of the project.
   */
  getProject() {
    return this.#project;
  }
  /**
   * Returns the name of the repo.
   */
  getRepo() {
    return this.#repo;
  }
  /**
   * Returns the file path within the repo if the URL contains one.
   */
  getPath() {
    return this.#path;
  }
  /**
   * Returns the git ref in the repo if the URL contains one.
   */
  getRef() {
    return this.#ref;
  }
}

const AZURE_HOST = "dev.azure.com";
const AzureDevOpsCredentialFields = [
  "clientId",
  "clientSecret",
  "tenantId",
  "personalAccessToken"
];
const AzureDevopsCredentialFieldMap = /* @__PURE__ */ new Map([
  ["ClientSecret", ["clientId", "clientSecret", "tenantId"]],
  ["ManagedIdentity", ["clientId"]],
  ["PersonalAccessToken", ["personalAccessToken"]]
]);
function asAzureDevOpsCredential(credential) {
  for (const entry of AzureDevopsCredentialFieldMap.entries()) {
    const [kind, requiredFields] = entry;
    const forbiddenFields = AzureDevOpsCredentialFields.filter(
      (field) => !requiredFields.includes(field)
    );
    if (requiredFields.every((field) => credential[field] !== void 0) && forbiddenFields.every((field) => credential[field] === void 0)) {
      return {
        kind,
        organizations: credential.organizations,
        ...requiredFields.reduce((acc, field) => {
          acc[field] = credential[field];
          return acc;
        }, {})
      };
    }
  }
  throw new Error("is not a valid credential");
}
function readAzureIntegrationConfig(config) {
  const host = config.getOptionalString("host") ?? AZURE_HOST;
  let credentialConfigs = config.getOptionalConfigArray("credentials")?.map((credential) => {
    const result = {
      organizations: credential.getOptionalStringArray("organizations"),
      personalAccessToken: credential.getOptionalString("personalAccessToken")?.trim(),
      tenantId: credential.getOptionalString("tenantId"),
      clientId: credential.getOptionalString("clientId"),
      clientSecret: credential.getOptionalString("clientSecret")?.trim()
    };
    return result;
  });
  const token = config.getOptionalString("token")?.trim();
  if (config.getOptional("credential") !== void 0 && config.getOptional("credentials") !== void 0) {
    throw new Error(
      `Invalid Azure integration config, 'credential' and 'credentials' cannot be used together. Use 'credentials' instead.`
    );
  }
  if (config.getOptional("token") !== void 0 && config.getOptional("credentials") !== void 0) {
    throw new Error(
      `Invalid Azure integration config, 'token' and 'credentials' cannot be used together. Use 'credentials' instead.`
    );
  }
  if (token !== void 0) {
    const mapped = [{ personalAccessToken: token }];
    credentialConfigs = credentialConfigs?.concat(mapped) ?? mapped;
  }
  if (config.getOptional("credential") !== void 0) {
    const mapped = [
      {
        organizations: config.getOptionalStringArray(
          "credential.organizations"
        ),
        token: config.getOptionalString("credential.token")?.trim(),
        tenantId: config.getOptionalString("credential.tenantId"),
        clientId: config.getOptionalString("credential.clientId"),
        clientSecret: config.getOptionalString("credential.clientSecret")?.trim()
      }
    ];
    credentialConfigs = credentialConfigs?.concat(mapped) ?? mapped;
  }
  if (!isValidHost(host)) {
    throw new Error(
      `Invalid Azure integration config, '${host}' is not a valid host`
    );
  }
  let credentials = void 0;
  if (credentialConfigs !== void 0) {
    const errors = credentialConfigs?.reduce((acc, credentialConfig, index) => {
      let error = void 0;
      try {
        asAzureDevOpsCredential(credentialConfig);
      } catch (e) {
        error = e.message;
      }
      if (error !== void 0) {
        acc.push(`credential at position ${index + 1} ${error}`);
      }
      return acc;
    }, Array.of()).concat(
      Object.entries(
        credentialConfigs.filter(
          (credential) => credential.organizations !== void 0 && credential.organizations.length > 0
        ).reduce((acc, credential, index) => {
          credential.organizations?.forEach((organization) => {
            if (!acc[organization]) {
              acc[organization] = [];
            }
            acc[organization].push(index + 1);
          });
          return acc;
        }, {})
      ).filter(([_, indexes]) => indexes.length > 1).reduce((acc, [org, indexes]) => {
        acc.push(
          `organization ${org} is specified multiple times in credentials at positions ${indexes.slice(0, indexes.length - 1).join(", ")} and ${indexes[indexes.length - 1]}`
        );
        return acc;
      }, Array.of())
    );
    if (errors?.length > 0) {
      throw new Error(
        `Invalid Azure integration config for ${host}: ${errors.join("; ")}`
      );
    }
    credentials = credentialConfigs.map(
      (credentialConfig) => asAzureDevOpsCredential(credentialConfig)
    );
    if (credentials.some(
      (credential) => credential.kind !== "PersonalAccessToken"
    ) && host !== AZURE_HOST) {
      throw new Error(
        `Invalid Azure integration config for ${host}, only personal access tokens can be used with hosts other than ${AZURE_HOST}`
      );
    }
    if (credentials.filter(
      (credential) => credential.organizations === void 0 || credential.organizations.length === 0
    ).length > 1) {
      throw new Error(
        `Invalid Azure integration config for ${host}, you cannot specify multiple credentials without organizations`
      );
    }
  }
  return {
    host,
    credentials
  };
}
function readAzureIntegrationConfigs(configs) {
  const result = configs.map(readAzureIntegrationConfig);
  if (!result.some((c) => c.host === AZURE_HOST)) {
    result.push({ host: AZURE_HOST });
  }
  return result;
}

class AzureIntegration {
  constructor(integrationConfig) {
    this.integrationConfig = integrationConfig;
  }
  static factory = ({ config }) => {
    const configs = readAzureIntegrationConfigs(
      config.getOptionalConfigArray("integrations.azure") ?? []
    );
    return basicIntegrations(
      configs.map((c) => new AzureIntegration(c)),
      (i) => i.config.host
    );
  };
  get type() {
    return "azure";
  }
  get title() {
    return this.integrationConfig.host;
  }
  get config() {
    return this.integrationConfig;
  }
  /*
   * Azure repo URLs on the form with a `path` query param are treated specially.
   *
   * Example base URL: https://dev.azure.com/organization/project/_git/repository?path=%2Fcatalog-info.yaml
   */
  resolveUrl(options) {
    const { url, base } = options;
    if (isValidUrl(url)) {
      return url;
    }
    try {
      const azureUrl = AzureUrl.fromRepoUrl(base);
      const newUrl = new URL(base);
      const mockBaseUrl = new URL(`https://a.com${azureUrl.getPath() ?? ""}`);
      const updatedPath = new URL(url, mockBaseUrl).pathname;
      newUrl.searchParams.set("path", updatedPath);
      if (options.lineNumber) {
        newUrl.searchParams.set("line", String(options.lineNumber));
        newUrl.searchParams.set("lineEnd", String(options.lineNumber + 1));
        newUrl.searchParams.set("lineStartColumn", "1");
        newUrl.searchParams.set("lineEndColumn", "1");
      }
      return newUrl.toString();
    } catch {
      return new URL(url, base).toString();
    }
  }
  resolveEditUrl(url) {
    return url;
  }
}

function getAzureFileFetchUrl(url) {
  return AzureUrl.fromRepoUrl(url).toFileUrl();
}
function getAzureDownloadUrl(url) {
  return AzureUrl.fromRepoUrl(url).toArchiveUrl();
}
function getAzureCommitsUrl(url) {
  return AzureUrl.fromRepoUrl(url).toCommitsUrl();
}

const tenMinutes = 1e3 * 60 * 10;
class CachedAzureDevOpsCredentialsProvider {
  constructor(credential) {
    this.credential = credential;
  }
  azureDevOpsScope = "499b84ac-1321-427f-aa17-267ca6975798/.default";
  cached;
  static fromAzureDevOpsCredential(credential) {
    switch (credential.kind) {
      case "PersonalAccessToken":
        return CachedAzureDevOpsCredentialsProvider.fromPersonalAccessTokenCredential(
          credential
        );
      case "ClientSecret":
        return CachedAzureDevOpsCredentialsProvider.fromTokenCredential(
          new identity.ClientSecretCredential(
            credential.tenantId,
            credential.clientId,
            credential.clientSecret
          )
        );
      case "ManagedIdentity":
        return CachedAzureDevOpsCredentialsProvider.fromTokenCredential(
          new identity.ManagedIdentityCredential(credential.clientId)
        );
      default:
        throw new Error(
          `Credential kind '${credential.kind}' not supported`
        );
    }
  }
  static fromTokenCredential(credential) {
    return new CachedAzureDevOpsCredentialsProvider(credential);
  }
  static fromPersonalAccessTokenCredential(credential) {
    return new CachedAzureDevOpsCredentialsProvider(
      credential.personalAccessToken
    );
  }
  async getCredentials() {
    if (this.cached === void 0 || this.cached.expiresAt !== void 0 && Date.now() > this.cached.expiresAt) {
      if (typeof this.credential === "string") {
        this.cached = {
          headers: {
            Authorization: `Basic ${btoa(`:${this.credential}`)}`
          },
          type: "pat",
          token: this.credential
        };
      } else {
        const accessToken = await this.credential.getToken(
          this.azureDevOpsScope
        );
        if (!accessToken) {
          throw new Error("Failed to retrieve access token");
        }
        this.cached = {
          expiresAt: accessToken.expiresOnTimestamp - tenMinutes,
          headers: {
            Authorization: `Bearer ${accessToken.token}`
          },
          type: "bearer",
          token: accessToken.token
        };
      }
    }
    return this.cached;
  }
}

class DefaultAzureDevOpsCredentialsProvider {
  constructor(providers) {
    this.providers = providers;
  }
  static fromIntegrations(integrations) {
    const providers = integrations.azure.list().reduce((acc, integration) => {
      integration.config.credentials?.forEach((credential) => {
        if (credential.organizations === void 0 || credential.organizations.length === 0) {
          if (acc.get(integration.config.host) === void 0) {
            acc.set(
              integration.config.host,
              CachedAzureDevOpsCredentialsProvider.fromAzureDevOpsCredential(
                credential
              )
            );
          }
        } else {
          const provider = CachedAzureDevOpsCredentialsProvider.fromAzureDevOpsCredential(
            credential
          );
          credential.organizations?.forEach((organization) => {
            acc.set(`${integration.config.host}/${organization}`, provider);
          });
        }
      });
      if (integration.config.host === "dev.azure.com" && acc.get(integration.config.host) === void 0) {
        acc.set(
          integration.config.host,
          CachedAzureDevOpsCredentialsProvider.fromTokenCredential(
            new identity.DefaultAzureCredential()
          )
        );
      }
      return acc;
    }, /* @__PURE__ */ new Map());
    return new DefaultAzureDevOpsCredentialsProvider(providers);
  }
  forAzureDevOpsServerOrganization(url) {
    const parts = url.pathname.split("/").filter((part) => part !== "");
    if (url.host !== "dev.azure.com" && parts.length > 0) {
      if (parts[0] !== "tfs") {
        return this.providers.get(`${url.host}/${parts[0]}`);
      } else if (parts[0] === "tfs" && parts.length > 1) {
        return this.providers.get(`${url.host}/${parts[1]}`);
      }
    }
    return void 0;
  }
  forAzureDevOpsOrganization(url) {
    const parts = url.pathname.split("/").filter((part) => part !== "");
    if (url.host === "dev.azure.com" && parts.length > 0) {
      return this.providers.get(`${url.host}/${parts[0]}`);
    }
    return void 0;
  }
  forHost(url) {
    return this.providers.get(url.host);
  }
  async getCredentials(opts) {
    const url = new URL(opts.url);
    const provider = this.forAzureDevOpsOrganization(url) ?? this.forAzureDevOpsServerOrganization(url) ?? this.forHost(url);
    if (provider === void 0) {
      return void 0;
    }
    return provider.getCredentials(opts);
  }
}

async function getAzureRequestOptions(config, additionalHeaders) {
  const headers = additionalHeaders ? { ...additionalHeaders } : {};
  const credentialConfig = config.credentials?.filter(
    (credential) => credential.organizations === void 0 || credential.organizations.length === 0
  )[0];
  if (credentialConfig) {
    const credentialsProvider = CachedAzureDevOpsCredentialsProvider.fromAzureDevOpsCredential(
      credentialConfig
    );
    const credentials = await credentialsProvider.getCredentials();
    return {
      headers: {
        ...credentials?.headers,
        ...headers
      }
    };
  }
  return { headers };
}

const BITBUCKET_HOST = "bitbucket.org";
const BITBUCKET_API_BASE_URL = "https://api.bitbucket.org/2.0";
function readBitbucketIntegrationConfig(config) {
  const host = config.getOptionalString("host") ?? BITBUCKET_HOST;
  let apiBaseUrl = config.getOptionalString("apiBaseUrl");
  const token = config.getOptionalString("token")?.trim();
  const username = config.getOptionalString("username");
  const appPassword = config.getOptionalString("appPassword")?.trim();
  if (!isValidHost(host)) {
    throw new Error(
      `Invalid Bitbucket integration config, '${host}' is not a valid host`
    );
  }
  if (apiBaseUrl) {
    apiBaseUrl = lodash.trimEnd(apiBaseUrl, "/");
  } else if (host === BITBUCKET_HOST) {
    apiBaseUrl = BITBUCKET_API_BASE_URL;
  } else {
    apiBaseUrl = `https://${host}/rest/api/1.0`;
  }
  return {
    host,
    apiBaseUrl,
    token,
    username,
    appPassword
  };
}
function readBitbucketIntegrationConfigs(configs) {
  const result = configs.map(readBitbucketIntegrationConfig);
  if (!result.some((c) => c.host === BITBUCKET_HOST)) {
    result.push({
      host: BITBUCKET_HOST,
      apiBaseUrl: BITBUCKET_API_BASE_URL
    });
  }
  return result;
}

class BitbucketIntegration {
  constructor(integrationConfig) {
    this.integrationConfig = integrationConfig;
  }
  static factory = ({
    config
  }) => {
    const configs = readBitbucketIntegrationConfigs(
      config.getOptionalConfigArray("integrations.bitbucket") ?? [
        // if integrations.bitbucket was not used assume the use was migrated to the new configs
        // and backport for the deprecated integration to be usable for other parts of the system
        // until these got migrated
        ...config.getOptionalConfigArray("integrations.bitbucketCloud") ?? [],
        ...config.getOptionalConfigArray("integrations.bitbucketServer") ?? []
      ]
    );
    return basicIntegrations(
      configs.map((c) => new BitbucketIntegration(c)),
      (i) => i.config.host
    );
  };
  get type() {
    return "bitbucket";
  }
  get title() {
    return this.integrationConfig.host;
  }
  get config() {
    return this.integrationConfig;
  }
  resolveUrl(options) {
    const resolved = defaultScmResolveUrl(options);
    if (!options.lineNumber) {
      return resolved;
    }
    const url = new URL(resolved);
    if (this.integrationConfig.host === "bitbucket.org") {
      url.hash = `lines-${options.lineNumber}`;
    } else {
      url.hash = `${options.lineNumber}`;
    }
    return url.toString();
  }
  resolveEditUrl(url) {
    const urlData = parseGitUrl__default.default(url);
    const editUrl = new URL(url);
    editUrl.searchParams.set("mode", "edit");
    editUrl.searchParams.set("spa", "0");
    editUrl.searchParams.set("at", urlData.ref);
    return editUrl.toString();
  }
}

async function getBitbucketDefaultBranch(url, config) {
  const { name: repoName, owner: project, resource } = parseGitUrl__default.default(url);
  const isHosted = resource === "bitbucket.org";
  let branchUrl = isHosted ? `${config.apiBaseUrl}/repositories/${project}/${repoName}` : `${config.apiBaseUrl}/projects/${project}/repos/${repoName}/default-branch`;
  let response = await fetch__default.default(branchUrl, getBitbucketRequestOptions(config));
  if (response.status === 404 && !isHosted) {
    branchUrl = `${config.apiBaseUrl}/projects/${project}/repos/${repoName}/branches/default`;
    response = await fetch__default.default(branchUrl, getBitbucketRequestOptions(config));
  }
  if (!response.ok) {
    const message = `Failed to retrieve default branch from ${branchUrl}, ${response.status} ${response.statusText}`;
    throw new Error(message);
  }
  let defaultBranch;
  if (isHosted) {
    const repoInfo = await response.json();
    defaultBranch = repoInfo.mainbranch.name;
  } else {
    const { displayId } = await response.json();
    defaultBranch = displayId;
  }
  if (!defaultBranch) {
    throw new Error(
      `Failed to read default branch from ${branchUrl}. Response ${response.status} ${response.json()}`
    );
  }
  return defaultBranch;
}
async function getBitbucketDownloadUrl(url, config) {
  const {
    name: repoName,
    owner: project,
    ref,
    protocol,
    resource,
    filepath
  } = parseGitUrl__default.default(url);
  const isHosted = resource === "bitbucket.org";
  let branch = ref;
  if (!branch) {
    branch = await getBitbucketDefaultBranch(url, config);
  }
  const path = filepath ? `&path=${encodeURIComponent(decodeURIComponent(filepath))}` : "";
  const archiveUrl = isHosted ? `${protocol}://${resource}/${project}/${repoName}/get/${branch}.tar.gz` : `${config.apiBaseUrl}/projects/${project}/repos/${repoName}/archive?format=tgz&at=${branch}&prefix=${project}-${repoName}${path}`;
  return archiveUrl;
}
function getBitbucketFileFetchUrl(url, config) {
  try {
    const { owner, name, ref, filepathtype, filepath } = parseGitUrl__default.default(url);
    if (!owner || !name || filepathtype !== "browse" && filepathtype !== "raw" && filepathtype !== "src") {
      throw new Error("Invalid Bitbucket URL or file path");
    }
    const pathWithoutSlash = filepath.replace(/^\//, "");
    if (config.host === "bitbucket.org") {
      if (!ref) {
        throw new Error("Invalid Bitbucket URL or file path");
      }
      return `${config.apiBaseUrl}/repositories/${owner}/${name}/src/${ref}/${pathWithoutSlash}`;
    }
    return `${config.apiBaseUrl}/projects/${owner}/repos/${name}/raw/${pathWithoutSlash}?at=${ref}`;
  } catch (e) {
    throw new Error(`Incorrect URL: ${url}, ${e}`);
  }
}
function getBitbucketRequestOptions(config) {
  const headers = {};
  if (config.token) {
    headers.Authorization = `Bearer ${config.token}`;
  } else if (config.username && config.appPassword) {
    const buffer = Buffer.from(
      `${config.username}:${config.appPassword}`,
      "utf8"
    );
    headers.Authorization = `Basic ${buffer.toString("base64")}`;
  }
  return {
    headers
  };
}

const BITBUCKET_CLOUD_HOST = "bitbucket.org";
const BITBUCKET_CLOUD_API_BASE_URL = "https://api.bitbucket.org/2.0";
function readBitbucketCloudIntegrationConfig(config) {
  const host = BITBUCKET_CLOUD_HOST;
  const apiBaseUrl = BITBUCKET_CLOUD_API_BASE_URL;
  const username = config.getString("username");
  const appPassword = config.getString("appPassword")?.trim();
  return {
    host,
    apiBaseUrl,
    username,
    appPassword
  };
}
function readBitbucketCloudIntegrationConfigs(configs) {
  const result = configs.map(readBitbucketCloudIntegrationConfig);
  if (result.length === 0) {
    result.push({
      host: BITBUCKET_CLOUD_HOST,
      apiBaseUrl: BITBUCKET_CLOUD_API_BASE_URL
    });
  }
  return result;
}

class BitbucketCloudIntegration {
  constructor(integrationConfig) {
    this.integrationConfig = integrationConfig;
  }
  static factory = ({
    config
  }) => {
    const configs = readBitbucketCloudIntegrationConfigs(
      config.getOptionalConfigArray("integrations.bitbucketCloud") ?? []
    );
    return basicIntegrations(
      configs.map((c) => new BitbucketCloudIntegration(c)),
      (i) => i.config.host
    );
  };
  get type() {
    return "bitbucketCloud";
  }
  get title() {
    return this.integrationConfig.host;
  }
  get config() {
    return this.integrationConfig;
  }
  resolveUrl(options) {
    const resolved = defaultScmResolveUrl(options);
    if (options.lineNumber) {
      const url = new URL(resolved);
      url.hash = `lines-${options.lineNumber}`;
      return url.toString();
    }
    return resolved;
  }
  resolveEditUrl(url) {
    const urlData = parseGitUrl__default.default(url);
    const editUrl = new URL(url);
    editUrl.searchParams.set("mode", "edit");
    editUrl.searchParams.set("at", urlData.ref);
    return editUrl.toString();
  }
}

async function getBitbucketCloudDefaultBranch(url, config) {
  const { name: repoName, owner: project } = parseGitUrl__default.default(url);
  const branchUrl = `${config.apiBaseUrl}/repositories/${project}/${repoName}`;
  const response = await fetch__default.default(
    branchUrl,
    getBitbucketCloudRequestOptions(config)
  );
  if (!response.ok) {
    const message = `Failed to retrieve default branch from ${branchUrl}, ${response.status} ${response.statusText}`;
    throw new Error(message);
  }
  const repoInfo = await response.json();
  const defaultBranch = repoInfo.mainbranch.name;
  if (!defaultBranch) {
    throw new Error(
      `Failed to read default branch from ${branchUrl}. Response ${response.status} ${response.json()}`
    );
  }
  return defaultBranch;
}
async function getBitbucketCloudDownloadUrl(url, config) {
  const {
    name: repoName,
    owner: project,
    ref,
    protocol,
    resource
  } = parseGitUrl__default.default(url);
  let branch = ref;
  if (!branch) {
    branch = await getBitbucketCloudDefaultBranch(url, config);
  }
  return `${protocol}://${resource}/${project}/${repoName}/get/${branch}.tar.gz`;
}
function getBitbucketCloudFileFetchUrl(url, config) {
  try {
    const { owner, name, ref, filepathtype, filepath } = parseGitUrl__default.default(url);
    if (!owner || !name || filepathtype !== "src" && filepathtype !== "raw") {
      throw new Error("Invalid Bitbucket Cloud URL or file path");
    }
    const pathWithoutSlash = filepath.replace(/^\//, "");
    if (!ref) {
      throw new Error("Invalid Bitbucket Cloud URL or file path");
    }
    return `${config.apiBaseUrl}/repositories/${owner}/${name}/src/${ref}/${pathWithoutSlash}`;
  } catch (e) {
    throw new Error(`Incorrect URL: ${url}, ${e}`);
  }
}
function getBitbucketCloudRequestOptions(config) {
  const headers = {};
  if (config.username && config.appPassword) {
    const buffer = Buffer.from(
      `${config.username}:${config.appPassword}`,
      "utf8"
    );
    headers.Authorization = `Basic ${buffer.toString("base64")}`;
  }
  return {
    headers
  };
}

function readBitbucketServerIntegrationConfig(config) {
  const host = config.getString("host");
  let apiBaseUrl = config.getOptionalString("apiBaseUrl");
  const token = config.getOptionalString("token")?.trim();
  const username = config.getOptionalString("username");
  const password = config.getOptionalString("password");
  if (!isValidHost(host)) {
    throw new Error(
      `Invalid Bitbucket Server integration config, '${host}' is not a valid host`
    );
  }
  if (apiBaseUrl) {
    apiBaseUrl = lodash.trimEnd(apiBaseUrl, "/");
  } else {
    apiBaseUrl = `https://${host}/rest/api/1.0`;
  }
  return {
    host,
    apiBaseUrl,
    token,
    username,
    password
  };
}
function readBitbucketServerIntegrationConfigs(configs) {
  return configs.map(readBitbucketServerIntegrationConfig);
}

class BitbucketServerIntegration {
  constructor(integrationConfig) {
    this.integrationConfig = integrationConfig;
  }
  static factory = ({
    config
  }) => {
    const configs = readBitbucketServerIntegrationConfigs(
      config.getOptionalConfigArray("integrations.bitbucketServer") ?? []
    );
    return basicIntegrations(
      configs.map((c) => new BitbucketServerIntegration(c)),
      (i) => i.config.host
    );
  };
  get type() {
    return "bitbucketServer";
  }
  get title() {
    return this.integrationConfig.host;
  }
  get config() {
    return this.integrationConfig;
  }
  resolveUrl(options) {
    const resolved = defaultScmResolveUrl(options);
    if (options.lineNumber) {
      const url = new URL(resolved);
      url.hash = options.lineNumber.toString();
      return url.toString();
    }
    return resolved;
  }
  resolveEditUrl(url) {
    if (url.includes("?")) {
      return url.substring(0, url.indexOf("?"));
    }
    return url;
  }
}

async function getBitbucketServerDefaultBranch(url, config) {
  const { name: repoName, owner: project } = parseGitUrl__default.default(url);
  let branchUrl = `${config.apiBaseUrl}/projects/${project}/repos/${repoName}/default-branch`;
  let response = await fetch__default.default(
    branchUrl,
    getBitbucketServerRequestOptions(config)
  );
  if (response.status === 404) {
    branchUrl = `${config.apiBaseUrl}/projects/${project}/repos/${repoName}/branches/default`;
    response = await fetch__default.default(branchUrl, getBitbucketServerRequestOptions(config));
  }
  if (!response.ok) {
    const message = `Failed to retrieve default branch from ${branchUrl}, ${response.status} ${response.statusText}`;
    throw new Error(message);
  }
  const { displayId } = await response.json();
  const defaultBranch = displayId;
  if (!defaultBranch) {
    throw new Error(
      `Failed to read default branch from ${branchUrl}. Response ${response.status} ${response.json()}`
    );
  }
  return defaultBranch;
}
async function getBitbucketServerDownloadUrl(url, config) {
  const { name: repoName, owner: project, ref, filepath } = parseGitUrl__default.default(url);
  let branch = ref;
  if (!branch) {
    branch = await getBitbucketServerDefaultBranch(url, config);
  }
  const path = filepath ? `&path=${encodeURIComponent(decodeURIComponent(filepath))}` : "";
  return `${config.apiBaseUrl}/projects/${project}/repos/${repoName}/archive?format=tgz&at=${branch}&prefix=${project}-${repoName}${path}`;
}
function getBitbucketServerFileFetchUrl(url, config) {
  try {
    const { owner, name, ref, filepathtype, filepath } = parseGitUrl__default.default(url);
    if (!owner || !name || filepathtype !== "browse" && filepathtype !== "raw" && filepathtype !== "src") {
      throw new Error("Invalid Bitbucket Server URL or file path");
    }
    const pathWithoutSlash = filepath.replace(/^\//, "");
    return `${config.apiBaseUrl}/projects/${owner}/repos/${name}/raw/${pathWithoutSlash}?at=${ref}`;
  } catch (e) {
    throw new Error(`Incorrect URL: ${url}, ${e}`);
  }
}
function getBitbucketServerRequestOptions(config) {
  const headers = {};
  if (config.token) {
    headers.Authorization = `Bearer ${config.token}`;
  } else if (config.username && config.password) {
    const buffer = Buffer.from(`${config.username}:${config.password}`, "utf8");
    headers.Authorization = `Basic ${buffer.toString("base64")}`;
  }
  return {
    headers
  };
}

function readGerritIntegrationConfig(config) {
  const host = config.getString("host");
  let baseUrl = config.getOptionalString("baseUrl");
  let cloneUrl = config.getOptionalString("cloneUrl");
  let gitilesBaseUrl = config.getString("gitilesBaseUrl");
  const username = config.getOptionalString("username");
  const password = config.getOptionalString("password")?.trim();
  if (!isValidHost(host)) {
    throw new Error(
      `Invalid Gerrit integration config, '${host}' is not a valid host`
    );
  } else if (baseUrl && !isValidUrl(baseUrl)) {
    throw new Error(
      `Invalid Gerrit integration config, '${baseUrl}' is not a valid baseUrl`
    );
  } else if (cloneUrl && !isValidUrl(cloneUrl)) {
    throw new Error(
      `Invalid Gerrit integration config, '${cloneUrl}' is not a valid cloneUrl`
    );
  } else if (!isValidUrl(gitilesBaseUrl)) {
    throw new Error(
      `Invalid Gerrit integration config, '${gitilesBaseUrl}' is not a valid gitilesBaseUrl`
    );
  }
  if (baseUrl) {
    baseUrl = lodash.trimEnd(baseUrl, "/");
  } else {
    baseUrl = `https://${host}`;
  }
  if (gitilesBaseUrl) {
    gitilesBaseUrl = lodash.trimEnd(gitilesBaseUrl, "/");
  } else {
    gitilesBaseUrl = `https://${host}`;
  }
  if (cloneUrl) {
    cloneUrl = lodash.trimEnd(cloneUrl, "/");
  } else {
    cloneUrl = baseUrl;
  }
  return {
    host,
    baseUrl,
    cloneUrl,
    gitilesBaseUrl,
    username,
    password
  };
}
function readGerritIntegrationConfigs(configs) {
  return configs.map(readGerritIntegrationConfig);
}

const GERRIT_BODY_PREFIX = ")]}'";
function parseGerritGitilesUrl(config, url) {
  const baseUrlParse = new URL(config.gitilesBaseUrl);
  const urlParse = new URL(url);
  const urlPath = urlParse.pathname.substring(urlParse.pathname.startsWith("/a/") ? 2 : 0).replace(baseUrlParse.pathname, "");
  const parts = urlPath.split("/").filter((p) => !!p);
  const projectEndIndex = parts.indexOf("+");
  if (projectEndIndex <= 0) {
    throw new Error(`Unable to parse project from url: ${url}`);
  }
  const project = lodash.trimStart(parts.slice(0, projectEndIndex).join("/"), "/");
  const branchIndex = parts.indexOf("heads");
  if (branchIndex <= 0) {
    throw new Error(`Unable to parse branch from url: ${url}`);
  }
  const branch = parts[branchIndex + 1];
  const filePath = parts.slice(branchIndex + 2).join("/");
  return {
    branch,
    filePath: filePath === "" ? "/" : filePath,
    project
  };
}
function parseGitilesUrlRef(config, url) {
  const baseUrlParse = new URL(config.gitilesBaseUrl);
  const urlParse = new URL(url);
  const urlPath = lodash.trimStart(
    urlParse.pathname.substring(urlParse.pathname.startsWith("/a/") ? 2 : 0).replace(baseUrlParse.pathname, ""),
    "/"
  );
  const parts = urlPath.split("/").filter((p) => !!p);
  const projectParts = lodash.takeWhile(parts, (p) => p !== "+");
  if (projectParts.length === 0) {
    throw new Error(`Unable to parse gitiles url: ${url}`);
  }
  const rest = parts.slice(projectParts.length + 1);
  const project = lodash.join(projectParts, "/");
  if (rest.length > 0 && rest[0] === "HEAD") {
    const ref = rest.shift();
    const path = lodash.join(rest, "/");
    return {
      project,
      ref,
      refType: "head",
      path: path || "/",
      basePath: lodash.trimEnd(url.replace(path, ""), "/")
    };
  }
  if (rest.length > 0 && rest[0].length === 40) {
    const ref = rest.shift();
    const path = lodash.join(rest, "/");
    return {
      project,
      ref,
      refType: "sha",
      path: path || "/",
      basePath: lodash.trimEnd(url.replace(path, ""), "/")
    };
  }
  const remainingPath = lodash.join(rest, "/");
  const refsRegexp = /^refs\/(?<refsReference>heads|tags)\/(?<ref>.*?)(\/|$)/;
  const result = refsRegexp.exec(remainingPath);
  if (result) {
    const matchString = result[0];
    let refType;
    const { refsReference, ref } = result.groups || {};
    const path = remainingPath.replace(matchString, "");
    switch (refsReference) {
      case "heads":
        refType = "branch";
        break;
      case "tags":
        refType = "tag";
        break;
      default:
        throw new Error(`Unable to parse gitiles url: ${url}`);
    }
    return {
      project,
      ref,
      refType,
      path: path || "/",
      basePath: lodash.trimEnd(url.replace(path, ""), "/")
    };
  }
  throw new Error(`Unable to parse gitiles : ${url}`);
}
function buildGerritGitilesArchiveUrl(config, project, branch, filePath) {
  const archiveName = filePath === "/" || filePath === "" ? ".tar.gz" : `/${filePath}.tar.gz`;
  return `${getGitilesAuthenticationUrl(
    config
  )}/${project}/+archive/refs/heads/${branch}${archiveName}`;
}
function getAuthenticationPrefix(config) {
  return config.password ? "/a/" : "/";
}
function getGitilesAuthenticationUrl(config) {
  if (!config.baseUrl || !config.gitilesBaseUrl) {
    throw new Error(
      "Unexpected Gerrit config values. baseUrl or gitilesBaseUrl not set."
    );
  }
  if (config.gitilesBaseUrl.startsWith(config.baseUrl)) {
    return config.gitilesBaseUrl.replace(
      config.baseUrl.concat("/"),
      config.baseUrl.concat(getAuthenticationPrefix(config))
    );
  }
  if (config.password) {
    throw new Error(
      "Since the baseUrl (Gerrit) is not part of the gitilesBaseUrl, an authentication URL could not be constructed."
    );
  }
  return config.gitilesBaseUrl;
}
function getGerritBranchApiUrl(config, url) {
  const { branch, project } = parseGerritGitilesUrl(config, url);
  return `${config.baseUrl}${getAuthenticationPrefix(
    config
  )}projects/${encodeURIComponent(project)}/branches/${branch}`;
}
function getGerritCloneRepoUrl(config, url) {
  const { project } = parseGerritGitilesUrl(config, url);
  return `${config.cloneUrl}${getAuthenticationPrefix(config)}${project}`;
}
function getGerritFileContentsApiUrl(config, url) {
  const { branch, filePath, project } = parseGerritGitilesUrl(config, url);
  return `${config.baseUrl}${getAuthenticationPrefix(
    config
  )}projects/${encodeURIComponent(
    project
  )}/branches/${branch}/files/${encodeURIComponent(filePath)}/content`;
}
function getGerritProjectsApiUrl(config) {
  return `${config.baseUrl}${getAuthenticationPrefix(config)}projects/`;
}
function getGerritRequestOptions(config) {
  const headers = {};
  if (!config.password) {
    return headers;
  }
  const buffer = Buffer.from(`${config.username}:${config.password}`, "utf8");
  headers.Authorization = `Basic ${buffer.toString("base64")}`;
  return {
    headers
  };
}
async function parseGerritJsonResponse(response) {
  const responseBody = await response.text();
  if (responseBody.startsWith(GERRIT_BODY_PREFIX)) {
    try {
      return JSON.parse(responseBody.slice(GERRIT_BODY_PREFIX.length));
    } catch (ex) {
      throw new Error(
        `Invalid response from Gerrit: ${responseBody.slice(0, 10)} - ${ex}`
      );
    }
  }
  throw new Error(
    `Gerrit JSON body prefix missing. Found: ${responseBody.slice(0, 10)}`
  );
}

class GerritIntegration {
  constructor(integrationConfig) {
    this.integrationConfig = integrationConfig;
  }
  static factory = ({ config }) => {
    const configs = readGerritIntegrationConfigs(
      config.getOptionalConfigArray("integrations.gerrit") ?? []
    );
    return basicIntegrations(
      configs.map((c) => new GerritIntegration(c)),
      (i) => i.config.host
    );
  };
  get type() {
    return "gerrit";
  }
  get title() {
    return this.integrationConfig.host;
  }
  get config() {
    return this.integrationConfig;
  }
  resolveUrl(options) {
    const { url, base, lineNumber } = options;
    let updated;
    if (url.startsWith("/")) {
      const { basePath } = parseGitilesUrlRef(this.config, base);
      return basePath + url;
    }
    if (url) {
      updated = new URL(url, base);
    } else {
      updated = new URL(base);
    }
    if (lineNumber) {
      updated.hash = lineNumber.toString();
    }
    return updated.toString();
  }
  resolveEditUrl(url) {
    return url;
  }
}

function readGiteaConfig(config) {
  const host = config.getString("host");
  let baseUrl = config.getOptionalString("baseUrl");
  const username = config.getOptionalString("username");
  const password = config.getOptionalString("password")?.trim();
  if (!isValidHost(host)) {
    throw new Error(
      `Invalid Gitea integration config, '${host}' is not a valid host`
    );
  } else if (baseUrl && !isValidUrl(baseUrl)) {
    throw new Error(
      `Invalid Gitea integration config, '${baseUrl}' is not a valid baseUrl`
    );
  }
  if (baseUrl) {
    baseUrl = lodash.trimEnd(baseUrl, "/");
  } else {
    baseUrl = `https://${host}`;
  }
  return {
    host,
    baseUrl,
    username,
    password
  };
}

function getGiteaEditContentsUrl(config, url) {
  const giteaUrl = parseGiteaUrl(config, url);
  return `${giteaUrl.url}/${giteaUrl.owner}/${giteaUrl.name}/_edit/${giteaUrl.ref}/${giteaUrl.path}`;
}
function getGiteaFileContentsUrl(config, url) {
  const giteaUrl = parseGiteaUrl(config, url);
  return `${giteaUrl.url}/api/v1/repos/${giteaUrl.owner}/${giteaUrl.name}/contents/${giteaUrl.path}?ref=${giteaUrl.ref}`;
}
function getGiteaArchiveUrl(config, url) {
  const giteaUrl = parseGiteaUrl(config, url);
  return `${giteaUrl.url}/api/v1/repos/${giteaUrl.owner}/${giteaUrl.name}/archive/${giteaUrl.ref}.tar.gz`;
}
function getGiteaLatestCommitUrl(config, url) {
  const giteaUrl = parseGiteaUrl(config, url);
  return `${giteaUrl.url}/api/v1/repos/${giteaUrl.owner}/${giteaUrl.name}/git/commits/${giteaUrl.ref}`;
}
function getGiteaRequestOptions(config) {
  const headers = {};
  const { username, password } = config;
  if (!password) {
    return headers;
  }
  if (username) {
    headers.Authorization = `basic ${Buffer.from(
      `${username}:${password}`
    ).toString("base64")}`;
  } else {
    headers.Authorization = `token ${password}`;
  }
  return {
    headers
  };
}
function parseGiteaUrl(config, url) {
  const baseUrl = config.baseUrl ?? `https://${config.host}`;
  try {
    const [_blank, owner, name, _src, _branch, ref, ...path] = url.replace(baseUrl, "").split("/");
    const pathWithoutSlash = path.join("/").replace(/^\//, "");
    return {
      url: baseUrl,
      owner,
      name,
      ref,
      path: pathWithoutSlash
    };
  } catch (e) {
    throw new Error(`Incorrect URL: ${url}, ${e}`);
  }
}

class GiteaIntegration {
  constructor(config) {
    this.config = config;
  }
  static factory = ({ config }) => {
    const configs = config.getOptionalConfigArray("integrations.gitea") ?? [];
    const giteaConfigs = configs.map((c) => readGiteaConfig(c));
    return basicIntegrations(
      giteaConfigs.map((c) => new GiteaIntegration(c)),
      (gitea) => gitea.config.host
    );
  };
  get type() {
    return "gitea";
  }
  get title() {
    return this.config.host;
  }
  resolveUrl(options) {
    return defaultScmResolveUrl(options);
  }
  resolveEditUrl(url) {
    return getGiteaEditContentsUrl(this.config, url);
  }
}

const GITHUB_HOST = "github.com";
const GITHUB_API_BASE_URL = "https://api.github.com";
const GITHUB_RAW_BASE_URL = "https://raw.githubusercontent.com";
function readGithubIntegrationConfig(config) {
  const host = config.getOptionalString("host") ?? GITHUB_HOST;
  let apiBaseUrl = config.getOptionalString("apiBaseUrl");
  let rawBaseUrl = config.getOptionalString("rawBaseUrl");
  const token = config.getOptionalString("token")?.trim();
  const apps = config.getOptionalConfigArray("apps")?.map((c) => ({
    appId: c.getNumber("appId"),
    clientId: c.getString("clientId"),
    clientSecret: c.getString("clientSecret"),
    webhookSecret: c.getString("webhookSecret"),
    privateKey: c.getString("privateKey"),
    allowedInstallationOwners: c.getOptionalStringArray(
      "allowedInstallationOwners"
    )
  }));
  if (!isValidHost(host)) {
    throw new Error(
      `Invalid GitHub integration config, '${host}' is not a valid host`
    );
  }
  if (apiBaseUrl) {
    apiBaseUrl = lodash.trimEnd(apiBaseUrl, "/");
  } else if (host === GITHUB_HOST) {
    apiBaseUrl = GITHUB_API_BASE_URL;
  }
  if (rawBaseUrl) {
    rawBaseUrl = lodash.trimEnd(rawBaseUrl, "/");
  } else if (host === GITHUB_HOST) {
    rawBaseUrl = GITHUB_RAW_BASE_URL;
  }
  return { host, apiBaseUrl, rawBaseUrl, token, apps };
}
function readGithubIntegrationConfigs(configs) {
  const result = configs.map(readGithubIntegrationConfig);
  if (!result.some((c) => c.host === GITHUB_HOST)) {
    result.push({
      host: GITHUB_HOST,
      apiBaseUrl: GITHUB_API_BASE_URL,
      rawBaseUrl: GITHUB_RAW_BASE_URL
    });
  }
  return result;
}

function getGithubFileFetchUrl(url, config, credentials) {
  try {
    const { owner, name, ref, filepathtype, filepath } = parseGitUrl__default.default(url);
    if (!owner || !name || !ref || // GitHub is automatically redirecting tree urls to blob urls so it's
    // fine to pass a tree url.
    filepathtype !== "blob" && filepathtype !== "raw" && filepathtype !== "tree") {
      throw new Error("Invalid GitHub URL or file path");
    }
    const pathWithoutSlash = filepath.replace(/^\//, "");
    if (chooseEndpoint(config, credentials) === "api") {
      return `${config.apiBaseUrl}/repos/${owner}/${name}/contents/${pathWithoutSlash}?ref=${ref}`;
    }
    return `${config.rawBaseUrl}/${owner}/${name}/${ref}/${pathWithoutSlash}`;
  } catch (e) {
    throw new Error(`Incorrect URL: ${url}, ${e}`);
  }
}
function getGitHubRequestOptions(config, credentials) {
  const headers = {};
  if (chooseEndpoint(config, credentials) === "api") {
    headers.Accept = "application/vnd.github.v3.raw";
  }
  if (credentials.token) {
    headers.Authorization = `token ${credentials.token}`;
  }
  return { headers };
}
function chooseEndpoint(config, credentials) {
  if (config.apiBaseUrl && (credentials.token || !config.rawBaseUrl)) {
    return "api";
  }
  return "raw";
}

class Cache {
  tokenCache = /* @__PURE__ */ new Map();
  async getOrCreateToken(owner, repo, supplier) {
    let existingInstallationData = this.tokenCache.get(owner);
    if (!existingInstallationData || this.isExpired(existingInstallationData.expiresAt)) {
      existingInstallationData = await supplier();
      existingInstallationData.expiresAt = existingInstallationData.expiresAt.minus({ minutes: 10 });
      this.tokenCache.set(owner, existingInstallationData);
    }
    if (!this.appliesToRepo(existingInstallationData, repo)) {
      throw new Error(
        `The Backstage GitHub application used in the ${owner} organization does not have access to a repository with the name ${repo}`
      );
    }
    return { accessToken: existingInstallationData.token };
  }
  isExpired = (date) => luxon.DateTime.local() > date;
  appliesToRepo(tokenData, repo) {
    if (repo === void 0) {
      return true;
    }
    if (tokenData.repositories !== void 0) {
      return tokenData.repositories.includes(repo);
    }
    return true;
  }
}
const HEADERS = {
  Accept: "application/vnd.github.machine-man-preview+json"
};
class GithubAppManager {
  appClient;
  baseUrl;
  baseAuthConfig;
  cache = new Cache();
  allowedInstallationOwners;
  // undefined allows all installations
  constructor(config, baseUrl) {
    this.allowedInstallationOwners = config.allowedInstallationOwners;
    this.baseUrl = baseUrl;
    this.baseAuthConfig = {
      appId: config.appId,
      privateKey: config.privateKey.replace(/\\n/gm, "\n")
    };
    this.appClient = new rest.Octokit({
      baseUrl,
      headers: HEADERS,
      authStrategy: authApp.createAppAuth,
      auth: this.baseAuthConfig
    });
  }
  async getInstallationCredentials(owner, repo) {
    if (this.allowedInstallationOwners) {
      if (!this.allowedInstallationOwners?.includes(owner)) {
        return { accessToken: void 0 };
      }
    }
    return this.cache.getOrCreateToken(owner, repo, async () => {
      const { installationId, suspended } = await this.getInstallationData(
        owner
      );
      if (suspended) {
        throw new Error(`The GitHub application for ${owner} is suspended`);
      }
      const result = await this.appClient.apps.createInstallationAccessToken({
        installation_id: installationId,
        headers: HEADERS
      });
      let repositoryNames;
      if (result.data.repository_selection === "selected") {
        const installationClient = new rest.Octokit({
          baseUrl: this.baseUrl,
          auth: result.data.token
        });
        const repos = await installationClient.paginate(
          installationClient.apps.listReposAccessibleToInstallation
        );
        const repositories = repos.repositories ?? repos;
        repositoryNames = repositories.map((repository) => repository.name);
      }
      return {
        token: result.data.token,
        expiresAt: luxon.DateTime.fromISO(result.data.expires_at),
        repositories: repositoryNames
      };
    });
  }
  getInstallations() {
    return this.appClient.paginate(this.appClient.apps.listInstallations);
  }
  async getInstallationData(owner) {
    const allInstallations = await this.getInstallations();
    const installation = allInstallations.find(
      (inst) => inst.account && "login" in inst.account && inst.account.login?.toLocaleLowerCase("en-US") === owner.toLocaleLowerCase("en-US")
    );
    if (installation) {
      return {
        installationId: installation.id,
        suspended: Boolean(installation.suspended_by)
      };
    }
    const notFoundError = new Error(
      `No app installation found for ${owner} in ${this.baseAuthConfig.appId}`
    );
    notFoundError.name = "NotFoundError";
    throw notFoundError;
  }
}
class GithubAppCredentialsMux {
  apps;
  constructor(config) {
    this.apps = config.apps?.map((ac) => new GithubAppManager(ac, config.apiBaseUrl)) ?? [];
  }
  async getAllInstallations() {
    if (!this.apps.length) {
      return [];
    }
    const installs = await Promise.all(
      this.apps.map((app) => app.getInstallations())
    );
    return installs.flat();
  }
  async getAppToken(owner, repo) {
    if (this.apps.length === 0) {
      return void 0;
    }
    const results = await Promise.all(
      this.apps.map(
        (app) => app.getInstallationCredentials(owner, repo).then(
          (credentials) => ({ credentials, error: void 0 }),
          (error) => ({ credentials: void 0, error })
        )
      )
    );
    const result = results.find(
      (resultItem) => resultItem.credentials?.accessToken
    );
    if (result) {
      return result.credentials.accessToken;
    }
    const errors = results.map((r) => r.error);
    const notNotFoundError = errors.find((err) => err?.name !== "NotFoundError");
    if (notNotFoundError) {
      throw notNotFoundError;
    }
    return void 0;
  }
}
class SingleInstanceGithubCredentialsProvider {
  constructor(githubAppCredentialsMux, token) {
    this.githubAppCredentialsMux = githubAppCredentialsMux;
    this.token = token;
  }
  static create = (config) => {
    return new SingleInstanceGithubCredentialsProvider(
      new GithubAppCredentialsMux(config),
      config.token
    );
  };
  /**
   * Returns {@link GithubCredentials} for a given URL.
   *
   * @remarks
   *
   * Consecutive calls to this method with the same URL will return cached
   * credentials.
   *
   * The shortest lifetime for a token returned is 10 minutes.
   *
   * @example
   * ```ts
   * const { token, headers } = await getCredentials({
   *   url: 'github.com/backstage/foobar'
   * })
   * ```
   *
   * @param opts - The organization or repository URL
   * @returns A promise of {@link GithubCredentials}.
   */
  async getCredentials(opts) {
    const parsed = parseGitUrl__default.default(opts.url);
    const owner = parsed.owner || parsed.name;
    const repo = parsed.owner ? parsed.name : void 0;
    let type = "app";
    let token = await this.githubAppCredentialsMux.getAppToken(owner, repo);
    if (!token) {
      type = "token";
      token = this.token;
    }
    return {
      headers: token ? { Authorization: `Bearer ${token}` } : void 0,
      token,
      type
    };
  }
}

class DefaultGithubCredentialsProvider {
  constructor(providers) {
    this.providers = providers;
  }
  static fromIntegrations(integrations) {
    const credentialsProviders = /* @__PURE__ */ new Map();
    integrations.github.list().forEach((integration) => {
      const credentialsProvider = SingleInstanceGithubCredentialsProvider.create(integration.config);
      credentialsProviders.set(integration.config.host, credentialsProvider);
    });
    return new DefaultGithubCredentialsProvider(credentialsProviders);
  }
  /**
   * Returns {@link GithubCredentials} for a given URL.
   *
   * @remarks
   *
   * Consecutive calls to this method with the same URL will return cached
   * credentials.
   *
   * The shortest lifetime for a token returned is 10 minutes.
   *
   * @example
   * ```ts
   * const { token, headers } = await getCredentials({
   *   url: 'https://github.com/backstage/foobar'
   * })
   *
   * const { token, headers } = await getCredentials({
   *   url: 'https://github.com/backstage'
   * })
   * ```
   *
   * @param opts - The organization or repository URL
   * @returns A promise of {@link GithubCredentials}.
   */
  async getCredentials(opts) {
    const parsed = new URL(opts.url);
    const provider = this.providers.get(parsed.host);
    if (!provider) {
      throw new Error(
        `There is no GitHub integration that matches ${opts.url}. Please add a configuration for an integration.`
      );
    }
    return provider.getCredentials(opts);
  }
}

class GithubIntegration {
  constructor(integrationConfig) {
    this.integrationConfig = integrationConfig;
  }
  static factory = ({ config }) => {
    const configs = readGithubIntegrationConfigs(
      config.getOptionalConfigArray("integrations.github") ?? []
    );
    return basicIntegrations(
      configs.map((c) => new GithubIntegration(c)),
      (i) => i.config.host
    );
  };
  get type() {
    return "github";
  }
  get title() {
    return this.integrationConfig.host;
  }
  get config() {
    return this.integrationConfig;
  }
  resolveUrl(options) {
    return replaceGithubUrlType(defaultScmResolveUrl(options), "tree");
  }
  resolveEditUrl(url) {
    return replaceGithubUrlType(url, "edit");
  }
  parseRateLimitInfo(response) {
    return {
      isRateLimited: response.status === 429 || response.status === 403 && response.headers.get("x-ratelimit-remaining") === "0"
    };
  }
}
function replaceGithubUrlType(url, type) {
  return url.replace(
    /\/\/([^/]+)\/([^/]+)\/([^/]+)\/(blob|tree|edit)\//,
    (_, host, owner, repo) => {
      return `//${host}/${owner}/${repo}/${type}/`;
    }
  );
}

const GITLAB_HOST = "gitlab.com";
const GITLAB_API_BASE_URL = "https://gitlab.com/api/v4";
function readGitLabIntegrationConfig(config) {
  const host = config.getString("host");
  let apiBaseUrl = config.getOptionalString("apiBaseUrl");
  const token = config.getOptionalString("token")?.trim();
  let baseUrl = config.getOptionalString("baseUrl");
  if (apiBaseUrl) {
    apiBaseUrl = lodash.trimEnd(apiBaseUrl, "/");
  } else if (host === GITLAB_HOST) {
    apiBaseUrl = GITLAB_API_BASE_URL;
  }
  if (baseUrl) {
    baseUrl = lodash.trimEnd(baseUrl, "/");
  } else {
    baseUrl = `https://${host}`;
  }
  if (!isValidHost(host)) {
    throw new Error(
      `Invalid GitLab integration config, '${host}' is not a valid host`
    );
  } else if (!apiBaseUrl || !isValidUrl(apiBaseUrl)) {
    throw new Error(
      `Invalid GitLab integration config, '${apiBaseUrl}' is not a valid apiBaseUrl`
    );
  } else if (!isValidUrl(baseUrl)) {
    throw new Error(
      `Invalid GitLab integration config, '${baseUrl}' is not a valid baseUrl`
    );
  }
  return { host, token, apiBaseUrl, baseUrl };
}
function readGitLabIntegrationConfigs(configs) {
  const result = configs.map(readGitLabIntegrationConfig);
  if (!result.some((c) => c.host === GITLAB_HOST)) {
    result.push({
      host: GITLAB_HOST,
      apiBaseUrl: GITLAB_API_BASE_URL,
      baseUrl: `https://${GITLAB_HOST}`
    });
  }
  return result;
}
function getGitLabIntegrationRelativePath(config) {
  let relativePath = "";
  if (config.host !== GITLAB_HOST) {
    relativePath = new URL(config.baseUrl).pathname;
  }
  return lodash.trimEnd(relativePath, "/");
}

async function getGitLabFileFetchUrl(url, config) {
  const projectID = await getProjectId(url, config);
  return buildProjectUrl(url, projectID, config).toString();
}
function getGitLabRequestOptions(config, token) {
  if (token) {
    return {
      headers: token.startsWith("gl") ? { "PRIVATE-TOKEN": token } : { Authorization: `Bearer ${token}` }
      // Otherwise, it's a bearer token
    };
  }
  const { token: configToken = "" } = config;
  return {
    headers: { "PRIVATE-TOKEN": configToken }
  };
}
function buildProjectUrl(target, projectID, config) {
  try {
    const url = new URL(target);
    const branchAndFilePath = url.pathname.split("/blob/").slice(1).join("/blob/");
    const [branch, ...filePath] = branchAndFilePath.split("/");
    const relativePath = getGitLabIntegrationRelativePath(config);
    url.pathname = [
      ...relativePath ? [relativePath] : [],
      "api/v4/projects",
      projectID,
      "repository/files",
      encodeURIComponent(decodeURIComponent(filePath.join("/"))),
      "raw"
    ].join("/");
    url.search = `?ref=${branch}`;
    return url;
  } catch (e) {
    throw new Error(`Incorrect url: ${target}, ${e}`);
  }
}
async function getProjectId(target, config) {
  const url = new URL(target);
  if (!url.pathname.includes("/blob/")) {
    throw new Error("Please provide full path to yaml file from GitLab");
  }
  try {
    let repo = url.pathname.split("/-/blob/")[0].split("/blob/")[0];
    const relativePath = getGitLabIntegrationRelativePath(config);
    if (relativePath) {
      repo = repo.replace(relativePath, "");
    }
    const repoIDLookup = new URL(
      `${url.origin}${relativePath}/api/v4/projects/${encodeURIComponent(
        repo.replace(/^\//, "")
      )}`
    );
    const response = await fetch__default.default(
      repoIDLookup.toString(),
      getGitLabRequestOptions(config)
    );
    const data = await response.json();
    if (!response.ok) {
      throw new Error(
        `GitLab Error '${data.error}', ${data.error_description}`
      );
    }
    return Number(data.id);
  } catch (e) {
    throw new Error(`Could not get GitLab project ID for: ${target}, ${e}`);
  }
}

class GitLabIntegration {
  constructor(integrationConfig) {
    this.integrationConfig = integrationConfig;
  }
  static factory = ({ config }) => {
    const configs = readGitLabIntegrationConfigs(
      config.getOptionalConfigArray("integrations.gitlab") ?? []
    );
    return basicIntegrations(
      configs.map((c) => new GitLabIntegration(c)),
      (i) => i.config.host
    );
  };
  get type() {
    return "gitlab";
  }
  get title() {
    return this.integrationConfig.host;
  }
  get config() {
    return this.integrationConfig;
  }
  resolveUrl(options) {
    return defaultScmResolveUrl(options);
  }
  resolveEditUrl(url) {
    return replaceGitLabUrlType(url, "edit");
  }
}
function replaceGitLabUrlType(url, type) {
  return url.replace(/\/\-\/(blob|tree|edit)\//, `/-/${type}/`);
}

class SingleInstanceGitlabCredentialsProvider {
  constructor(token) {
    this.token = token;
  }
  static create = (config) => {
    return new SingleInstanceGitlabCredentialsProvider(config.token);
  };
  async getCredentials(_opts) {
    if (!this.token) {
      return {};
    }
    return {
      headers: {
        Authorization: `Bearer ${this.token}`
      },
      token: this.token
    };
  }
}

class DefaultGitlabCredentialsProvider {
  constructor(providers) {
    this.providers = providers;
  }
  static fromIntegrations(integrations) {
    const credentialsProviders = /* @__PURE__ */ new Map();
    integrations.gitlab.list().forEach((integration) => {
      const credentialsProvider = SingleInstanceGitlabCredentialsProvider.create(integration.config);
      credentialsProviders.set(integration.config.host, credentialsProvider);
    });
    return new DefaultGitlabCredentialsProvider(credentialsProviders);
  }
  async getCredentials(opts) {
    const parsed = new URL(opts.url);
    const provider = this.providers.get(parsed.host);
    if (!provider) {
      throw new Error(
        `There is no GitLab integration that matches ${opts.url}. Please add a configuration for an integration.`
      );
    }
    return provider.getCredentials(opts);
  }
}

function readGoogleGcsIntegrationConfig(config) {
  if (!config) {
    return {};
  }
  if (!config.has("clientEmail") && !config.has("privateKey")) {
    return {};
  }
  const privateKey = config.getString("privateKey").split("\\n").join("\n");
  const clientEmail = config.getString("clientEmail");
  return { clientEmail, privateKey };
}

function readHarnessConfig(config) {
  const host = config.getString("host");
  const token = config.getOptionalString("token");
  const apiKey = config.getOptionalString("apiKey");
  if (!isValidHost(host)) {
    throw new Error(
      `Invalid Harness Code integration config, '${host}' is not a valid host`
    );
  }
  return {
    host,
    apiKey,
    token
  };
}

function getHarnessEditContentsUrl(config, url) {
  const parsedUrl = parseHarnessUrl(config, url);
  return `${parsedUrl.baseUrl}/ng/account/${parsedUrl.accountId}/module/code${parsedUrl.orgName !== "" ? `/orgs/${parsedUrl.orgName}` : ""}${parsedUrl.projectName !== "" ? `/projects/${parsedUrl.projectName}` : ""}/repos/${parsedUrl.repoName}/files/${parsedUrl.branch}/~/${parsedUrl.path}`;
}
function getHarnessFileContentsUrl(config, url) {
  const parsedUrl = parseHarnessUrl(config, url);
  return `${parsedUrl.baseUrl}/gateway/code/api/v1/repos/${parsedUrl.accountId}/${parsedUrl.orgName}${parsedUrl.projectName !== "" ? `/${parsedUrl.projectName}/` : "/"}${parsedUrl.repoName}/+/raw/${parsedUrl.path}?routingId=${parsedUrl.accountId}&git_ref=refs/heads/${parsedUrl.refString}`;
}
function getHarnessArchiveUrl(config, url) {
  const parsedUrl = parseHarnessUrl(config, url);
  return `${parsedUrl.baseUrl}/gateway/code/api/v1/repos/${parsedUrl.accountId}/${parsedUrl.orgName}${parsedUrl.projectName !== "" ? `/${parsedUrl.projectName}/` : "/"}${parsedUrl.repoName}/+/archive/${parsedUrl.branch}.zip?routingId=${parsedUrl.accountId}`;
}
function getHarnessLatestCommitUrl(config, url) {
  const parsedUrl = parseHarnessUrl(config, url);
  return `${parsedUrl.baseUrl}/gateway/code/api/v1/repos/${parsedUrl.accountId}/${parsedUrl.orgName}${parsedUrl.projectName !== "" ? `/${parsedUrl.projectName}/` : "/"}${parsedUrl.repoName}/+/content?routingId=${parsedUrl.accountId}&include_commit=true&git_ref=refs/heads/${parsedUrl.branch}`;
}
function getHarnessRequestOptions(config) {
  const headers = {};
  const { token, apiKey } = config;
  if (apiKey) {
    headers["x-api-key"] = apiKey;
  } else if (token) {
    headers.Authorization = `Bearer ${token}`;
  }
  return {
    headers
  };
}
function parseHarnessUrl(config, url) {
  const baseUrl = `https://${config.host}`;
  try {
    const pathUrl = new URL(url);
    const pathSegments = pathUrl.pathname.split("/").filter((segment) => segment !== "");
    const urlParts = pathUrl.pathname.split("/");
    const accountIdIndex = pathSegments.findIndex((segment) => segment === "account") + 1;
    const accountId = pathSegments[accountIdIndex];
    const orgNameIndex = pathSegments.findIndex((segment) => segment === "orgs");
    const orgName = orgNameIndex !== -1 ? pathSegments[orgNameIndex + 1] : "";
    const projectNameIndex = pathSegments.findIndex(
      (segment) => segment === "projects"
    );
    const projectName = projectNameIndex !== -1 ? pathSegments[projectNameIndex + 1] : "";
    const repoNameIndex = pathSegments.findIndex((segment) => segment === "repos") + 1;
    const repoName = pathSegments[repoNameIndex];
    const refAndPath = urlParts.slice(
      urlParts.findIndex((i) => i === "files" || i === "edit") + 1
    );
    const refIndex = refAndPath.findIndex((item) => item === "~");
    const refString = refAndPath.slice(0, refIndex).join("/");
    const pathWithoutSlash = refIndex !== -1 ? refAndPath.slice(refIndex + 1).join("/").replace(/^\//, "") : "";
    return {
      baseUrl,
      accountId,
      orgName,
      projectName,
      refString,
      path: pathWithoutSlash,
      repoName,
      refDashStr: refAndPath.slice(0, refIndex).join("-"),
      branch: refIndex !== -1 ? refAndPath.slice(0, refIndex).join("/") : refAndPath.join("/")
    };
  } catch (e) {
    throw new Error(`Incorrect URL: ${url}, ${e}`);
  }
}

class HarnessIntegration {
  constructor(config) {
    this.config = config;
  }
  static factory = ({ config }) => {
    const configs = config.getOptionalConfigArray("integrations.harness") ?? [];
    const harnessConfigs = configs.map((c) => readHarnessConfig(c));
    return basicIntegrations(
      harnessConfigs.map((c) => new HarnessIntegration(c)),
      (harness) => harness.config.host
    );
  };
  get type() {
    return "harness";
  }
  get title() {
    return this.config.host;
  }
  resolveUrl(options) {
    return defaultScmResolveUrl(options);
  }
  resolveEditUrl(url) {
    return getHarnessEditContentsUrl(this.config, url);
  }
}

class ScmIntegrations {
  byType;
  static fromConfig(config) {
    return new ScmIntegrations({
      awsS3: AwsS3Integration.factory({ config }),
      awsCodeCommit: AwsCodeCommitIntegration.factory({ config }),
      azure: AzureIntegration.factory({ config }),
      bitbucket: BitbucketIntegration.factory({ config }),
      bitbucketCloud: BitbucketCloudIntegration.factory({ config }),
      bitbucketServer: BitbucketServerIntegration.factory({ config }),
      gerrit: GerritIntegration.factory({ config }),
      github: GithubIntegration.factory({ config }),
      gitlab: GitLabIntegration.factory({ config }),
      gitea: GiteaIntegration.factory({ config }),
      harness: HarnessIntegration.factory({ config })
    });
  }
  constructor(integrationsByType) {
    this.byType = integrationsByType;
  }
  get awsS3() {
    return this.byType.awsS3;
  }
  get awsCodeCommit() {
    return this.byType.awsCodeCommit;
  }
  get azure() {
    return this.byType.azure;
  }
  /**
   * @deprecated in favor of `bitbucketCloud()` and `bitbucketServer()`
   */
  get bitbucket() {
    return this.byType.bitbucket;
  }
  get bitbucketCloud() {
    return this.byType.bitbucketCloud;
  }
  get bitbucketServer() {
    return this.byType.bitbucketServer;
  }
  get gerrit() {
    return this.byType.gerrit;
  }
  get github() {
    return this.byType.github;
  }
  get gitlab() {
    return this.byType.gitlab;
  }
  get gitea() {
    return this.byType.gitea;
  }
  get harness() {
    return this.byType.harness;
  }
  list() {
    return Object.values(this.byType).flatMap(
      (i) => i.list()
    );
  }
  byUrl(url) {
    let candidates = Object.values(this.byType).map((i) => i.byUrl(url)).filter(Boolean);
    if (candidates.length > 1) {
      const filteredCandidates = candidates.filter(
        (x) => !(x instanceof BitbucketIntegration)
      );
      if (filteredCandidates.length !== 0) {
        candidates = filteredCandidates;
      }
    }
    return candidates[0];
  }
  byHost(host) {
    return Object.values(this.byType).map((i) => i.byHost(host)).find(Boolean);
  }
  resolveUrl(options) {
    const integration = this.byUrl(options.base);
    if (!integration) {
      return defaultScmResolveUrl(options);
    }
    return integration.resolveUrl(options);
  }
  resolveEditUrl(url) {
    const integration = this.byUrl(url);
    if (!integration) {
      return url;
    }
    return integration.resolveEditUrl(url);
  }
}

exports.AwsCodeCommitIntegration = AwsCodeCommitIntegration;
exports.AwsS3Integration = AwsS3Integration;
exports.AzureIntegration = AzureIntegration;
exports.BitbucketCloudIntegration = BitbucketCloudIntegration;
exports.BitbucketIntegration = BitbucketIntegration;
exports.BitbucketServerIntegration = BitbucketServerIntegration;
exports.DefaultAzureDevOpsCredentialsProvider = DefaultAzureDevOpsCredentialsProvider;
exports.DefaultGithubCredentialsProvider = DefaultGithubCredentialsProvider;
exports.DefaultGitlabCredentialsProvider = DefaultGitlabCredentialsProvider;
exports.GerritIntegration = GerritIntegration;
exports.GitLabIntegration = GitLabIntegration;
exports.GiteaIntegration = GiteaIntegration;
exports.GithubAppCredentialsMux = GithubAppCredentialsMux;
exports.GithubIntegration = GithubIntegration;
exports.HarnessIntegration = HarnessIntegration;
exports.ScmIntegrations = ScmIntegrations;
exports.SingleInstanceGithubCredentialsProvider = SingleInstanceGithubCredentialsProvider;
exports.buildGerritGitilesArchiveUrl = buildGerritGitilesArchiveUrl;
exports.defaultScmResolveUrl = defaultScmResolveUrl;
exports.getAzureCommitsUrl = getAzureCommitsUrl;
exports.getAzureDownloadUrl = getAzureDownloadUrl;
exports.getAzureFileFetchUrl = getAzureFileFetchUrl;
exports.getAzureRequestOptions = getAzureRequestOptions;
exports.getBitbucketCloudDefaultBranch = getBitbucketCloudDefaultBranch;
exports.getBitbucketCloudDownloadUrl = getBitbucketCloudDownloadUrl;
exports.getBitbucketCloudFileFetchUrl = getBitbucketCloudFileFetchUrl;
exports.getBitbucketCloudRequestOptions = getBitbucketCloudRequestOptions;
exports.getBitbucketDefaultBranch = getBitbucketDefaultBranch;
exports.getBitbucketDownloadUrl = getBitbucketDownloadUrl;
exports.getBitbucketFileFetchUrl = getBitbucketFileFetchUrl;
exports.getBitbucketRequestOptions = getBitbucketRequestOptions;
exports.getBitbucketServerDefaultBranch = getBitbucketServerDefaultBranch;
exports.getBitbucketServerDownloadUrl = getBitbucketServerDownloadUrl;
exports.getBitbucketServerFileFetchUrl = getBitbucketServerFileFetchUrl;
exports.getBitbucketServerRequestOptions = getBitbucketServerRequestOptions;
exports.getGerritBranchApiUrl = getGerritBranchApiUrl;
exports.getGerritCloneRepoUrl = getGerritCloneRepoUrl;
exports.getGerritFileContentsApiUrl = getGerritFileContentsApiUrl;
exports.getGerritProjectsApiUrl = getGerritProjectsApiUrl;
exports.getGerritRequestOptions = getGerritRequestOptions;
exports.getGitHubRequestOptions = getGitHubRequestOptions;
exports.getGitLabFileFetchUrl = getGitLabFileFetchUrl;
exports.getGitLabIntegrationRelativePath = getGitLabIntegrationRelativePath;
exports.getGitLabRequestOptions = getGitLabRequestOptions;
exports.getGiteaArchiveUrl = getGiteaArchiveUrl;
exports.getGiteaEditContentsUrl = getGiteaEditContentsUrl;
exports.getGiteaFileContentsUrl = getGiteaFileContentsUrl;
exports.getGiteaLatestCommitUrl = getGiteaLatestCommitUrl;
exports.getGiteaRequestOptions = getGiteaRequestOptions;
exports.getGithubFileFetchUrl = getGithubFileFetchUrl;
exports.getHarnessArchiveUrl = getHarnessArchiveUrl;
exports.getHarnessFileContentsUrl = getHarnessFileContentsUrl;
exports.getHarnessLatestCommitUrl = getHarnessLatestCommitUrl;
exports.getHarnessRequestOptions = getHarnessRequestOptions;
exports.parseGerritGitilesUrl = parseGerritGitilesUrl;
exports.parseGerritJsonResponse = parseGerritJsonResponse;
exports.parseGiteaUrl = parseGiteaUrl;
exports.parseGitilesUrlRef = parseGitilesUrlRef;
exports.parseHarnessUrl = parseHarnessUrl;
exports.readAwsCodeCommitIntegrationConfig = readAwsCodeCommitIntegrationConfig;
exports.readAwsCodeCommitIntegrationConfigs = readAwsCodeCommitIntegrationConfigs;
exports.readAwsS3IntegrationConfig = readAwsS3IntegrationConfig;
exports.readAwsS3IntegrationConfigs = readAwsS3IntegrationConfigs;
exports.readAzureIntegrationConfig = readAzureIntegrationConfig;
exports.readAzureIntegrationConfigs = readAzureIntegrationConfigs;
exports.readBitbucketCloudIntegrationConfig = readBitbucketCloudIntegrationConfig;
exports.readBitbucketCloudIntegrationConfigs = readBitbucketCloudIntegrationConfigs;
exports.readBitbucketIntegrationConfig = readBitbucketIntegrationConfig;
exports.readBitbucketIntegrationConfigs = readBitbucketIntegrationConfigs;
exports.readBitbucketServerIntegrationConfig = readBitbucketServerIntegrationConfig;
exports.readBitbucketServerIntegrationConfigs = readBitbucketServerIntegrationConfigs;
exports.readGerritIntegrationConfig = readGerritIntegrationConfig;
exports.readGerritIntegrationConfigs = readGerritIntegrationConfigs;
exports.readGitLabIntegrationConfig = readGitLabIntegrationConfig;
exports.readGitLabIntegrationConfigs = readGitLabIntegrationConfigs;
exports.readGiteaConfig = readGiteaConfig;
exports.readGithubIntegrationConfig = readGithubIntegrationConfig;
exports.readGithubIntegrationConfigs = readGithubIntegrationConfigs;
exports.readGoogleGcsIntegrationConfig = readGoogleGcsIntegrationConfig;
exports.readHarnessConfig = readHarnessConfig;
exports.replaceGitLabUrlType = replaceGitLabUrlType;
exports.replaceGithubUrlType = replaceGithubUrlType;
//# sourceMappingURL=index.cjs.js.map
