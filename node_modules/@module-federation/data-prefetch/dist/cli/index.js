"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/cli/index.ts
var cli_exports = {};
__export(cli_exports, {
  PrefetchPlugin: () => PrefetchPlugin,
  getFederationGlobalScope: () => getFederationGlobalScope
});
module.exports = __toCommonJS(cli_exports);
var import_path2 = __toESM(require("path"));
var import_fs_extra2 = __toESM(require("fs-extra"));
var import_sdk2 = require("@module-federation/sdk");
var import_normalize_webpack_path = require("@module-federation/sdk/normalize-webpack-path");

// src/common/constant.ts
var TEMP_DIR = ".mf";

// src/common/node-utils.ts
var import_path = __toESM(require("path"));
var import_fs_extra = __toESM(require("fs-extra"));
var fileExistsWithCaseSync = (filepath) => {
  const dir = import_path.default.dirname(filepath);
  if (filepath === "/" || filepath === ".") {
    return true;
  }
  const filenames = import_fs_extra.default.readdirSync(dir);
  if (filenames.indexOf(import_path.default.basename(filepath)) === -1) {
    return false;
  }
  return fileExistsWithCaseSync(dir);
};
var fixPrefetchPath = (exposePath) => {
  const pathExt = [".js", ".ts"];
  const extReg = /\.(ts|js|tsx|jsx)$/;
  if (extReg.test(exposePath)) {
    return pathExt.map((ext) => exposePath.replace(extReg, `.prefetch${ext}`));
  } else {
    return pathExt.map((ext) => exposePath + `.prefetch${ext}`);
  }
};

// src/common/runtime-utils.ts
var import_runtime = require("@module-federation/runtime");
var import_sdk = require("@module-federation/sdk");
var getPrefetchId = (id) => (0, import_sdk.encodeName)(`${id}/${import_sdk.MFPrefetchCommon.identifier}`);

// src/cli/index.ts
var { RuntimeGlobals, Template } = require((0, import_normalize_webpack_path.normalizeWebpackPath)("webpack"));
function getFederationGlobalScope(runtimeGlobals) {
  return `${runtimeGlobals.require || "__webpack_require__"}.federation`;
}
var PrefetchPlugin = class {
  constructor(options) {
    this.options = options;
    this._reWriteExports = "";
  }
  apply(compiler) {
    var _a, _b;
    const { name, exposes } = this.options;
    if (!exposes) {
      return;
    }
    if (!compiler.options.context) {
      throw new Error("compiler.options.context is not defined");
    }
    const { runtimePlugins } = this.options;
    if (!Array.isArray(runtimePlugins)) {
      this.options.runtimePlugins = [];
    }
    const runtimePath = import_path2.default.resolve(__dirname, "../esm/plugin.js");
    const sharedPath = import_path2.default.resolve(__dirname, "../esm/shared/index.js");
    if (!((_a = this.options.runtimePlugins) == null ? void 0 : _a.includes(runtimePath))) {
      this.options.runtimePlugins.push(runtimePath);
    }
    if (!((_b = this.options.runtimePlugins) == null ? void 0 : _b.includes(sharedPath))) {
      this.options.runtimePlugins.push(sharedPath);
    }
    const encodedName = (0, import_sdk2.encodeName)(name);
    const asyncEntryPath = import_path2.default.resolve(
      compiler.options.context,
      `node_modules/${TEMP_DIR}/${encodedName}/bootstrap.js`
    );
    if (import_fs_extra2.default.existsSync(asyncEntryPath)) {
      import_fs_extra2.default.unlinkSync(asyncEntryPath);
    }
    if (!this.options.dataPrefetch) {
      return;
    }
    const prefetchs = [];
    const exposeAlias = Object.keys(exposes);
    exposeAlias.forEach((alias) => {
      let exposePath;
      const exposeValue = exposes[alias];
      if (typeof exposeValue === "string") {
        exposePath = exposeValue;
      } else {
        exposePath = exposeValue.import[0];
      }
      const targetPaths = fixPrefetchPath(exposePath);
      for (const pathItem of targetPaths) {
        const absolutePath = import_path2.default.resolve(compiler.options.context, pathItem);
        if (fileExistsWithCaseSync(absolutePath)) {
          prefetchs.push(pathItem);
          const absoluteAlias = alias.replace(".", "");
          this._reWriteExports += `export * as ${getPrefetchId(
            `${name}${absoluteAlias}`
          )} from '${absolutePath}';
`;
          break;
        }
      }
    });
    if (!this._reWriteExports) {
      return;
    }
    const tempDirRealPath = import_path2.default.resolve(
      compiler.options.context,
      "node_modules",
      TEMP_DIR
    );
    if (!import_fs_extra2.default.existsSync(tempDirRealPath)) {
      import_fs_extra2.default.mkdirSync(tempDirRealPath);
    }
    if (!import_fs_extra2.default.existsSync(`${tempDirRealPath}/${encodedName}`)) {
      import_fs_extra2.default.mkdirSync(`${tempDirRealPath}/${encodedName}`);
    }
    import_fs_extra2.default.writeFileSync(asyncEntryPath, this._reWriteExports);
    new compiler.webpack.DefinePlugin({
      FederationDataPrefetch: JSON.stringify(asyncEntryPath)
    }).apply(compiler);
  }
  static addRuntime(compiler, options) {
    const encodedName = (0, import_sdk2.encodeName)(options.name);
    if (!compiler.options.context) {
      throw new Error("compiler.options.context is not defined");
    }
    const prefetchEntry = import_path2.default.resolve(
      compiler.options.context,
      `node_modules/.mf/${encodedName}/bootstrap.js`
    );
    const federationGlobal = getFederationGlobalScope(
      RuntimeGlobals || {}
    );
    return Template.asString([
      import_fs_extra2.default.existsSync(prefetchEntry) ? Template.indent([
        "function injectPrefetch() {",
        `globalThis.__FEDERATION__ = globalThis.__FEDERATION__ || {};`,
        `globalThis.__FEDERATION__['${import_sdk2.MFPrefetchCommon.globalKey}'] = globalThis.__FEDERATION__['${import_sdk2.MFPrefetchCommon.globalKey}'] || {`,
        `entryLoading: {},`,
        `instance: new Map(),`,
        `__PREFETCH_EXPORTS__: {},`,
        `};`,
        `globalThis.__FEDERATION__['${import_sdk2.MFPrefetchCommon.globalKey}']['${import_sdk2.MFPrefetchCommon.exportsKey}'] = globalThis.__FEDERATION__['${import_sdk2.MFPrefetchCommon.globalKey}']['${import_sdk2.MFPrefetchCommon.exportsKey}'] || {};`,
        `globalThis.__FEDERATION__['${import_sdk2.MFPrefetchCommon.globalKey}']['${import_sdk2.MFPrefetchCommon.exportsKey}']['${options.name}'] = import('${prefetchEntry}');`,
        "}",
        `${federationGlobal}.prefetch = injectPrefetch`
      ]) : "",
      Template.indent([
        `if(!${federationGlobal}.isMFRemote && ${federationGlobal}.prefetch){`,
        `${federationGlobal}.prefetch()`,
        "}"
      ])
    ]);
  }
  static setRemoteIdentifier() {
    const federationGlobal = getFederationGlobalScope(
      RuntimeGlobals || {}
    );
    return Template.indent([`${federationGlobal}.isMFRemote = true;`]);
  }
  static removeRemoteIdentifier() {
    const federationGlobal = getFederationGlobalScope(
      RuntimeGlobals || {}
    );
    return Template.indent([`${federationGlobal}.isMFRemote = false;`]);
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  PrefetchPlugin,
  getFederationGlobalScope
});
