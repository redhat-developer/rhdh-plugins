"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/cli/babel.ts
var babel_exports = {};
__export(babel_exports, {
  default: () => babel_default
});
module.exports = __toCommonJS(babel_exports);
var import_path = __toESM(require("path"));
var attribute = "id";
var hookId = "usePrefetch";
var importPackage = "@module-federation/data-prefetch/react";
var babel_default = (babel, options) => {
  const t = babel.types;
  let shouldHandle = false;
  let scope = "";
  const { name, exposes } = options;
  if (!exposes) {
    return {};
  }
  const exposesKey = Object.keys(exposes);
  const processedExposes = exposesKey.map((expose) => ({
    key: expose.replace(".", ""),
    value: import_path.default.resolve(
      typeof exposes[expose] === "string" ? exposes[expose] : exposes[expose].import
    )
  }));
  return {
    visitor: {
      ImportDeclaration(nodePath, state) {
        const source = nodePath.node.source.value;
        const { specifiers } = nodePath.node;
        const { filename } = state.file.opts;
        if (source === importPackage) {
          shouldHandle = specifiers.some(
            (specifier) => specifier.imported && specifier.imported.name === hookId && processedExposes.find(
              (expose) => expose.value === filename && (scope = expose.key)
            )
          );
        }
      },
      CallExpression(nodePath) {
        if (shouldHandle && t.isIdentifier(nodePath.node.callee, { name: hookId }) && nodePath.node.arguments.length > 0) {
          const objectExpression = nodePath.node.arguments[0];
          if (objectExpression && t.isObjectExpression(objectExpression) && !objectExpression.properties.find(
            (p) => p.key.name === attribute
          )) {
            objectExpression.properties.push(
              t.objectProperty(
                t.identifier(attribute),
                t.stringLiteral(name + scope)
              )
            );
          }
        }
      }
    }
  };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
