import {
  compatGetPrefetchId,
  getPrefetchId
} from "./chunk-AJPO2B2T.js";

// src/prefetch.ts
import {
  getRemoteEntry,
  getRemoteInfo
} from "@module-federation/runtime";
import {
  loadScript
} from "@module-federation/sdk";
globalThis.__FEDERATION__ ?? (globalThis.__FEDERATION__ = {});
var _a;
(_a = globalThis.__FEDERATION__).__PREFETCH__ ?? (_a.__PREFETCH__ = {
  entryLoading: {},
  instance: /* @__PURE__ */ new Map(),
  __PREFETCH_EXPORTS__: {}
});
var MFDataPrefetch = class {
  constructor(options) {
    this.prefetchMemory = /* @__PURE__ */ new Map();
    this.recordOutdate = {};
    this._exports = {};
    this._options = options;
    this.global.instance.set(options.name, this);
  }
  get global() {
    return globalThis.__FEDERATION__.__PREFETCH__;
  }
  static getInstance(id) {
    return globalThis.__FEDERATION__.__PREFETCH__.instance.get(id);
  }
  async loadEntry(entry) {
    const { name, remoteSnapshot, remote, origin } = this._options;
    if (entry) {
      const { buildVersion, globalName } = remoteSnapshot;
      const uniqueKey = globalName || `${name}:${buildVersion}`;
      if (!this.global.entryLoading[uniqueKey]) {
        this.global.entryLoading[uniqueKey] = loadScript(entry, {});
      }
      return this.global.entryLoading[uniqueKey];
    } else {
      const remoteInfo = getRemoteInfo(remote);
      const module = origin.moduleCache.get(remoteInfo.name);
      return getRemoteEntry({
        origin,
        remoteInfo,
        remoteEntryExports: module ? module.remoteEntryExports : void 0
      });
    }
  }
  getProjectExports() {
    var _a2;
    if (Object.keys(this._exports).length > 0) {
      return this._exports;
    }
    const { name } = this._options;
    const exportsPromise = (_a2 = globalThis.__FEDERATION__.__PREFETCH__.__PREFETCH_EXPORTS__) == null ? void 0 : _a2[name];
    const resolve = exportsPromise.then(
      (exports = {}) => {
        const memory = {};
        Object.keys(exports).forEach((key) => {
          memory[key] = {};
          const exportVal = exports[key];
          Object.keys(exportVal).reduce(
            (memo, current) => {
              if (current.toLocaleLowerCase().endsWith("prefetch") || current.toLocaleLowerCase() === "default") {
                memo[current] = exportVal[current];
              }
              return memo;
            },
            memory[key]
          );
        });
        this.memorizeExports(memory);
      }
    );
    return resolve;
  }
  memorizeExports(exports) {
    this._exports = exports;
  }
  getExposeExports(id) {
    const prefetchId = getPrefetchId(id);
    const compatId = compatGetPrefetchId(id);
    const prefetchExports = this._exports[prefetchId] || this._exports[compatId];
    return prefetchExports || {};
  }
  prefetch(prefetchOptions) {
    const { id, functionId = "default", refetchParams } = prefetchOptions;
    let prefetchResult;
    const prefetchId = getPrefetchId(id);
    const compatId = compatGetPrefetchId(id);
    const memorizeId = id + functionId;
    const memory = this.prefetchMemory.get(memorizeId);
    if (!this.checkOutdate(prefetchOptions) && memory) {
      return memory;
    }
    const prefetchExports = this._exports[prefetchId] || this._exports[compatId];
    if (!prefetchExports) {
      return;
    }
    const executePrefetch = prefetchExports[functionId];
    if (typeof executePrefetch === "function") {
      if (refetchParams) {
        prefetchResult = executePrefetch(refetchParams);
      } else {
        prefetchResult = executePrefetch();
      }
    } else {
      throw new Error(
        `[Module Federation Data Prefetch]: No prefetch function called ${functionId} export in prefetch file`
      );
    }
    this.memorize(memorizeId, prefetchResult);
    return prefetchResult;
  }
  memorize(id, value) {
    this.prefetchMemory.set(id, value);
  }
  markOutdate(markOptions, isOutdate) {
    const { id, functionId = "default" } = markOptions;
    if (!this.recordOutdate[id]) {
      this.recordOutdate[id] = {};
    }
    this.recordOutdate[id][functionId] = isOutdate;
  }
  checkOutdate(outdateOptions) {
    const { id, functionId = "default", cacheStrategy } = outdateOptions;
    if (typeof cacheStrategy === "function") {
      return cacheStrategy();
    }
    if (!this.recordOutdate[id]) {
      this.recordOutdate[id] = {};
    }
    if (this.recordOutdate[id][functionId]) {
      this.markOutdate(
        {
          id,
          functionId
        },
        false
      );
      return true;
    } else {
      return false;
    }
  }
};

export {
  MFDataPrefetch
};
