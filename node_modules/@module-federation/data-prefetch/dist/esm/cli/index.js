import {
  getPrefetchId
} from "../chunk-AJPO2B2T.js";
import {
  __require
} from "../chunk-EZUCZHGV.js";

// src/cli/index.ts
import path2 from "path";
import fs2 from "fs-extra";
import {
  encodeName,
  MFPrefetchCommon
} from "@module-federation/sdk";
import { normalizeWebpackPath } from "@module-federation/sdk/normalize-webpack-path";

// src/common/constant.ts
var TEMP_DIR = ".mf";

// src/common/node-utils.ts
import path from "path";
import fs from "fs-extra";
var fileExistsWithCaseSync = (filepath) => {
  const dir = path.dirname(filepath);
  if (filepath === "/" || filepath === ".") {
    return true;
  }
  const filenames = fs.readdirSync(dir);
  if (filenames.indexOf(path.basename(filepath)) === -1) {
    return false;
  }
  return fileExistsWithCaseSync(dir);
};
var fixPrefetchPath = (exposePath) => {
  const pathExt = [".js", ".ts"];
  const extReg = /\.(ts|js|tsx|jsx)$/;
  if (extReg.test(exposePath)) {
    return pathExt.map((ext) => exposePath.replace(extReg, `.prefetch${ext}`));
  } else {
    return pathExt.map((ext) => exposePath + `.prefetch${ext}`);
  }
};

// src/cli/index.ts
var { RuntimeGlobals, Template } = __require(normalizeWebpackPath("webpack"));
function getFederationGlobalScope(runtimeGlobals) {
  return `${runtimeGlobals.require || "__webpack_require__"}.federation`;
}
var PrefetchPlugin = class {
  constructor(options) {
    this.options = options;
    this._reWriteExports = "";
  }
  apply(compiler) {
    var _a, _b;
    const { name, exposes } = this.options;
    if (!exposes) {
      return;
    }
    if (!compiler.options.context) {
      throw new Error("compiler.options.context is not defined");
    }
    const { runtimePlugins } = this.options;
    if (!Array.isArray(runtimePlugins)) {
      this.options.runtimePlugins = [];
    }
    const runtimePath = path2.resolve(__dirname, "../esm/plugin.js");
    const sharedPath = path2.resolve(__dirname, "../esm/shared/index.js");
    if (!((_a = this.options.runtimePlugins) == null ? void 0 : _a.includes(runtimePath))) {
      this.options.runtimePlugins.push(runtimePath);
    }
    if (!((_b = this.options.runtimePlugins) == null ? void 0 : _b.includes(sharedPath))) {
      this.options.runtimePlugins.push(sharedPath);
    }
    const encodedName = encodeName(name);
    const asyncEntryPath = path2.resolve(
      compiler.options.context,
      `node_modules/${TEMP_DIR}/${encodedName}/bootstrap.js`
    );
    if (fs2.existsSync(asyncEntryPath)) {
      fs2.unlinkSync(asyncEntryPath);
    }
    if (!this.options.dataPrefetch) {
      return;
    }
    const prefetchs = [];
    const exposeAlias = Object.keys(exposes);
    exposeAlias.forEach((alias) => {
      let exposePath;
      const exposeValue = exposes[alias];
      if (typeof exposeValue === "string") {
        exposePath = exposeValue;
      } else {
        exposePath = exposeValue.import[0];
      }
      const targetPaths = fixPrefetchPath(exposePath);
      for (const pathItem of targetPaths) {
        const absolutePath = path2.resolve(compiler.options.context, pathItem);
        if (fileExistsWithCaseSync(absolutePath)) {
          prefetchs.push(pathItem);
          const absoluteAlias = alias.replace(".", "");
          this._reWriteExports += `export * as ${getPrefetchId(
            `${name}${absoluteAlias}`
          )} from '${absolutePath}';
`;
          break;
        }
      }
    });
    if (!this._reWriteExports) {
      return;
    }
    const tempDirRealPath = path2.resolve(
      compiler.options.context,
      "node_modules",
      TEMP_DIR
    );
    if (!fs2.existsSync(tempDirRealPath)) {
      fs2.mkdirSync(tempDirRealPath);
    }
    if (!fs2.existsSync(`${tempDirRealPath}/${encodedName}`)) {
      fs2.mkdirSync(`${tempDirRealPath}/${encodedName}`);
    }
    fs2.writeFileSync(asyncEntryPath, this._reWriteExports);
    new compiler.webpack.DefinePlugin({
      FederationDataPrefetch: JSON.stringify(asyncEntryPath)
    }).apply(compiler);
  }
  static addRuntime(compiler, options) {
    const encodedName = encodeName(options.name);
    if (!compiler.options.context) {
      throw new Error("compiler.options.context is not defined");
    }
    const prefetchEntry = path2.resolve(
      compiler.options.context,
      `node_modules/.mf/${encodedName}/bootstrap.js`
    );
    const federationGlobal = getFederationGlobalScope(
      RuntimeGlobals || {}
    );
    return Template.asString([
      fs2.existsSync(prefetchEntry) ? Template.indent([
        "function injectPrefetch() {",
        `globalThis.__FEDERATION__ = globalThis.__FEDERATION__ || {};`,
        `globalThis.__FEDERATION__['${MFPrefetchCommon.globalKey}'] = globalThis.__FEDERATION__['${MFPrefetchCommon.globalKey}'] || {`,
        `entryLoading: {},`,
        `instance: new Map(),`,
        `__PREFETCH_EXPORTS__: {},`,
        `};`,
        `globalThis.__FEDERATION__['${MFPrefetchCommon.globalKey}']['${MFPrefetchCommon.exportsKey}'] = globalThis.__FEDERATION__['${MFPrefetchCommon.globalKey}']['${MFPrefetchCommon.exportsKey}'] || {};`,
        `globalThis.__FEDERATION__['${MFPrefetchCommon.globalKey}']['${MFPrefetchCommon.exportsKey}']['${options.name}'] = import('${prefetchEntry}');`,
        "}",
        `${federationGlobal}.prefetch = injectPrefetch`
      ]) : "",
      Template.indent([
        `if(!${federationGlobal}.isMFRemote && ${federationGlobal}.prefetch){`,
        `${federationGlobal}.prefetch()`,
        "}"
      ])
    ]);
  }
  static setRemoteIdentifier() {
    const federationGlobal = getFederationGlobalScope(
      RuntimeGlobals || {}
    );
    return Template.indent([`${federationGlobal}.isMFRemote = true;`]);
  }
  static removeRemoteIdentifier() {
    const federationGlobal = getFederationGlobalScope(
      RuntimeGlobals || {}
    );
    return Template.indent([`${federationGlobal}.isMFRemote = false;`]);
  }
};
export {
  PrefetchPlugin,
  getFederationGlobalScope
};
