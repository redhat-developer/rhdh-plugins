"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  MFDataPrefetch: () => MFDataPrefetch,
  prefetchPlugin: () => prefetchPlugin
});
module.exports = __toCommonJS(src_exports);

// src/prefetch.ts
var import_runtime2 = require("@module-federation/runtime");
var import_sdk2 = require("@module-federation/sdk");

// src/common/runtime-utils.ts
var import_runtime = require("@module-federation/runtime");
var import_sdk = require("@module-federation/sdk");
var getPrefetchId = (id) => (0, import_sdk.encodeName)(`${id}/${import_sdk.MFPrefetchCommon.identifier}`);
var compatGetPrefetchId = (id) => (0, import_sdk.encodeName)(`${id}/VmokPrefetch`);
var getSignalFromManifest = (remoteSnapshot) => {
  if (!remoteSnapshot) {
    return false;
  }
  if (!("prefetchEntry" in remoteSnapshot) && !("prefetchInterface" in remoteSnapshot)) {
    return false;
  }
  if (!remoteSnapshot.prefetchEntry && !remoteSnapshot.prefetchInterface) {
    return false;
  }
  return true;
};

// src/prefetch.ts
globalThis.__FEDERATION__ ?? (globalThis.__FEDERATION__ = {});
var _a;
(_a = globalThis.__FEDERATION__).__PREFETCH__ ?? (_a.__PREFETCH__ = {
  entryLoading: {},
  instance: /* @__PURE__ */ new Map(),
  __PREFETCH_EXPORTS__: {}
});
var MFDataPrefetch = class {
  constructor(options) {
    this.prefetchMemory = /* @__PURE__ */ new Map();
    this.recordOutdate = {};
    this._exports = {};
    this._options = options;
    this.global.instance.set(options.name, this);
  }
  get global() {
    return globalThis.__FEDERATION__.__PREFETCH__;
  }
  static getInstance(id) {
    return globalThis.__FEDERATION__.__PREFETCH__.instance.get(id);
  }
  async loadEntry(entry) {
    const { name, remoteSnapshot, remote, origin } = this._options;
    if (entry) {
      const { buildVersion, globalName } = remoteSnapshot;
      const uniqueKey = globalName || `${name}:${buildVersion}`;
      if (!this.global.entryLoading[uniqueKey]) {
        this.global.entryLoading[uniqueKey] = (0, import_sdk2.loadScript)(entry, {});
      }
      return this.global.entryLoading[uniqueKey];
    } else {
      const remoteInfo = (0, import_runtime2.getRemoteInfo)(remote);
      const module2 = origin.moduleCache.get(remoteInfo.name);
      return (0, import_runtime2.getRemoteEntry)({
        origin,
        remoteInfo,
        remoteEntryExports: module2 ? module2.remoteEntryExports : void 0
      });
    }
  }
  getProjectExports() {
    var _a2;
    if (Object.keys(this._exports).length > 0) {
      return this._exports;
    }
    const { name } = this._options;
    const exportsPromise = (_a2 = globalThis.__FEDERATION__.__PREFETCH__.__PREFETCH_EXPORTS__) == null ? void 0 : _a2[name];
    const resolve = exportsPromise.then(
      (exports = {}) => {
        const memory = {};
        Object.keys(exports).forEach((key) => {
          memory[key] = {};
          const exportVal = exports[key];
          Object.keys(exportVal).reduce(
            (memo, current) => {
              if (current.toLocaleLowerCase().endsWith("prefetch") || current.toLocaleLowerCase() === "default") {
                memo[current] = exportVal[current];
              }
              return memo;
            },
            memory[key]
          );
        });
        this.memorizeExports(memory);
      }
    );
    return resolve;
  }
  memorizeExports(exports) {
    this._exports = exports;
  }
  getExposeExports(id) {
    const prefetchId = getPrefetchId(id);
    const compatId = compatGetPrefetchId(id);
    const prefetchExports = this._exports[prefetchId] || this._exports[compatId];
    return prefetchExports || {};
  }
  prefetch(prefetchOptions) {
    const { id, functionId = "default", refetchParams } = prefetchOptions;
    let prefetchResult;
    const prefetchId = getPrefetchId(id);
    const compatId = compatGetPrefetchId(id);
    const memorizeId = id + functionId;
    const memory = this.prefetchMemory.get(memorizeId);
    if (!this.checkOutdate(prefetchOptions) && memory) {
      return memory;
    }
    const prefetchExports = this._exports[prefetchId] || this._exports[compatId];
    if (!prefetchExports) {
      return;
    }
    const executePrefetch = prefetchExports[functionId];
    if (typeof executePrefetch === "function") {
      if (refetchParams) {
        prefetchResult = executePrefetch(refetchParams);
      } else {
        prefetchResult = executePrefetch();
      }
    } else {
      throw new Error(
        `[Module Federation Data Prefetch]: No prefetch function called ${functionId} export in prefetch file`
      );
    }
    this.memorize(memorizeId, prefetchResult);
    return prefetchResult;
  }
  memorize(id, value) {
    this.prefetchMemory.set(id, value);
  }
  markOutdate(markOptions, isOutdate) {
    const { id, functionId = "default" } = markOptions;
    if (!this.recordOutdate[id]) {
      this.recordOutdate[id] = {};
    }
    this.recordOutdate[id][functionId] = isOutdate;
  }
  checkOutdate(outdateOptions) {
    const { id, functionId = "default", cacheStrategy } = outdateOptions;
    if (typeof cacheStrategy === "function") {
      return cacheStrategy();
    }
    if (!this.recordOutdate[id]) {
      this.recordOutdate[id] = {};
    }
    if (this.recordOutdate[id][functionId]) {
      this.markOutdate(
        {
          id,
          functionId
        },
        false
      );
      return true;
    } else {
      return false;
    }
  }
};

// src/plugin.ts
var import_sdk4 = require("@module-federation/sdk");

// src/logger/index.ts
var import_sdk3 = require("@module-federation/sdk");
var logger_default = new import_sdk3.Logger("[Module Federation Data Prefetch]");

// src/plugin.ts
var loadingArray = [];
var strategy = "loaded-first";
var sharedFlag = strategy;
var prefetchPlugin = () => ({
  name: "data-prefetch-runtime-plugin",
  initContainer(options) {
    const { remoteSnapshot, remoteInfo, id, origin } = options;
    const snapshot = remoteSnapshot;
    const { name } = remoteInfo;
    const prefetchOptions = {
      name,
      remote: remoteInfo,
      origin,
      remoteSnapshot: snapshot
    };
    const signal = getSignalFromManifest(snapshot);
    if (!signal) {
      return options;
    }
    if (sharedFlag !== strategy) {
      throw new Error(
        `[Module Federation Data Prefetch]: If you want to use data prefetch, the shared strategy must be 'loaded-first'`
      );
    }
    const instance = MFDataPrefetch.getInstance(name) || new MFDataPrefetch(prefetchOptions);
    let prefetchUrl;
    if (snapshot.prefetchEntry) {
      prefetchUrl = (0, import_sdk4.getResourceUrl)(snapshot, snapshot.prefetchEntry);
    }
    const exist = loadingArray.find((loading) => loading.id === id);
    if (exist) {
      return options;
    }
    const promise = instance.loadEntry(prefetchUrl).then(async () => {
      const projectExports = instance.getProjectExports();
      if (projectExports instanceof Promise) {
        await projectExports;
      }
      return Promise.resolve().then(() => {
        const exports = instance.getExposeExports(id);
        logger_default.info(
          `1. Start Prefetch initContainer: ${id} - ${performance.now()}`
        );
        const result = Object.keys(exports).map((k) => {
          const value = instance.prefetch({
            id,
            functionId: k
          });
          const functionId = k;
          return {
            value,
            functionId
          };
        });
        return result;
      });
    });
    loadingArray.push({
      id,
      promise
    });
    return options;
  },
  afterResolve(options) {
    const { remoteSnapshot, remoteInfo, id, origin } = options;
    const snapshot = remoteSnapshot;
    const { name } = remoteInfo;
    const prefetchOptions = {
      name,
      remote: remoteInfo,
      origin,
      remoteSnapshot: snapshot
    };
    const signal = getSignalFromManifest(snapshot);
    if (!signal) {
      return options;
    }
    const inited = loadingArray.some((info) => info.id === id);
    if (!inited) {
      return options;
    }
    if (sharedFlag !== strategy) {
      throw new Error(
        `[Module Federation Data Prefetch]: If you want to use data prefetch, the shared strategy must be 'loaded-first'`
      );
    }
    const instance = MFDataPrefetch.getInstance(name) || new MFDataPrefetch(prefetchOptions);
    let prefetchUrl;
    if (snapshot.prefetchEntry) {
      prefetchUrl = (0, import_sdk4.getResourceUrl)(snapshot, snapshot.prefetchEntry);
    }
    const index = loadingArray.findIndex((loading) => loading.id === id);
    if (index !== -1) {
      loadingArray.splice(index, 1);
    }
    const promise = instance.loadEntry(prefetchUrl).then(async () => {
      const projectExports = instance.getProjectExports();
      if (projectExports instanceof Promise) {
        await projectExports;
      }
      return Promise.resolve().then(() => {
        const exports = instance.getExposeExports(id);
        logger_default.info(
          `1. Start Prefetch afterResolve: ${id} - ${performance.now()}`
        );
        const result = Object.keys(exports).map((k) => {
          const value = instance.prefetch({
            id,
            functionId: k
          });
          const functionId = k;
          return {
            value,
            functionId
          };
        });
        return result;
      });
    });
    loadingArray.push({
      id,
      promise
    });
    return options;
  },
  async onLoad(options) {
    var _a2;
    const { remote, id } = options;
    const { name } = remote;
    const promise = (_a2 = loadingArray.find((loading) => loading.id === id)) == null ? void 0 : _a2.promise;
    if (promise) {
      const prefetch = await promise;
      const prefetchValue = prefetch.map((result) => result.value);
      await Promise.all(prefetchValue);
      const instance = MFDataPrefetch.getInstance(name);
      prefetch.forEach((result) => {
        const { value, functionId } = result;
        instance.memorize(id + functionId, value);
      });
    }
    return options;
  },
  beforeLoadShare(options) {
    const shareInfo = options.shareInfo;
    sharedFlag = (shareInfo == null ? void 0 : shareInfo.strategy) || sharedFlag;
    return options;
  }
});
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  MFDataPrefetch,
  prefetchPlugin
});
