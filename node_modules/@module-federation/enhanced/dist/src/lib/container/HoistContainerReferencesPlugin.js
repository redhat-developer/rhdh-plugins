"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HoistContainerReferences = void 0;
exports.getAllReferencedModules = getAllReferencedModules;
const normalize_webpack_path_1 = require("@module-federation/sdk/normalize-webpack-path");
const ContainerEntryModule_1 = __importDefault(require("./ContainerEntryModule"));
const { NormalModule, AsyncDependenciesBlock } = require((0, normalize_webpack_path_1.normalizeWebpackPath)('webpack'));
const ConcatenatedModule = require((0, normalize_webpack_path_1.normalizeWebpackPath)('webpack/lib/optimize/ConcatenatedModule'));
const PLUGIN_NAME = 'HoistContainerReferences';
/**
 * This class is used to hoist container references in the code.
 * @constructor
 */
class HoistContainerReferences {
    constructor(name, entryFilePath, bundlerRuntimeDep, experiments) {
        this.containerName = name || 'no known chunk name';
        this.entryFilePath = entryFilePath;
        this.bundlerRuntimeDep = bundlerRuntimeDep;
        this.experiments = experiments;
        this.explanation =
            'Bundler runtime path module is required for proper functioning';
    }
    apply(compiler) {
        compiler.hooks.thisCompilation.tap(PLUGIN_NAME, (compilation) => {
            const logger = compilation.getLogger(PLUGIN_NAME);
            const { chunkGraph, moduleGraph } = compilation;
            // Hook into the optimizeChunks phase
            compilation.hooks.optimizeChunks.tap({
                name: PLUGIN_NAME,
                // advanced stage is where SplitChunksPlugin runs.
                stage: 11, // advanced + 1
            }, (chunks) => {
                const runtimeChunks = this.getRuntimeChunks(compilation);
                this.hoistModulesInChunks(compilation, runtimeChunks, chunks, logger);
            });
            // Hook into the optimizeDependencies phase
            compilation.hooks.optimizeDependencies.tap({
                name: PLUGIN_NAME,
                // basic optimization stage - it runs first
                stage: -10,
            }, (modules) => {
                if (this.entryFilePath) {
                    let runtime;
                    for (const [name, { options }] of compilation.entries) {
                        runtime = compiler.webpack.util.runtime.mergeRuntimeOwned(runtime, compiler.webpack.util.runtime.getEntryRuntime(compilation, name, options));
                    }
                    for (const module of modules) {
                        if (module instanceof NormalModule &&
                            module.resource === this.bundlerRuntimeDep) {
                            const allRefs = getAllReferencedModules(compilation, module, 'initial');
                            for (const module of allRefs) {
                                const exportsInfo = moduleGraph.getExportsInfo(module);
                                // Since i dont use the import federation var, tree shake will eliminate it.
                                // also because currently the runtime is copied into all runtime chunks
                                // some might not have the runtime import in the tree to begin with
                                exportsInfo.setUsedInUnknownWay(runtime);
                                moduleGraph.addExtraReason(module, this.explanation);
                                if (module.factoryMeta === undefined) {
                                    module.factoryMeta = {};
                                }
                                module.factoryMeta.sideEffectFree = false;
                            }
                        }
                    }
                }
            });
        });
    }
    // Helper method to find a specific module in a chunk
    findModule(compilation, chunk, entryFilePath) {
        const { chunkGraph } = compilation;
        let module = null;
        for (const mod of chunkGraph.getChunkEntryModulesIterable(chunk)) {
            if (mod instanceof NormalModule && mod.resource === entryFilePath) {
                module = mod;
                break;
            }
            if (mod instanceof ConcatenatedModule) {
                for (const m of mod.modules) {
                    if (m instanceof NormalModule && m.resource === entryFilePath) {
                        module = mod;
                        break;
                    }
                }
            }
        }
        return module;
    }
    // Method to hoist modules in chunks
    hoistModulesInChunks(compilation, runtimeChunks, chunks, logger) {
        const { chunkGraph, moduleGraph } = compilation;
        // when runtimeChunk: single is set - ContainerPlugin will create a "partial" chunk we can use to
        // move modules into the runtime chunk
        const partialChunk = this.containerName
            ? compilation.namedChunks.get(this.containerName)
            : undefined;
        let runtimeModule;
        if (!partialChunk) {
            for (const chunk of chunks) {
                if (chunkGraph.getNumberOfEntryModules(chunk) > 0 &&
                    this.entryFilePath) {
                    runtimeModule = this.findModule(compilation, chunk, this.entryFilePath);
                    if (runtimeModule)
                        break;
                }
            }
        }
        else {
            const entryModules = chunkGraph.getChunkEntryModulesIterable(partialChunk);
            runtimeModule = entryModules
                ? Array.from(entryModules).find((module) => module instanceof ContainerEntryModule_1.default)
                : undefined;
        }
        if (!runtimeModule) {
            logger.error('[Federation HoistContainerReferences] unable to find runtime module:', this.entryFilePath);
            return;
        }
        const allReferencedModules = getAllReferencedModules(compilation, runtimeModule, 'initial');
        // If single runtime chunk, copy the remoteEntry into the runtime chunk to allow for embed container
        // this will not work well if there multiple runtime chunks from entrypoints (like next)
        // need better solution to multi runtime chunk hoisting
        if (partialChunk) {
            for (const module of chunkGraph.getChunkModulesIterable(partialChunk)) {
                allReferencedModules.add(module);
            }
        }
        for (const chunk of runtimeChunks) {
            for (const module of allReferencedModules) {
                if (!chunkGraph.isModuleInChunk(module, chunk)) {
                    chunkGraph.connectChunkAndModule(chunk, module);
                }
            }
        }
        // Set used exports for the runtime module
        this.cleanUpChunks(compilation, allReferencedModules);
    }
    // Method to clean up chunks by disconnecting unused modules
    cleanUpChunks(compilation, modules) {
        const { chunkGraph } = compilation;
        for (const module of modules) {
            for (const chunk of chunkGraph.getModuleChunks(module)) {
                if (!chunk.hasRuntime()) {
                    chunkGraph.disconnectChunkAndModule(chunk, module);
                    if (chunkGraph.getNumberOfChunkModules(chunk) === 0 &&
                        chunkGraph.getNumberOfEntryModules(chunk) === 0) {
                        chunkGraph.disconnectChunk(chunk);
                        compilation.chunks.delete(chunk);
                        if (chunk.name) {
                            compilation.namedChunks.delete(chunk.name);
                        }
                    }
                }
            }
        }
        modules.clear();
    }
    // Helper method to get runtime chunks from the compilation
    getRuntimeChunks(compilation) {
        const runtimeChunks = new Set();
        const entries = compilation.entrypoints;
        for (const entrypoint of entries.values()) {
            const runtimeChunk = entrypoint.getRuntimeChunk();
            if (runtimeChunk) {
                runtimeChunks.add(runtimeChunk);
            }
        }
        return runtimeChunks;
    }
}
exports.HoistContainerReferences = HoistContainerReferences;
// Helper method to collect all referenced modules recursively
function getAllReferencedModules(compilation, module, type) {
    const collectedModules = new Set([module]);
    const stack = [module];
    while (stack.length > 0) {
        const currentModule = stack.pop();
        if (!currentModule)
            continue;
        const mgm = compilation.moduleGraph._getModuleGraphModule(currentModule);
        if (mgm && mgm.outgoingConnections) {
            for (const connection of mgm.outgoingConnections) {
                if (type === 'initial') {
                    const parentBlock = compilation.moduleGraph.getParentBlock(connection.dependency);
                    if (parentBlock instanceof AsyncDependenciesBlock) {
                        continue;
                    }
                }
                if (connection.module && !collectedModules.has(connection.module)) {
                    collectedModules.add(connection.module);
                    stack.push(connection.module);
                }
            }
        }
    }
    return collectedModules;
}
exports.default = HoistContainerReferences;
//# sourceMappingURL=HoistContainerReferencesPlugin.js.map