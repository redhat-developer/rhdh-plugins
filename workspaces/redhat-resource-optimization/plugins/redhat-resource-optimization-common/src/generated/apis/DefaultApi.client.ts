/*
 * Copyright Red Hat, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// ******************************************************************
// * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY. *
// ******************************************************************
import { DiscoveryApi } from '../types/discovery';
import { FetchApi } from '../types/fetch';
import crossFetch from 'cross-fetch';
import { pluginId } from '../pluginId';
import * as parser from 'uri-template';

import { RecommendationBoxPlots } from '../models/RecommendationBoxPlots.model';
import { RecommendationList } from '../models/RecommendationList.model';
import type {
  CostManagementReport,
  CurrencyCode,
} from '../../clients/types/cost-management';

/**
 * Wraps the Response type to convey a type on the json call.
 *
 * @public
 */
export type TypedResponse<T> = Omit<Response, 'json'> & {
  json: () => Promise<T>;
};

/**
 * Options you can pass into a request for additional information.
 *
 * @public
 */
export interface RequestOptions {
  token?: string;
}

/**
 * no description
 * @public
 */
export class DefaultApiClient {
  private readonly discoveryApi: DiscoveryApi;
  private readonly fetchApi: FetchApi;

  constructor(options: {
    discoveryApi: { getBaseUrl(pluginId: string): Promise<string> };
    fetchApi?: { fetch: typeof fetch };
  }) {
    this.discoveryApi = options.discoveryApi;
    this.fetchApi = options.fetchApi || { fetch: crossFetch };
  }

  /**
   * This feature is in limited preview for select customers
   * Get recommendation for container
   * @param recommendationId - The recommendation UUID
   * @param memoryUnit - unit preference for memory
   * @param cpuUnit - unit preference for cpu
   */
  public async getRecommendationById(
    // @ts-ignore
    request: {
      path: {
        recommendationId: string;
      };
      query: {
        memoryUnit?: 'bytes' | 'MiB' | 'GiB';
        cpuUnit?: 'millicores' | 'cores';
      };
    },
    options?: RequestOptions,
  ): Promise<TypedResponse<RecommendationBoxPlots>> {
    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId);

    const uriTemplate = `/recommendations/openshift/{recommendation_id}{?memory_unit,cpu_unit}`;

    const uri = parser.parse(uriTemplate).expand({
      recommendation_id: request.path.recommendationId,
      ...request.query,
    });

    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {
      headers: {
        'Content-Type': 'application/json',
        ...(options?.token && { Authorization: `Bearer ${options?.token}` }),
      },
      method: 'GET',
    });
  }

  /**
   * This feature is in limited preview for select customers
   * Get all recommendations
   * @param cluster - Cluster alias or UUID
   * @param workloadType - Options are daemonset, deployment, deploymentconfig, replicaset, replicationcontroller, statefulset
   * @param workload - Workload name
   * @param container - Container name
   * @param project - Project name
   * @param startDate - Start date
   * @param endDate - End date
   * @param offset - Pagination offset
   * @param limit - Pagination limit
   * @param orderBy - Options are cluster, project, workload_type, workload, container, last_reported
   * @param orderHow - Options are ASC, DESC
   */
  public async getRecommendationList(
    // @ts-ignore
    request: {
      query: {
        cluster?: Array<string>;
        workloadType?: Array<string>;
        workload?: Array<string>;
        container?: Array<string>;
        project?: Array<string>;
        startDate?: string;
        endDate?: string;
        offset?: number;
        limit?: number;
        orderBy?:
          | 'cluster'
          | 'project'
          | 'workload_type'
          | 'workload'
          | 'container'
          | 'last_reported';
        orderHow?: 'asc' | 'desc';
      };
    },
    options?: RequestOptions,
  ): Promise<TypedResponse<RecommendationList>> {
    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId);

    const uriTemplate = `/recommendations/openshift{?cluster*,workload_type*,workload*,container*,project*,start_date,end_date,offset,limit,order_by,order_how}`;

    const uri = parser.parse(uriTemplate).expand({
      ...request.query,
    });

    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {
      headers: {
        'Content-Type': 'application/json',
        ...(options?.token && { Authorization: `Bearer ${options?.token}` }),
      },
      method: 'GET',
    });
  }

  /**
   * Get cost management report for OpenShift projects
   * @param currency - Currency preference (USD, EUR, GBP, JPY, AUD, CAD, CHF, CNY, INR, MXN, NZD, SEK, SGD, HKD, TWD, THB, RUB, BRL, ZAR, PLN, KRW, TRY, IDR, MYR, PHP, VND, HUF, CZK, NOK, DKK, NGN)
   * @param delta - Delta calculation method
   * @param filter - Filter parameters
   * @param group_by - Group by parameters
   * @param order_by - Order by parameters
   */
  public async getCostManagementReport(
    request: {
      query: {
        currency?: CurrencyCode;
        delta?: string;
        'filter[limit]'?: number;
        'filter[offset]'?: number;
        'filter[resolution]'?: 'daily' | 'monthly';
        'filter[time_scope_units]'?: 'day' | 'month';
        'filter[time_scope_value]'?: number;
        'group_by[project]'?: '*' | string;
        'group_by[cluster]'?: '*' | string;
        'group_by[node]'?: '*' | string;
        'group_by[tag]'?: '*' | string;
        'order_by[cost]'?: 'asc' | 'desc';
        'order_by[distributed_cost]'?: 'asc' | 'desc';
        'order_by[markup_cost]'?: 'asc' | 'desc';
        'order_by[raw_cost]'?: 'asc' | 'desc';
        [key: string]: string | number | undefined;
      };
    },
    options?: RequestOptions,
  ): Promise<TypedResponse<CostManagementReport>> {
    // Get the proxy base URL for cost-management API
    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId);
    const uri = '/reports/openshift/costs/';

    // Build query string manually
    const queryParams = new URLSearchParams();
    if (request.query.currency) {
      queryParams.append('currency', request.query.currency);
    }
    if (request.query.delta) {
      queryParams.append('delta', request.query.delta);
    }
    if (request.query['filter[limit]']) {
      queryParams.append(
        'filter[limit]',
        String(request.query['filter[limit]']),
      );
    }
    if (request.query['filter[offset]']) {
      queryParams.append(
        'filter[offset]',
        String(request.query['filter[offset]']),
      );
    }
    if (request.query['filter[resolution]']) {
      queryParams.append(
        'filter[resolution]',
        request.query['filter[resolution]'],
      );
    }
    if (request.query['filter[time_scope_units]']) {
      queryParams.append(
        'filter[time_scope_units]',
        request.query['filter[time_scope_units]'],
      );
    }
    if (request.query['filter[time_scope_value]']) {
      queryParams.append(
        'filter[time_scope_value]',
        String(request.query['filter[time_scope_value]']),
      );
    }
    // Handle dynamic group_by parameters (project, cluster, node, tag, etc.)
    Object.keys(request.query).forEach(key => {
      if (key.startsWith('group_by[') && key.endsWith(']')) {
        const value = request.query[key as keyof typeof request.query];
        if (value) {
          queryParams.append(key, String(value));
        }
      }
    });

    // Handle dynamic order_by parameters (cost, distributed_cost, raw_cost, etc.)
    Object.keys(request.query).forEach(key => {
      if (key.startsWith('order_by[') && key.endsWith(']')) {
        const value = request.query[key as keyof typeof request.query];
        if (value) {
          queryParams.append(key, String(value));
        }
      }
    });

    // Handle dynamic filter parameters (filter[project], filter[cluster], filter[node], etc.)
    // Skip the ones already handled explicitly above (limit, offset, resolution, time_scope_units, time_scope_value)
    const handledFilterKeys = [
      'filter[limit]',
      'filter[offset]',
      'filter[resolution]',
      'filter[time_scope_units]',
      'filter[time_scope_value]',
    ];
    Object.keys(request.query).forEach(key => {
      if (
        key.startsWith('filter[') &&
        key.endsWith(']') &&
        !handledFilterKeys.includes(key)
      ) {
        const value = request.query[key as keyof typeof request.query];
        if (value) {
          queryParams.append(key, String(value));
        }
      }
    });

    const queryString = queryParams.toString();
    const url = `${baseUrl}${uri}${queryString ? `?${queryString}` : ''}`;

    return await this.fetchApi.fetch(url, {
      headers: {
        'Content-Type': 'application/json',
        ...(options?.token && { Authorization: `Bearer ${options?.token}` }),
      },
      method: 'GET',
    });
  }
}
