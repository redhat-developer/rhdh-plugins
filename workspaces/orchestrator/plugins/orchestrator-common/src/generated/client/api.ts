/* tslint:disable */
/* eslint-disable */
/**
 * Orchestrator plugin
 * API to interact with orchestrator plugin
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AuthToken
 */
export interface AuthToken {
    /**
     * The auth token provider name
     * @type {string}
     * @memberof AuthToken
     */
    'provider': string;
    /**
     * The auth token itself retrieved from the above specified provider name
     * @type {string}
     * @memberof AuthToken
     */
    'token': string;
}
/**
 * The ErrorResponse object represents a common structure for handling errors in API responses. It includes essential information about the error, such as the error message and additional optional details.
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * A string providing a concise and human-readable description of the encountered error. This field is required in the ErrorResponse object.
     * @type {string}
     * @memberof ErrorResponse
     */
    'message': string;
    /**
     * An optional field that can contain additional information or context about the error. It provides flexibility for including extra details based on specific error scenarios.
     * @type {string}
     * @memberof ErrorResponse
     */
    'additionalInfo'?: string;
}
/**
 * 
 * @export
 * @interface ExecuteWorkflowRequestDTO
 */
export interface ExecuteWorkflowRequestDTO {
    /**
     * 
     * @type {object}
     * @memberof ExecuteWorkflowRequestDTO
     */
    'inputData'?: object;
    /**
     * 
     * @type {Array<AuthToken>}
     * @memberof ExecuteWorkflowRequestDTO
     */
    'authTokens'?: Array<AuthToken>;
    /**
     * The entity string identifier to execute the workflow for
     * @type {string}
     * @memberof ExecuteWorkflowRequestDTO
     */
    'targetEntity'?: string;
}
/**
 * 
 * @export
 * @interface ExecuteWorkflowResponseDTO
 */
export interface ExecuteWorkflowResponseDTO {
    /**
     * 
     * @type {string}
     * @memberof ExecuteWorkflowResponseDTO
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface FieldFilter
 */
export interface FieldFilter {
    /**
     * 
     * @type {string}
     * @memberof FieldFilter
     */
    'field': string;
    /**
     * 
     * @type {string}
     * @memberof FieldFilter
     */
    'operator': FieldFilterOperatorEnum;
    /**
     * 
     * @type {FieldFilterValue}
     * @memberof FieldFilter
     */
    'value': FieldFilterValue;
}

export const FieldFilterOperatorEnum = {
    Eq: 'EQ',
    Gt: 'GT',
    Gte: 'GTE',
    Lt: 'LT',
    Lte: 'LTE',
    In: 'IN',
    IsNull: 'IS_NULL',
    Like: 'LIKE',
    Between: 'BETWEEN'
} as const;

export type FieldFilterOperatorEnum = typeof FieldFilterOperatorEnum[keyof typeof FieldFilterOperatorEnum];

/**
 * @type FieldFilterValue
 * @export
 */
export type FieldFilterValue = any | boolean | number | string;

/**
 * @type Filter
 * @export
 */
export type Filter = FieldFilter | LogicalFilter | NestedFilter;

/**
 * 
 * @export
 * @interface GetOverviewsRequestParams
 */
export interface GetOverviewsRequestParams {
    /**
     * 
     * @type {PaginationInfoDTO}
     * @memberof GetOverviewsRequestParams
     */
    'paginationInfo'?: PaginationInfoDTO;
    /**
     * 
     * @type {SearchRequest}
     * @memberof GetOverviewsRequestParams
     */
    'filters'?: SearchRequest;
}
/**
 * 
 * @export
 * @interface GetWorkflowsOverviewForEntityRequest
 */
export interface GetWorkflowsOverviewForEntityRequest {
    /**
     * 
     * @type {string}
     * @memberof GetWorkflowsOverviewForEntityRequest
     */
    'targetEntity'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetWorkflowsOverviewForEntityRequest
     */
    'annotationWorkflowIds'?: Array<string>;
}
/**
 * 
 * @export
 * @interface InputSchemaResponseDTO
 */
export interface InputSchemaResponseDTO {
    /**
     * 
     * @type {object}
     * @memberof InputSchemaResponseDTO
     */
    'inputSchema'?: object;
    /**
     * 
     * @type {object}
     * @memberof InputSchemaResponseDTO
     */
    'data'?: object;
}
/**
 * 
 * @export
 * @interface LogicalFilter
 */
export interface LogicalFilter {
    /**
     * 
     * @type {string}
     * @memberof LogicalFilter
     */
    'operator': LogicalFilterOperatorEnum;
    /**
     * 
     * @type {Array<Filter>}
     * @memberof LogicalFilter
     */
    'filters': Array<Filter>;
}

export const LogicalFilterOperatorEnum = {
    And: 'AND',
    Or: 'OR',
    Not: 'NOT'
} as const;

export type LogicalFilterOperatorEnum = typeof LogicalFilterOperatorEnum[keyof typeof LogicalFilterOperatorEnum];

/**
 * 
 * @export
 * @interface NestedFilter
 */
export interface NestedFilter {
    /**
     * 
     * @type {string}
     * @memberof NestedFilter
     */
    'field': string;
    /**
     * 
     * @type {NestedFilterNested}
     * @memberof NestedFilter
     */
    'nested': NestedFilterNested;
}
/**
 * @type NestedFilterNested
 * @export
 */
export type NestedFilterNested = FieldFilter | NestedFilter;

/**
 * 
 * @export
 * @interface NodeInstanceDTO
 */
export interface NodeInstanceDTO {
    /**
     * Type name
     * @type {string}
     * @memberof NodeInstanceDTO
     */
    '__typename'?: string;
    /**
     * Node instance ID
     * @type {string}
     * @memberof NodeInstanceDTO
     */
    'id': string;
    /**
     * Node name
     * @type {string}
     * @memberof NodeInstanceDTO
     */
    'name'?: string;
    /**
     * Node type
     * @type {string}
     * @memberof NodeInstanceDTO
     */
    'type'?: string;
    /**
     * Date when the node was entered
     * @type {string}
     * @memberof NodeInstanceDTO
     */
    'enter'?: string;
    /**
     * Date when the node was exited (optional)
     * @type {string}
     * @memberof NodeInstanceDTO
     */
    'exit'?: string;
    /**
     * Definition ID
     * @type {string}
     * @memberof NodeInstanceDTO
     */
    'definitionId'?: string;
    /**
     * Node ID
     * @type {string}
     * @memberof NodeInstanceDTO
     */
    'nodeId'?: string;
}
/**
 * 
 * @export
 * @interface PaginationInfoDTO
 */
export interface PaginationInfoDTO {
    /**
     * 
     * @type {number}
     * @memberof PaginationInfoDTO
     */
    'pageSize'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaginationInfoDTO
     */
    'offset'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginationInfoDTO
     */
    'orderDirection'?: PaginationInfoDTOOrderDirectionEnum;
    /**
     * 
     * @type {string}
     * @memberof PaginationInfoDTO
     */
    'orderBy'?: string;
}

export const PaginationInfoDTOOrderDirectionEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;

export type PaginationInfoDTOOrderDirectionEnum = typeof PaginationInfoDTOOrderDirectionEnum[keyof typeof PaginationInfoDTOOrderDirectionEnum];

/**
 * 
 * @export
 * @interface ProcessInstanceDTO
 */
export interface ProcessInstanceDTO {
    /**
     * 
     * @type {string}
     * @memberof ProcessInstanceDTO
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ProcessInstanceDTO
     */
    'processId': string;
    /**
     * 
     * @type {string}
     * @memberof ProcessInstanceDTO
     */
    'processName'?: string;
    /**
     * 
     * @type {ProcessInstanceStatusDTO}
     * @memberof ProcessInstanceDTO
     */
    'state'?: ProcessInstanceStatusDTO;
    /**
     * 
     * @type {string}
     * @memberof ProcessInstanceDTO
     */
    'endpoint'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProcessInstanceDTO
     */
    'serviceUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProcessInstanceDTO
     */
    'start'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProcessInstanceDTO
     */
    'end'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProcessInstanceDTO
     */
    'duration'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProcessInstanceDTO
     */
    'description'?: string;
    /**
     * 
     * @type {WorkflowDataDTO}
     * @memberof ProcessInstanceDTO
     */
    'workflowdata'?: WorkflowDataDTO;
    /**
     * 
     * @type {string}
     * @memberof ProcessInstanceDTO
     */
    'initiatorEntity'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProcessInstanceDTO
     */
    'targetEntity'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProcessInstanceDTO
     */
    'executionSummary'?: Array<string>;
    /**
     * 
     * @type {Array<NodeInstanceDTO>}
     * @memberof ProcessInstanceDTO
     */
    'nodes': Array<NodeInstanceDTO>;
    /**
     * 
     * @type {ProcessInstanceErrorDTO}
     * @memberof ProcessInstanceDTO
     */
    'error'?: ProcessInstanceErrorDTO;
}


/**
 * 
 * @export
 * @interface ProcessInstanceErrorDTO
 */
export interface ProcessInstanceErrorDTO {
    /**
     * Type name
     * @type {string}
     * @memberof ProcessInstanceErrorDTO
     */
    '__typename'?: string;
    /**
     * Node definition ID
     * @type {string}
     * @memberof ProcessInstanceErrorDTO
     */
    'nodeDefinitionId': string;
    /**
     * Error message (optional)
     * @type {string}
     * @memberof ProcessInstanceErrorDTO
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ProcessInstanceListResultDTO
 */
export interface ProcessInstanceListResultDTO {
    /**
     * 
     * @type {Array<ProcessInstanceDTO>}
     * @memberof ProcessInstanceListResultDTO
     */
    'items'?: Array<ProcessInstanceDTO>;
    /**
     * 
     * @type {PaginationInfoDTO}
     * @memberof ProcessInstanceListResultDTO
     */
    'paginationInfo'?: PaginationInfoDTO;
}
/**
 * Status of the workflow run
 * @export
 * @enum {string}
 */

export const ProcessInstanceStatusDTO = {
    Active: 'ACTIVE',
    Error: 'ERROR',
    Completed: 'COMPLETED',
    Aborted: 'ABORTED',
    Suspended: 'SUSPENDED',
    Pending: 'PENDING'
} as const;

export type ProcessInstanceStatusDTO = typeof ProcessInstanceStatusDTO[keyof typeof ProcessInstanceStatusDTO];


/**
 * 
 * @export
 * @interface RetriggerInstanceRequestDTO
 */
export interface RetriggerInstanceRequestDTO {
    /**
     * 
     * @type {Array<AuthToken>}
     * @memberof RetriggerInstanceRequestDTO
     */
    'authTokens'?: Array<AuthToken>;
}
/**
 * 
 * @export
 * @interface SearchRequest
 */
export interface SearchRequest {
    /**
     * 
     * @type {Filter}
     * @memberof SearchRequest
     */
    'filters'?: Filter;
    /**
     * 
     * @type {PaginationInfoDTO}
     * @memberof SearchRequest
     */
    'paginationInfo'?: PaginationInfoDTO;
}
/**
 * 
 * @export
 * @interface WorkflowDTO
 */
export interface WorkflowDTO {
    /**
     * Workflow unique identifier
     * @type {string}
     * @memberof WorkflowDTO
     */
    'id': string;
    /**
     * Workflow name
     * @type {string}
     * @memberof WorkflowDTO
     */
    'name'?: string;
    /**
     * 
     * @type {WorkflowFormatDTO}
     * @memberof WorkflowDTO
     */
    'format': WorkflowFormatDTO;
    /**
     * Description of the workflow
     * @type {string}
     * @memberof WorkflowDTO
     */
    'description'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof WorkflowDTO
     */
    'annotations'?: Array<string>;
}


/**
 * 
 * @export
 * @interface WorkflowDataDTO
 */
export interface WorkflowDataDTO {
    /**
     * 
     * @type {WorkflowResultDTO}
     * @memberof WorkflowDataDTO
     */
    'result'?: WorkflowResultDTO;
}
/**
 * Format of the workflow definition
 * @export
 * @enum {string}
 */

export const WorkflowFormatDTO = {
    Yaml: 'yaml',
    Json: 'json'
} as const;

export type WorkflowFormatDTO = typeof WorkflowFormatDTO[keyof typeof WorkflowFormatDTO];


/**
 * 
 * @export
 * @interface WorkflowListResultDTO
 */
export interface WorkflowListResultDTO {
    /**
     * 
     * @type {Array<WorkflowDTO>}
     * @memberof WorkflowListResultDTO
     */
    'items': Array<WorkflowDTO>;
    /**
     * 
     * @type {PaginationInfoDTO}
     * @memberof WorkflowListResultDTO
     */
    'paginationInfo': PaginationInfoDTO;
}
/**
 * 
 * @export
 * @interface WorkflowOverviewDTO
 */
export interface WorkflowOverviewDTO {
    /**
     * Workflow unique identifier
     * @type {string}
     * @memberof WorkflowOverviewDTO
     */
    'workflowId': string;
    /**
     * Workflow name
     * @type {string}
     * @memberof WorkflowOverviewDTO
     */
    'name'?: string;
    /**
     * 
     * @type {WorkflowFormatDTO}
     * @memberof WorkflowOverviewDTO
     */
    'format': WorkflowFormatDTO;
    /**
     * 
     * @type {string}
     * @memberof WorkflowOverviewDTO
     */
    'lastRunId'?: string;
    /**
     * 
     * @type {number}
     * @memberof WorkflowOverviewDTO
     */
    'lastTriggeredMs'?: number;
    /**
     * 
     * @type {ProcessInstanceStatusDTO}
     * @memberof WorkflowOverviewDTO
     */
    'lastRunStatus'?: ProcessInstanceStatusDTO;
    /**
     * 
     * @type {string}
     * @memberof WorkflowOverviewDTO
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof WorkflowOverviewDTO
     */
    'isAvailable'?: boolean;
}


/**
 * 
 * @export
 * @interface WorkflowOverviewListResultDTO
 */
export interface WorkflowOverviewListResultDTO {
    /**
     * 
     * @type {Array<WorkflowOverviewDTO>}
     * @memberof WorkflowOverviewListResultDTO
     */
    'overviews'?: Array<WorkflowOverviewDTO>;
    /**
     * 
     * @type {PaginationInfoDTO}
     * @memberof WorkflowOverviewListResultDTO
     */
    'paginationInfo'?: PaginationInfoDTO;
}
/**
 * 
 * @export
 * @interface WorkflowProgressDTO
 */
export interface WorkflowProgressDTO {
    /**
     * Type name
     * @type {any}
     * @memberof WorkflowProgressDTO
     */
    '__typename'?: any;
    /**
     * Node instance ID
     * @type {any}
     * @memberof WorkflowProgressDTO
     */
    'id': any;
    /**
     * Node name
     * @type {any}
     * @memberof WorkflowProgressDTO
     */
    'name'?: any;
    /**
     * Node type
     * @type {any}
     * @memberof WorkflowProgressDTO
     */
    'type'?: any;
    /**
     * Date when the node was entered
     * @type {any}
     * @memberof WorkflowProgressDTO
     */
    'enter'?: any;
    /**
     * Date when the node was exited (optional)
     * @type {any}
     * @memberof WorkflowProgressDTO
     */
    'exit'?: any;
    /**
     * Definition ID
     * @type {any}
     * @memberof WorkflowProgressDTO
     */
    'definitionId'?: any;
    /**
     * Node ID
     * @type {any}
     * @memberof WorkflowProgressDTO
     */
    'nodeId'?: any;
    /**
     * 
     * @type {ProcessInstanceStatusDTO}
     * @memberof WorkflowProgressDTO
     */
    'status'?: ProcessInstanceStatusDTO;
    /**
     * 
     * @type {ProcessInstanceErrorDTO}
     * @memberof WorkflowProgressDTO
     */
    'error'?: ProcessInstanceErrorDTO;
}


/**
 * Result of a workflow execution
 * @export
 * @interface WorkflowResultDTO
 */
export interface WorkflowResultDTO {
    /**
     * High-level summary of the current status, free-form text, human readable.
     * @type {string}
     * @memberof WorkflowResultDTO
     */
    'message'?: string;
    /**
     * List of workflows suggested to run next. Items at lower indexes are of higher priority.
     * @type {Array<WorkflowResultDTONextWorkflowsInner>}
     * @memberof WorkflowResultDTO
     */
    'nextWorkflows'?: Array<WorkflowResultDTONextWorkflowsInner>;
    /**
     * Additional structured output of workflow processing. This can contain identifiers of created resources, links to resources, logs or other output.
     * @type {Array<WorkflowResultDTOOutputsInner>}
     * @memberof WorkflowResultDTO
     */
    'outputs'?: Array<WorkflowResultDTOOutputsInner>;
}
/**
 * 
 * @export
 * @interface WorkflowResultDTONextWorkflowsInner
 */
export interface WorkflowResultDTONextWorkflowsInner {
    /**
     * Workflow identifier
     * @type {string}
     * @memberof WorkflowResultDTONextWorkflowsInner
     */
    'id': string;
    /**
     * Human readable title describing the workflow.
     * @type {string}
     * @memberof WorkflowResultDTONextWorkflowsInner
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface WorkflowResultDTOOutputsInner
 */
export interface WorkflowResultDTOOutputsInner {
    /**
     * Unique identifier of the option. Preferably human-readable.
     * @type {string}
     * @memberof WorkflowResultDTOOutputsInner
     */
    'key': string;
    /**
     * 
     * @type {WorkflowResultDTOOutputsInnerValue}
     * @memberof WorkflowResultDTOOutputsInner
     */
    'value': WorkflowResultDTOOutputsInnerValue;
    /**
     * More detailed type of the \'value\' property. Defaults to \'text\'.
     * @type {string}
     * @memberof WorkflowResultDTOOutputsInner
     */
    'format'?: WorkflowResultDTOOutputsInnerFormatEnum;
}

export const WorkflowResultDTOOutputsInnerFormatEnum = {
    Text: 'text',
    Number: 'number',
    Link: 'link',
    Markdown: 'markdown'
} as const;

export type WorkflowResultDTOOutputsInnerFormatEnum = typeof WorkflowResultDTOOutputsInnerFormatEnum[keyof typeof WorkflowResultDTOOutputsInnerFormatEnum];

/**
 * Free form value of the option.
 * @export
 * @interface WorkflowResultDTOOutputsInnerValue
 */
export interface WorkflowResultDTOOutputsInnerValue {
}
/**
 * 
 * @export
 * @interface WorkflowRunStatusDTO
 */
export interface WorkflowRunStatusDTO {
    /**
     * 
     * @type {string}
     * @memberof WorkflowRunStatusDTO
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowRunStatusDTO
     */
    'value'?: string;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Aborts a workflow instance identified by the provided instanceId.
         * @summary Abort a workflow instance
         * @param {string} instanceId The identifier of the workflow instance to abort.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        abortWorkflow: async (instanceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('abortWorkflow', 'instanceId', instanceId)
            const localVarPath = `/v2/workflows/instances/{instanceId}/abort`
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Execute a workflow
         * @summary Execute a workflow
         * @param {string} workflowId ID of the workflow to execute
         * @param {ExecuteWorkflowRequestDTO} executeWorkflowRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeWorkflow: async (workflowId: string, executeWorkflowRequestDTO: ExecuteWorkflowRequestDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('executeWorkflow', 'workflowId', workflowId)
            // verify required parameter 'executeWorkflowRequestDTO' is not null or undefined
            assertParamExists('executeWorkflow', 'executeWorkflowRequestDTO', executeWorkflowRequestDTO)
            const localVarPath = `/v2/workflows/{workflowId}/execute`
                .replace(`{${"workflowId"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(executeWorkflowRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a workflow execution/run (instance)
         * @summary Get Workflow Instance by ID
         * @param {string} instanceId ID of the workflow instance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstanceById: async (instanceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('getInstanceById', 'instanceId', instanceId)
            const localVarPath = `/v2/workflows/instances/{instanceId}`
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an array of workflow executions (instances)
         * @summary Get instances
         * @param {SearchRequest} [searchRequest] Parameters for retrieving instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstances: async (searchRequest?: SearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/workflows/instances`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the workflow input schema. It defines the input fields of the workflow
         * @param {string} workflowId ID of the workflow to fetch
         * @param {string} [instanceId] ID of instance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowInputSchemaById: async (workflowId: string, instanceId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('getWorkflowInputSchemaById', 'workflowId', workflowId)
            const localVarPath = `/v2/workflows/{workflowId}/inputSchema`
                .replace(`{${"workflowId"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (instanceId !== undefined) {
                localVarQueryParameter['instanceId'] = instanceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an array of workflow executions (instances) for the given workflow
         * @summary Get instances for a specific workflow
         * @param {string} workflowId ID of the workflow
         * @param {SearchRequest} [searchRequest] Parameters for retrieving workflow instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowInstances: async (workflowId: string, searchRequest?: SearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('getWorkflowInstances', 'workflowId', workflowId)
            const localVarPath = `/v2/workflows/{workflowId}/instances`
                .replace(`{${"workflowId"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the log for a given workflow ID.
         * @param {string} instanceId ID of the workflow instance
         * @param {boolean} [rawlog] whether to return the raw log or not
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowLogById: async (instanceId: string, rawlog?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('getWorkflowLogById', 'instanceId', instanceId)
            const localVarPath = `/v2/workflows/instances/{instanceId}/logs`
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (rawlog !== undefined) {
                localVarQueryParameter['rawlog'] = rawlog;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the key fields of the workflow including data on the last run instance
         * @param {string} workflowId Unique identifier of the workflow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowOverviewById: async (workflowId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('getWorkflowOverviewById', 'workflowId', workflowId)
            const localVarPath = `/v2/workflows/{workflowId}/overview`
                .replace(`{${"workflowId"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the workflow\'s definition
         * @param {string} workflowId ID of the workflow to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowSourceById: async (workflowId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('getWorkflowSourceById', 'workflowId', workflowId)
            const localVarPath = `/v2/workflows/{workflowId}/source`
                .replace(`{${"workflowId"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve array with the status of all instances
         * @summary Get workflow status list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowStatuses: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/workflows/instances/statuses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the key fields of the workflow including data on the last run instance
         * @param {SearchRequest} [searchRequest] Pagination and filters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowsOverview: async (searchRequest?: SearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/workflows/overview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the key fields of the workflow including data on the last run instance
         * @param {GetWorkflowsOverviewForEntityRequest} [getWorkflowsOverviewForEntityRequest] Target entity reference and annotation workflow ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowsOverviewForEntity: async (getWorkflowsOverviewForEntityRequest?: GetWorkflowsOverviewForEntityRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/workflows/overview/entity`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getWorkflowsOverviewForEntityRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns true if the workflow service is up for the given workflow ID.
         * @param {string} workflowId ID of the workflow to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pingWorkflowServiceById: async (workflowId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('pingWorkflowServiceById', 'workflowId', workflowId)
            const localVarPath = `/v2/workflows/{workflowId}/pingWorkflowService`
                .replace(`{${"workflowId"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrigger an instance
         * @summary Retrigger an instance
         * @param {string} workflowId ID of the workflow
         * @param {string} instanceId ID of the instance to retrigger
         * @param {RetriggerInstanceRequestDTO} retriggerInstanceRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retriggerInstance: async (workflowId: string, instanceId: string, retriggerInstanceRequestDTO: RetriggerInstanceRequestDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('retriggerInstance', 'workflowId', workflowId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('retriggerInstance', 'instanceId', instanceId)
            // verify required parameter 'retriggerInstanceRequestDTO' is not null or undefined
            assertParamExists('retriggerInstance', 'retriggerInstanceRequestDTO', retriggerInstanceRequestDTO)
            const localVarPath = `/v2/workflows/{workflowId}/{instanceId}/retrigger`
                .replace(`{${"workflowId"}}`, encodeURIComponent(String(workflowId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(retriggerInstanceRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * Aborts a workflow instance identified by the provided instanceId.
         * @summary Abort a workflow instance
         * @param {string} instanceId The identifier of the workflow instance to abort.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async abortWorkflow(instanceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.abortWorkflow(instanceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.abortWorkflow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Execute a workflow
         * @summary Execute a workflow
         * @param {string} workflowId ID of the workflow to execute
         * @param {ExecuteWorkflowRequestDTO} executeWorkflowRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeWorkflow(workflowId: string, executeWorkflowRequestDTO: ExecuteWorkflowRequestDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExecuteWorkflowResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeWorkflow(workflowId, executeWorkflowRequestDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.executeWorkflow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a workflow execution/run (instance)
         * @summary Get Workflow Instance by ID
         * @param {string} instanceId ID of the workflow instance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInstanceById(instanceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProcessInstanceDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInstanceById(instanceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getInstanceById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an array of workflow executions (instances)
         * @summary Get instances
         * @param {SearchRequest} [searchRequest] Parameters for retrieving instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInstances(searchRequest?: SearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProcessInstanceListResultDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInstances(searchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getInstances']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the workflow input schema. It defines the input fields of the workflow
         * @param {string} workflowId ID of the workflow to fetch
         * @param {string} [instanceId] ID of instance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkflowInputSchemaById(workflowId: string, instanceId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InputSchemaResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkflowInputSchemaById(workflowId, instanceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getWorkflowInputSchemaById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an array of workflow executions (instances) for the given workflow
         * @summary Get instances for a specific workflow
         * @param {string} workflowId ID of the workflow
         * @param {SearchRequest} [searchRequest] Parameters for retrieving workflow instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkflowInstances(workflowId: string, searchRequest?: SearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProcessInstanceListResultDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkflowInstances(workflowId, searchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getWorkflowInstances']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the log for a given workflow ID.
         * @param {string} instanceId ID of the workflow instance
         * @param {boolean} [rawlog] whether to return the raw log or not
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkflowLogById(instanceId: string, rawlog?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProcessInstanceDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkflowLogById(instanceId, rawlog, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getWorkflowLogById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the key fields of the workflow including data on the last run instance
         * @param {string} workflowId Unique identifier of the workflow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkflowOverviewById(workflowId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowOverviewDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkflowOverviewById(workflowId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getWorkflowOverviewById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the workflow\'s definition
         * @param {string} workflowId ID of the workflow to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkflowSourceById(workflowId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkflowSourceById(workflowId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getWorkflowSourceById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve array with the status of all instances
         * @summary Get workflow status list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkflowStatuses(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkflowRunStatusDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkflowStatuses(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getWorkflowStatuses']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the key fields of the workflow including data on the last run instance
         * @param {SearchRequest} [searchRequest] Pagination and filters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkflowsOverview(searchRequest?: SearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowOverviewListResultDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkflowsOverview(searchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getWorkflowsOverview']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the key fields of the workflow including data on the last run instance
         * @param {GetWorkflowsOverviewForEntityRequest} [getWorkflowsOverviewForEntityRequest] Target entity reference and annotation workflow ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkflowsOverviewForEntity(getWorkflowsOverviewForEntityRequest?: GetWorkflowsOverviewForEntityRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowOverviewListResultDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkflowsOverviewForEntity(getWorkflowsOverviewForEntityRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getWorkflowsOverviewForEntity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns true if the workflow service is up for the given workflow ID.
         * @param {string} workflowId ID of the workflow to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pingWorkflowServiceById(workflowId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pingWorkflowServiceById(workflowId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.pingWorkflowServiceById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrigger an instance
         * @summary Retrigger an instance
         * @param {string} workflowId ID of the workflow
         * @param {string} instanceId ID of the instance to retrigger
         * @param {RetriggerInstanceRequestDTO} retriggerInstanceRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retriggerInstance(workflowId: string, instanceId: string, retriggerInstanceRequestDTO: RetriggerInstanceRequestDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retriggerInstance(workflowId, instanceId, retriggerInstanceRequestDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.retriggerInstance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * Aborts a workflow instance identified by the provided instanceId.
         * @summary Abort a workflow instance
         * @param {string} instanceId The identifier of the workflow instance to abort.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        abortWorkflow(instanceId: string, options?: any): AxiosPromise<string> {
            return localVarFp.abortWorkflow(instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Execute a workflow
         * @summary Execute a workflow
         * @param {string} workflowId ID of the workflow to execute
         * @param {ExecuteWorkflowRequestDTO} executeWorkflowRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeWorkflow(workflowId: string, executeWorkflowRequestDTO: ExecuteWorkflowRequestDTO, options?: any): AxiosPromise<ExecuteWorkflowResponseDTO> {
            return localVarFp.executeWorkflow(workflowId, executeWorkflowRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a workflow execution/run (instance)
         * @summary Get Workflow Instance by ID
         * @param {string} instanceId ID of the workflow instance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstanceById(instanceId: string, options?: any): AxiosPromise<ProcessInstanceDTO> {
            return localVarFp.getInstanceById(instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an array of workflow executions (instances)
         * @summary Get instances
         * @param {SearchRequest} [searchRequest] Parameters for retrieving instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstances(searchRequest?: SearchRequest, options?: any): AxiosPromise<ProcessInstanceListResultDTO> {
            return localVarFp.getInstances(searchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the workflow input schema. It defines the input fields of the workflow
         * @param {string} workflowId ID of the workflow to fetch
         * @param {string} [instanceId] ID of instance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowInputSchemaById(workflowId: string, instanceId?: string, options?: any): AxiosPromise<InputSchemaResponseDTO> {
            return localVarFp.getWorkflowInputSchemaById(workflowId, instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an array of workflow executions (instances) for the given workflow
         * @summary Get instances for a specific workflow
         * @param {string} workflowId ID of the workflow
         * @param {SearchRequest} [searchRequest] Parameters for retrieving workflow instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowInstances(workflowId: string, searchRequest?: SearchRequest, options?: any): AxiosPromise<ProcessInstanceListResultDTO> {
            return localVarFp.getWorkflowInstances(workflowId, searchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the log for a given workflow ID.
         * @param {string} instanceId ID of the workflow instance
         * @param {boolean} [rawlog] whether to return the raw log or not
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowLogById(instanceId: string, rawlog?: boolean, options?: any): AxiosPromise<ProcessInstanceDTO> {
            return localVarFp.getWorkflowLogById(instanceId, rawlog, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the key fields of the workflow including data on the last run instance
         * @param {string} workflowId Unique identifier of the workflow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowOverviewById(workflowId: string, options?: any): AxiosPromise<WorkflowOverviewDTO> {
            return localVarFp.getWorkflowOverviewById(workflowId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the workflow\'s definition
         * @param {string} workflowId ID of the workflow to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowSourceById(workflowId: string, options?: any): AxiosPromise<string> {
            return localVarFp.getWorkflowSourceById(workflowId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve array with the status of all instances
         * @summary Get workflow status list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowStatuses(options?: any): AxiosPromise<Array<WorkflowRunStatusDTO>> {
            return localVarFp.getWorkflowStatuses(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the key fields of the workflow including data on the last run instance
         * @param {SearchRequest} [searchRequest] Pagination and filters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowsOverview(searchRequest?: SearchRequest, options?: any): AxiosPromise<WorkflowOverviewListResultDTO> {
            return localVarFp.getWorkflowsOverview(searchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the key fields of the workflow including data on the last run instance
         * @param {GetWorkflowsOverviewForEntityRequest} [getWorkflowsOverviewForEntityRequest] Target entity reference and annotation workflow ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowsOverviewForEntity(getWorkflowsOverviewForEntityRequest?: GetWorkflowsOverviewForEntityRequest, options?: any): AxiosPromise<WorkflowOverviewListResultDTO> {
            return localVarFp.getWorkflowsOverviewForEntity(getWorkflowsOverviewForEntityRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns true if the workflow service is up for the given workflow ID.
         * @param {string} workflowId ID of the workflow to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pingWorkflowServiceById(workflowId: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.pingWorkflowServiceById(workflowId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrigger an instance
         * @summary Retrigger an instance
         * @param {string} workflowId ID of the workflow
         * @param {string} instanceId ID of the instance to retrigger
         * @param {RetriggerInstanceRequestDTO} retriggerInstanceRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retriggerInstance(workflowId: string, instanceId: string, retriggerInstanceRequestDTO: RetriggerInstanceRequestDTO, options?: any): AxiosPromise<object> {
            return localVarFp.retriggerInstance(workflowId, instanceId, retriggerInstanceRequestDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * Aborts a workflow instance identified by the provided instanceId.
     * @summary Abort a workflow instance
     * @param {string} instanceId The identifier of the workflow instance to abort.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public abortWorkflow(instanceId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).abortWorkflow(instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Execute a workflow
     * @summary Execute a workflow
     * @param {string} workflowId ID of the workflow to execute
     * @param {ExecuteWorkflowRequestDTO} executeWorkflowRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public executeWorkflow(workflowId: string, executeWorkflowRequestDTO: ExecuteWorkflowRequestDTO, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).executeWorkflow(workflowId, executeWorkflowRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a workflow execution/run (instance)
     * @summary Get Workflow Instance by ID
     * @param {string} instanceId ID of the workflow instance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getInstanceById(instanceId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getInstanceById(instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an array of workflow executions (instances)
     * @summary Get instances
     * @param {SearchRequest} [searchRequest] Parameters for retrieving instances
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getInstances(searchRequest?: SearchRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getInstances(searchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the workflow input schema. It defines the input fields of the workflow
     * @param {string} workflowId ID of the workflow to fetch
     * @param {string} [instanceId] ID of instance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getWorkflowInputSchemaById(workflowId: string, instanceId?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getWorkflowInputSchemaById(workflowId, instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an array of workflow executions (instances) for the given workflow
     * @summary Get instances for a specific workflow
     * @param {string} workflowId ID of the workflow
     * @param {SearchRequest} [searchRequest] Parameters for retrieving workflow instances
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getWorkflowInstances(workflowId: string, searchRequest?: SearchRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getWorkflowInstances(workflowId, searchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the log for a given workflow ID.
     * @param {string} instanceId ID of the workflow instance
     * @param {boolean} [rawlog] whether to return the raw log or not
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getWorkflowLogById(instanceId: string, rawlog?: boolean, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getWorkflowLogById(instanceId, rawlog, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the key fields of the workflow including data on the last run instance
     * @param {string} workflowId Unique identifier of the workflow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getWorkflowOverviewById(workflowId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getWorkflowOverviewById(workflowId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the workflow\'s definition
     * @param {string} workflowId ID of the workflow to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getWorkflowSourceById(workflowId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getWorkflowSourceById(workflowId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve array with the status of all instances
     * @summary Get workflow status list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getWorkflowStatuses(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getWorkflowStatuses(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the key fields of the workflow including data on the last run instance
     * @param {SearchRequest} [searchRequest] Pagination and filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getWorkflowsOverview(searchRequest?: SearchRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getWorkflowsOverview(searchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the key fields of the workflow including data on the last run instance
     * @param {GetWorkflowsOverviewForEntityRequest} [getWorkflowsOverviewForEntityRequest] Target entity reference and annotation workflow ids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getWorkflowsOverviewForEntity(getWorkflowsOverviewForEntityRequest?: GetWorkflowsOverviewForEntityRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getWorkflowsOverviewForEntity(getWorkflowsOverviewForEntityRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns true if the workflow service is up for the given workflow ID.
     * @param {string} workflowId ID of the workflow to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public pingWorkflowServiceById(workflowId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).pingWorkflowServiceById(workflowId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrigger an instance
     * @summary Retrigger an instance
     * @param {string} workflowId ID of the workflow
     * @param {string} instanceId ID of the instance to retrigger
     * @param {RetriggerInstanceRequestDTO} retriggerInstanceRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public retriggerInstance(workflowId: string, instanceId: string, retriggerInstanceRequestDTO: RetriggerInstanceRequestDTO, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).retriggerInstance(workflowId, instanceId, retriggerInstanceRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



