{"version":3,"file":"I18nextTranslationApi.esm.js","sources":["../../../../../../../core-app-api/src/apis/implementations/TranslationApi/I18nextTranslationApi.ts"],"sourcesContent":["/*\n * Copyright 2023 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  AppLanguageApi,\n  TranslationApi,\n  TranslationFunction,\n  TranslationMessages,\n  TranslationRef,\n  TranslationResource,\n  TranslationSnapshot,\n} from '@backstage/core-plugin-api/alpha';\nimport {\n  createInstance as createI18n,\n  FormatFunction,\n  Interpolator,\n  TFunction,\n  type i18n as I18n,\n} from 'i18next';\nimport ObservableImpl from 'zen-observable';\n\n// Internal import to avoid code duplication, this will lead to duplication in build output\n// eslint-disable-next-line @backstage/no-relative-monorepo-imports\nimport {\n  toInternalTranslationResource,\n  InternalTranslationResourceLoader,\n} from '../../../../../core-plugin-api/src/translation/TranslationResource';\n// eslint-disable-next-line @backstage/no-relative-monorepo-imports\nimport {\n  toInternalTranslationRef,\n  InternalTranslationRef,\n} from '../../../../../core-plugin-api/src/translation/TranslationRef';\nimport { Observable } from '@backstage/types';\nimport { DEFAULT_LANGUAGE } from '../AppLanguageApi/AppLanguageSelector';\nimport { createElement, Fragment, ReactNode, isValidElement } from 'react';\n\n/** @alpha */\nexport interface I18nextTranslationApiOptions {\n  languageApi: AppLanguageApi;\n  resources?: Array<TranslationMessages | TranslationResource>;\n}\n\nfunction removeNulls(\n  messages: Record<string, string | null>,\n): Record<string, string> {\n  return Object.fromEntries(\n    Object.entries(messages).filter(\n      (e): e is [string, string] => e[1] !== null,\n    ),\n  );\n}\n\n/**\n * The built-in i18next backend loading logic doesn't handle on the fly switches\n * of language very well. It gets a bit confused about whether resources are actually\n * loaded or not, so instead we implement our own resource loader.\n */\nclass ResourceLoader {\n  /** Loaded resources by loader key */\n  #loaded = new Set<string>();\n  /** Resource loading promises by loader key */\n  #loading = new Map<string, Promise<void>>();\n  /** Loaders for each resource language */\n  #loaders = new Map<string, InternalTranslationResourceLoader>();\n\n  constructor(\n    private readonly onLoad: (loaded: {\n      language: string;\n      namespace: string;\n      messages: Record<string, string | null>;\n    }) => void,\n  ) {}\n\n  addTranslationResource(resource: TranslationResource) {\n    const internalResource = toInternalTranslationResource(resource);\n    for (const entry of internalResource.resources) {\n      const key = this.#getLoaderKey(entry.language, internalResource.id);\n\n      // First loader to register wins, this means that resources registered in the app\n      // have priority over default resource from translation refs\n      if (!this.#loaders.has(key)) {\n        this.#loaders.set(key, entry.loader);\n      }\n    }\n  }\n\n  #getLoaderKey(language: string, namespace: string) {\n    return `${language}/${namespace}`;\n  }\n\n  needsLoading(language: string, namespace: string) {\n    const key = this.#getLoaderKey(language, namespace);\n    const loader = this.#loaders.get(key);\n    if (!loader) {\n      return false;\n    }\n\n    return !this.#loaded.has(key);\n  }\n\n  async load(language: string, namespace: string): Promise<void> {\n    const key = this.#getLoaderKey(language, namespace);\n\n    const loader = this.#loaders.get(key);\n    if (!loader) {\n      return;\n    }\n\n    if (this.#loaded.has(key)) {\n      return;\n    }\n\n    const loading = this.#loading.get(key);\n    if (loading) {\n      await loading;\n      return;\n    }\n\n    const load = loader().then(\n      result => {\n        this.onLoad({ language, namespace, messages: result.messages });\n        this.#loaded.add(key);\n      },\n      error => {\n        this.#loaded.add(key); // Do not try to load failed resources again\n        throw error;\n      },\n    );\n    this.#loading.set(key, load);\n    await load;\n  }\n}\n\n/**\n * A helper for implementing JSX interpolation\n */\nexport class JsxInterpolator {\n  readonly #setFormatHook: (hook: FormatFunction) => void;\n  readonly #marker: string;\n  readonly #pattern: RegExp;\n\n  static fromI18n(i18n: I18n) {\n    const interpolator = i18n.services.interpolator as Interpolator & {\n      format: FormatFunction;\n    };\n    const originalFormat = interpolator.format;\n\n    let formatHook: FormatFunction | undefined;\n\n    // This is the only way to override the format function of the interpolator\n    // without overriding the default formatters. See the behavior here:\n    // https://github.com/i18next/i18next/blob/c633121e57e2b6024080142d78027842bf2a6e5e/src/i18next.js#L120-L125\n    interpolator.format = (value, format, lng, formatOpts) => {\n      if (format) {\n        return originalFormat(value, format, lng, formatOpts);\n      }\n      return formatHook?.(value, format, lng, formatOpts) ?? value;\n    };\n\n    return new JsxInterpolator(\n      // Using a random marker to ensure it can't be misused\n      Math.random().toString(36).substring(2, 8),\n      hook => {\n        formatHook = hook;\n      },\n    );\n  }\n\n  private constructor(\n    marker: string,\n    setFormatHook: (hook: FormatFunction) => void,\n  ) {\n    this.#setFormatHook = setFormatHook;\n    this.#marker = marker;\n    this.#pattern = new RegExp(`\\\\$${marker}\\\\(([^)]+)\\\\)`);\n  }\n\n  wrapT<TMessages extends { [key in string]: string }>(\n    originalT: TFunction,\n  ): TranslationFunction<TMessages> {\n    return ((key, options) => {\n      let elementsMap: Map<string, ReactNode> | undefined = undefined;\n\n      // There's no way to override the format hook via the translation function\n      // options, event though types indicate that it might be possible.\n      // Instead, override the format function hook before every invocation and\n      // rely on synchronous execution.\n      this.#setFormatHook(value => {\n        if (isValidElement(value)) {\n          if (!elementsMap) {\n            elementsMap = new Map();\n          }\n          const elementKey = elementsMap.size.toString();\n          elementsMap.set(elementKey, value);\n\n          return `$${this.#marker}(${elementKey})`;\n        }\n        return value;\n      });\n\n      // Overriding the return options is not allowed via TranslationFunction,\n      // so this will always be a string\n      const result = originalT(key, options as any) as unknown as string;\n      if (!elementsMap) {\n        return result;\n      }\n\n      const split = result.split(this.#pattern);\n\n      return createElement(\n        Fragment,\n        null,\n        ...split\n          .map((part, index) => {\n            if (index % 2 === 0) {\n              return part;\n            }\n            return elementsMap?.get(part);\n          })\n          .filter(Boolean),\n      );\n    }) as TranslationFunction<TMessages>;\n  }\n}\n\n/** @alpha */\nexport class I18nextTranslationApi implements TranslationApi {\n  static create(options: I18nextTranslationApiOptions) {\n    const { languages } = options.languageApi.getAvailableLanguages();\n\n    const i18n = createI18n({\n      fallbackLng: DEFAULT_LANGUAGE,\n      supportedLngs: languages,\n      interpolation: {\n        escapeValue: false,\n        // Used for the JsxInterpolator format hook\n        alwaysFormat: true,\n      },\n      ns: [],\n      defaultNS: false,\n      fallbackNS: false,\n\n      // Disable resource loading on init, meaning i18n will be ready to use immediately\n      initImmediate: false,\n    });\n\n    i18n.init();\n    if (!i18n.isInitialized) {\n      throw new Error('i18next was unexpectedly not initialized');\n    }\n\n    const interpolator = JsxInterpolator.fromI18n(i18n);\n\n    const { language: initialLanguage } = options.languageApi.getLanguage();\n    if (initialLanguage !== DEFAULT_LANGUAGE) {\n      i18n.changeLanguage(initialLanguage);\n    }\n\n    const loader = new ResourceLoader(loaded => {\n      i18n.addResourceBundle(\n        loaded.language,\n        loaded.namespace,\n        removeNulls(loaded.messages),\n        false, // do not merge with existing translations\n        true, // overwrite translations\n      );\n    });\n\n    const resources = options?.resources || [];\n    // Iterate in reverse, giving higher priority to resources registered later\n    for (let i = resources.length - 1; i >= 0; i--) {\n      const resource = resources[i];\n      if (resource.$$type === '@backstage/TranslationResource') {\n        loader.addTranslationResource(resource);\n      } else if (resource.$$type === '@backstage/TranslationMessages') {\n        // Overrides for default messages, created with createTranslationMessages and installed via app\n        i18n.addResourceBundle(\n          DEFAULT_LANGUAGE,\n          resource.id,\n          removeNulls(resource.messages),\n          true, // merge with existing translations\n          false, // do not overwrite translations\n        );\n      }\n    }\n\n    const instance = new I18nextTranslationApi(\n      i18n,\n      loader,\n      options.languageApi.getLanguage().language,\n      interpolator,\n    );\n\n    options.languageApi.language$().subscribe(({ language }) => {\n      instance.#changeLanguage(language);\n    });\n\n    return instance;\n  }\n\n  #i18n: I18n;\n  #loader: ResourceLoader;\n  #language: string;\n  #jsxInterpolator: JsxInterpolator;\n\n  /** Keep track of which refs we have registered default resources for */\n  #registeredRefs = new Set<string>();\n  /** Notify observers when language changes */\n  #languageChangeListeners = new Set<() => void>();\n\n  private constructor(\n    i18n: I18n,\n    loader: ResourceLoader,\n    language: string,\n    jsxInterpolator: JsxInterpolator,\n  ) {\n    this.#i18n = i18n;\n    this.#loader = loader;\n    this.#language = language;\n    this.#jsxInterpolator = jsxInterpolator;\n  }\n\n  getTranslation<TMessages extends { [key in string]: string }>(\n    translationRef: TranslationRef<string, TMessages>,\n  ): TranslationSnapshot<TMessages> {\n    const internalRef = toInternalTranslationRef(translationRef);\n\n    this.#registerDefaults(internalRef);\n\n    return this.#createSnapshot(internalRef);\n  }\n\n  translation$<TMessages extends { [key in string]: string }>(\n    translationRef: TranslationRef<string, TMessages>,\n  ): Observable<TranslationSnapshot<TMessages>> {\n    const internalRef = toInternalTranslationRef(translationRef);\n\n    this.#registerDefaults(internalRef);\n\n    return new ObservableImpl<TranslationSnapshot<TMessages>>(subscriber => {\n      let loadTicket = {}; // To check for stale loads\n\n      const loadResource = () => {\n        loadTicket = {};\n        const ticket = loadTicket;\n        this.#loader.load(this.#language, internalRef.id).then(\n          () => {\n            if (ticket === loadTicket) {\n              const snapshot = this.#createSnapshot(internalRef);\n              if (snapshot.ready) {\n                subscriber.next(snapshot);\n              }\n            }\n          },\n          error => {\n            if (ticket === loadTicket) {\n              subscriber.error(Array.isArray(error) ? error[0] : error);\n            }\n          },\n        );\n      };\n\n      const onChange = () => {\n        const snapshot = this.#createSnapshot(internalRef);\n        if (snapshot.ready) {\n          subscriber.next(snapshot);\n        } else {\n          loadResource();\n        }\n      };\n\n      if (this.#loader.needsLoading(this.#language, internalRef.id)) {\n        loadResource();\n      }\n\n      this.#languageChangeListeners.add(onChange);\n      return () => {\n        this.#languageChangeListeners.delete(onChange);\n      };\n    });\n  }\n\n  #changeLanguage(language: string): void {\n    if (this.#language !== language) {\n      this.#language = language;\n      this.#i18n.changeLanguage(language);\n      this.#languageChangeListeners.forEach(listener => listener());\n    }\n  }\n\n  #createSnapshot<TMessages extends { [key in string]: string }>(\n    internalRef: InternalTranslationRef<string, TMessages>,\n  ): TranslationSnapshot<TMessages> {\n    if (this.#loader.needsLoading(this.#language, internalRef.id)) {\n      return { ready: false };\n    }\n\n    const unwrappedT = this.#i18n.getFixedT(null, internalRef.id);\n    const t = this.#jsxInterpolator.wrapT<TMessages>(unwrappedT);\n\n    return {\n      ready: true,\n      t,\n    };\n  }\n\n  #registerDefaults(internalRef: InternalTranslationRef): void {\n    if (this.#registeredRefs.has(internalRef.id)) {\n      return;\n    }\n    this.#registeredRefs.add(internalRef.id);\n\n    const defaultMessages = internalRef.getDefaultMessages();\n    this.#i18n.addResourceBundle(\n      DEFAULT_LANGUAGE,\n      internalRef.id,\n      defaultMessages,\n      true, // merge with existing translations\n      false, // do not overwrite translations\n    );\n\n    const defaultResource = internalRef.getDefaultResource();\n    if (defaultResource) {\n      this.#loader.addTranslationResource(defaultResource);\n    }\n  }\n}\n"],"names":[],"mappings":";;;;;AAqJO,MAAM,eAAA,CAAgB;AAAA,EAClB,cAAA;AAAA,EACA,OAAA;AAAA,EACA,QAAA;AAAA,EAET,OAAO,SAAS,IAAA,EAAY;AAC1B,IAAA,MAAM,YAAA,GAAe,KAAK,QAAA,CAAS,YAAA;AAGnC,IAAA,MAAM,iBAAiB,YAAA,CAAa,MAAA;AAEpC,IAAA,IAAI,UAAA;AAKJ,IAAA,YAAA,CAAa,MAAA,GAAS,CAAC,KAAA,EAAO,MAAA,EAAQ,KAAK,UAAA,KAAe;AACxD,MAAA,IAAI,MAAA,EAAQ;AACV,QAAA,OAAO,cAAA,CAAe,KAAA,EAAO,MAAA,EAAQ,GAAA,EAAK,UAAU,CAAA;AAAA,MACtD;AACA,MAAA,OAAO,UAAA,GAAa,KAAA,EAAO,MAAA,EAAQ,GAAA,EAAK,UAAU,CAAA,IAAK,KAAA;AAAA,IACzD,CAAA;AAEA,IAAA,OAAO,IAAI,eAAA;AAAA;AAAA,MAET,IAAA,CAAK,QAAO,CAAE,QAAA,CAAS,EAAE,CAAA,CAAE,SAAA,CAAU,GAAG,CAAC,CAAA;AAAA,MACzC,CAAA,IAAA,KAAQ;AACN,QAAA,UAAA,GAAa,IAAA;AAAA,MACf;AAAA,KACF;AAAA,EACF;AAAA,EAEQ,WAAA,CACN,QACA,aAAA,EACA;AACA,IAAA,IAAA,CAAK,cAAA,GAAiB,aAAA;AACtB,IAAA,IAAA,CAAK,OAAA,GAAU,MAAA;AACf,IAAA,IAAA,CAAK,QAAA,GAAW,IAAI,MAAA,CAAO,CAAA,GAAA,EAAM,MAAM,CAAA,aAAA,CAAe,CAAA;AAAA,EACxD;AAAA,EAEA,MACE,SAAA,EACgC;AAChC,IAAA,OAAQ,CAAC,KAAK,OAAA,KAAY;AACxB,MAAA,IAAI,WAAA,GAAkD,MAAA;AAMtD,MAAA,IAAA,CAAK,eAAe,CAAA,KAAA,KAAS;AAC3B,QAAA,IAAI,cAAA,CAAe,KAAK,CAAA,EAAG;AACzB,UAAA,IAAI,CAAC,WAAA,EAAa;AAChB,YAAA,WAAA,uBAAkB,GAAA,EAAI;AAAA,UACxB;AACA,UAAA,MAAM,UAAA,GAAa,WAAA,CAAY,IAAA,CAAK,QAAA,EAAS;AAC7C,UAAA,WAAA,CAAY,GAAA,CAAI,YAAY,KAAK,CAAA;AAEjC,UAAA,OAAO,CAAA,CAAA,EAAI,IAAA,CAAK,OAAO,CAAA,CAAA,EAAI,UAAU,CAAA,CAAA,CAAA;AAAA,QACvC;AACA,QAAA,OAAO,KAAA;AAAA,MACT,CAAC,CAAA;AAID,MAAA,MAAM,MAAA,GAAS,SAAA,CAAU,GAAA,EAAK,OAAc,CAAA;AAC5C,MAAA,IAAI,CAAC,WAAA,EAAa;AAChB,QAAA,OAAO,MAAA;AAAA,MACT;AAEA,MAAA,MAAM,KAAA,GAAQ,MAAA,CAAO,KAAA,CAAM,IAAA,CAAK,QAAQ,CAAA;AAExC,MAAA,OAAO,aAAA;AAAA,QACL,QAAA;AAAA,QACA,IAAA;AAAA,QACA,GAAG,KAAA,CACA,GAAA,CAAI,CAAC,MAAM,KAAA,KAAU;AACpB,UAAA,IAAI,KAAA,GAAQ,MAAM,CAAA,EAAG;AACnB,YAAA,OAAO,IAAA;AAAA,UACT;AACA,UAAA,OAAO,WAAA,EAAa,IAAI,IAAI,CAAA;AAAA,QAC9B,CAAC,CAAA,CACA,MAAA,CAAO,OAAO;AAAA,OACnB;AAAA,IACF,CAAA;AAAA,EACF;AACF;;;;"}