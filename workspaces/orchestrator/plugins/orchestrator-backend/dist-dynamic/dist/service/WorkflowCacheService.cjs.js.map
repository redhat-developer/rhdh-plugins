{"version":3,"file":"WorkflowCacheService.cjs.js","sources":["../../src/service/WorkflowCacheService.ts"],"sourcesContent":["/*\n * Copyright Red Hat, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { LoggerService } from '@backstage/backend-plugin-api';\nimport { PluginTaskScheduler } from '@backstage/backend-tasks';\n\nimport { DataIndexService } from './DataIndexService';\nimport { SonataFlowService } from './SonataFlowService';\n\nexport type CacheHandler = 'skip' | 'throw';\n\nexport class WorkflowCacheService {\n  private readonly TASK_ID = 'task__Orchestrator__WorkflowCacheService';\n  private readonly DEFAULT_FREQUENCY_IN_SECONDS = 5;\n  private readonly DEFAULT_TIMEOUT_IN_MINUTES = 10;\n  private readonly definitionIdCache = new Set<string>();\n  private readonly unavailableDefinitionIdCache = new Set<string>();\n\n  constructor(\n    private readonly logger: LoggerService,\n    private readonly dataIndexService: DataIndexService,\n    private readonly sonataFlowService: SonataFlowService,\n  ) {}\n\n  public get definitionIds(): string[] {\n    return Array.from(this.definitionIdCache);\n  }\n\n  public get unavailableDefinitionIds(): string[] {\n    return Array.from(this.unavailableDefinitionIdCache);\n  }\n\n  private isEmpty(): boolean {\n    return (\n      this.definitionIdCache.size === 0 &&\n      this.unavailableDefinitionIdCache.size === 0\n    );\n  }\n\n  public isAvailable(\n    definitionId?: string,\n    cacheHandler: CacheHandler = 'skip',\n  ): boolean {\n    if (!definitionId) {\n      return false;\n    }\n    const isAvailable = this.definitionIdCache.has(definitionId);\n    if (!isAvailable && cacheHandler === 'throw') {\n      throw new Error(\n        `Workflow service \"${definitionId}\" not available at the moment`,\n      );\n    }\n    return isAvailable;\n  }\n\n  public schedule(args: {\n    scheduler: PluginTaskScheduler;\n    frequencyInSeconds?: number;\n    timeoutInMinutes?: number;\n  }): void {\n    const {\n      scheduler,\n      frequencyInSeconds = this.DEFAULT_FREQUENCY_IN_SECONDS,\n      timeoutInMinutes = this.DEFAULT_TIMEOUT_IN_MINUTES,\n    } = args;\n\n    scheduler.scheduleTask({\n      id: this.TASK_ID,\n      frequency: { seconds: frequencyInSeconds },\n      timeout: { minutes: timeoutInMinutes },\n      fn: async () => {\n        await this.runTask();\n      },\n    });\n  }\n\n  private async runTask() {\n    try {\n      const idUrlMap = await this.dataIndexService.fetchWorkflowServiceUrls();\n      this.definitionIdCache.forEach(definitionId => {\n        if (!idUrlMap[definitionId]) {\n          this.definitionIdCache.delete(definitionId);\n        }\n      });\n      this.unavailableDefinitionIdCache.forEach(definitionId => {\n        if (!idUrlMap[definitionId]) {\n          this.unavailableDefinitionIdCache.delete(definitionId);\n        }\n      });\n      await Promise.all(\n        Object.entries(idUrlMap).map(async ([definitionId, serviceUrl]) => {\n          let isServiceUp = false;\n          try {\n            isServiceUp = await this.sonataFlowService.pingWorkflowService({\n              definitionId,\n              serviceUrl,\n            });\n          } catch (err) {\n            this.logger.error(\n              `Ping workflow ${definitionId} service threw error: ${err}`,\n            );\n          }\n          if (isServiceUp) {\n            this.definitionIdCache.add(definitionId);\n            this.unavailableDefinitionIdCache.delete(definitionId);\n          } else {\n            this.logger.error(\n              `Failed to ping service for workflow ${definitionId} at ${serviceUrl}`,\n            );\n            if (this.definitionIdCache.has(definitionId)) {\n              this.definitionIdCache.delete(definitionId);\n            }\n            this.unavailableDefinitionIdCache.add(definitionId);\n          }\n        }),\n      );\n\n      const workflowDefinitionIds = this.isEmpty()\n        ? 'empty cache'\n        : Array.from(this.definitionIdCache)\n            .concat(Array.from(this.unavailableDefinitionIdCache))\n            .join(', ');\n\n      this.logger.debug(\n        `${this.TASK_ID} updated the workflow definition ID cache to: ${workflowDefinitionIds}`,\n      );\n    } catch (error) {\n      this.logger.error(`Error running ${this.TASK_ID}: ${error}`);\n      return;\n    }\n  }\n}\n"],"names":[],"mappings":"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"}