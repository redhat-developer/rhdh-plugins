{"version":3,"file":"Helper.cjs.js","sources":["../../src/service/Helper.ts"],"sourcesContent":["/*\n * Copyright 2024 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { LoggerService } from '@backstage/backend-plugin-api';\nimport type { Config } from '@backstage/config';\n\nimport fs from 'fs-extra';\n\nimport os from 'os';\n\nexport async function retryAsyncFunction<T>(args: {\n  asyncFn: () => Promise<T | undefined>;\n  maxAttempts: number;\n  delayMs: number;\n}): Promise<T> {\n  let result: T | undefined;\n  for (let i = 0; i < args.maxAttempts; i++) {\n    result = await args.asyncFn();\n    if (result !== undefined) {\n      return result;\n    }\n    await new Promise(resolve => setTimeout(resolve, args.delayMs));\n  }\n  throw new Error('Exceeded maximum number of retries for async function');\n}\n\nexport async function getWorkingDirectory(\n  config: Config,\n  logger: LoggerService,\n): Promise<string> {\n  if (!config.has('backend.workingDirectory')) {\n    return os.tmpdir();\n  }\n\n  const workingDirectory = config.getString('backend.workingDirectory');\n  try {\n    // Check if working directory exists and is writable\n    await fs.access(workingDirectory, fs.constants.F_OK | fs.constants.W_OK);\n    logger.info(`using working directory: ${workingDirectory}`);\n  } catch (err: any) {\n    logger.error(\n      `working directory ${workingDirectory} ${\n        err.code === 'ENOENT' ? 'does not exist' : 'is not writable'\n      }`,\n    );\n    throw err;\n  }\n  return workingDirectory;\n}\n\nexport async function executeWithRetry(\n  action: () => Promise<Response>,\n  maxErrors = 15,\n): Promise<Response> {\n  let response: Response;\n  let errorCount = 0;\n  // execute with retry\n  const backoff = 5000;\n  while (errorCount < maxErrors) {\n    try {\n      response = await action();\n      if (response.status >= 400) {\n        errorCount++;\n        // backoff\n        await delay(backoff);\n      } else {\n        return response;\n      }\n    } catch (e) {\n      errorCount++;\n      await delay(backoff);\n    }\n  }\n  throw new Error('Unable to execute query.');\n}\n\nexport function delay(time: number) {\n  return new Promise(r => setTimeout(r, time));\n}\n"],"names":[],"mappings":";;;;;AAsBA,eAAsB,mBAAsB,IAAA,EAI7B;AACb,EAAA,IAAI,MAAA;AACJ,EAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,IAAA,CAAK,aAAa,CAAA,EAAA,EAAK;AACzC,IAAA,MAAA,GAAS,MAAM,KAAK,OAAA,EAAQ;AAC5B,IAAA,IAAI,WAAW,MAAA,EAAW;AACxB,MAAA,OAAO,MAAA;AAAA,IACT;AACA,IAAA,MAAM,IAAI,OAAA,CAAQ,CAAA,OAAA,KAAW,WAAW,OAAA,EAAS,IAAA,CAAK,OAAO,CAAC,CAAA;AAAA,EAChE;AACA,EAAA,MAAM,IAAI,MAAM,uDAAuD,CAAA;AACzE;AA0BA,eAAsB,gBAAA,CACpB,MAAA,EACA,SAAA,GAAY,EAAA,EACO;AACnB,EAAA,IAAI,QAAA;AACJ,EAAA,IAAI,UAAA,GAAa,CAAA;AAEjB,EAAA,MAAM,OAAA,GAAU,GAAA;AAChB,EAAA,OAAO,aAAa,SAAA,EAAW;AAC7B,IAAA,IAAI;AACF,MAAA,QAAA,GAAW,MAAM,MAAA,EAAO;AACxB,MAAA,IAAI,QAAA,CAAS,UAAU,GAAA,EAAK;AAC1B,QAAA,UAAA,EAAA;AAEA,QAAA,MAAM,MAAM,OAAO,CAAA;AAAA,MACrB,CAAA,MAAO;AACL,QAAA,OAAO,QAAA;AAAA,MACT;AAAA,IACF,SAAS,CAAA,EAAG;AACV,MAAA,UAAA,EAAA;AACA,MAAA,MAAM,MAAM,OAAO,CAAA;AAAA,IACrB;AAAA,EACF;AACA,EAAA,MAAM,IAAI,MAAM,0BAA0B,CAAA;AAC5C;AAEO,SAAS,MAAM,IAAA,EAAc;AAClC,EAAA,OAAO,IAAI,OAAA,CAAQ,CAAA,CAAA,KAAK,UAAA,CAAW,CAAA,EAAG,IAAI,CAAC,CAAA;AAC7C;;;;;;"}