import EventEmitter from 'events';
import Keyv, { KeyvStoreAdapter, StoredData } from 'keyv';
import { Redis, Cluster } from 'iovalkey';

type KeyvValkeyOptions = {
    [K in keyof Redis]?: Redis[K];
} & {
    uri?: string;
    dialect?: string;
    useRedisSets?: boolean;
};
type KeyvUriOptions = string | KeyvValkeyOptions | Redis | Cluster;

declare class KeyvValkey extends EventEmitter implements KeyvStoreAdapter {
    ttlSupport: boolean;
    namespace?: string;
    opts: Record<string, unknown>;
    redis: any;
    constructor(uri: KeyvValkeyOptions | KeyvUriOptions, options?: KeyvValkeyOptions);
    _getNamespace(): string;
    _getKeyName: (key: string) => string;
    get<Value>(key: string): Promise<StoredData<Value> | undefined>;
    getMany<Value>(keys: string[]): Promise<Array<StoredData<Value | undefined>>>;
    set(key: string, value: any, ttl?: number): Promise<undefined>;
    delete(key: string): Promise<boolean>;
    deleteMany(keys: string[]): Promise<boolean>;
    clear(): Promise<void>;
    iterator(namespace?: string): AsyncGenerator<any[], void, unknown>;
    has(key: string): Promise<boolean>;
    disconnect(): Promise<any>;
}
/**
 * Will create a Keyv instance with the Valkey adapter.
 * @param {KeyvValkeyOptions | KeyvUriOptions} connect - How to connect to the Valkey server. If string pass in the url, if object pass in the options.
 * @param {KeyvValkeyOptions} options - Options for the adapter such as namespace, keyPrefixSeparator, and clearBatchSize.
 * @returns {Keyv} - Keyv instance with the Redis adapter
 */
declare function createKeyv(connect?: KeyvValkeyOptions | KeyvUriOptions, options?: KeyvValkeyOptions): Keyv;

export { type KeyvValkeyOptions, createKeyv, KeyvValkey as default };
