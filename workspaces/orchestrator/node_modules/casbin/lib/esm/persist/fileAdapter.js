import { Helper } from './helper';
import { arrayToString } from '../util';
import { mustGetDefaultFileSystem } from './fileSystem';
/**
 * FileAdapter is the file adapter for Casbin.
 * It can load policy from file or save policy to file.
 */
export class FileAdapter {
    /**
     * FileAdapter is the constructor for FileAdapter.
     *
     * @param filePath filePath the path of the policy file.
     * @param fs {@link FileSystem}
     */
    constructor(filePath, fs) {
        this.filePath = filePath;
        this.fs = fs;
    }
    async loadPolicy(model) {
        if (!this.filePath) {
            // throw new Error('invalid file path, file path cannot be empty');
            return;
        }
        await this.loadPolicyFile(model, Helper.loadPolicyLine);
    }
    async loadPolicyFile(model, handler) {
        const bodyBuf = await (this.fs ? this.fs : mustGetDefaultFileSystem()).readFileSync(this.filePath);
        const lines = bodyBuf.toString().split('\n');
        lines.forEach((line) => {
            if (!line || line.trim().startsWith('#')) {
                return;
            }
            handler(line, model);
        });
    }
    /**
     * savePolicy saves all policy rules to the storage.
     */
    async savePolicy(model) {
        if (!this.filePath) {
            // throw new Error('invalid file path, file path cannot be empty');
            return false;
        }
        let result = '';
        const pList = model.model.get('p');
        if (!pList) {
            return false;
        }
        pList.forEach((n) => {
            n.policy.forEach((m) => {
                result += n.key + ', ';
                result += arrayToString(m);
                result += '\n';
            });
        });
        const gList = model.model.get('g');
        if (!gList) {
            return false;
        }
        gList.forEach((n) => {
            n.policy.forEach((m) => {
                result += n.key + ', ';
                result += arrayToString(m.map((element) => this.escapeCsv(element)));
                result += '\n';
            });
        });
        await this.savePolicyFile(result.trim());
        return true;
    }
    escapeCsv(value) {
        // If the value contains a comma, wrap it in double quotes and escape any existing double quotes
        if (value.includes(',')) {
            return `"${value.replace(/"/g, '""')}"`;
        }
        return value;
    }
    async savePolicyFile(text) {
        (this.fs ? this.fs : mustGetDefaultFileSystem()).writeFileSync(this.filePath, text);
    }
    /**
     * addPolicy adds a policy rule to the storage.
     */
    async addPolicy(sec, ptype, rule) {
        throw new Error('not implemented');
    }
    /**
     * addPolicies adds policy rules to the storage.
     This is part of the Auto-Save feature.
     */
    async addPolicies(sec, ptype, rules) {
        throw new Error('not implemented');
    }
    /**
     * UpdatePolicy updates a policy rule from storage.
     * This is part of the Auto-Save feature.
     */
    updatePolicy(sec, ptype, oldRule, newRule) {
        throw new Error('not implemented');
    }
    /**
     * removePolicy removes a policy rule from the storage.
     */
    async removePolicy(sec, ptype, rule) {
        throw new Error('not implemented');
    }
    /**
     * removePolicies removes policy rules from the storage.
     * This is part of the Auto-Save feature.
     */
    async removePolicies(sec, ptype, rules) {
        throw new Error('not implemented');
    }
    /**
     * removeFilteredPolicy removes policy rules that match the filter from the storage.
     */
    async removeFilteredPolicy(sec, ptype, fieldIndex, ...fieldValues) {
        throw new Error('not implemented');
    }
}
