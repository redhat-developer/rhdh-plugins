import * as rbac from '../rbac';
import { ConfigInterface } from '../config';
import { Assertion } from './assertion';
import { FileSystem } from '../persist/fileSystem';
export declare const sectionNameMap: {
    [index: string]: string;
};
export declare enum PolicyOp {
    PolicyAdd = 0,
    PolicyRemove = 1
}
export declare const requiredSections: string[];
export declare class Model {
    model: Map<string, Map<string, Assertion>>;
    /**
     * constructor is the constructor for Model.
     */
    constructor();
    private loadAssertion;
    private getKeySuffix;
    private loadSection;
    addDef(sec: string, key: string, value: string): boolean;
    /**
     * loadModel loads the model from model CONF file.
     * @param path the model file path
     * @param fs {@link FileSystem}
     * @deprecated {@link loadModelFromFile}
     */
    loadModel(path: string, fs?: FileSystem): void;
    /**
     * loadModelFromFile loads the model from model CONF file.
     * @param path the model file path
     * @param fs {@link FileSystem}
     */
    loadModelFromFile(path: string, fs?: FileSystem): void;
    loadModelFromText(text: string): void;
    loadModelFromConfig(cfg: ConfigInterface): void;
    private hasSection;
    printModel(): void;
    buildIncrementalRoleLinks(rm: rbac.RoleManager, op: PolicyOp, sec: string, ptype: string, rules: string[][]): Promise<void>;
    buildRoleLinks(rmMap: Map<string, rbac.RoleManager>): Promise<void>;
    clearPolicy(): void;
    getPolicy(sec: string, key: string): string[][];
    hasPolicy(sec: string, key: string, rule: string[]): boolean;
    addPolicy(sec: string, key: string, rule: string[]): boolean;
    addPolicies(sec: string, ptype: string, rules: string[][]): [boolean, string[][]];
    updatePolicy(sec: string, ptype: string, oldRule: string[], newRule: string[]): boolean;
    removePolicy(sec: string, key: string, rule: string[]): boolean;
    removePolicies(sec: string, ptype: string, rules: string[][]): [boolean, string[][]];
    getFilteredPolicy(sec: string, key: string, fieldIndex: number, ...fieldValues: string[]): string[][];
    removeFilteredPolicy(sec: string, key: string, fieldIndex: number, ...fieldValues: string[]): [boolean, string[][]];
    getValuesForFieldInPolicy(sec: string, key: string, fieldIndex: number): string[];
    getValuesForFieldInPolicyAllTypes(sec: string, fieldIndex: number): string[];
    printPolicy(): void;
    /**
     * return the field index in fieldMap, if no this field in fieldMap, add it.
     */
    getFieldIndex(ptype: string, field: string): number;
    /**
     * sort policies by subject hieraichy
     */
    sortPoliciesBySubjectHierarchy(): void;
    /**
     * Calculate the priority of each policy store in Map<string, number>
     */
    getSubjectHierarchyMap(groupPolicies: string[][]): Map<string, number>;
    findHierarchy(policyMap: Map<string, string>, subjectHierarchyMap: Map<string, number>, set: Set<string>, child: string): void;
    /**
     * get full name with domain
     */
    getNameWithDomain(domain: string, name: string): string;
}
/**
 * newModel creates a model.
 */
export declare function newModel(...text: string[]): Model;
/**
 * newModelFromFile creates a model from a .CONF file.
 */
export declare function newModelFromFile(path: string, fs?: FileSystem): Model;
/**
 * newModelFromString creates a model from a string which contains model text.
 */
export declare function newModelFromString(text: string): Model;
