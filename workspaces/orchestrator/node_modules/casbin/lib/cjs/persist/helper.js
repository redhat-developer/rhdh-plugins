"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Helper = exports.PolicyLoader = exports.BracketAwareCsvParser = exports.BasicCsvParser = void 0;
const sync_1 = require("csv-parse/sync");
class BasicCsvParser {
    parse(line) {
        if (!line || line.trimStart().charAt(0) === '#') {
            return null;
        }
        return sync_1.parse(line, {
            delimiter: ',',
            skip_empty_lines: true,
            trim: true,
            relax_quotes: true,
        });
    }
}
exports.BasicCsvParser = BasicCsvParser;
class BracketAwareCsvParser {
    constructor(baseParser = new BasicCsvParser()) {
        this.baseParser = baseParser;
    }
    parse(line) {
        const rawTokens = this.baseParser.parse(line);
        if (!rawTokens || !rawTokens[0]) {
            return null;
        }
        const tokens = rawTokens[0];
        const processedTokens = [];
        let currentToken = '';
        let bracketCount = 0;
        for (const token of tokens) {
            for (const char of token) {
                if (char === '(')
                    bracketCount++;
                else if (char === ')')
                    bracketCount--;
            }
            currentToken += (currentToken ? ',' : '') + token;
            if (bracketCount === 0) {
                processedTokens.push(currentToken);
                currentToken = '';
            }
        }
        if (bracketCount !== 0) {
            throw new Error(`Unmatched brackets in policy line: ${line}`);
        }
        return processedTokens.length > 0 ? [processedTokens] : null;
    }
}
exports.BracketAwareCsvParser = BracketAwareCsvParser;
class PolicyLoader {
    constructor(parser = new BracketAwareCsvParser()) {
        this.parser = parser;
    }
    loadPolicyLine(line, model) {
        const tokens = this.parser.parse(line);
        if (!tokens || !tokens[0]) {
            return;
        }
        let key = tokens[0][0].trim();
        if (key.startsWith('"') && key.endsWith('"')) {
            key = key.slice(1, -1);
        }
        const sec = key.substring(0, 1);
        const item = model.model.get(sec);
        if (!item) {
            return;
        }
        const policy = item.get(key);
        if (!policy) {
            return;
        }
        const values = tokens[0].slice(1).map((v) => {
            if (v.startsWith('"') && v.endsWith('"')) {
                v = v.slice(1, -1);
            }
            return v.replace(/""/g, '"').trim();
        });
        policy.policy.push(values);
    }
}
exports.PolicyLoader = PolicyLoader;
class Helper {
    static loadPolicyLine(line, model) {
        Helper.policyLoader.loadPolicyLine(line, model);
    }
}
exports.Helper = Helper;
Helper.policyLoader = new PolicyLoader();
