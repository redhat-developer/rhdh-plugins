'use strict';

var lodash = require('lodash');

class DefaultAuditLogger {
  logger;
  authService;
  httpAuthService;
  constructor(options) {
    this.logger = options.logger;
    this.authService = options.authService;
    this.httpAuthService = options.httpAuthService;
  }
  async getActorId(request) {
    if (!(request && this.httpAuthService && this.authService)) {
      return void 0;
    }
    try {
      const credentials = await this.httpAuthService.credentials(request);
      const userEntityRef = this.authService.isPrincipal(credentials, "user") ? credentials.principal.userEntityRef : void 0;
      const serviceEntityRef = this.authService.isPrincipal(
        credentials,
        "service"
      ) ? credentials.principal.subject : void 0;
      return userEntityRef ?? serviceEntityRef;
    } catch {
      return void 0;
    }
  }
  async createAuditLogDetails(options) {
    const { eventName, stage, metadata, request, response, status } = options;
    const actorId = options.actorId || await this.getActorId(request) || null;
    const auditRequest = request ? {
      method: request.method,
      url: request.originalUrl,
      params: lodash.cloneDeep(request.params),
      query: lodash.cloneDeep(request.query),
      body: lodash.cloneDeep(request.body)
    } : void 0;
    const actor = { actorId };
    if (request) {
      actor.ip = request.ip;
      actor.hostname = request.hostname;
      actor.userAgent = request.get("user-agent");
    }
    const auditLogCommonDetails = {
      actor: lodash.cloneDeep(actor),
      meta: lodash.cloneDeep(metadata) || {},
      request: auditRequest,
      isAuditLog: true,
      response: lodash.cloneDeep(response),
      eventName,
      stage
    };
    if (status === "failed") {
      const errs = lodash.cloneDeep(options.errors);
      return {
        ...auditLogCommonDetails,
        status,
        errors: errs.map((err) => {
          return {
            name: err.name,
            message: err.message,
            stack: err.stack
          };
        })
      };
    }
    return {
      ...auditLogCommonDetails,
      status
    };
  }
  async auditLog(options) {
    let auditLogDetails;
    const logLevel = options.level || "info";
    const auditLogCommonDetails = {
      eventName: options.eventName,
      stage: options.stage,
      actorId: options.actorId,
      request: options.request,
      response: options.response,
      metadata: options.metadata
    };
    if (options.status === "failed") {
      auditLogDetails = await this.createAuditLogDetails({
        ...auditLogCommonDetails,
        status: options.status,
        errors: options.errors
      });
    } else {
      auditLogDetails = await this.createAuditLogDetails({
        ...auditLogCommonDetails,
        status: options.status
      });
    }
    switch (logLevel) {
      case "info":
        this.logger.info(options.message, auditLogDetails);
        return;
      case "debug":
        this.logger.debug(options.message, auditLogDetails);
        return;
      case "warn":
        this.logger.warn(options.message, auditLogDetails);
        return;
      case "error":
        this.logger.error(options.message, auditLogDetails);
        return;
      default:
        throw new Error(`Log level of ${logLevel} is not supported`);
    }
  }
}

exports.DefaultAuditLogger = DefaultAuditLogger;
//# sourceMappingURL=DefaultAuditLogger.cjs.js.map
