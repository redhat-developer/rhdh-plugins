'use strict';

var cliNode = require('@backstage/cli-node');
var chalk = require('chalk');
var fs = require('fs-extra');
var semver = require('semver');
var path = require('path');
var paths = require('../../lib/paths.cjs.js');
var collect = require('../../lib/schema/collect.cjs.js');
var tasks = require('../../lib/tasks.cjs.js');
var backend = require('./backend.cjs.js');
var dev = require('./dev.cjs.js');
var frontend = require('./frontend.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

function _interopNamespaceCompat(e) {
  if (e && typeof e === 'object' && 'default' in e) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var chalk__default = /*#__PURE__*/_interopDefaultCompat(chalk);
var fs__default = /*#__PURE__*/_interopDefaultCompat(fs);
var semver__namespace = /*#__PURE__*/_interopNamespaceCompat(semver);
var path__default = /*#__PURE__*/_interopDefaultCompat(path);

async function command(opts) {
  const rawPkg = await fs__default.default.readJson(paths.paths.resolveTarget("package.json"));
  const role = cliNode.PackageRoles.getRoleFromPackage(rawPkg);
  if (!role) {
    throw new Error(`Target package must have 'backstage.role' set`);
  }
  let targetPath;
  const roleInfo = cliNode.PackageRoles.getRoleInfo(role);
  let configSchemaPaths;
  if (role === "backend-plugin" || role === "backend-plugin-module") {
    targetPath = await backend.backend(opts);
    configSchemaPaths = [
      path__default.default.join(targetPath, "dist/configSchema.json"),
      path__default.default.join(targetPath, "dist/.config-schema.json")
    ];
  } else if (role === "frontend-plugin" || role === "frontend-plugin-module") {
    targetPath = await frontend.frontend(roleInfo, opts);
    configSchemaPaths = [
      path__default.default.join(targetPath, "dist-scalprum/configSchema.json")
    ];
  } else {
    throw new Error(
      'Only packages with the "backend-plugin", "backend-plugin-module" or "frontend-plugin" roles can be exported as dynamic backend plugins'
    );
  }
  tasks.Task.log(
    `Saving self-contained config schema in ${chalk__default.default.cyan(configSchemaPaths.join(" and "))}`
  );
  const configSchema = await collect.getConfigSchema(rawPkg.name);
  for (const configSchemaPath of configSchemaPaths) {
    await fs__default.default.writeJson(paths.paths.resolveTarget(configSchemaPath), configSchema, {
      encoding: "utf8",
      spaces: 2
    });
  }
  await checkBackstageSupportedVersions(targetPath);
  await dev.applyDevOptions(opts, rawPkg.name, roleInfo, targetPath);
}
async function checkBackstageSupportedVersions(targetPath) {
  const targetPackageFile = path__default.default.join(targetPath, "package.json");
  const targetPackage = await fs__default.default.readJSON(targetPackageFile);
  const supportedVersions = targetPackage.backstage?.["supported-versions"];
  const backstageJson = path__default.default.join(paths.paths.targetRoot, "/backstage.json");
  if (!fs__default.default.existsSync(backstageJson)) {
    return;
  }
  const backstageVersion = (await fs__default.default.readJSON(backstageJson)).version;
  if (supportedVersions) {
    const singleVersionInSupportedVersions = semver__namespace.valid(
      supportedVersions,
      true
    );
    const supportedVersionsRange = singleVersionInSupportedVersions ? `~${supportedVersions}` : supportedVersions;
    if (semver__namespace.subset(`~${backstageVersion}`, supportedVersionsRange)) {
      return;
    }
    const errorMessage = `The ${chalk__default.default.cyan("backstage.supported-versions")} field in the package descriptor is not compatible with the backstage version specified in the ${chalk__default.default.cyan("backstage.json")} file: ${chalk__default.default.cyan(supportedVersions)} vs ${chalk__default.default.cyan(backstageVersion)}.`;
    if (!singleVersionInSupportedVersions) {
      throw new Error(errorMessage);
    }
    tasks.Task.log(
      chalk__default.default.yellow(
        `${errorMessage}
Overriding it with ${chalk__default.default.cyan(backstageVersion)}.`
      )
    );
  } else {
    tasks.Task.log(
      `Filling ${chalk__default.default.cyan("supported-versions")} with ${chalk__default.default.cyan(backstageVersion)}.`
    );
  }
  targetPackage.backstage["supported-versions"] = backstageVersion;
  await fs__default.default.writeJSON(targetPackageFile, targetPackage, {
    spaces: 2
  });
}

exports.command = command;
//# sourceMappingURL=command.cjs.js.map
