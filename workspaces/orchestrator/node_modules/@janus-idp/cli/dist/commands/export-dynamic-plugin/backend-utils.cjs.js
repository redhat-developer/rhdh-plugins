'use strict';

var fs = require('fs-extra');
var isNative = require('is-native-module');
var semver = require('semver');
var path = require('path');
var tasks = require('../../lib/tasks.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

function _interopNamespaceCompat(e) {
  if (e && typeof e === 'object' && 'default' in e) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var fs__namespace = /*#__PURE__*/_interopNamespaceCompat(fs);
var isNative__default = /*#__PURE__*/_interopDefaultCompat(isNative);
var semver__default = /*#__PURE__*/_interopDefaultCompat(semver);
var path__default = /*#__PURE__*/_interopDefaultCompat(path);

function addToDependenciesForModule({
  dependency,
  dependencies,
  ignoreVersionCheck = [],
  module
}) {
  const existingDependencyVersion = dependencies[dependency.name];
  if (existingDependencyVersion === undefined) {
    dependencies[dependency.name] = dependency.version;
    return;
  }
  if (existingDependencyVersion === dependency.version) {
    return;
  }
  const existingDependencyMinVersion = semver__default.default.minVersion(
    existingDependencyVersion
  );
  if (existingDependencyMinVersion && semver__default.default.satisfies(existingDependencyMinVersion, dependency.version)) {
    tasks.Task.log(
      `Several compatible versions ('${existingDependencyVersion}', '${dependency.version}') of the same transitive dependency ('${dependency.name}') for embedded module ('${module}'): keeping '${existingDependencyVersion}'`
    );
    return;
  }
  const newDependencyMinVersion = semver__default.default.minVersion(dependency.version);
  if (newDependencyMinVersion && semver__default.default.satisfies(newDependencyMinVersion, existingDependencyVersion)) {
    dependencies[dependency.name] = dependency.version;
    tasks.Task.log(
      `Several compatible versions ('${existingDependencyVersion}', '${dependency.version}') of the same transitive dependency ('${dependency.name}') for embedded module ('${module}'): keeping '${dependency.version}'`
    );
    return;
  }
  if (!ignoreVersionCheck.includes(dependency.name)) {
    throw new Error(
      `Several incompatible versions ('${existingDependencyVersion}', '${dependency.version}') of the same transitive dependency ('${dependency.name}') for embedded module ('${module}')`
    );
  } else {
    tasks.Task.log(
      `Several incompatible versions ('${existingDependencyVersion}', '${dependency.version}') of the same transitive dependency ('${dependency.name}') for embedded module ('${module}') however this has been overridden to use '${dependency.version}'`
    );
  }
}
function addToMainDependencies(dependenciesToAdd, mainDependencies, ignoreVersionCheck = []) {
  for (const dep in dependenciesToAdd) {
    if (!Object.prototype.hasOwnProperty.call(dependenciesToAdd, dep)) {
      continue;
    }
    const existingVersion = mainDependencies[dep];
    if (existingVersion === undefined) {
      mainDependencies[dep] = dependenciesToAdd[dep];
      continue;
    }
    if (existingVersion !== dependenciesToAdd[dep]) {
      const existingMinVersion = semver__default.default.minVersion(existingVersion);
      if (existingMinVersion && semver__default.default.satisfies(existingMinVersion, dependenciesToAdd[dep])) {
        tasks.Task.log(
          `The version of a dependency ('${dep}') of an embedded module differs from the main module's dependencies: '${dependenciesToAdd[dep]}', '${existingVersion}': keeping it as it is compatible`
        );
        continue;
      }
      if (ignoreVersionCheck.includes(dep)) {
        tasks.Task.log(
          `The version of a dependency ('${dep}') of an embedded module conflicts with the main module's dependencies: '${dependenciesToAdd[dep]}', '${existingVersion}': however this has been overridden`
        );
      } else {
        throw new Error(
          `The version of a dependency ('${dep}') of an embedded module conflicts with main module dependencies: '${dependenciesToAdd[dep]}', '${existingVersion}': cannot proceed!`
        );
      }
    }
  }
}
function isValidPluginModule(pluginModule) {
  return isBackendFeature(pluginModule?.default) || isBackendFeatureFactory(pluginModule?.default) || isBackendDynamicPluginInstaller(pluginModule?.dynamicPluginInstaller);
}
function isBackendFeature(value) {
  return !!value && (typeof value === "object" || typeof value === "function") && value.$$type === "@backstage/BackendFeature";
}
function isBackendFeatureFactory(value) {
  return !!value && typeof value === "function" && value.$$type === "@backstage/BackendFeatureFactory";
}
function isBackendDynamicPluginInstaller(obj) {
  return obj !== undefined && typeof obj === "object" && obj !== null && "kind" in obj && obj.kind === "new" && "install" in obj && typeof obj.install === "function";
}
async function* gatherNativeModules(pkgPath) {
  if (await fs__namespace.pathExists(path__default.default.join(pkgPath, "package.json"))) {
    yield* async function* anaylzePackageJson() {
      const pkg = JSON.parse(
        (await fs__namespace.readFile(path__default.default.join(pkgPath, "package.json"))).toString(
          "utf8"
        )
      );
      if (isNative__default.default(pkg)) {
        yield pkg.name || pkgPath;
      }
    }();
    if (await fs__namespace.pathExists(path__default.default.join(pkgPath, "node_modules"))) {
      yield* gatherNativeModules(path__default.default.join(pkgPath, "node_modules"));
    }
  } else {
    for (const file of await fs__namespace.readdir(pkgPath)) {
      if ((await fs__namespace.stat(path__default.default.join(pkgPath, file))).isDirectory()) {
        yield* gatherNativeModules(path__default.default.join(pkgPath, file));
      }
    }
  }
}

exports.addToDependenciesForModule = addToDependenciesForModule;
exports.addToMainDependencies = addToMainDependencies;
exports.gatherNativeModules = gatherNativeModules;
exports.isValidPluginModule = isValidPluginModule;
//# sourceMappingURL=backend-utils.cjs.js.map
