'use strict';

var config = require('@backstage/config');
var configLoader = require('@backstage/config-loader');
var chalk = require('chalk');
var fs = require('fs-extra');
var path = require('path');
var paths = require('../../lib/paths.cjs.js');
var tasks = require('../../lib/tasks.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

function _interopNamespaceCompat(e) {
  if (e && typeof e === 'object' && 'default' in e) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var chalk__default = /*#__PURE__*/_interopDefaultCompat(chalk);
var fs__namespace = /*#__PURE__*/_interopNamespaceCompat(fs);
var path__default = /*#__PURE__*/_interopDefaultCompat(path);

async function applyDevOptions(opts, pkgName, role, target) {
  if (opts.dev) {
    if (role.platform === "node") {
      await fs__namespace.ensureSymlink(
        paths.paths.resolveTarget("src"),
        path__default.default.resolve(target, "src"),
        "dir"
      );
    }
    let dynamicPluginsRootPath = opts.dynamicPluginsRoot;
    let shouldSymlink = false;
    if (!dynamicPluginsRootPath) {
      shouldSymlink = true;
      const appConfigs = await configLoader.loadConfig({
        configRoot: paths.paths.targetRoot,
        configTargets: []
      });
      const fullConfig = config.ConfigReader.fromConfigs(appConfigs.appConfigs);
      const dynamicPlugins = fullConfig.getOptional("dynamicPlugins");
      if (typeof dynamicPlugins === "object" && dynamicPlugins !== null && "rootDirectory" in dynamicPlugins && typeof dynamicPlugins.rootDirectory === "string") {
        dynamicPluginsRootPath = path__default.default.isAbsolute(dynamicPlugins.rootDirectory) ? dynamicPlugins.rootDirectory : paths.paths.resolveTargetRoot(dynamicPlugins.rootDirectory);
      } else {
        throw new Error(
          `${chalk__default.default.cyan(
            "dynamicPlugins.rootDirectory"
          )} should be configured in the app config in order to use the ${chalk__default.default.cyan(
            "--dev"
          )} option`
        );
      }
    }
    const destFolderPath = path__default.default.resolve(
      dynamicPluginsRootPath,
      pkgName.replace(/^@/, "").replace(/\//, "-") + (role.platform === "node" ? "-dynamic" : "")
    );
    if (shouldSymlink) {
      tasks.Task.log(
        `Linking to the dynamic plugin folder in the dynamic plugins root: ${chalk__default.default.cyan(
          path__default.default.dirname(destFolderPath)
        )}`
      );
      fs__namespace.rmSync(destFolderPath, { force: true, recursive: true });
      await fs__namespace.ensureSymlink(target, destFolderPath, "dir");
    } else {
      tasks.Task.log(
        `Copying the dynamic plugin folder to the dynamic plugins root:  ${chalk__default.default.cyan(
          path__default.default.dirname(destFolderPath)
        )}`
      );
      if (!fs__namespace.existsSync(dynamicPluginsRootPath)) {
        await fs__namespace.mkdirs(dynamicPluginsRootPath);
        await fs__namespace.writeFile(
          path__default.default.resolve(dynamicPluginsRootPath, ".gitignore"),
          "*"
        );
      }
      fs__namespace.rmSync(destFolderPath, { force: true, recursive: true });
      fs__namespace.cpSync(target, destFolderPath, { recursive: true });
    }
  }
}

exports.applyDevOptions = applyDevOptions;
//# sourceMappingURL=dev.cjs.js.map
