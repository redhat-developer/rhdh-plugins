'use strict';

var cliNode = require('@backstage/cli-node');
var chalk = require('chalk');
var fs = require('fs-extra');
var YAML = require('yaml');
var os = require('os');
var path = require('path');
var paths = require('../../lib/paths.cjs.js');
var tasks = require('../../lib/tasks.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var chalk__default = /*#__PURE__*/_interopDefaultCompat(chalk);
var fs__default = /*#__PURE__*/_interopDefaultCompat(fs);
var YAML__default = /*#__PURE__*/_interopDefaultCompat(YAML);
var os__default = /*#__PURE__*/_interopDefaultCompat(os);
var path__default = /*#__PURE__*/_interopDefaultCompat(path);

async function command(opts) {
  const {
    exportTo,
    forceExport,
    preserveTempDir,
    tag,
    useDocker,
    containerTool = "podman",
    platform
  } = opts;
  if (!exportTo && !tag) {
    tasks.Task.error(
      `Neither ${chalk__default.default.white("--export-to")} or ${chalk__default.default.white("--tag")} was specified, either specify ${chalk__default.default.white("--export-to")} to export plugins to a directory or ${chalk__default.default.white("--tag")} to export plugins to a container image`
    );
    return;
  }
  let containerToolCmd = containerTool;
  if (!exportTo) {
    let _containerTool = containerTool;
    if (useDocker) {
      tasks.Task.log(
        `The ${chalk__default.default.white("--use-docker")} flag is deprecated, use ${chalk__default.default.white(
          "--container-tool"
        )} instead`
      );
      tasks.Task.log(
        `Setting ${chalk__default.default.white("--container-tool")} to docker as ${chalk__default.default.white(
          "--use-docker"
        )} was specified`
      );
      _containerTool = "docker";
    }
    const allowedTools = ["docker", "podman", "buildah"];
    if (!allowedTools.includes(_containerTool)) {
      tasks.Task.error(
        `Invalid value for --container-tool: ${_containerTool}. Allowed values are: ${allowedTools.join(", ")}`
      );
      return;
    }
    containerToolCmd = _containerTool;
    try {
      await tasks.Task.forCommand(`${containerToolCmd} --version`);
    } catch (e) {
      tasks.Task.error(
        `Unable to find ${containerToolCmd} command: ${e}
Make sure that ${containerToolCmd} is installed and available in your PATH.`
      );
      return;
    }
  }
  const workspacePackage = await fs__default.default.readJson(
    paths.paths.resolveTarget("package.json")
  );
  const workspacePackageRole = cliNode.PackageRoles.getRoleFromPackage(workspacePackage);
  const workspacePackageRoleInfo = workspacePackageRole !== undefined ? cliNode.PackageRoles.getRoleInfo(workspacePackageRole) : undefined;
  const isMonoRepo = typeof workspacePackage.workspaces !== "undefined";
  const packages = isMonoRepo ? await discoverPluginPackages() : [
    {
      packageDirectory: ".",
      packageFilePath: "package.json",
      packageJson: workspacePackage,
      packageRole: workspacePackageRole,
      packageRoleInfo: workspacePackageRoleInfo
    }
  ];
  for (const pluginPkg of packages) {
    const { packageDirectory, packageFilePath, packageJson } = pluginPkg;
    if (!fs__default.default.existsSync(path__default.default.join(packageDirectory, "dist-dynamic")) || forceExport) {
      if (Object.keys(packageJson.scripts).find(
        (script) => script === "export-dynamic"
      )) {
        tasks.Task.log(
          `Running existing export-dynamic script on plugin package ${packageFilePath}`
        );
        try {
          await tasks.Task.forCommand(`yarn export-dynamic`, {
            cwd: packageDirectory
          });
        } catch (err) {
          tasks.Task.log(
            `Encountered an error running 'yarn export-dynamic' on plugin package ${packageFilePath}, this plugin will not be packaged.  The error was ${err}`
          );
        }
      } else {
        tasks.Task.log(
          `Using generated command to export plugin package ${packageFilePath}`
        );
        try {
          await tasks.Task.forCommand(
            `${process.execPath} ${process.argv[1]} package export-dynamic-plugin`,
            { cwd: packageDirectory }
          );
        } catch (err) {
          tasks.Task.log(
            `Encountered an error running 'npx @janus-idp/cli' on plugin package ${packageFilePath}, this plugin will not be packaged.  The error was ${err}`
          );
        }
      }
    } else {
      tasks.Task.log(
        `Using existing 'dist-dynamic' directory at ${packageDirectory}`
      );
    }
  }
  const tmpDir = fs__default.default.mkdtempSync(
    path__default.default.join(os__default.default.tmpdir(), "package-dynamic-plugins")
  );
  const pluginRegistryMetadata = [];
  const pluginConfigs = {};
  try {
    for (const pluginPkg of packages) {
      const { packageDirectory, packageFilePath } = pluginPkg;
      const distDynamicDirectory = path__default.default.join(packageDirectory, "dist-dynamic");
      const pluginPackageJson = await fs__default.default.readJson(
        path__default.default.join(distDynamicDirectory, "package.json")
      );
      const packageName = pluginPackageJson.name.replace(/-dynamic$/, "").replace(/^@/, "").replace(/\//, "-");
      const targetDirectory = path__default.default.join(tmpDir, packageName);
      tasks.Task.log(`Copying '${distDynamicDirectory}' to '${targetDirectory}`);
      try {
        fs__default.default.cpSync(distDynamicDirectory, targetDirectory, {
          recursive: true,
          dereference: true
        });
        const {
          name,
          version,
          description,
          backstage,
          homepage,
          repository,
          license,
          maintainers,
          author,
          bugs,
          keywords
        } = pluginPackageJson;
        pluginRegistryMetadata.push({
          [packageName]: {
            name,
            version,
            description,
            backstage,
            homepage,
            repository,
            license,
            maintainers,
            author,
            bugs,
            keywords
          }
        });
        const pluginConfigPath = discoverPluginConfigurationFile(packageDirectory);
        if (typeof pluginConfigPath !== "undefined") {
          try {
            const pluginConfig = fs__default.default.readFileSync(pluginConfigPath);
            pluginConfigs[packageName] = YAML__default.default.parse(
              pluginConfig.toLocaleString()
            );
          } catch (err) {
            tasks.Task.log(
              `Encountered an error parsing configuration at ${pluginConfigPath}, no example configuration will be displayed. The error was ${err}`
            );
          }
        }
      } catch (err) {
        tasks.Task.log(
          `Encountered an error copying static assets for plugin ${packageFilePath}, the plugin will not be packaged. The error was ${err}`
        );
      }
    }
    const metadataFile = path__default.default.join(tmpDir, "index.json");
    tasks.Task.log(`Writing plugin registry metadata to '${metadataFile}'`);
    await fs__default.default.writeFile(
      metadataFile,
      JSON.stringify(pluginRegistryMetadata, void 0, 2)
    );
    if (exportTo) {
      fs__default.default.mkdirSync(exportTo, { recursive: true });
      tasks.Task.log(`Writing exported plugins to ${exportTo}`);
      fs__default.default.readdirSync(tmpDir).forEach((entry) => {
        const source = path__default.default.join(tmpDir, entry);
        const destination = path__default.default.join(exportTo, entry);
        fs__default.default.copySync(source, destination, { recursive: true, overwrite: true });
      });
    } else {
      const flags = [
        `--annotation io.backstage.dynamic-packages='${Buffer.from(JSON.stringify(pluginRegistryMetadata)).toString("base64")}'`
      ];
      if (platform) {
        flags.push(`--platform ${platform}`);
      }
      tasks.Task.log(`Creating image using ${containerToolCmd}`);
      const containerInput = `from scratch
COPY . .
`;
      const buildCmd = `echo "${containerInput}" | ${containerToolCmd} build ${flags.join(" ")} -t '${tag}' -f - .`;
      await tasks.Task.forCommand(buildCmd, { cwd: tmpDir });
      tasks.Task.log(`Successfully built image ${tag} with following plugins:`);
      for (const plugin of pluginRegistryMetadata) {
        tasks.Task.log(`  ${chalk__default.default.white(Object.keys(plugin)[0])}`);
      }
    }
    try {
      const configurationExample = YAML__default.default.stringify({
        plugins: pluginRegistryMetadata.map((plugin) => {
          const packageName = Object.keys(plugin)[0];
          const pluginConfig = pluginConfigs[packageName];
          const packageString = exportTo ? `./local-plugins/${packageName}` : `oci://${tag}!${packageName}`;
          return {
            package: packageString,
            disabled: false,
            ...pluginConfig ? { pluginConfig } : {}
          };
        })
      });
      tasks.Task.log(
        `
Here is an example dynamic-plugins.yaml for these plugins: 

${chalk__default.default.white(configurationExample)}

`
      );
    } catch (err) {
      tasks.Task.error(
        `An error occurred while creating configuration example: ${err}`
      );
    }
  } catch (e) {
    tasks.Task.error(`Error encountered while packaging dynamic plugins: ${e}`);
  } finally {
    try {
      if (tmpDir && !preserveTempDir) {
        fs__default.default.rmSync(tmpDir, { recursive: true });
      }
      if (preserveTempDir) {
        tasks.Task.log(`Keeping temporary directory ${tmpDir}`);
      }
    } catch (err) {
      tasks.Task.error(
        `An error occurred while removing the temporary staging directory: ${err}`
      );
    }
  }
  return;
}
async function discoverPluginPackages() {
  const packageJsonFilePaths = [];
  for (const file of discoverFiles(
    "plugins",
    ["package.json"],
    ["node_modules", "dist-dynamic"]
  )) {
    packageJsonFilePaths.push(file);
  }
  return (await Promise.all(
    packageJsonFilePaths.map(async (packageFilePath) => {
      const packageJson = await fs__default.default.readJson(packageFilePath);
      const packageRole = cliNode.PackageRoles.getRoleFromPackage(packageJson);
      const packageRoleInfo = cliNode.PackageRoles.getRoleInfo(packageRole ?? "");
      const packageDirectory = path__default.default.dirname(packageFilePath);
      return {
        packageDirectory,
        packageFilePath,
        packageJson,
        packageRole,
        packageRoleInfo
      };
    })
  )).filter((pkg) => {
    const { packageFilePath, packageRole } = pkg;
    switch (packageRole) {
      case "frontend-plugin":
      case "frontend-plugin-module":
      case "backend-plugin":
      case "backend-plugin-module":
        return true;
      default:
        tasks.Task.log(
          `Skipping package '${packageFilePath}' with unknown 'backstage.role': '${packageRole}'`
        );
        return false;
    }
  });
}
function discoverPluginConfigurationFile(directory) {
  const supportedFilenames = [
    "app-config.janus-idp.yaml",
    "app-config.backstage-community.yaml",
    "app-config.yaml"
  ];
  return supportedFilenames.map((fileName) => {
    const candidate = path__default.default.join(directory, fileName);
    return fs__default.default.existsSync(candidate);
  }).reduce((val, current, index) => {
    if (typeof val === "undefined" && current) {
      return path__default.default.join(directory, supportedFilenames[index]);
    }
    return val;
  }, undefined);
}
function* discoverFiles(dir, includedFiles = [], excludedDirectories = []) {
  const files = fs__default.default.readdirSync(dir, { withFileTypes: true });
  for (const file of files) {
    const isExcluded = (fileName) => excludedDirectories.some((exclude) => fileName === exclude);
    const isIncluded = (fileName) => includedFiles.some((include) => fileName === include);
    if (file.isDirectory() && !isExcluded(file.name)) {
      yield* discoverFiles(
        path__default.default.join(dir, file.name),
        includedFiles,
        excludedDirectories
      );
    } else if (isIncluded(file.name)) {
      yield path__default.default.join(dir, file.name);
    }
  }
}

exports.command = command;
//# sourceMappingURL=command.cjs.js.map
