'use strict';

var Codeowners = require('codeowners');
var gitconfig = require('gitconfiglocal');
var fs = require('fs');
var node_fs = require('node:fs');
var node_path = require('node:path');
var process = require('node:process');
var node_util = require('node:util');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

function _interopNamespaceCompat(e) {
  if (e && typeof e === 'object' && 'default' in e) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var Codeowners__default = /*#__PURE__*/_interopDefaultCompat(Codeowners);
var gitconfig__default = /*#__PURE__*/_interopDefaultCompat(gitconfig);
var fs__namespace = /*#__PURE__*/_interopNamespaceCompat(fs);
var process__default = /*#__PURE__*/_interopDefaultCompat(process);

const pGitconfig = node_util.promisify(gitconfig__default.default);
async function command(opts) {
  const config = await pGitconfig(process__default.default.cwd());
  updatePackageMetadata(opts, config?.remote?.origin?.url);
}
const path = {
  /**
   * @method resolveRelativeFromAbsolute resolves a relative path from an absolute path
   * @param {string} DotDotPath relative path
   * @returns {string} resolved absolutePath
   */
  resolveRelativeFromAbsolute(DotDotPath) {
    const pathsArray = DotDotPath.replaceAll(/[/|\\]/g, "/").split("/");
    const map = pathsArray.reduce(
      (acc, e) => acc.set(e, (acc.get(e) || 0) + 1),
      /* @__PURE__ */ new Map()
    );
    const rootDir = pathsArray.slice(0, -(map.get("..") * 2)).join("/");
    const relativeDir = process__default.default.cwd().replaceAll(`${rootDir}/`, "");
    return [rootDir, relativeDir];
  }
};
function findCodeowners(element) {
  if (fs__namespace.existsSync(`${element}/.github/CODEOWNERS`)) {
    return element;
  }
  return findCodeowners(`${element}/..`);
}
function separateKeywords(array) {
  return array.reduce(
    (prev, keyword) => {
      if (keyword.startsWith("lifecycle:")) {
        return { ...prev, lifecycle: keyword };
      }
      if (keyword.startsWith("support:")) {
        return { ...prev, support: keyword };
      }
      prev.keywords.push(keyword);
      return prev;
    },
    { keywords: [] }
  );
}
function updatePackageMetadata(opts, gitconfigRemoteOriginUrl) {
  const workingDir = `${process__default.default.cwd()}/${opts.dir}`;
  console.log(`Updating ${workingDir} / package.json`);
  const [rootDir, relativePath] = opts.dir ? [process__default.default.cwd(), opts.dir] : path.resolveRelativeFromAbsolute(findCodeowners(`${process__default.default.cwd()}`));
  const packageJSONPath = node_path.join(workingDir, "package.json");
  const packageJSON = JSON.parse(
    node_fs.readFileSync(packageJSONPath, "utf8")
  );
  if (fs__namespace.existsSync(node_path.join(rootDir, "/backstage.json"))) {
    packageJSON.backstage["supported-versions"] = JSON.parse(
      node_fs.readFileSync(node_path.join(rootDir, "/backstage.json"), "utf8")
    ).version;
  }
  const repo = {};
  repo.type = "git";
  repo.url = gitconfigRemoteOriginUrl.toString().replaceAll("git@github.com:", "https://github.com/").replaceAll(".git", "").trim();
  repo.directory = relativePath;
  packageJSON.repository = repo;
  let owners = [];
  if (packageJSON.repository.directory) {
    const repos = new Codeowners__default.default();
    owners = repos.getOwner(relativePath);
  } else {
    console.log(
      ` ! Could not load .github/CODEOWNERS file, so cannot update maintainers in package.json`
    );
  }
  packageJSON.maintainers = owners;
  packageJSON.author = opts.author;
  packageJSON.license = opts.license;
  packageJSON.homepage = new URL(opts.homepage);
  packageJSON.bugs = new URL(opts.bugs);
  if (!packageJSON.keywords) {
    packageJSON.keywords = [];
  }
  const {
    keywords: oldKeywords,
    lifecycle: oldLifecycle,
    support: oldSupport
  } = separateKeywords(packageJSON.keywords);
  const {
    keywords: optsKeywords,
    lifecycle: optsLifecycle,
    support: optsSupport
  } = separateKeywords(opts.keywords.split(","));
  const newKeywords = oldKeywords.concat(optsKeywords);
  if (oldLifecycle || optsLifecycle) {
    newKeywords.unshift(optsLifecycle ?? oldLifecycle ?? "");
  }
  if (oldSupport || optsSupport) {
    newKeywords.unshift(optsSupport ?? oldSupport ?? "");
  }
  packageJSON.keywords = Array.from(new Set(newKeywords));
  node_fs.writeFileSync(packageJSONPath, JSON.stringify(packageJSON, null, 2), "utf8");
}

exports.command = command;
exports.updatePackageMetadata = updatePackageMetadata;
//# sourceMappingURL=command.cjs.js.map
