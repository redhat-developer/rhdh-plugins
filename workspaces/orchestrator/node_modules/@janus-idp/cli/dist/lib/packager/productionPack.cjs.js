'use strict';

var fs = require('fs-extra');
var npmPackList = require('npm-packlist');
var path = require('path');
var entryPoints = require('../entryPoints.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var fs__default = /*#__PURE__*/_interopDefaultCompat(fs);
var npmPackList__default = /*#__PURE__*/_interopDefaultCompat(npmPackList);

const PKG_PATH = "package.json";
const PKG_BACKUP_PATH = "package.json-prepack";
const SKIPPED_KEYS = ["access", "registry", "tag"];
const SCRIPT_EXTS = [".js", ".jsx", ".ts", ".tsx"];
async function productionPack(options) {
  const { packageDir, targetDir } = options;
  const pkgPath = path.resolve(packageDir, PKG_PATH);
  const pkgContent = await fs__default.default.readFile(pkgPath, "utf8");
  const pkg = JSON.parse(pkgContent);
  if (!targetDir) {
    await fs__default.default.writeFile(PKG_BACKUP_PATH, pkgContent);
  }
  const writeCompatibilityEntryPoints = await prepareExportsEntryPoints(
    pkg,
    packageDir
  );
  const publishConfig = pkg.publishConfig ?? {};
  for (const key of Object.keys(publishConfig)) {
    if (!SKIPPED_KEYS.includes(key)) {
      pkg[key] = publishConfig[key];
    }
  }
  delete pkg.typesVersions;
  if (pkg.bundled) {
    delete pkg.dependencies;
    delete pkg.devDependencies;
    delete pkg.peerDependencies;
    delete pkg.optionalDependencies;
  }
  if (options.customizeManifest !== undefined) {
    options.customizeManifest(pkg);
  }
  if (targetDir) {
    const filePaths = await npmPackList__default.default({
      path: packageDir,
      // This makes sure we use the updated package.json when listing files
      packageJsonCache: /* @__PURE__ */ new Map([
        [path.resolve(packageDir, PKG_PATH), pkg]
      ])
      // Seems like this parameter type is wrong,
    });
    await fs__default.default.ensureDir(targetDir);
    for (const filePath of filePaths.sort()) {
      const target = path.resolve(targetDir, filePath);
      if (filePath === PKG_PATH) {
        await fs__default.default.writeJson(target, pkg, { encoding: "utf8", spaces: 2 });
      } else {
        await fs__default.default.copy(path.resolve(packageDir, filePath), target);
      }
    }
  } else {
    await fs__default.default.writeJson(pkgPath, pkg, { encoding: "utf8", spaces: 2 });
  }
  if (writeCompatibilityEntryPoints) {
    await writeCompatibilityEntryPoints(targetDir ?? packageDir);
  }
}
const EXPORT_MAP = {
  import: ".esm.js",
  require: ".cjs.js",
  types: ".d.ts"
};
async function prepareExportsEntryPoints(pkg, packageDir) {
  const distPath = path.resolve(packageDir, "dist");
  if (!await fs__default.default.pathExists(distPath)) {
    return undefined;
  }
  const distFiles = await fs__default.default.readdir(distPath);
  const outputExports = {};
  const compatibilityWriters = new Array();
  const entryPoints$1 = entryPoints.readEntryPoints(pkg);
  for (const entryPoint of entryPoints$1) {
    if (!SCRIPT_EXTS.includes(entryPoint.ext)) {
      outputExports[entryPoint.mount] = entryPoint.path;
      continue;
    }
    const exp = {};
    for (const [key, ext] of Object.entries(EXPORT_MAP)) {
      const name = `${entryPoint.name}${ext}`;
      if (distFiles.includes(name)) {
        exp[key] = `./${path.posix.join(`dist`, name)}`;
      }
    }
    exp.default = exp.require ?? exp.import;
    if (entryPoint.mount === ".") {
      if (exp.default) {
        pkg.main = exp.default;
      }
      if (exp.import) {
        pkg.module = exp.import;
      }
      if (exp.types) {
        pkg.types = exp.types;
      }
    } else {
      compatibilityWriters.push(async (targetDir) => {
        const entryPointDir = path.resolve(targetDir, entryPoint.name);
        await fs__default.default.ensureDir(entryPointDir);
        await fs__default.default.writeJson(
          path.resolve(entryPointDir, PKG_PATH),
          {
            name: pkg.name,
            version: pkg.version,
            ...exp.default ? { main: path.posix.join("..", exp.default) } : {},
            ...exp.import ? { module: path.posix.join("..", exp.import) } : {},
            ...exp.types ? { types: path.posix.join("..", exp.types) } : {}
          },
          { encoding: "utf8", spaces: 2 }
        );
      });
      if (Array.isArray(pkg.files) && !pkg.files.includes(entryPoint.name)) {
        pkg.files.push(entryPoint.name);
      }
    }
    if (Object.keys(exp).length > 0) {
      outputExports[entryPoint.mount] = exp;
    }
  }
  if (pkg.exports) {
    pkg.exports = outputExports;
    pkg.exports["./package.json"] = "./package.json";
  }
  if (compatibilityWriters.length > 0) {
    return async (targetDir) => {
      await Promise.all(compatibilityWriters.map((writer) => writer(targetDir)));
    };
  }
  return undefined;
}

exports.productionPack = productionPack;
//# sourceMappingURL=productionPack.cjs.js.map
