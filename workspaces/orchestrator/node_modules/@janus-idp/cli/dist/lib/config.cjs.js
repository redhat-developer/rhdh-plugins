'use strict';

var cliNode = require('@backstage/cli-node');
var config = require('@backstage/config');
var configLoader = require('@backstage/config-loader');
var getPackages = require('@manypkg/get-packages');
var paths = require('./paths.cjs.js');
var urls = require('./urls.cjs.js');

async function loadCliConfig(options) {
  const configTargets = [];
  options.args.forEach((arg) => {
    if (!urls.isValidUrl(arg)) {
      configTargets.push({ path: paths.paths.resolveTarget(arg) });
    }
  });
  const { packages } = await getPackages.getPackages(paths.paths.targetDir);
  let localPackageNames;
  if (options.fromPackage) {
    if (packages.length) {
      const graph = cliNode.PackageGraph.fromPackages(packages);
      localPackageNames = Array.from(
        graph.collectPackageNames([options.fromPackage], (node) => {
          if (node.name === "@janus-idp/cli") {
            return undefined;
          }
          return node.localDependencies.keys();
        })
      );
    } else {
      localPackageNames = [options.fromPackage];
    }
  } else {
    localPackageNames = packages.map((p) => p.packageJson.name);
  }
  const schema = await configLoader.loadConfigSchema({
    dependencies: localPackageNames,
    // Include the package.json in the project root if it exists
    packagePaths: [paths.paths.resolveTargetRoot("package.json")],
    noUndeclaredProperties: options.strict
  });
  const { appConfigs } = await configLoader.loadConfig({
    experimentalEnvFunc: options.mockEnv ? async (name) => process.env[name] || "x" : undefined,
    configRoot: paths.paths.targetRoot,
    configTargets,
    watch: options.watch && {
      onChange(newAppConfigs) {
        const newFrontendAppConfigs = schema.process(newAppConfigs, {
          visibility: options.fullVisibility ? ["frontend", "backend", "secret"] : ["frontend"],
          withFilteredKeys: options.withFilteredKeys,
          withDeprecatedKeys: options.withDeprecatedKeys,
          ignoreSchemaErrors: !options.strict
        });
        options.watch?.(newFrontendAppConfigs);
      }
    }
  });
  process.stderr.write(
    `Loaded config from ${appConfigs.map((c) => c.context).join(", ")}
`
  );
  try {
    const frontendAppConfigs = schema.process(appConfigs, {
      visibility: options.fullVisibility ? ["frontend", "backend", "secret"] : ["frontend"],
      withFilteredKeys: options.withFilteredKeys,
      withDeprecatedKeys: options.withDeprecatedKeys,
      ignoreSchemaErrors: !options.strict
    });
    const frontendConfig = config.ConfigReader.fromConfigs(frontendAppConfigs);
    const fullConfig = config.ConfigReader.fromConfigs(appConfigs);
    return {
      schema,
      appConfigs,
      frontendConfig,
      frontendAppConfigs,
      fullConfig
    };
  } catch (error) {
    const maybeSchemaError = error;
    if (maybeSchemaError.messages) {
      const messages = maybeSchemaError.messages.join("\n  ");
      throw new Error(`Configuration does not match schema

  ${messages}`);
    }
    throw error;
  }
}

exports.loadCliConfig = loadCliConfig;
//# sourceMappingURL=config.cjs.js.map
