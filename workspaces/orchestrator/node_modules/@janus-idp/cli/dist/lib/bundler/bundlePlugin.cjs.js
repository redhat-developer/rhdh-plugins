'use strict';

var FileSizeReporter = require('react-dev-utils/FileSizeReporter');
var formatWebpackMessages = require('react-dev-utils/formatWebpackMessages');
var chalk = require('chalk');
var fs = require('fs-extra');
var webpack = require('webpack');
var yn = require('yn');
var paths = require('./paths.cjs.js');
var scalprumConfig = require('./scalprumConfig.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var formatWebpackMessages__default = /*#__PURE__*/_interopDefaultCompat(formatWebpackMessages);
var chalk__default = /*#__PURE__*/_interopDefaultCompat(chalk);
var fs__default = /*#__PURE__*/_interopDefaultCompat(fs);
var webpack__default = /*#__PURE__*/_interopDefaultCompat(webpack);
var yn__default = /*#__PURE__*/_interopDefaultCompat(yn);

const WARN_AFTER_BUNDLE_GZIP_SIZE = 512 * 1024;
const WARN_AFTER_CHUNK_GZIP_SIZE = 1024 * 1024;
function applyContextToError(error, moduleName) {
  return `Failed to compile '${moduleName}':
  ${error}`;
}
async function buildScalprumBundle(options) {
  const paths$1 = paths.resolveBundlingPaths(options);
  const config = await scalprumConfig.createScalprumConfig(
    {
      targetScalprumDist: options.resolvedScalprumDistPath,
      ...paths$1
    },
    {
      ...options,
      checksEnabled: false,
      isDev: false
    }
  );
  const isCi = yn__default.default(process.env.CI, { default: false });
  const previousFileSizes = await FileSizeReporter.measureFileSizesBeforeBuild(
    options.resolvedScalprumDistPath
  );
  await fs__default.default.emptyDir(options.resolvedScalprumDistPath);
  if (paths$1.targetPublic) {
    await fs__default.default.copy(paths$1.targetPublic, paths$1.targetDist, {
      dereference: true,
      filter: (file) => file !== paths$1.targetHtml
    });
  }
  const { stats } = await build(config, isCi);
  if (!stats) {
    throw new Error("No stats returned");
  }
  FileSizeReporter.printFileSizesAfterBuild(
    stats,
    previousFileSizes,
    options.resolvedScalprumDistPath,
    WARN_AFTER_BUNDLE_GZIP_SIZE,
    WARN_AFTER_CHUNK_GZIP_SIZE
  );
}
async function build(config, isCi) {
  const stats = await new Promise(
    (resolve, reject) => {
      webpack__default.default(config, (err, buildStats) => {
        if (err) {
          if (err.message) {
            const { errors: errors2 } = formatWebpackMessages__default.default({
              errors: [err.message],
              warnings: new Array(),
              _showErrors: true,
              _showWarnings: true
            });
            throw new Error(errors2[0]);
          } else {
            reject(err);
          }
        } else {
          resolve(buildStats);
        }
      });
    }
  );
  if (!stats) {
    throw new Error("Failed to compile: No stats provided");
  }
  const serializedStats = stats.toJson({
    all: false,
    warnings: true,
    errors: true
  });
  const { errors, warnings } = formatWebpackMessages__default.default({
    errors: serializedStats.errors,
    warnings: serializedStats.warnings
  });
  if (errors.length) {
    const errorWithContext = applyContextToError(
      errors[0],
      serializedStats.errors?.[0]?.moduleName ?? ""
    );
    throw new Error(errorWithContext);
  }
  if (isCi && warnings.length) {
    const warningsWithContext = warnings.map((warning, i) => {
      return applyContextToError(
        warning,
        serializedStats.warnings?.[i]?.moduleName ?? ""
      );
    });
    console.log(chalk__default.default.yellow(warningsWithContext.join("\n\n")));
  }
  return { stats };
}

exports.buildScalprumBundle = buildScalprumBundle;
//# sourceMappingURL=bundlePlugin.cjs.js.map
