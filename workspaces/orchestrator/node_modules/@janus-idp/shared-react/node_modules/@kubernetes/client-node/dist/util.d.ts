import { CoreV1Api, V1Container, V1Pod } from './gen/api';
export declare function podsForNode(api: CoreV1Api, nodeName: string): Promise<V1Pod[]>;
export declare function findSuffix(quantity: string): string;
export declare function quantityToScalar(quantity: string): number | bigint;
export declare class ResourceStatus {
    readonly request: bigint | number;
    readonly limit: bigint | number;
    readonly resourceType: string;
    constructor(request: bigint | number, limit: bigint | number, resourceType: string);
}
export declare function totalCPUForContainer(container: V1Container): ResourceStatus;
export declare function totalMemoryForContainer(container: V1Container): ResourceStatus;
export declare function totalCPU(pod: V1Pod): ResourceStatus;
export declare function totalMemory(pod: V1Pod): ResourceStatus;
export declare function add(n1: number | bigint, n2: number | bigint): number | bigint;
export declare function containerTotalForResource(container: V1Container, resource: string): ResourceStatus;
export declare function totalForResource(pod: V1Pod, resource: string): ResourceStatus;
export declare function generateTmpFileName(): Promise<string>;
/**
 * If you don't want to or can't await a promise right await and need to store
 * it in a variable to await it later, wrap it with this function.
 * Otherwise, if the promise rejects before you await it, it will cause an
 * unhandled promise rejection which can cause process termination (in node).
 */
export declare const awaitLater: <T, P extends Promise<T>>(p: P) => P;
export interface ResolvablePromise<T> extends Promise<T> {
    resolve: (value: T) => void;
    reject: (error: Error) => void;
}
export declare const resolvablePromise: <T>() => ResolvablePromise<T>;
export declare const sleep: (ms: number) => Promise<void>;
