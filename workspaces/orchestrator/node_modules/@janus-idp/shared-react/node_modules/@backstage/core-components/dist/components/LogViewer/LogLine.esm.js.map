{"version":3,"file":"LogLine.esm.js","sources":["../../../src/components/LogViewer/LogLine.tsx"],"sourcesContent":["/*\n * Copyright 2021 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport React, { useMemo } from 'react';\nimport { AnsiChunk, AnsiLine, ChunkModifiers } from './AnsiProcessor';\nimport startCase from 'lodash/startCase';\nimport classnames from 'classnames';\nimport { useStyles } from './styles';\nimport Linkify from 'linkify-react';\nimport { Link } from '../Link';\n\nexport function getModifierClasses(\n  classes: ReturnType<typeof useStyles>,\n  modifiers: ChunkModifiers,\n) {\n  const classNames = new Array<string>();\n  if (modifiers.bold) {\n    classNames.push(classes.modifierBold);\n  }\n  if (modifiers.italic) {\n    classNames.push(classes.modifierItalic);\n  }\n  if (modifiers.underline) {\n    classNames.push(classes.modifierUnderline);\n  }\n  if (modifiers.foreground) {\n    const key = `modifierForeground${startCase(\n      modifiers.foreground,\n    )}` as keyof typeof classes;\n    classNames.push(classes[key]);\n  }\n  if (modifiers.background) {\n    const key = `modifierBackground${startCase(\n      modifiers.background,\n    )}` as keyof typeof classes;\n    classNames.push(classes[key]);\n  }\n  return classNames.length > 0 ? classNames.join(' ') : undefined;\n}\n\nexport function findSearchResults(text: string, searchText: string) {\n  if (!searchText || !text.includes(searchText)) {\n    return undefined;\n  }\n  const searchResults = new Array<{ start: number; end: number }>();\n  let offset = 0;\n  for (;;) {\n    const start = text.indexOf(searchText, offset);\n    if (start === -1) {\n      break;\n    }\n    const end = start + searchText.length;\n    searchResults.push({ start, end });\n    offset = end;\n  }\n  return searchResults;\n}\n\nexport interface HighlightAnsiChunk extends AnsiChunk {\n  highlight?: number;\n}\n\nexport function calculateHighlightedChunks(\n  line: AnsiLine,\n  searchText: string,\n): HighlightAnsiChunk[] {\n  const results = findSearchResults(line.text, searchText);\n  if (!results) {\n    return line.chunks;\n  }\n\n  const chunks = new Array<HighlightAnsiChunk>();\n\n  let lineOffset = 0;\n  let resultIndex = 0;\n  let result = results[resultIndex];\n  for (const chunk of line.chunks) {\n    const { text, modifiers } = chunk;\n    if (!result || lineOffset + text.length < result.start) {\n      chunks.push(chunk);\n      lineOffset += text.length;\n      continue;\n    }\n\n    let localOffset = 0;\n    while (result) {\n      const localStart = Math.max(result.start - lineOffset, 0);\n      if (localStart > text.length) {\n        break; // The next result is not in this chunk\n      }\n\n      const localEnd = Math.min(result.end - lineOffset, text.length);\n\n      const hasTextBeforeResult = localStart > localOffset;\n      if (hasTextBeforeResult) {\n        chunks.push({ text: text.slice(localOffset, localStart), modifiers });\n      }\n      const hasResultText = localEnd > localStart;\n      if (hasResultText) {\n        chunks.push({\n          modifiers,\n          highlight: resultIndex,\n          text: text.slice(localStart, localEnd),\n        });\n      }\n\n      localOffset = localEnd;\n\n      const foundCompleteResult = result.end - lineOffset === localEnd;\n      if (foundCompleteResult) {\n        resultIndex += 1;\n        result = results[resultIndex];\n      } else {\n        break; // The rest of the result is in the following chunks\n      }\n    }\n\n    const hasTextAfterResult = localOffset < text.length;\n    if (hasTextAfterResult) {\n      chunks.push({ text: text.slice(localOffset), modifiers });\n    }\n\n    lineOffset += text.length;\n  }\n\n  return chunks;\n}\n\nconst renderLink = ({\n  attributes,\n  content,\n}: {\n  attributes: { [attr: string]: any };\n  content: string;\n}) => {\n  const { href, ...props } = attributes;\n  return (\n    <Link to={href} {...props}>\n      {content}\n    </Link>\n  );\n};\n\nexport interface LogLineProps {\n  line: AnsiLine;\n  classes: ReturnType<typeof useStyles>;\n  searchText: string;\n  highlightResultIndex?: number;\n}\n\nexport function LogLine({\n  line,\n  classes,\n  searchText,\n  highlightResultIndex,\n}: LogLineProps) {\n  const chunks = useMemo(\n    () => calculateHighlightedChunks(line, searchText),\n    [line, searchText],\n  );\n\n  const elements = useMemo(\n    () =>\n      chunks.map(({ text, modifiers, highlight }, index) => (\n        // eslint-disable-next-line react/forbid-elements\n        <span\n          key={index}\n          className={classnames(\n            getModifierClasses(classes, modifiers),\n            highlight !== undefined &&\n              (highlight === highlightResultIndex\n                ? classes.textSelectedHighlight\n                : classes.textHighlight),\n          )}\n        >\n          <Linkify options={{ render: renderLink }}>{text}</Linkify>\n        </span>\n      )),\n    [chunks, highlightResultIndex, classes],\n  );\n\n  return <>{elements}</>;\n}\n"],"names":["React","classnames"],"mappings":"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"}