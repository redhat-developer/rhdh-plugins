import React from 'react';
import { V1ObjectMeta, V1PersistentVolumeClaimTemplate, V1ConfigMap, V1Secret } from '@kubernetes/client-node';
import { Entity } from '@backstage/catalog-model';
import { ApiRef } from '@backstage/core-plugin-api';
import { ObjectsByEntityResponse } from '@backstage/plugin-kubernetes-common';
import { KubernetesApi, KubernetesAuthProvidersApi } from '@backstage/plugin-kubernetes-react';

type StackedValue = {
    color: string;
    name: string;
    size: number;
};
type HorizontalStackedBarsProps = {
    id: string;
    barGap?: number;
    height?: number | string;
    inline?: boolean;
    values: StackedValue[];
    width?: number | string;
    onClick?: () => void;
};
declare const HorizontalStackedBars: ({ id, barGap, height, inline, values, width, onClick, }: HorizontalStackedBarsProps) => React.JSX.Element;

type CamelCaseWrapProps = {
    value: string;
    dataTest?: string;
};
declare const CamelCaseWrap: ({ value, dataTest }: CamelCaseWrapProps) => any;

type TektonParam = {
    default?: string | string[];
    description?: string;
    name: string;
    type?: string;
};
type TektonResource = {
    name: string;
    optional?: boolean;
    type: string;
};
type TektonWorkspace = {
    name: string;
    description?: string;
    mountPath?: string;
    readOnly?: boolean;
    optional?: boolean;
};
type TektonResourceGroup<ResourceType> = {
    inputs?: ResourceType[];
    outputs?: ResourceType[];
};
type TektonTaskSteps = {
    name: string;
    args?: string[];
    command?: string[];
    image?: string;
    resources?: {}[] | {};
    env?: {
        name: string;
        value?: string;
    }[];
    script?: string;
    workingDir?: string;
    volumeMounts?: {
        name: string;
        mountPath: string;
    }[];
};
type TaskResult = {
    name: string;
    description?: string;
};
type TektonTaskSpec = {
    metadata?: {};
    description?: string;
    steps: TektonTaskSteps[];
    params?: TektonParam[];
    resources?: TektonResourceGroup<TektonResource>;
    results?: TaskResult[];
    workspaces?: TektonWorkspace[];
};
type TektonResultsRun = {
    name: string;
    type?: string;
    value: string;
};
type PipelineTaskRef = {
    kind?: string;
    name: string;
};
type PipelineTaskWorkspace = {
    name: string;
    workspace: string;
    optional?: boolean;
};
type PipelineTaskResource = {
    name: string;
    resource?: string;
    from?: string[];
};
type PipelineTaskParam = {
    name: string;
    value: any;
};
type WhenExpression = {
    input: string;
    operator: string;
    values: string[];
};
type PipelineResult = {
    name: string;
    value: string;
    description?: string;
};
type PipelineTask = {
    name: string;
    params?: PipelineTaskParam[];
    resources?: TektonResourceGroup<PipelineTaskResource>;
    runAfter?: string[];
    taskRef?: PipelineTaskRef;
    taskSpec?: TektonTaskSpec;
    when?: WhenExpression[];
    workspaces?: PipelineTaskWorkspace[];
};
type PipelineSpec = {
    params?: TektonParam[];
    resources?: TektonResource[];
    serviceAccountName?: string;
    tasks: PipelineTask[];
    workspaces?: TektonWorkspace[];
    finally?: PipelineTask[];
    results?: PipelineResult[];
};
type Condition = {
    type: string;
    status: string;
    reason?: string;
    message?: string;
    lastTransitionTime?: string;
};
type PipelineKind = {
    apiVersion?: string;
    kind?: string;
    metadata?: V1ObjectMeta;
    spec: PipelineSpec;
};

declare enum TerminatedReasons {
    Completed = "Completed"
}
declare enum ComputedStatus {
    All = "All",
    Cancelling = "Cancelling",
    Succeeded = "Succeeded",
    Failed = "Failed",
    Running = "Running",
    'In Progress' = "In Progress",
    FailedToStart = "FailedToStart",
    PipelineNotStarted = "PipelineNotStarted",
    Skipped = "Skipped",
    Cancelled = "Cancelled",
    Pending = "Pending",
    Idle = "Idle",
    Other = "Other"
}
declare enum SucceedConditionReason {
    PipelineRunCancelled = "StoppedRunFinally",
    PipelineRunStopped = "CancelledRunFinally",
    TaskRunCancelled = "TaskRunCancelled",
    Cancelled = "Cancelled",
    PipelineRunStopping = "PipelineRunStopping",
    PipelineRunPending = "PipelineRunPending",
    TaskRunStopping = "TaskRunStopping",
    CreateContainerConfigError = "CreateContainerConfigError",
    ExceededNodeResources = "ExceededNodeResources",
    ExceededResourceQuota = "ExceededResourceQuota",
    ConditionCheckFailed = "ConditionCheckFailed"
}
type StatusMessage = {
    message: string;
    color: string;
};
type TaskStatusTypes = {
    PipelineNotStarted: number;
    Pending: number;
    Running: number;
    Succeeded: number;
    Cancelled: number;
    Failed: number;
    Skipped: number;
};

type PLRTaskRunStep = {
    container: string;
    imageID?: string;
    name: string;
    waiting?: {
        reason: string;
    };
    running?: {
        startedAt: string;
    };
    terminated?: {
        containerID: string;
        exitCode: number;
        finishedAt: string;
        reason: string;
        startedAt: string;
        message?: string;
    };
};
type PipelineRunParam = {
    name: string;
    value: string | string[];
    input?: string;
    output?: string;
    resource?: object;
};
type PipelineRunWorkspace = {
    name: string;
    [volumeType: string]: {};
};
type PipelineRunEmbeddedResourceParam = {
    name: string;
    value: string;
};
type PipelineRunEmbeddedResource = {
    name: string;
    resourceSpec: {
        params: PipelineRunEmbeddedResourceParam[];
        type: string;
    };
};
type PipelineRunReferenceResource = {
    name: string;
    resourceRef: {
        name: string;
    };
};
type PipelineRunResource = PipelineRunReferenceResource | PipelineRunEmbeddedResource;
type PLRTaskRunData = {
    pipelineTaskName: string;
    status?: {
        completionTime?: string;
        conditions: Condition[];
        podName: string;
        startTime: string;
        steps?: PLRTaskRunStep[];
        taskSpec?: TektonTaskSpec;
        taskResults?: {
            name: string;
            value: string;
            type?: string;
        }[];
    };
};
type PLRTaskRuns = {
    [taskRunName: string]: PLRTaskRunData;
};
type PipelineRunStatus = {
    succeededCondition?: string;
    creationTimestamp?: string;
    conditions?: Condition[];
    startTime?: string;
    completionTime?: string;
    taskRuns?: PLRTaskRuns;
    pipelineSpec: PipelineSpec;
    skippedTasks?: {
        name: string;
    }[];
    pipelineResults?: TektonResultsRun[];
    results?: TektonResultsRun[];
};
type PipelineRunKind = {
    apiVersion?: string;
    kind?: string;
    metadata?: V1ObjectMeta;
    spec: {
        pipelineRef?: {
            name: string;
        };
        pipelineSpec?: PipelineSpec;
        params?: PipelineRunParam[];
        workspaces?: PipelineRunWorkspace[];
        resources?: PipelineRunResource[];
        serviceAccountName?: string;
        timeout?: string;
        status?: string;
    };
    status?: PipelineRunStatus;
};
type PipelineTaskWithStatus = PipelineTask & {
    status: {
        reason: string;
        completionTime?: string;
        conditions: Condition[];
        podName?: string;
        startTime?: string;
        steps?: PLRTaskRunStep[];
        taskSpec?: TektonTaskSpec;
        taskResults?: {
            name: string;
            value: string;
        }[];
        duration?: string;
    };
};

type VolumeTypePVC = {
    claimName: string;
};
type TaskRunWorkspace = {
    name: string;
    volumeClaimTemplate?: V1PersistentVolumeClaimTemplate;
    persistentVolumeClaim?: VolumeTypePVC;
    configMap?: V1ConfigMap;
    emptyDir?: {};
    secret?: V1Secret;
    subPath?: string;
};
type TaskRunStatus = {
    completionTime?: string;
    conditions?: Condition[];
    podName?: string;
    startTime?: string;
    steps?: PLRTaskRunStep[];
    taskResults?: TektonResultsRun[];
    results?: TektonResultsRun[];
};
type TaskRunKind = {
    apiVersion?: string;
    kind?: string;
    metadata?: V1ObjectMeta;
    spec: {
        taskRef?: PipelineTaskRef;
        taskSpec?: TektonTaskSpec;
        serviceAccountName?: string;
        params?: PipelineTaskParam[];
        resources?: TektonResource[] | {};
        timeout?: string;
        workspaces?: TaskRunWorkspace[];
    };
    status?: TaskRunStatus;
};

interface TaskStatusToolTipProps {
    taskStatus: TaskStatusTypes;
}
declare const TaskStatusTooltip: ({ taskStatus }: TaskStatusToolTipProps) => React.JSX.Element;

declare const StatusIconAndText: ({ icon, title, spin, iconOnly, className, dataTestId, }: {
    title: string;
    iconOnly?: boolean;
    className?: string;
    icon: React.ReactElement;
    spin?: boolean;
    dataTestId?: string;
}) => React.ReactElement;

type DeleteDialogContextType = {
    deleteComponent: {
        [key: string]: any;
    };
    setDeleteComponent: (component: {
        [key: string]: any;
    }) => void;
    openDialog: boolean;
    setOpenDialog: (open: boolean) => void;
};
declare const DeleteDialogContext: React.Context<DeleteDialogContextType>;
declare const DeleteDialogContextProvider: (props: any) => React.JSX.Element;
declare const useDeleteDialog: () => DeleteDialogContextType;

type DrawerContextType = {
    drawerData: any;
    setDrawerData: (data: any) => void;
    openDrawer: boolean;
    setOpenDrawer: (open: boolean) => void;
};
declare const DrawerContext: React.Context<DrawerContextType>;
declare const DrawerContextProvider: ({ children, }: {
    children: React.ReactElement;
}) => React.JSX.Element;
declare const useDrawer: () => DrawerContextType;

/**
 * Component for displaying a status message
 * @param {string} status - type of status to be displayed
 * @param {boolean} [iconOnly] - (optional) if true, only displays icon
 * @param {string} [className] - (optional) additional class name for the component
 * @param {string} [displayStatusText] - (optional) use a different text to display the status

 * @example
 * ```tsx
 * <Status status='Warning' />
 * ```
 */
declare const Status: ({ status, iconOnly, className, displayStatusText, dataTestId, iconStyles, iconClassName, }: {
    status: string | null;
    displayStatusText?: string;
    iconOnly?: boolean;
    className?: string;
    dataTestId?: string;
    iconStyles?: React.CSSProperties;
    iconClassName?: string;
}) => React.ReactElement;

declare const pipelineGroupColor = "#38812f";

declare const skippedColor = "#8a8d90";
declare const cancelledColor = "#6a6e73";
declare const pendingColor = "#8bc1f7";
declare const runningColor = "#06c";
declare const successColor = "#38812f";
declare const failureColor = "#c9190b";

/**
 * Returns the given date as a formated Date.
 *
 * @param date - The given date in seconds
 * @return The date formatted to en-US locale, otherwise return 'N/A'
 */
declare function formatDate(date: string | number | Date | undefined): string;

declare const getRunStatusColor: (status: string) => StatusMessage;
declare const getLatestPipelineRun: (runs: PipelineRunKind[], field: string) => PipelineRunKind | null;
declare const pipelineRunStatus: (pipelineRun: PipelineRunKind | TaskRunKind | PipelineTaskWithStatus | null) => ComputedStatus | null;
declare const pipelineRunFilterReducer: (pipelineRun: PipelineRunKind | TaskRunKind) => ComputedStatus;
declare const updateTaskStatus: (pipelinerun: PipelineRunKind | null, taskRuns: TaskRunKind[]) => TaskStatusTypes;
declare const totalPipelineRunTasks: (pipelinerun: PipelineRunKind | null) => number;
declare const getTaskStatus: (pipelinerun: PipelineRunKind, taskRuns: TaskRunKind[]) => TaskStatusTypes;

declare const getTaskRunsForPipelineRun: (pipelinerun: PipelineRunKind | null, taskRuns: TaskRunKind[]) => TaskRunKind[];

/**
 * Returns a given size in bytes formated to the closest to power of 1024
 *
 * @param sizeInBytes - The given size in bytes
 * @return Formated bytes in powers of 1024
 */
declare function formatByteSize(sizeInBytes: number | undefined): string;

declare const downloadLogFile: (data: string, filename: string) => void;

declare const getTitleCase: (str: string) => string;

interface Cancelable {
    cancel(): void;
    flush(): void;
}
declare const useDebounceCallback: <T extends (...args: any[]) => any>(callback: T, timeout?: number, debounceParams?: {
    leading?: boolean;
    trailing?: boolean;
    maxWait?: number;
}) => ((...args: any) => any) & Cancelable;

declare const useDeepCompareMemoize: <T = any>(value: T, stringify?: boolean) => T;

/**
 *
 * @public
 */
interface KubernetesObjects {
    kubernetesObjects?: ObjectsByEntityResponse;
    loading: boolean;
    error?: string;
}
/**
 *
 * @public
 */
declare const useKubernetesObjects: (entity: Entity, kubernetesApiRef: ApiRef<KubernetesApi>, kubernetesAuthProvidersApiRef: ApiRef<KubernetesAuthProvidersApi>, intervalMs?: number) => KubernetesObjects;

export { CamelCaseWrap, ComputedStatus, type Condition, DeleteDialogContext, DeleteDialogContextProvider, DrawerContext, DrawerContextProvider, HorizontalStackedBars, type PLRTaskRunData, type PLRTaskRunStep, type PLRTaskRuns, type PipelineKind, type PipelineResult, type PipelineRunEmbeddedResource, type PipelineRunEmbeddedResourceParam, type PipelineRunKind, type PipelineRunParam, type PipelineRunReferenceResource, type PipelineRunResource, type PipelineRunStatus, type PipelineRunWorkspace, type PipelineSpec, type PipelineTask, type PipelineTaskParam, type PipelineTaskRef, type PipelineTaskResource, type PipelineTaskWithStatus, type PipelineTaskWorkspace, Status, StatusIconAndText, type StatusMessage, SucceedConditionReason, type TaskResult, type TaskRunKind, type TaskRunStatus, type TaskRunWorkspace, TaskStatusTooltip, type TaskStatusTypes, type TektonParam, type TektonResource, type TektonResourceGroup, type TektonResultsRun, type TektonTaskSpec, type TektonTaskSteps, type TektonWorkspace, TerminatedReasons, type VolumeTypePVC, type WhenExpression, cancelledColor, downloadLogFile, failureColor, formatByteSize, formatDate, getLatestPipelineRun, getRunStatusColor, getTaskRunsForPipelineRun, getTaskStatus, getTitleCase, pendingColor, pipelineGroupColor, pipelineRunFilterReducer, pipelineRunStatus, runningColor, skippedColor, successColor, totalPipelineRunTasks, updateTaskStatus, useDebounceCallback, useDeepCompareMemoize, useDeleteDialog, useDrawer, useKubernetesObjects };
