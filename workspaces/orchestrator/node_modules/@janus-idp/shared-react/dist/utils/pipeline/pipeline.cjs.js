'use strict';

var common = require('../../consts/common.cjs.js');
var computedStatus = require('../../types/pipeline/computedStatus.cjs.js');
var taskRun = require('./task-run.cjs.js');

const getRunStatusColor = (status) => {
  switch (status) {
    case computedStatus.ComputedStatus.Succeeded:
      return { message: "Succeeded", color: common.successColor };
    case computedStatus.ComputedStatus.Failed:
      return { message: "Failed", color: common.failureColor };
    case computedStatus.ComputedStatus.FailedToStart:
      return {
        message: "PipelineRun failed to start",
        color: common.failureColor
      };
    case computedStatus.ComputedStatus.Running:
    case computedStatus.ComputedStatus["In Progress"]:
      return { message: "Running", color: common.runningColor };
    case computedStatus.ComputedStatus.Skipped:
      return { message: "Skipped", color: common.skippedColor };
    case computedStatus.ComputedStatus.Cancelled:
      return { message: "Cancelled", color: common.cancelledColor };
    case computedStatus.ComputedStatus.Cancelling:
      return { message: "Cancelling", color: common.cancelledColor };
    case computedStatus.ComputedStatus.Idle:
    case computedStatus.ComputedStatus.Pending:
      return { message: "Pending", color: common.pendingColor };
    default:
      return {
        message: "PipelineRun not started yet",
        color: common.pendingColor
      };
  }
};
const getDate = (run, field) => {
  if (field === "creationTimestamp") {
    return run?.metadata?.creationTimestamp ?? "";
  }
  if (field === "startTime" || field === "completionTime") {
    return run?.status?.[field] ?? "";
  }
  return "";
};
const getLatestRun = (runs, field) => {
  let latestRun = runs[0];
  for (let i = 1; i < runs.length; i++) {
    latestRun = new Date(getDate(runs?.[i], field)) > new Date(getDate(latestRun, field)) ? runs[i] : latestRun;
  }
  return latestRun;
};
const getLatestPipelineRun = (runs, field) => {
  if (runs?.length > 0 && field) {
    let latestRun;
    if (field === "completionTime" || field === "startTime" || field === "creationTimestamp") {
      latestRun = getLatestRun(runs, field);
    } else {
      latestRun = runs[runs.length - 1];
    }
    return latestRun;
  }
  return null;
};
const getSucceededStatus = (status) => {
  if (status === "True") {
    return computedStatus.ComputedStatus.Succeeded;
  } else if (status === "False") {
    return computedStatus.ComputedStatus.Failed;
  }
  return computedStatus.ComputedStatus.Running;
};
const pipelineRunStatus = (pipelineRun) => {
  const conditions = pipelineRun?.status?.conditions || [];
  if (conditions.length === 0) return null;
  const succeedCondition = conditions.find((c) => c.type === "Succeeded");
  const cancelledCondition = conditions.find(
    (c) => c.reason === "Cancelled"
  );
  const failedCondition = conditions.find((c) => c.reason === "Failed");
  if ([
    computedStatus.SucceedConditionReason.PipelineRunStopped,
    computedStatus.SucceedConditionReason.PipelineRunCancelled
  ].includes(
    pipelineRun?.spec?.status
  ) && !cancelledCondition && !failedCondition) {
    return computedStatus.ComputedStatus.Cancelling;
  }
  if (!succeedCondition?.status) {
    return null;
  }
  const status = getSucceededStatus(succeedCondition.status);
  if (succeedCondition.reason && succeedCondition.reason !== status) {
    switch (succeedCondition.reason) {
      case computedStatus.SucceedConditionReason.PipelineRunCancelled:
      case computedStatus.SucceedConditionReason.TaskRunCancelled:
      case computedStatus.SucceedConditionReason.Cancelled:
      case computedStatus.SucceedConditionReason.PipelineRunStopped:
        return computedStatus.ComputedStatus.Cancelled;
      case computedStatus.SucceedConditionReason.PipelineRunStopping:
      case computedStatus.SucceedConditionReason.TaskRunStopping:
        return computedStatus.ComputedStatus.Failed;
      case computedStatus.SucceedConditionReason.CreateContainerConfigError:
      case computedStatus.SucceedConditionReason.ExceededNodeResources:
      case computedStatus.SucceedConditionReason.ExceededResourceQuota:
      case computedStatus.SucceedConditionReason.PipelineRunPending:
        return computedStatus.ComputedStatus.Pending;
      case computedStatus.SucceedConditionReason.ConditionCheckFailed:
        return computedStatus.ComputedStatus.Skipped;
      default:
        return status;
    }
  }
  return status;
};
const pipelineRunFilterReducer = (pipelineRun) => {
  const status = pipelineRunStatus(pipelineRun);
  return status || computedStatus.ComputedStatus.Other;
};
const updateTaskStatus = (pipelinerun, taskRuns) => {
  const skippedTaskLength = pipelinerun?.status?.skippedTasks?.length || 0;
  const PLRTaskRuns = taskRun.getTaskRunsForPipelineRun(pipelinerun, taskRuns);
  const taskStatus = {
    PipelineNotStarted: 0,
    Pending: 0,
    Running: 0,
    Succeeded: 0,
    Failed: 0,
    Cancelled: 0,
    Skipped: skippedTaskLength
  };
  if (!PLRTaskRuns || PLRTaskRuns.length === 0) {
    return taskStatus;
  }
  PLRTaskRuns.forEach((taskRun) => {
    const status = taskRun && pipelineRunFilterReducer(taskRun);
    if (status === "Succeeded") {
      taskStatus[computedStatus.ComputedStatus.Succeeded]++;
    } else if (status === "Running") {
      taskStatus[computedStatus.ComputedStatus.Running]++;
    } else if (status === "Failed") {
      taskStatus[computedStatus.ComputedStatus.Failed]++;
    } else if (status === "Cancelled") {
      taskStatus[computedStatus.ComputedStatus.Cancelled]++;
    } else {
      taskStatus[computedStatus.ComputedStatus.Pending]++;
    }
  });
  return {
    ...taskStatus
  };
};
const totalPipelineRunTasks = (pipelinerun) => {
  if (!pipelinerun?.status?.pipelineSpec) {
    return 0;
  }
  const totalTasks = (pipelinerun.status.pipelineSpec?.tasks || []).length;
  const finallyTasks = (pipelinerun.status.pipelineSpec?.finally || []).length ?? 0;
  return totalTasks + finallyTasks;
};
const getTaskStatus = (pipelinerun, taskRuns) => {
  const totalTasks = totalPipelineRunTasks(pipelinerun);
  const plrTaskLength = taskRuns.length;
  const skippedTaskLength = pipelinerun?.status?.skippedTasks?.length || 0;
  const taskStatus = updateTaskStatus(pipelinerun, taskRuns);
  if (taskRuns?.length > 0) {
    const pipelineRunHasFailure = taskStatus[computedStatus.ComputedStatus.Failed] > 0;
    const pipelineRunIsCancelled = pipelineRunFilterReducer(pipelinerun) === computedStatus.ComputedStatus.Cancelled;
    const unhandledTasks = totalTasks >= plrTaskLength ? totalTasks - plrTaskLength - skippedTaskLength : totalTasks;
    if (pipelineRunHasFailure || pipelineRunIsCancelled) {
      taskStatus[computedStatus.ComputedStatus.Cancelled] += unhandledTasks;
    } else {
      taskStatus[computedStatus.ComputedStatus.Pending] += unhandledTasks;
    }
  } else if (pipelinerun?.status?.conditions?.[0]?.status === "False" || pipelinerun?.spec.status === computedStatus.SucceedConditionReason.PipelineRunCancelled) {
    taskStatus[computedStatus.ComputedStatus.Cancelled] = totalTasks;
  } else if (pipelinerun?.spec.status === computedStatus.SucceedConditionReason.PipelineRunPending) {
    taskStatus[computedStatus.ComputedStatus.Pending] += totalTasks;
  } else {
    taskStatus[computedStatus.ComputedStatus.PipelineNotStarted]++;
  }
  return taskStatus;
};

exports.getLatestPipelineRun = getLatestPipelineRun;
exports.getRunStatusColor = getRunStatusColor;
exports.getTaskStatus = getTaskStatus;
exports.pipelineRunFilterReducer = pipelineRunFilterReducer;
exports.pipelineRunStatus = pipelineRunStatus;
exports.totalPipelineRunTasks = totalPipelineRunTasks;
exports.updateTaskStatus = updateTaskStatus;
//# sourceMappingURL=pipeline.cjs.js.map
