'use strict';

var errors = require('@backstage/errors');
var integration = require('@backstage/integration');
var pluginScaffolderNode = require('@backstage/plugin-scaffolder-node');
var azureDevopsNodeApi = require('azure-devops-node-api');
var azure_examples = require('./azure.examples.cjs.js');

function createPublishAzureAction(options) {
  const { integrations, config } = options;
  return pluginScaffolderNode.createTemplateAction({
    id: "publish:azure",
    examples: azure_examples.examples,
    description: "Initializes a git repository of the content in the workspace, and publishes it to Azure.",
    schema: {
      input: {
        repoUrl: (z) => z.string({
          description: "Repository Location"
        }),
        description: (z) => z.string({
          description: "Repository Description"
        }).optional(),
        defaultBranch: (z) => z.string({
          description: `Sets the default branch on the repository. The default value is 'master'`
        }).optional(),
        sourcePath: (z) => z.string({
          description: "Path within the workspace that will be used as the repository root. If omitted, the entire workspace will be published as the repository."
        }).optional(),
        token: (z) => z.string({
          description: "The token to use for authorization to Azure"
        }).optional(),
        gitCommitMessage: (z) => z.string({
          description: `Sets the commit message on the repository. The default value is 'initial commit'`
        }).optional(),
        gitAuthorName: (z) => z.string({
          description: `Sets the default author name for the commit. The default value is 'Scaffolder'`
        }).optional(),
        gitAuthorEmail: (z) => z.string({
          description: `Sets the default author email for the commit.`
        }).optional(),
        signCommit: (z) => z.boolean({
          description: "Sign commit with configured PGP private key"
        }).optional()
      },
      output: {
        remoteUrl: (z) => z.string({
          description: "A URL to the repository with the provider"
        }).optional(),
        repoContentsUrl: (z) => z.string({
          description: "A URL to the root of the repository"
        }).optional(),
        repositoryId: (z) => z.string({
          description: "The Id of the created repository"
        }).optional(),
        commitHash: (z) => z.string({
          description: "The git commit hash of the initial commit"
        }).optional()
      }
    },
    async handler(ctx) {
      const {
        repoUrl,
        defaultBranch = "master",
        gitCommitMessage = "initial commit",
        gitAuthorName,
        gitAuthorEmail,
        signCommit
      } = ctx.input;
      const { project, repo, host, organization } = pluginScaffolderNode.parseRepoUrl(
        repoUrl,
        integrations
      );
      if (!organization) {
        throw new errors.InputError(
          `Invalid URL provider was included in the repo URL to create ${ctx.input.repoUrl}, missing organization`
        );
      }
      const url = `https://${host}/${organization}`;
      const credentialProvider = integration.DefaultAzureDevOpsCredentialsProvider.fromIntegrations(integrations);
      const credentials = await credentialProvider.getCredentials({ url });
      const integrationConfig = integrations.azure.byHost(host);
      if (credentials === void 0 && ctx.input.token === void 0) {
        throw new errors.InputError(
          `No credentials provided ${url}, please check your integrations config`
        );
      }
      const authHandler = ctx.input.token || credentials?.type === "pat" ? azureDevopsNodeApi.getPersonalAccessTokenHandler(ctx.input.token ?? credentials.token) : azureDevopsNodeApi.getBearerHandler(credentials.token);
      const webApi = new azureDevopsNodeApi.WebApi(url, authHandler);
      const client = await webApi.getGitApi();
      const createOptions = { name: repo };
      const { remoteUrl, repositoryId, repoContentsUrl } = await ctx.checkpoint(
        {
          key: `create.repo.${repo}`,
          fn: async () => {
            const returnedRepo = await client.createRepository(
              createOptions,
              project
            );
            if (!returnedRepo) {
              throw new errors.InputError(
                `Unable to create the repository with Organization ${organization}, Project ${project} and Repo ${repo}.
          Please make sure that both the Org and Project are typed corrected and exist.`
              );
            }
            if (!returnedRepo.remoteUrl) {
              throw new errors.InputError(
                "No remote URL returned from create repository for Azure"
              );
            }
            if (!returnedRepo.id) {
              throw new errors.InputError(
                "No Id returned from create repository for Azure"
              );
            }
            if (!returnedRepo.webUrl) {
              throw new errors.InputError(
                "No web URL returned from create repository for Azure"
              );
            }
            return {
              remoteUrl: returnedRepo.remoteUrl,
              repositoryId: returnedRepo.id,
              repoContentsUrl: returnedRepo.webUrl
            };
          }
        }
      );
      const gitAuthorInfo = {
        name: gitAuthorName ? gitAuthorName : config.getOptionalString("scaffolder.defaultAuthor.name"),
        email: gitAuthorEmail ? gitAuthorEmail : config.getOptionalString("scaffolder.defaultAuthor.email")
      };
      const auth = {
        username: "notempty",
        password: ctx.input.token ?? credentials.token
      };
      const signingKey = integrationConfig?.config.commitSigningKey ?? config.getOptionalString("scaffolder.defaultCommitSigningKey");
      if (signCommit && !signingKey) {
        throw new Error(
          "Signing commits is enabled but no signing key is provided in the configuration"
        );
      }
      const commitHash = await ctx.checkpoint({
        key: `init.repo.and.push.${remoteUrl}`,
        fn: async () => {
          const commitResult = await pluginScaffolderNode.initRepoAndPush({
            dir: pluginScaffolderNode.getRepoSourceDirectory(
              ctx.workspacePath,
              ctx.input.sourcePath
            ),
            remoteUrl,
            defaultBranch,
            auth,
            logger: ctx.logger,
            commitMessage: gitCommitMessage ? gitCommitMessage : config.getOptionalString("scaffolder.defaultCommitMessage"),
            gitAuthorInfo,
            signingKey: signCommit ? signingKey : void 0
          });
          return commitResult?.commitHash;
        }
      });
      ctx.output("commitHash", commitHash);
      ctx.output("remoteUrl", remoteUrl);
      ctx.output("repoContentsUrl", repoContentsUrl);
      ctx.output("repositoryId", repositoryId);
    }
  });
}

exports.createPublishAzureAction = createPublishAzureAction;
//# sourceMappingURL=azure.cjs.js.map
