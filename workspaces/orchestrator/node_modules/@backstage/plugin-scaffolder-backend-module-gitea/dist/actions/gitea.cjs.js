'use strict';

var errors = require('@backstage/errors');
var integration = require('@backstage/integration');
var pluginScaffolderNode = require('@backstage/plugin-scaffolder-node');
var gitea_examples = require('./gitea.examples.cjs.js');
var crypto = require('crypto');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var crypto__default = /*#__PURE__*/_interopDefaultCompat(crypto);

const checkGiteaContentUrl = async (config, options) => {
  const { owner, repo, defaultBranch } = options;
  let response;
  const getOptions = {
    method: "GET"
  };
  try {
    response = await fetch(
      `${config.baseUrl}/${owner}/${repo}/src/branch/${defaultBranch}`,
      getOptions
    );
  } catch (e) {
    throw new Error(
      `Unable to get the repository: ${owner}/${repo} metadata , ${e}`
    );
  }
  return response;
};
const checkGiteaOrg = async (config, options) => {
  const { owner } = options;
  let response;
  const getOptions = {
    method: "GET",
    headers: {
      ...integration.getGiteaRequestOptions(config).headers,
      "Content-Type": "application/json"
    }
  };
  try {
    response = await fetch(
      `${config.baseUrl}/api/v1/orgs/${owner}`,
      getOptions
    );
  } catch (e) {
    throw new Error(
      `Unable to get the Organization: ${owner}; Error cause: ${e.message}, code: ${e.cause.code}`
    );
  }
  if (response.status !== 200) {
    throw new Error(
      `Organization ${owner} do not exist. Please create it first !`
    );
  }
};
const createGiteaProject = async (config, options) => {
  const { projectName, description, owner, repoVisibility } = options;
  let response;
  let isPrivate;
  if (repoVisibility === "private") {
    isPrivate = true;
  } else if (repoVisibility === "public") {
    isPrivate = false;
  } else {
    isPrivate = false;
  }
  const postOptions = {
    method: "POST",
    body: JSON.stringify({
      name: projectName,
      description,
      private: isPrivate
    }),
    headers: {
      ...integration.getGiteaRequestOptions(config).headers,
      "Content-Type": "application/json"
    }
  };
  try {
    response = await fetch(
      `${config.baseUrl}/api/v1/orgs/${owner}/repos`,
      postOptions
    );
  } catch (e) {
    throw new Error(`Unable to create repository, ${e}`);
  }
  if (response.status !== 201) {
    throw new Error(
      `Unable to create repository, ${response.status} ${response.statusText}, ${await response.text()}`
    );
  }
};
const generateCommitMessage = (config, commitSubject) => {
  const changeId = crypto__default.default.randomBytes(20).toString("hex");
  const msg = `${config.getOptionalString("scaffolder.defaultCommitMessage") || commitSubject}

Change-Id: I${changeId}`;
  return msg;
};
async function checkAvailabilityGiteaRepository(maxDuration, integrationConfig, options) {
  const startTimestamp = Date.now();
  const { owner, repo, defaultBranch, ctx } = options;
  const sleep = (ms) => new Promise((r) => setTimeout(r, ms));
  let response;
  while (Date.now() - startTimestamp < maxDuration) {
    if (ctx.signal?.aborted) return;
    response = await checkGiteaContentUrl(integrationConfig, {
      owner,
      repo,
      defaultBranch
    });
    if (response.status !== 200) {
      await sleep(1e3);
    } else {
      break;
    }
  }
}
function createPublishGiteaAction(options) {
  const { integrations, config } = options;
  return pluginScaffolderNode.createTemplateAction({
    id: "publish:gitea",
    description: "Initializes a git repository using the content of the workspace, and publishes it to Gitea.",
    examples: gitea_examples.examples,
    schema: {
      input: {
        repoUrl: (z) => z.string({
          description: "Repository Location"
        }),
        description: (z) => z.string({
          description: "Repository Description"
        }),
        defaultBranch: (z) => z.string({
          description: `Sets the default branch on the repository. The default value is 'main'`
        }).optional(),
        repoVisibility: (z) => z.enum(["private", "public"], {
          description: `Sets the visibility of the repository. The default value is 'public'.`
        }).optional(),
        gitCommitMessage: (z) => z.string({
          description: `Sets the commit message on the repository. The default value is 'initial commit'`
        }).optional(),
        gitAuthorName: (z) => z.string({
          description: `Sets the default author name for the commit. The default value is 'Scaffolder'`
        }).optional(),
        gitAuthorEmail: (z) => z.string({
          description: `Sets the default author email for the commit.`
        }).optional(),
        sourcePath: (z) => z.string({
          description: `Path within the workspace that will be used as the repository root. If omitted, the entire workspace will be published as the repository.`
        }).optional(),
        signCommit: (z) => z.boolean({
          description: "Sign commit with configured PGP private key"
        }).optional()
      },
      output: {
        remoteUrl: (z) => z.string({
          description: "A URL to the repository with the provider"
        }).optional(),
        repoContentsUrl: (z) => z.string({
          description: "A URL to the root of the repository"
        }).optional(),
        commitHash: (z) => z.string({
          description: "The git commit hash of the initial commit"
        }).optional()
      }
    },
    async handler(ctx) {
      const {
        repoUrl,
        description,
        defaultBranch = "main",
        repoVisibility = "public",
        gitAuthorName,
        gitAuthorEmail,
        gitCommitMessage = "initial commit",
        sourcePath,
        signCommit
      } = ctx.input;
      const { repo, host, owner } = pluginScaffolderNode.parseRepoUrl(repoUrl, integrations);
      const integrationConfig = integrations.gitea.byHost(host);
      if (!integrationConfig) {
        throw new errors.InputError(
          `No matching integration configuration for host ${host}, please check your integrations config`
        );
      }
      const { username, password } = integrationConfig.config;
      if (!username || !password) {
        throw new Error("Credentials for the gitea ${host} required.");
      }
      if (owner) {
        await checkGiteaOrg(integrationConfig.config, { owner });
      }
      await createGiteaProject(integrationConfig.config, {
        description,
        repoVisibility,
        owner,
        projectName: repo
      });
      const auth = {
        username,
        password
      };
      const gitAuthorInfo = {
        name: gitAuthorName ? gitAuthorName : config.getOptionalString("scaffolder.defaultAuthor.name"),
        email: gitAuthorEmail ? gitAuthorEmail : config.getOptionalString("scaffolder.defaultAuthor.email")
      };
      const signingKey = integrationConfig.config.commitSigningKey ?? config.getOptionalString("scaffolder.defaultCommitSigningKey");
      if (signCommit && !signingKey) {
        throw new Error(
          "Signing commits is enabled but no signing key is provided in the configuration"
        );
      }
      const remoteUrl = `${integrationConfig.config.baseUrl}/${owner}/${repo}.git`;
      const commitResult = await pluginScaffolderNode.initRepoAndPush({
        dir: pluginScaffolderNode.getRepoSourceDirectory(ctx.workspacePath, sourcePath),
        remoteUrl,
        auth,
        defaultBranch,
        logger: ctx.logger,
        commitMessage: generateCommitMessage(config, gitCommitMessage),
        gitAuthorInfo
      });
      const maxDuration = 2e4;
      await checkAvailabilityGiteaRepository(
        maxDuration,
        integrationConfig.config,
        {
          owner,
          repo,
          defaultBranch,
          ctx
        }
      );
      const repoContentsUrl = `${integrationConfig.config.baseUrl}/${owner}/${repo}/src/branch/${defaultBranch}/`;
      ctx.output("remoteUrl", remoteUrl);
      ctx.output("commitHash", commitResult?.commitHash);
      ctx.output("repoContentsUrl", repoContentsUrl);
    }
  });
}

exports.createPublishGiteaAction = createPublishGiteaAction;
//# sourceMappingURL=gitea.cjs.js.map
