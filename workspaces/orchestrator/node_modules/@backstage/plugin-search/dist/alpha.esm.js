import { jsxs, jsx, Fragment } from 'react/jsx-runtime';
import { createElement } from 'react';
import Grid from '@material-ui/core/Grid';
import Paper from '@material-ui/core/Paper';
import { makeStyles } from '@material-ui/core/styles';
import SearchIcon from '@material-ui/icons/Search';
import { useSidebarPinState, Page, Header, Content, CatalogIcon, DocsIcon } from '@backstage/core-components';
import { fetchApiRef, discoveryApiRef, useApi } from '@backstage/core-plugin-api';
import { ApiBlueprint, PageBlueprint, createExtensionInput, NavItemBlueprint, createFrontendPlugin } from '@backstage/frontend-plugin-api';
import { catalogApiRef, CATALOG_FILTER_EXISTS } from '@backstage/plugin-catalog-react';
import { searchApiRef, SearchContextProvider, useSearch, SearchBar, SearchFilter, SearchPagination, SearchResult, SearchResultPager, DefaultResultListItem } from '@backstage/plugin-search-react';
import { SearchFilterResultTypeBlueprint, SearchFilterBlueprint, SearchResultListItemBlueprint } from '@backstage/plugin-search-react/alpha';
import { rootRouteRef } from './plugin.esm.js';
import { SearchClient } from './apis.esm.js';
import { SearchType } from './components/SearchType/SearchType.esm.js';
import { UrlUpdater } from './components/SearchPage/SearchPage.esm.js';
import { convertLegacyRouteRef, compatWrapper, convertLegacyRouteRefs } from '@backstage/core-compat-api';
export { searchTranslationRef } from './translation.esm.js';

const searchApi = ApiBlueprint.make({
  params: (defineParams) => defineParams({
    api: searchApiRef,
    deps: { discoveryApi: discoveryApiRef, fetchApi: fetchApiRef },
    factory: ({ discoveryApi, fetchApi }) => new SearchClient({ discoveryApi, fetchApi })
  })
});
const useSearchPageStyles = makeStyles((theme) => ({
  filter: {
    "& + &": {
      marginTop: theme.spacing(2.5)
    }
  },
  filters: {
    padding: theme.spacing(2),
    marginTop: theme.spacing(2)
  }
}));
const searchPage = PageBlueprint.makeWithOverrides({
  config: {
    schema: {
      noTrack: (z) => z.boolean().default(false)
    }
  },
  inputs: {
    items: createExtensionInput([SearchResultListItemBlueprint.dataRefs.item]),
    resultTypes: createExtensionInput([
      SearchFilterResultTypeBlueprint.dataRefs.resultType
    ]),
    searchFilters: createExtensionInput([
      SearchFilterBlueprint.dataRefs.searchFilters
    ])
  },
  factory(originalFactory, { config, inputs }) {
    return originalFactory({
      path: "/search",
      routeRef: convertLegacyRouteRef(rootRouteRef),
      loader: async () => {
        const getResultItemComponent = (result) => {
          const value = inputs.items.find(
            (item) => item?.get(SearchResultListItemBlueprint.dataRefs.item).predicate?.(result)
          );
          return value?.get(SearchResultListItemBlueprint.dataRefs.item).component ?? DefaultResultListItem;
        };
        const resultTypes = inputs.resultTypes.map(
          (item) => item.get(SearchFilterResultTypeBlueprint.dataRefs.resultType)
        );
        const additionalSearchFilters = inputs.searchFilters.map(
          (item) => item.get(SearchFilterBlueprint.dataRefs.searchFilters).component
        );
        const Component = () => {
          const classes = useSearchPageStyles();
          const { isMobile } = useSidebarPinState();
          const { types } = useSearch();
          const catalogApi = useApi(catalogApiRef);
          return /* @__PURE__ */ jsxs(Page, { themeId: "home", children: [
            !isMobile && /* @__PURE__ */ jsx(Header, { title: "Search" }),
            /* @__PURE__ */ jsx(Content, { children: /* @__PURE__ */ jsxs(Grid, { container: true, direction: "row", children: [
              /* @__PURE__ */ jsx(Grid, { item: true, xs: 12, children: /* @__PURE__ */ jsx(SearchBar, { debounceTime: 100 }) }),
              !isMobile && /* @__PURE__ */ jsxs(Grid, { item: true, xs: 3, children: [
                /* @__PURE__ */ jsx(
                  SearchType.Accordion,
                  {
                    name: "Result Type",
                    defaultValue: "software-catalog",
                    showCounts: true,
                    types: [
                      {
                        value: "software-catalog",
                        name: "Software Catalog",
                        icon: /* @__PURE__ */ jsx(CatalogIcon, {})
                      },
                      {
                        value: "techdocs",
                        name: "Documentation",
                        icon: /* @__PURE__ */ jsx(DocsIcon, {})
                      }
                    ].concat(resultTypes)
                  }
                ),
                /* @__PURE__ */ jsxs(Paper, { className: classes.filters, children: [
                  types.includes("techdocs") && /* @__PURE__ */ jsx(
                    SearchFilter.Select,
                    {
                      className: classes.filter,
                      label: "Entity",
                      name: "name",
                      values: async () => {
                        const { items } = await catalogApi.getEntities({
                          fields: ["metadata.name"],
                          filter: {
                            "metadata.annotations.backstage.io/techdocs-ref": CATALOG_FILTER_EXISTS
                          }
                        });
                        const names = items.map(
                          (entity) => entity.metadata.name
                        );
                        names.sort();
                        return names;
                      }
                    }
                  ),
                  /* @__PURE__ */ jsx(
                    SearchFilter.Select,
                    {
                      className: classes.filter,
                      label: "Kind",
                      name: "kind",
                      values: [
                        "API",
                        "Component",
                        "Domain",
                        "Group",
                        "Location",
                        "Resource",
                        "System",
                        "Template",
                        "User"
                      ]
                    }
                  ),
                  /* @__PURE__ */ jsx(
                    SearchFilter.Checkbox,
                    {
                      className: classes.filter,
                      label: "Lifecycle",
                      name: "lifecycle",
                      values: ["experimental", "production"]
                    }
                  ),
                  additionalSearchFilters.map((SearchFilterComponent) => /* @__PURE__ */ jsx(SearchFilterComponent, { className: classes.filter }))
                ] })
              ] }),
              /* @__PURE__ */ jsxs(Grid, { item: true, xs: true, children: [
                /* @__PURE__ */ jsx(SearchPagination, {}),
                /* @__PURE__ */ jsx(SearchResult, { children: ({ results }) => /* @__PURE__ */ jsx(Fragment, { children: results.map((result, index) => {
                  const { noTrack } = config;
                  const { document, ...rest } = result;
                  const SearchResultListItem = getResultItemComponent(result);
                  return /* @__PURE__ */ createElement(
                    SearchResultListItem,
                    {
                      ...rest,
                      key: index,
                      result: document,
                      noTrack
                    }
                  );
                }) }) }),
                /* @__PURE__ */ jsx(SearchResultPager, {})
              ] })
            ] }) })
          ] });
        };
        return compatWrapper(
          /* @__PURE__ */ jsxs(SearchContextProvider, { children: [
            /* @__PURE__ */ jsx(UrlUpdater, {}),
            /* @__PURE__ */ jsx(Component, {})
          ] })
        );
      }
    });
  }
});
const searchNavItem = NavItemBlueprint.make({
  params: {
    routeRef: convertLegacyRouteRef(rootRouteRef),
    title: "Search",
    icon: SearchIcon
  }
});
var alpha = createFrontendPlugin({
  pluginId: "search",
  info: { packageJson: () => import('./package.json.esm.js') },
  extensions: [searchApi, searchPage, searchNavItem],
  routes: convertLegacyRouteRefs({
    root: rootRouteRef
  })
});

export { alpha as default, searchApi, searchNavItem, searchPage };
//# sourceMappingURL=alpha.esm.js.map
