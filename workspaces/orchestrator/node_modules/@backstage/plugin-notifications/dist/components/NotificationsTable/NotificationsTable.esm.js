import { jsxs, Fragment, jsx } from 'react/jsx-runtime';
import { useState, useCallback, useMemo, useEffect } from 'react';
import throttle from 'lodash/throttle';
import RelativeTime from 'react-relative-time';
import Box from '@material-ui/core/Box';
import Grid from '@material-ui/core/Grid';
import Checkbox from '@material-ui/core/Checkbox';
import Typography from '@material-ui/core/Typography';
import { makeStyles } from '@material-ui/core/styles';
import { useConfirm } from 'material-ui-confirm';
import BroadcastIcon from '@material-ui/icons/RssFeed';
import { useApi, alertApiRef } from '@backstage/core-plugin-api';
import { Link, Table } from '@backstage/core-components';
import { notificationsApiRef } from '../../api/NotificationsApi.esm.js';
import '@backstage/errors';
import { SelectAll } from './SelectAll.esm.js';
import { BulkActions } from './BulkActions.esm.js';
import { NotificationIcon } from './NotificationIcon.esm.js';

const ThrottleDelayMs = 1e3;
const useStyles = makeStyles((theme) => ({
  description: {
    maxHeight: "5rem",
    overflow: "auto"
  },
  severityItem: {
    alignContent: "center"
  },
  broadcastIcon: {
    fontSize: "1rem",
    verticalAlign: "text-bottom"
  },
  notificationInfoRow: {
    marginLeft: theme.spacing(0.5),
    marginRight: theme.spacing(0.5)
  }
}));
const NotificationsTable = ({
  title,
  markAsReadOnLinkOpen,
  isLoading,
  notifications = [],
  isUnread,
  onUpdate,
  setContainsText,
  onPageChange,
  onRowsPerPageChange,
  page,
  pageSize,
  totalCount
}) => {
  const classes = useStyles();
  const notificationsApi = useApi(notificationsApiRef);
  const alertApi = useApi(alertApiRef);
  const confirm = useConfirm();
  const [selectedNotifications, setSelectedNotifications] = useState(
    /* @__PURE__ */ new Set()
  );
  const onNotificationsSelectChange = useCallback(
    (ids, checked) => {
      let newSelect;
      if (checked) {
        newSelect = /* @__PURE__ */ new Set([...selectedNotifications, ...ids]);
      } else {
        newSelect = new Set(selectedNotifications);
        ids.forEach((id) => newSelect.delete(id));
      }
      setSelectedNotifications(newSelect);
    },
    [selectedNotifications, setSelectedNotifications]
  );
  const onSwitchReadStatus = useCallback(
    (ids, newStatus) => {
      notificationsApi.updateNotifications({
        ids,
        read: newStatus
      }).then(onUpdate);
    },
    [notificationsApi, onUpdate]
  );
  const onSwitchSavedStatus = useCallback(
    (ids, newStatus) => {
      notificationsApi.updateNotifications({
        ids,
        saved: newStatus
      }).then(onUpdate);
    },
    [notificationsApi, onUpdate]
  );
  const onMarkAllRead = useCallback(() => {
    confirm({
      title: "Are you sure?",
      description: /* @__PURE__ */ jsxs(Fragment, { children: [
        "Mark ",
        /* @__PURE__ */ jsx("b", { children: "all" }),
        " notifications as ",
        /* @__PURE__ */ jsx("b", { children: "read" }),
        "."
      ] }),
      confirmationText: "Mark All"
    }).then(async () => {
      const ids = (await notificationsApi.getNotifications({ read: false })).notifications?.map((notification) => notification.id);
      return notificationsApi.updateNotifications({
        ids,
        read: true
      }).then(onUpdate);
    }).catch((e) => {
      if (e) {
        alertApi.post({
          message: "Failed to mark all notifications as read",
          severity: "error"
        });
      }
    });
  }, [alertApi, confirm, notificationsApi, onUpdate]);
  const throttledContainsTextHandler = useMemo(
    () => throttle(setContainsText, ThrottleDelayMs),
    [setContainsText]
  );
  useEffect(() => {
    const allShownIds = new Set(notifications.map((n) => n.id));
    const intersect = [...selectedNotifications].filter(
      (id) => allShownIds.has(id)
    );
    if (selectedNotifications.size !== intersect.length) {
      setSelectedNotifications(new Set(intersect));
    }
  }, [notifications, selectedNotifications]);
  const compactColumns = useMemo(() => {
    const showToolbar = notifications.length > 0;
    return [
      {
        /* selection column */
        width: "1rem",
        title: showToolbar ? /* @__PURE__ */ jsx(
          SelectAll,
          {
            count: selectedNotifications.size,
            totalCount: notifications.length,
            onSelectAll: () => onNotificationsSelectChange(
              notifications.map((notification) => notification.id),
              selectedNotifications.size !== notifications.length
            )
          }
        ) : void 0,
        render: (notification) => /* @__PURE__ */ jsx(
          Checkbox,
          {
            color: "primary",
            checked: selectedNotifications.has(notification.id),
            onChange: (_, checked) => onNotificationsSelectChange([notification.id], checked)
          }
        )
      },
      {
        /* compact-data column */
        customFilterAndSearch: () => true,
        render: (notification) => {
          return /* @__PURE__ */ jsxs(Grid, { container: true, children: [
            /* @__PURE__ */ jsx(Grid, { item: true, className: classes.severityItem, children: /* @__PURE__ */ jsx(NotificationIcon, { notification }) }),
            /* @__PURE__ */ jsx(Grid, { item: true, xs: 11, children: /* @__PURE__ */ jsxs(Box, { children: [
              /* @__PURE__ */ jsx(Typography, { variant: "subtitle1", children: notification.payload.link ? /* @__PURE__ */ jsx(
                Link,
                {
                  to: notification.payload.link,
                  onClick: () => {
                    if (markAsReadOnLinkOpen && !notification.read) {
                      onSwitchReadStatus([notification.id], true);
                    }
                  },
                  children: notification.payload.title
                }
              ) : notification.payload.title }),
              notification.payload.description ? /* @__PURE__ */ jsx(Typography, { variant: "body2", className: classes.description, children: notification.payload.description }) : null,
              /* @__PURE__ */ jsxs(Typography, { variant: "caption", children: [
                !notification.user && /* @__PURE__ */ jsx(Fragment, { children: /* @__PURE__ */ jsx(BroadcastIcon, { className: classes.broadcastIcon }) }),
                notification.origin && /* @__PURE__ */ jsxs(Fragment, { children: [
                  /* @__PURE__ */ jsx(
                    Typography,
                    {
                      variant: "inherit",
                      className: classes.notificationInfoRow,
                      children: notification.origin
                    }
                  ),
                  "\u2022"
                ] }),
                notification.payload.topic && /* @__PURE__ */ jsxs(Fragment, { children: [
                  /* @__PURE__ */ jsx(
                    Typography,
                    {
                      variant: "inherit",
                      className: classes.notificationInfoRow,
                      children: notification.payload.topic
                    }
                  ),
                  "\u2022"
                ] }),
                notification.created && /* @__PURE__ */ jsx(
                  RelativeTime,
                  {
                    value: notification.created,
                    className: classes.notificationInfoRow
                  }
                )
              ] })
            ] }) })
          ] });
        }
      },
      {
        /* actions column */
        width: "1rem",
        title: showToolbar ? /* @__PURE__ */ jsx(
          BulkActions,
          {
            notifications,
            selectedNotifications,
            isUnread,
            onSwitchReadStatus,
            onSwitchSavedStatus,
            onMarkAllRead
          }
        ) : void 0,
        render: (notification) => /* @__PURE__ */ jsx(
          BulkActions,
          {
            notifications: [notification],
            selectedNotifications: /* @__PURE__ */ new Set([notification.id]),
            onSwitchReadStatus,
            onSwitchSavedStatus
          }
        )
      }
    ];
  }, [
    notifications,
    selectedNotifications,
    isUnread,
    onSwitchReadStatus,
    onSwitchSavedStatus,
    onMarkAllRead,
    onNotificationsSelectChange,
    classes.severityItem,
    classes.description,
    classes.broadcastIcon,
    classes.notificationInfoRow,
    markAsReadOnLinkOpen
  ]);
  return /* @__PURE__ */ jsx(
    Table,
    {
      isLoading,
      options: {
        padding: "dense",
        search: true,
        paging: true,
        pageSize,
        header: true,
        sorting: false
      },
      title,
      onPageChange,
      onRowsPerPageChange,
      page,
      totalCount,
      onSearchChange: throttledContainsTextHandler,
      data: notifications,
      columns: compactColumns
    }
  );
};

export { NotificationsTable };
//# sourceMappingURL=NotificationsTable.esm.js.map
