{"version":3,"file":"resolveInputOverrides.esm.js","sources":["../../src/wiring/resolveInputOverrides.ts"],"sourcesContent":["/*\n * Copyright 2024 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { AppNode } from '../apis';\nimport { Expand } from '@backstage/types';\nimport { ResolvedExtensionInput } from './createExtension';\nimport { createExtensionDataContainer } from '@internal/frontend';\nimport {\n  ExtensionDataRef,\n  ExtensionDataRefToValue,\n  ExtensionDataValue,\n} from './createExtensionDataRef';\nimport { ExtensionInput } from './createExtensionInput';\nimport { ExtensionDataContainer } from './types';\n\n/** @ignore */\nexport type ResolvedInputValueOverrides<\n  TInputs extends {\n    [inputName in string]: ExtensionInput<\n      ExtensionDataRef,\n      { optional: boolean; singleton: boolean }\n    >;\n  } = {\n    [inputName in string]: ExtensionInput<\n      ExtensionDataRef,\n      { optional: boolean; singleton: boolean }\n    >;\n  },\n> = Expand<\n  {\n    [KName in keyof TInputs as TInputs[KName] extends ExtensionInput<\n      any,\n      {\n        optional: infer IOptional extends boolean;\n        singleton: boolean;\n      }\n    >\n      ? IOptional extends true\n        ? never\n        : KName\n      : never]: TInputs[KName] extends ExtensionInput<\n      infer IDataRefs,\n      { optional: boolean; singleton: infer ISingleton extends boolean }\n    >\n      ? ISingleton extends true\n        ? Iterable<ExtensionDataRefToValue<IDataRefs>>\n        : Array<Iterable<ExtensionDataRefToValue<IDataRefs>>>\n      : never;\n  } & {\n    [KName in keyof TInputs as TInputs[KName] extends ExtensionInput<\n      any,\n      {\n        optional: infer IOptional extends boolean;\n        singleton: boolean;\n      }\n    >\n      ? IOptional extends true\n        ? KName\n        : never\n      : never]?: TInputs[KName] extends ExtensionInput<\n      infer IDataRefs,\n      { optional: boolean; singleton: infer ISingleton extends boolean }\n    >\n      ? ISingleton extends true\n        ? Iterable<ExtensionDataRefToValue<IDataRefs>>\n        : Array<Iterable<ExtensionDataRefToValue<IDataRefs>>>\n      : never;\n  }\n>;\n\nfunction expectArray<T>(value: T | T[]): T[] {\n  return value as T[];\n}\nfunction expectItem<T>(value: T | T[]): T {\n  return value as T;\n}\n\n/** @internal */\nexport function resolveInputOverrides(\n  declaredInputs?: {\n    [inputName in string]: ExtensionInput<\n      ExtensionDataRef,\n      { optional: boolean; singleton: boolean }\n    >;\n  },\n  inputs?: {\n    [KName in string]?:\n      | ({ node: AppNode } & ExtensionDataContainer<any>)\n      | Array<{ node: AppNode } & ExtensionDataContainer<any>>;\n  },\n  inputOverrides?: ResolvedInputValueOverrides,\n) {\n  if (!declaredInputs || !inputs || !inputOverrides) {\n    return inputs;\n  }\n\n  const newInputs: typeof inputs = {};\n  for (const name in declaredInputs) {\n    if (!Object.hasOwn(declaredInputs, name)) {\n      continue;\n    }\n    const declaredInput = declaredInputs[name];\n    const providedData = inputOverrides[name];\n    if (declaredInput.config.singleton) {\n      const originalInput = expectItem(inputs[name]);\n      if (providedData) {\n        const providedContainer = createExtensionDataContainer(\n          providedData as Iterable<ExtensionDataValue<any, any>>,\n          'extension input override',\n          declaredInput.extensionData,\n        );\n        if (!originalInput) {\n          throw new Error(\n            `attempted to override data of input '${name}' but it is not present in the original inputs`,\n          );\n        }\n        newInputs[name] = Object.assign(providedContainer, {\n          node: (originalInput as ResolvedExtensionInput<any>).node,\n        }) as any;\n      }\n    } else {\n      const originalInput = expectArray(inputs[name]);\n      if (!Array.isArray(providedData)) {\n        throw new Error(\n          `override data provided for input '${name}' must be an array`,\n        );\n      }\n\n      // Regular inputs can be overridden in two different ways:\n      // 1) Forward a subset of the original inputs in a new order\n      // 2) Provide new data for each original input\n\n      // First check if all inputs are being removed\n      if (providedData.length === 0) {\n        newInputs[name] = [];\n      } else {\n        // Check how many of the provided data items have a node property, i.e. is a forwarded input\n        const withNodesCount = providedData.filter(d => 'node' in d).length;\n        if (withNodesCount === 0) {\n          if (originalInput.length !== providedData.length) {\n            throw new Error(\n              `override data provided for input '${name}' must match the length of the original inputs`,\n            );\n          }\n          newInputs[name] = providedData.map((data, i) => {\n            const providedContainer = createExtensionDataContainer(\n              data as Iterable<ExtensionDataValue<any, any>>,\n              'extension input override',\n              declaredInput.extensionData,\n            );\n            return Object.assign(providedContainer, {\n              node: (originalInput[i] as ResolvedExtensionInput<any>).node,\n            }) as any;\n          });\n        } else if (withNodesCount === providedData.length) {\n          newInputs[name] = providedData as any;\n        } else {\n          throw new Error(\n            `override data for input '${name}' may not mix forwarded inputs with data overrides`,\n          );\n        }\n      }\n    }\n  }\n  return newInputs;\n}\n"],"names":[],"mappings":"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"}