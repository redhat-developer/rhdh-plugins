import { parseEntityRef } from '@backstage/catalog-model';
import { ResponseError } from '@backstage/errors';
import { fetchEventSource } from '@microsoft/fetch-event-source';
import ObservableImpl from 'zen-observable';
import { DefaultApiClient } from './schema/openapi/generated/apis/Api.client.esm.js';

class ScaffolderClient {
  apiClient;
  discoveryApi;
  scmIntegrationsApi;
  fetchApi;
  identityApi;
  useLongPollingLogs;
  constructor(options) {
    this.apiClient = new DefaultApiClient(options);
    this.discoveryApi = options.discoveryApi;
    this.fetchApi = options.fetchApi ?? { fetch };
    this.scmIntegrationsApi = options.scmIntegrationsApi;
    this.useLongPollingLogs = options.useLongPollingLogs ?? false;
    this.identityApi = options.identityApi;
  }
  /**
   * {@inheritdoc ScaffolderApi.listTasks}
   */
  async listTasks(request, options) {
    if (!this.identityApi) {
      throw new Error(
        "IdentityApi is not available in the ScaffolderClient, please pass through the IdentityApi to the ScaffolderClient constructor in order to use the listTasks method"
      );
    }
    const { userEntityRef } = await this.identityApi.getBackstageIdentity();
    return await this.requestRequired(
      await this.apiClient.listTasks(
        {
          query: {
            createdBy: request.filterByOwnership === "owned" ? [userEntityRef] : void 0,
            limit: request.limit,
            offset: request.offset
          }
        },
        options
      )
    );
  }
  async getIntegrationsList(options) {
    const integrations = [
      ...this.scmIntegrationsApi.azure.list(),
      ...this.scmIntegrationsApi.bitbucket.list().filter(
        (item) => !this.scmIntegrationsApi.bitbucketCloud.byHost(item.config.host) && !this.scmIntegrationsApi.bitbucketServer.byHost(item.config.host)
      ),
      ...this.scmIntegrationsApi.bitbucketCloud.list(),
      ...this.scmIntegrationsApi.bitbucketServer.list(),
      ...this.scmIntegrationsApi.gerrit.list(),
      ...this.scmIntegrationsApi.gitea.list(),
      ...this.scmIntegrationsApi.github.list(),
      ...this.scmIntegrationsApi.gitlab.list()
    ].map((c) => ({ type: c.type, title: c.title, host: c.config.host })).filter((c) => options.allowedHosts.includes(c.host));
    return {
      integrations
    };
  }
  /**
   * {@inheritdoc ScaffolderApi.getTemplateParameterSchema}
   */
  async getTemplateParameterSchema(templateRef, options) {
    return await this.requestRequired(
      await this.apiClient.getTemplateParameterSchema(
        {
          path: parseEntityRef(templateRef, {
            defaultKind: "template"
          })
        },
        options
      )
    );
  }
  /**
   * {@inheritdoc ScaffolderApi.scaffold}
   */
  async scaffold(request, options) {
    const response = await this.apiClient.scaffold(
      {
        body: request
      },
      options
    );
    if (response.status !== 201) {
      const status = `${response.status} ${response.statusText}`;
      const body = await response.text();
      throw new Error(`Backend request failed, ${status} ${body.trim()}`);
    }
    const { id } = await response.json();
    return { taskId: id };
  }
  /**
   * {@inheritdoc ScaffolderApi.getTask}
   */
  async getTask(taskId, options) {
    return await this.requestRequired(
      await this.apiClient.getTask(
        {
          path: { taskId }
        },
        options
      )
    );
  }
  /**
   * {@inheritdoc ScaffolderApi.streamLogs}
   */
  streamLogs(request, options) {
    if (this.useLongPollingLogs) {
      return this.streamLogsPolling(request, options);
    }
    return this.streamLogsEventStream(request);
  }
  /**
   * {@inheritdoc ScaffolderApi.dryRun}
   */
  async dryRun(request, options) {
    return await this.requestRequired(
      await this.apiClient.dryRun(
        {
          body: {
            template: request.template,
            values: request.values,
            secrets: request.secrets,
            directoryContents: request.directoryContents
          }
        },
        options
      )
    );
  }
  streamLogsEventStream({
    isTaskRecoverable,
    taskId,
    after
  }) {
    return new ObservableImpl((subscriber) => {
      const params = new URLSearchParams();
      if (after !== void 0) {
        params.set("after", String(Number(after)));
      }
      this.discoveryApi.getBaseUrl("scaffolder").then(
        (baseUrl) => {
          const url = `${baseUrl}/v2/tasks/${encodeURIComponent(
            taskId
          )}/eventstream`;
          const processEvent = (event) => {
            if (event.data) {
              try {
                subscriber.next(JSON.parse(event.data));
              } catch (ex) {
                subscriber.error(ex);
              }
            }
          };
          const ctrl = new AbortController();
          void fetchEventSource(url, {
            fetch: this.fetchApi.fetch,
            signal: ctrl.signal,
            onmessage(e) {
              if (e.event === "log") {
                processEvent(e);
                return;
              } else if (e.event === "completion" && !isTaskRecoverable) {
                processEvent(e);
                subscriber.complete();
                ctrl.abort();
                return;
              }
              processEvent(e);
            },
            onerror(err) {
              subscriber.error(err);
            }
          });
        },
        (error) => {
          subscriber.error(error);
        }
      );
    });
  }
  streamLogsPolling({
    taskId,
    after: inputAfter
  }, options) {
    let after = inputAfter;
    return new ObservableImpl((subscriber) => {
      (async () => {
        while (!subscriber.closed) {
          const response = await this.apiClient.streamLogsPolling(
            {
              path: { taskId },
              query: { after }
            },
            options
          );
          if (!response.ok) {
            await new Promise((resolve) => setTimeout(resolve, 1e3));
            continue;
          }
          const logs = await response.json();
          for (const event of logs) {
            after = Number(event.id);
            subscriber.next(event);
            if (event.type === "completion") {
              subscriber.complete();
              return;
            }
          }
        }
      })();
    });
  }
  /**
   * {@inheritdoc ScaffolderApi.listActions}
   */
  async listActions(options) {
    return await this.requestRequired(
      await this.apiClient.listActions(null, options)
    );
  }
  /**
   * {@inheritdoc ScaffolderApi.listTemplatingExtensions}
   */
  async listTemplatingExtensions(options) {
    return await this.requestRequired(
      await this.apiClient.listTemplatingExtensions(null, options)
    );
  }
  /**
   * {@inheritdoc ScaffolderApi.cancelTask}
   */
  async cancelTask(taskId, options) {
    return await this.requestRequired(
      await this.apiClient.cancelTask({ path: { taskId } }, options)
    );
  }
  /**
   * {@inheritdoc ScaffolderApi.retry}
   */
  async retry(taskId, options) {
    return await this.requestRequired(
      await this.apiClient.retry({ body: {}, path: { taskId } }, options)
    );
  }
  /**
   * {@inheritdoc ScaffolderApi.retry}
   */
  async autocomplete({
    token,
    resource,
    provider,
    context
  }) {
    return await this.requestRequired(
      await this.apiClient.autocomplete({
        path: { provider, resource },
        body: { token, context }
      })
    );
  }
  //
  // Private methods
  //
  async requestRequired(response) {
    if (!response.ok) {
      throw await ResponseError.fromResponse(response);
    }
    return response.json();
  }
}

export { ScaffolderClient };
//# sourceMappingURL=ScaffolderClient.esm.js.map
