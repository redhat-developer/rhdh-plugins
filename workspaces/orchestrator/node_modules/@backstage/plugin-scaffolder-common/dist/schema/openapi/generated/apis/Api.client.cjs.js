'use strict';

var crossFetch = require('cross-fetch');
var pluginId = require('../pluginId.cjs.js');
var parser = require('uri-template');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

function _interopNamespaceCompat(e) {
  if (e && typeof e === 'object' && 'default' in e) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var crossFetch__default = /*#__PURE__*/_interopDefaultCompat(crossFetch);
var parser__namespace = /*#__PURE__*/_interopNamespaceCompat(parser);

class DefaultApiClient {
  discoveryApi;
  fetchApi;
  constructor(options) {
    this.discoveryApi = options.discoveryApi;
    this.fetchApi = options.fetchApi || { fetch: crossFetch__default.default };
  }
  /**
   * Perform an autocomplete for the given provider and resource.
   * @param provider -
   * @param resource -
   * @param autocompleteRequest -
   */
  async autocomplete(request, options) {
    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId.pluginId);
    const uriTemplate = `/v2/autocomplete/{provider}/{resource}`;
    const uri = parser__namespace.parse(uriTemplate).expand({
      provider: request.path.provider,
      resource: request.path.resource
    });
    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {
      headers: {
        "Content-Type": "application/json",
        ...options?.token && { Authorization: `Bearer ${options?.token}` }
      },
      method: "POST",
      body: JSON.stringify(request.body)
    });
  }
  /**
   * Sends a signal to a task broker to cancel the running task by taskId.
   * @param taskId -
   */
  async cancelTask(request, options) {
    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId.pluginId);
    const uriTemplate = `/v2/tasks/{taskId}/cancel`;
    const uri = parser__namespace.parse(uriTemplate).expand({
      taskId: request.path.taskId
    });
    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {
      headers: {
        "Content-Type": "application/json",
        ...options?.token && { Authorization: `Bearer ${options?.token}` }
      },
      method: "POST"
    });
  }
  /**
   * Perform a dry-run of a template
   * @param dryRunRequest -
   */
  async dryRun(request, options) {
    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId.pluginId);
    const uriTemplate = `/v2/dry-run`;
    const uri = parser__namespace.parse(uriTemplate).expand({});
    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {
      headers: {
        "Content-Type": "application/json",
        ...options?.token && { Authorization: `Bearer ${options?.token}` }
      },
      method: "POST",
      body: JSON.stringify(request.body)
    });
  }
  /**
   * Get a task by ID.
   * @param taskId -
   */
  async getTask(request, options) {
    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId.pluginId);
    const uriTemplate = `/v2/tasks/{taskId}`;
    const uri = parser__namespace.parse(uriTemplate).expand({
      taskId: request.path.taskId
    });
    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {
      headers: {
        "Content-Type": "application/json",
        ...options?.token && { Authorization: `Bearer ${options?.token}` }
      },
      method: "GET"
    });
  }
  /**
   * Get template parameter schema.
   * @param namespace -
   * @param kind -
   * @param name -
   */
  async getTemplateParameterSchema(request, options) {
    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId.pluginId);
    const uriTemplate = `/v2/templates/{namespace}/{kind}/{name}/parameter-schema`;
    const uri = parser__namespace.parse(uriTemplate).expand({
      namespace: request.path.namespace,
      kind: request.path.kind,
      name: request.path.name
    });
    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {
      headers: {
        "Content-Type": "application/json",
        ...options?.token && { Authorization: `Bearer ${options?.token}` }
      },
      method: "GET"
    });
  }
  /**
   * Returns a list of all installed actions.
   */
  async listActions(request, options) {
    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId.pluginId);
    const uriTemplate = `/v2/actions`;
    const uri = parser__namespace.parse(uriTemplate).expand({});
    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {
      headers: {
        "Content-Type": "application/json",
        ...options?.token && { Authorization: `Bearer ${options?.token}` }
      },
      method: "GET"
    });
  }
  /**
   * Returns a list of tasks, filtering by ownership and/or status if given.
   * @param createdBy - Created by
   * @param limit - Number of records to return in the response.
   * @param offset - Number of records to skip in the query page.
   * @param order - Order
   * @param status - Status
   */
  async listTasks(request, options) {
    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId.pluginId);
    const uriTemplate = `/v2/tasks{?createdBy*,limit,offset,order*,status*}`;
    const uri = parser__namespace.parse(uriTemplate).expand({
      ...request.query
    });
    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {
      headers: {
        "Content-Type": "application/json",
        ...options?.token && { Authorization: `Bearer ${options?.token}` }
      },
      method: "GET"
    });
  }
  /**
   * Returns a structure describing the available templating extensions.
   */
  async listTemplatingExtensions(request, options) {
    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId.pluginId);
    const uriTemplate = `/v2/templating-extensions`;
    const uri = parser__namespace.parse(uriTemplate).expand({});
    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {
      headers: {
        "Content-Type": "application/json",
        ...options?.token && { Authorization: `Bearer ${options?.token}` }
      },
      method: "GET"
    });
  }
  /**
   * Starts the task again from the point where it failed.
   * @param taskId -
   * @param retryRequest -
   */
  async retry(request, options) {
    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId.pluginId);
    const uriTemplate = `/v2/tasks/{taskId}/retry`;
    const uri = parser__namespace.parse(uriTemplate).expand({
      taskId: request.path.taskId
    });
    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {
      headers: {
        "Content-Type": "application/json",
        ...options?.token && { Authorization: `Bearer ${options?.token}` }
      },
      method: "POST",
      body: JSON.stringify(request.body)
    });
  }
  /**
   * Executes the scaffolding of a component, given a template and its parameter values.
   * @param scaffolderScaffoldOptions -
   */
  async scaffold(request, options) {
    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId.pluginId);
    const uriTemplate = `/v2/tasks`;
    const uri = parser__namespace.parse(uriTemplate).expand({});
    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {
      headers: {
        "Content-Type": "application/json",
        ...options?.token && { Authorization: `Bearer ${options?.token}` }
      },
      method: "POST",
      body: JSON.stringify(request.body)
    });
  }
  /**
   * Get events for a task by ID.
   * @param taskId -
   * @param after - Offset event ID to stream events after.
   */
  async streamLogsPolling(request, options) {
    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId.pluginId);
    const uriTemplate = `/v2/tasks/{taskId}/events{?after}`;
    const uri = parser__namespace.parse(uriTemplate).expand({
      taskId: request.path.taskId,
      ...request.query
    });
    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {
      headers: {
        "Content-Type": "application/json",
        ...options?.token && { Authorization: `Bearer ${options?.token}` }
      },
      method: "GET"
    });
  }
}

exports.DefaultApiClient = DefaultApiClient;
//# sourceMappingURL=Api.client.cjs.js.map
