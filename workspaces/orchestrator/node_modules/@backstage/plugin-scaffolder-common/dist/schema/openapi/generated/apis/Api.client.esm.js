import crossFetch from 'cross-fetch';
import { pluginId } from '../pluginId.esm.js';
import * as parser from 'uri-template';

class DefaultApiClient {
  discoveryApi;
  fetchApi;
  constructor(options) {
    this.discoveryApi = options.discoveryApi;
    this.fetchApi = options.fetchApi || { fetch: crossFetch };
  }
  /**
   * Perform an autocomplete for the given provider and resource.
   * @param provider -
   * @param resource -
   * @param autocompleteRequest -
   */
  async autocomplete(request, options) {
    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId);
    const uriTemplate = `/v2/autocomplete/{provider}/{resource}`;
    const uri = parser.parse(uriTemplate).expand({
      provider: request.path.provider,
      resource: request.path.resource
    });
    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {
      headers: {
        "Content-Type": "application/json",
        ...options?.token && { Authorization: `Bearer ${options?.token}` }
      },
      method: "POST",
      body: JSON.stringify(request.body)
    });
  }
  /**
   * Sends a signal to a task broker to cancel the running task by taskId.
   * @param taskId -
   */
  async cancelTask(request, options) {
    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId);
    const uriTemplate = `/v2/tasks/{taskId}/cancel`;
    const uri = parser.parse(uriTemplate).expand({
      taskId: request.path.taskId
    });
    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {
      headers: {
        "Content-Type": "application/json",
        ...options?.token && { Authorization: `Bearer ${options?.token}` }
      },
      method: "POST"
    });
  }
  /**
   * Perform a dry-run of a template
   * @param dryRunRequest -
   */
  async dryRun(request, options) {
    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId);
    const uriTemplate = `/v2/dry-run`;
    const uri = parser.parse(uriTemplate).expand({});
    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {
      headers: {
        "Content-Type": "application/json",
        ...options?.token && { Authorization: `Bearer ${options?.token}` }
      },
      method: "POST",
      body: JSON.stringify(request.body)
    });
  }
  /**
   * Get a task by ID.
   * @param taskId -
   */
  async getTask(request, options) {
    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId);
    const uriTemplate = `/v2/tasks/{taskId}`;
    const uri = parser.parse(uriTemplate).expand({
      taskId: request.path.taskId
    });
    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {
      headers: {
        "Content-Type": "application/json",
        ...options?.token && { Authorization: `Bearer ${options?.token}` }
      },
      method: "GET"
    });
  }
  /**
   * Get template parameter schema.
   * @param namespace -
   * @param kind -
   * @param name -
   */
  async getTemplateParameterSchema(request, options) {
    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId);
    const uriTemplate = `/v2/templates/{namespace}/{kind}/{name}/parameter-schema`;
    const uri = parser.parse(uriTemplate).expand({
      namespace: request.path.namespace,
      kind: request.path.kind,
      name: request.path.name
    });
    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {
      headers: {
        "Content-Type": "application/json",
        ...options?.token && { Authorization: `Bearer ${options?.token}` }
      },
      method: "GET"
    });
  }
  /**
   * Returns a list of all installed actions.
   */
  async listActions(request, options) {
    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId);
    const uriTemplate = `/v2/actions`;
    const uri = parser.parse(uriTemplate).expand({});
    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {
      headers: {
        "Content-Type": "application/json",
        ...options?.token && { Authorization: `Bearer ${options?.token}` }
      },
      method: "GET"
    });
  }
  /**
   * Returns a list of tasks, filtering by ownership and/or status if given.
   * @param createdBy - Created by
   * @param limit - Number of records to return in the response.
   * @param offset - Number of records to skip in the query page.
   * @param order - Order
   * @param status - Status
   */
  async listTasks(request, options) {
    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId);
    const uriTemplate = `/v2/tasks{?createdBy*,limit,offset,order*,status*}`;
    const uri = parser.parse(uriTemplate).expand({
      ...request.query
    });
    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {
      headers: {
        "Content-Type": "application/json",
        ...options?.token && { Authorization: `Bearer ${options?.token}` }
      },
      method: "GET"
    });
  }
  /**
   * Returns a structure describing the available templating extensions.
   */
  async listTemplatingExtensions(request, options) {
    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId);
    const uriTemplate = `/v2/templating-extensions`;
    const uri = parser.parse(uriTemplate).expand({});
    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {
      headers: {
        "Content-Type": "application/json",
        ...options?.token && { Authorization: `Bearer ${options?.token}` }
      },
      method: "GET"
    });
  }
  /**
   * Starts the task again from the point where it failed.
   * @param taskId -
   * @param retryRequest -
   */
  async retry(request, options) {
    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId);
    const uriTemplate = `/v2/tasks/{taskId}/retry`;
    const uri = parser.parse(uriTemplate).expand({
      taskId: request.path.taskId
    });
    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {
      headers: {
        "Content-Type": "application/json",
        ...options?.token && { Authorization: `Bearer ${options?.token}` }
      },
      method: "POST",
      body: JSON.stringify(request.body)
    });
  }
  /**
   * Executes the scaffolding of a component, given a template and its parameter values.
   * @param scaffolderScaffoldOptions -
   */
  async scaffold(request, options) {
    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId);
    const uriTemplate = `/v2/tasks`;
    const uri = parser.parse(uriTemplate).expand({});
    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {
      headers: {
        "Content-Type": "application/json",
        ...options?.token && { Authorization: `Bearer ${options?.token}` }
      },
      method: "POST",
      body: JSON.stringify(request.body)
    });
  }
  /**
   * Get events for a task by ID.
   * @param taskId -
   * @param after - Offset event ID to stream events after.
   */
  async streamLogsPolling(request, options) {
    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId);
    const uriTemplate = `/v2/tasks/{taskId}/events{?after}`;
    const uri = parser.parse(uriTemplate).expand({
      taskId: request.path.taskId,
      ...request.query
    });
    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {
      headers: {
        "Content-Type": "application/json",
        ...options?.token && { Authorization: `Bearer ${options?.token}` }
      },
      method: "GET"
    });
  }
}

export { DefaultApiClient };
//# sourceMappingURL=Api.client.esm.js.map
