import { EntityMeta, UserEntity, KindValidator, Entity } from '@backstage/catalog-model';
import { JsonObject, JsonArray, JsonValue, Observable } from '@backstage/types';
import { ScmIntegrationRegistry } from '@backstage/integration';
import { JSONSchema7 } from 'json-schema';

/**
 * Information about a template that is stored on a task specification.
 * Includes a stringified entityRef, and the baseUrl which is usually the relative path of the template definition
 *
 * @public
 */
type TemplateInfo = {
    /**
     * The entityRef of the template
     */
    entityRef: string;
    /**
     * Where the template is stored, so we can resolve relative paths for things like `fetch:template` paths.
     */
    baseUrl?: string;
    /**
     * the Template entity
     */
    entity?: {
        /**
         * The metadata of the Template
         */
        metadata: EntityMeta;
    };
};
/**
 *
 * none - not recover, let the task be marked as failed
 * startOver - do recover, start the execution of the task from the first step.
 *
 * @public
 */
type TaskRecoverStrategy = 'none' | 'startOver';
/**
 * When task didn't have a chance to complete due to system restart you can define the strategy what to do with such tasks,
 * by defining a strategy.
 *
 * By default, it is none, what means to not recover but updating the status from 'processing' to 'failed'.
 *
 * @public
 */
interface TaskRecovery {
    /**
     * Depends on how you designed your task you might tailor the behaviour for each of them.
     */
    EXPERIMENTAL_strategy?: TaskRecoverStrategy;
}
/**
 * An individual step of a scaffolder task, as stored in the database.
 *
 * @public
 */
interface TaskStep {
    /**
     * A unique identifier for this step.
     */
    id: string;
    /**
     * A display name to show the user.
     */
    name: string;
    /**
     * The underlying action ID that will be called as part of running this step.
     */
    action: string;
    /**
     * Additional data that will be passed to the action.
     */
    input?: JsonObject;
    /**
     * When this is false, or if the templated value string evaluates to something that is falsy the step will be skipped.
     */
    if?: string | boolean;
    /**
     * Run step repeatedly
     */
    each?: string | JsonArray;
}
/**
 * A scaffolder task as stored in the database, generated from a v1beta3
 * apiVersion Template.
 *
 * @public
 */
interface TaskSpecV1beta3 {
    /**
     * The apiVersion string of the TaskSpec.
     */
    apiVersion: 'scaffolder.backstage.io/v1beta3';
    /**
     * This is a JSONSchema which is used to render a form in the frontend
     * to collect user input and validate it against that schema. This can then be used in the `steps` part below to template
     * variables passed from the user into each action in the template.
     */
    parameters: JsonObject;
    /**
     * A list of steps to be executed in sequence which are defined by the template. These steps are a list of the underlying
     * javascript action and some optional input parameters that may or may not have been collected from the end user.
     */
    steps: TaskStep[];
    /**
     * The output is an object where template authors can pull out information from template actions and return them in a known standard way.
     */
    output: {
        [name: string]: JsonValue;
    };
    /**
     * Some information about the template that is stored on the task spec.
     */
    templateInfo?: TemplateInfo;
    /**
     * Some decoration of the author of the task that should be available in the context
     */
    user?: {
        /**
         * The decorated entity from the Catalog
         */
        entity?: UserEntity;
        /**
         * An entity ref for the author of the task
         */
        ref?: string;
    };
    /**
     * How to recover the task after system restart or system crash.
     */
    EXPERIMENTAL_recovery?: TaskRecovery;
}
/**
 * A scaffolder task as stored in the database, generated from a Template.
 *
 * @public
 */
type TaskSpec = TaskSpecV1beta3;

/**
 * Backstage catalog Template kind Entity. Templates are used by the Scaffolder
 * plugin to create new entities, such as Components.
 *
 * @public
 */
interface TemplateEntityV1beta3 extends Entity {
    /**
     * The apiVersion string of the TaskSpec.
     */
    apiVersion: 'scaffolder.backstage.io/v1beta3';
    /**
     * The kind of the entity
     */
    kind: 'Template';
    /**
     * The specification of the Template Entity
     */
    spec: {
        /**
         * The type that the Template will create. For example service, website or library.
         */
        type: string;
        /**
         * Template specific configuration of the presentation layer.
         */
        presentation?: TemplatePresentationV1beta3;
        /**
         * Recovery strategy for the template
         */
        EXPERIMENTAL_recovery?: TemplateRecoveryV1beta3;
        /**
         * Form hooks to be run
         */
        EXPERIMENTAL_formDecorators?: {
            id: string;
            input?: JsonObject;
        }[];
        /**
         * This is a JSONSchema or an array of JSONSchema's which is used to render a form in the frontend
         * to collect user input and validate it against that schema. This can then be used in the `steps` part below to template
         * variables passed from the user into each action in the template.
         */
        parameters?: TemplateParametersV1beta3 | TemplateParametersV1beta3[];
        /**
         * A list of steps to be executed in sequence which are defined by the template. These steps are a list of the underlying
         * javascript action and some optional input parameters that may or may not have been collected from the end user.
         */
        steps: Array<TemplateEntityStepV1beta3>;
        /**
         * The output is an object where template authors can pull out information from template actions and return them in a known standard way.
         */
        output?: {
            [name: string]: string;
        };
        /**
         * The owner entityRef of the TemplateEntity
         */
        owner?: string;
        /**
         * Specifies the lifecycle phase of the TemplateEntity
         */
        lifecycle?: string;
    };
}
/**
 * Depends on how you designed your task you might tailor the behaviour for each of them.
 *
 * @public
 */
interface TemplateRecoveryV1beta3 extends JsonObject {
    /**
     *
     * none - not recover, let the task be marked as failed
     * startOver - do recover, start the execution of the task from the first step.
     *
     * @public
     */
    EXPERIMENTAL_strategy?: 'none' | 'startOver';
}
/**
 * The presentation of the template.
 *
 * @public
 */
interface TemplatePresentationV1beta3 extends JsonObject {
    /**
     * Overrides default buttons' text
     */
    buttonLabels?: {
        /**
         * The text for the button which leads to the previous template page
         */
        backButtonText?: string;
        /**
         * The text for the button which starts the execution of the template
         */
        createButtonText?: string;
        /**
         * The text for the button which opens template's review/summary
         */
        reviewButtonText?: string;
    };
}
/**
 * Step that is part of a Template Entity.
 *
 * @public
 */
interface TemplateEntityStepV1beta3 extends JsonObject {
    id?: string;
    name?: string;
    action: string;
    input?: JsonObject;
    if?: string | boolean;
    'backstage:permissions'?: TemplatePermissionsV1beta3;
}
/**
 * The shape of each entry of parameters which gets rendered
 * as a separate step in the wizard input
 *
 * @public
 */
type TemplateParameterSchema = {
    title: string;
    description?: string;
    presentation?: TemplatePresentationV1beta3;
    steps: Array<{
        title: string;
        description?: string;
        schema: JsonObject;
    }>;
    EXPERIMENTAL_formDecorators?: {
        id: string;
        input?: JsonObject;
    }[];
};
/**
 * Parameter that is part of a Template Entity.
 *
 * @public
 */
interface TemplateParametersV1beta3 extends JsonObject {
    'backstage:permissions'?: TemplatePermissionsV1beta3;
}
/**
 *  Access control properties for parts of a template.
 *
 * @public
 */
interface TemplatePermissionsV1beta3 extends JsonObject {
    tags?: string[];
}
/**
 * Entity data validator for {@link TemplateEntityV1beta3}.
 *
 * @public
 */
declare const templateEntityV1beta3Validator: KindValidator;
/**
 * Typeguard for filtering entities and ensuring v1beta3 entities
 * @public
 */
declare const isTemplateEntityV1beta3: (entity: Entity) => entity is TemplateEntityV1beta3;

/**
 * @public
 */
type TaskStatus = 'cancelled' | 'completed' | 'failed' | 'open' | 'processing' | 'skipped';

/**
 * @public
 */
type TaskEventType = 'cancelled' | 'completion' | 'log' | 'recovered';

/**
 * Options you can pass into a Scaffolder request for additional information.
 *
 * @public
 */
interface ScaffolderRequestOptions {
    token?: string;
}
/**
 * The shape of each task returned from the `scaffolder-backend`
 *
 * @public
 */
type ScaffolderTask = {
    id: string;
    spec: TaskSpec;
    status: TaskStatus;
    lastHeartbeatAt?: string;
    createdAt: string;
};
/**
 * A single scaffolder usage example
 *
 * @public
 */
type ScaffolderUsageExample = {
    description?: string;
    example: string;
    notes?: string;
};
/**
 * The response shape for a single action in the `listActions` call to the `scaffolder-backend`
 *
 * @public
 */
type Action = {
    id: string;
    description?: string;
    schema?: {
        input?: JSONSchema7;
        output?: JSONSchema7;
    };
    examples?: ScaffolderUsageExample[];
};
/**
 * The response shape for the `listActions` call to the `scaffolder-backend`
 *
 * @public
 */
type ListActionsResponse = Array<Action>;
/**
 * The response shape for a single filter in the `listTemplatingExtensions` call to the `scaffolder-backend`
 *
 * @public
 */
type TemplateFilter = {
    description?: string;
    schema?: {
        input?: JSONSchema7;
        arguments?: JSONSchema7[];
        output?: JSONSchema7;
    };
    examples?: ScaffolderUsageExample[];
};
/**
 * The response shape for a single global function in the `listTemplatingExtensions` call to the `scaffolder-backend`
 *
 * @public
 */
type TemplateGlobalFunction = {
    description?: string;
    schema?: {
        arguments?: JSONSchema7[];
        output?: JSONSchema7;
    };
    examples?: ScaffolderUsageExample[];
};
/**
 * The response shape for a single global value in the `listTemplatingExtensions` call to the `scaffolder-backend`
 *
 * @public
 */
type TemplateGlobalValue = {
    description?: string;
    value: JsonValue;
};
/**
 * The response shape for the `listTemplatingExtensions` call to the `scaffolder-backend`
 *
 * @public
 */
type ListTemplatingExtensionsResponse = {
    filters: Record<string, TemplateFilter>;
    globals: {
        functions: Record<string, TemplateGlobalFunction>;
        values: Record<string, TemplateGlobalValue>;
    };
};
/** @public */
type ScaffolderOutputLink = {
    title?: string;
    icon?: string;
    url?: string;
    entityRef?: string;
};
/** @public */
type ScaffolderOutputText = {
    title?: string;
    icon?: string;
    content?: string;
    default?: boolean;
};
/** @public */
type ScaffolderTaskOutput = {
    links?: ScaffolderOutputLink[];
    text?: ScaffolderOutputText[];
} & {
    [key: string]: unknown;
};
/**
 * The shape of a `LogEvent` message from the `scaffolder-backend`
 *
 * @public
 */
type LogEvent = {
    type: TaskEventType;
    body: {
        message: string;
        stepId?: string;
        status?: TaskStatus;
    };
    createdAt: string;
    id: number;
    taskId: string;
};
/**
 * The input options to the `scaffold` method of the `ScaffolderClient`.
 *
 * @public
 */
interface ScaffolderScaffoldOptions {
    templateRef: string;
    values: Record<string, JsonValue>;
    secrets?: Record<string, string>;
}
/**
 * The response shape of the `scaffold` method of the `ScaffolderClient`.
 *
 * @public
 */
interface ScaffolderScaffoldResponse {
    taskId: string;
}
/**
 * The arguments for `getIntegrationsList`.
 *
 * @public
 */
interface ScaffolderGetIntegrationsListOptions {
    allowedHosts: string[];
}
/**
 * The response shape for `getIntegrationsList`.
 *
 * @public
 */
interface ScaffolderGetIntegrationsListResponse {
    integrations: {
        type: string;
        title: string;
        host: string;
    }[];
}
/**
 * The input options to the `streamLogs` method of the `ScaffolderClient`.
 *
 * @public
 */
interface ScaffolderStreamLogsOptions {
    isTaskRecoverable?: boolean;
    taskId: string;
    after?: number;
}
/** @public */
interface ScaffolderDryRunOptions {
    template: TemplateEntityV1beta3;
    values: JsonObject;
    secrets?: Record<string, string>;
    directoryContents: {
        path: string;
        base64Content: string;
    }[];
}
/** @public */
interface ScaffolderDryRunResponse {
    directoryContents: Array<{
        path: string;
        base64Content: string;
        executable?: boolean;
    }>;
    log: Array<Pick<LogEvent, 'body'>>;
    steps: TaskStep[];
    output: ScaffolderTaskOutput;
}
/**
 * An API to interact with the scaffolder backend.
 *
 * @public
 */
interface ScaffolderApi {
    getTemplateParameterSchema(templateRef: string, options?: ScaffolderRequestOptions): Promise<TemplateParameterSchema>;
    /**
     * Executes the scaffolding of a component, given a template and its
     * parameter values.
     *
     * @param options - The {@link ScaffolderScaffoldOptions} the scaffolding.
     */
    scaffold(request: ScaffolderScaffoldOptions, options?: ScaffolderRequestOptions): Promise<ScaffolderScaffoldResponse>;
    getTask(taskId: string, options?: ScaffolderRequestOptions): Promise<ScaffolderTask>;
    /**
     * Sends a signal to a task broker to cancel the running task by taskId.
     *
     * @param taskId - the id of the task
     */
    cancelTask(taskId: string, options?: ScaffolderRequestOptions): Promise<{
        status?: TaskStatus;
    }>;
    /**
     * Starts the task again from the point where it failed.
     *
     * @param taskId - the id of the task
     */
    retry?(taskId: string, options?: ScaffolderRequestOptions): Promise<{
        id: string;
    }>;
    listTasks?(request: {
        filterByOwnership: 'owned' | 'all';
        limit?: number;
        offset?: number;
    }, options?: ScaffolderRequestOptions): Promise<{
        tasks: ScaffolderTask[];
        totalTasks?: number;
    }>;
    getIntegrationsList(options: ScaffolderGetIntegrationsListOptions): Promise<ScaffolderGetIntegrationsListResponse>;
    /**
     * Returns a list of all installed actions.
     */
    listActions(options?: ScaffolderRequestOptions): Promise<ListActionsResponse>;
    /**
     * Returns a structure describing the available templating extensions.
     */
    listTemplatingExtensions?(options?: ScaffolderRequestOptions): Promise<ListTemplatingExtensionsResponse>;
    streamLogs(request: ScaffolderStreamLogsOptions, options?: ScaffolderRequestOptions): Observable<LogEvent>;
    dryRun?(request: ScaffolderDryRunOptions, options?: ScaffolderRequestOptions): Promise<ScaffolderDryRunResponse>;
    autocomplete?(request: {
        token: string;
        provider: string;
        resource: string;
        context: Record<string, string>;
    }, options?: ScaffolderRequestOptions): Promise<{
        results: {
            title?: string;
            id: string;
        }[];
    }>;
}

/**
 * An API to interact with the scaffolder backend.
 *
 * @public
 */
declare class ScaffolderClient implements ScaffolderApi {
    private readonly apiClient;
    private readonly discoveryApi;
    private readonly scmIntegrationsApi;
    private readonly fetchApi;
    private readonly identityApi?;
    private readonly useLongPollingLogs;
    constructor(options: {
        discoveryApi: {
            getBaseUrl(pluginId: string): Promise<string>;
        };
        fetchApi: {
            fetch: typeof fetch;
        };
        identityApi?: {
            getBackstageIdentity(): Promise<{
                type: 'user';
                userEntityRef: string;
                ownershipEntityRefs: string[];
            }>;
        };
        scmIntegrationsApi: ScmIntegrationRegistry;
        useLongPollingLogs?: boolean;
    });
    /**
     * {@inheritdoc ScaffolderApi.listTasks}
     */
    listTasks(request: {
        filterByOwnership: 'owned' | 'all';
        limit?: number;
        offset?: number;
    }, options?: ScaffolderRequestOptions): Promise<{
        tasks: ScaffolderTask[];
        totalTasks?: number;
    }>;
    getIntegrationsList(options: ScaffolderGetIntegrationsListOptions): Promise<ScaffolderGetIntegrationsListResponse>;
    /**
     * {@inheritdoc ScaffolderApi.getTemplateParameterSchema}
     */
    getTemplateParameterSchema(templateRef: string, options?: ScaffolderRequestOptions): Promise<TemplateParameterSchema>;
    /**
     * {@inheritdoc ScaffolderApi.scaffold}
     */
    scaffold(request: ScaffolderScaffoldOptions, options?: ScaffolderRequestOptions): Promise<ScaffolderScaffoldResponse>;
    /**
     * {@inheritdoc ScaffolderApi.getTask}
     */
    getTask(taskId: string, options?: ScaffolderRequestOptions): Promise<ScaffolderTask>;
    /**
     * {@inheritdoc ScaffolderApi.streamLogs}
     */
    streamLogs(request: ScaffolderStreamLogsOptions, options?: ScaffolderRequestOptions): Observable<LogEvent>;
    /**
     * {@inheritdoc ScaffolderApi.dryRun}
     */
    dryRun(request: ScaffolderDryRunOptions, options?: ScaffolderRequestOptions): Promise<ScaffolderDryRunResponse>;
    private streamLogsEventStream;
    private streamLogsPolling;
    /**
     * {@inheritdoc ScaffolderApi.listActions}
     */
    listActions(options?: ScaffolderRequestOptions): Promise<ListActionsResponse>;
    /**
     * {@inheritdoc ScaffolderApi.listTemplatingExtensions}
     */
    listTemplatingExtensions(options?: ScaffolderRequestOptions): Promise<ListTemplatingExtensionsResponse>;
    /**
     * {@inheritdoc ScaffolderApi.cancelTask}
     */
    cancelTask(taskId: string, options?: ScaffolderRequestOptions): Promise<{
        status?: TaskStatus;
    }>;
    /**
     * {@inheritdoc ScaffolderApi.retry}
     */
    retry?(taskId: string, options?: ScaffolderRequestOptions): Promise<{
        id: string;
    }>;
    /**
     * {@inheritdoc ScaffolderApi.retry}
     */
    autocomplete({ token, resource, provider, context, }: {
        token: string;
        provider: string;
        resource: string;
        context: Record<string, string>;
    }): Promise<{
        results: {
            title?: string;
            id: string;
        }[];
    }>;
    private requestRequired;
}

export { type Action, type ListActionsResponse, type ListTemplatingExtensionsResponse, type LogEvent, type ScaffolderApi, ScaffolderClient, type ScaffolderDryRunOptions, type ScaffolderDryRunResponse, type ScaffolderGetIntegrationsListOptions, type ScaffolderGetIntegrationsListResponse, type ScaffolderOutputLink, type ScaffolderOutputText, type ScaffolderRequestOptions, type ScaffolderScaffoldOptions, type ScaffolderScaffoldResponse, type ScaffolderStreamLogsOptions, type ScaffolderTask, type ScaffolderTaskOutput, type TaskStatus as ScaffolderTaskStatus, type ScaffolderUsageExample, type TaskEventType, type TaskRecoverStrategy, type TaskRecovery, type TaskSpec, type TaskSpecV1beta3, type TaskStep, type TemplateEntityStepV1beta3, type TemplateEntityV1beta3, type TemplateFilter, type TemplateGlobalFunction, type TemplateGlobalValue, type TemplateInfo, type TemplateParameterSchema, type TemplateParametersV1beta3, type TemplatePermissionsV1beta3, type TemplatePresentationV1beta3, type TemplateRecoveryV1beta3, isTemplateEntityV1beta3, templateEntityV1beta3Validator };
