{"version":3,"file":"validation.cjs.js","sources":["../../src/schema/validation.ts"],"sourcesContent":["/*\n * Copyright 2024 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { CompletedRequest, CompletedResponse } from 'mockttp';\nimport { OpenAPIObject, OperationObject } from 'openapi3-ts';\nimport Ajv from 'ajv';\nimport Parser from '@apidevtools/swagger-parser';\nimport { Operation, Validator, ValidatorParams } from './types';\nimport { ParameterValidator } from './parameter-validation';\nimport { OperationError } from './errors';\nimport { RequestBodyParser } from './request-body-validation';\nimport { mockttpToFetchRequest, mockttpToFetchResponse } from './utils';\nimport { ResponseBodyParser } from './response-body-validation';\n\nconst ajv = new Ajv({ allErrors: true });\n\nclass RequestBodyValidator implements Validator {\n  schema: OpenAPIObject;\n  constructor(schema: OpenAPIObject) {\n    this.schema = schema;\n  }\n\n  async validate({ pair, operation }: ValidatorParams) {\n    const { request, response } = pair;\n    if (response.statusCode === 400) {\n      // If the response is a 400, then the request is invalid and we shouldn't validate the parameters\n      return;\n    }\n\n    // NOTE: There may be a worthwhile optimization here to cache these results to avoid re-parsing the schema for every request. As is, I don't think this is a big deal.\n    const parser = RequestBodyParser.fromOperation(operation, { ajv });\n    const fetchRequest = mockttpToFetchRequest(request);\n    await parser.parse(fetchRequest);\n  }\n}\n\nclass ResponseBodyValidator implements Validator {\n  schema: OpenAPIObject;\n  constructor(schema: OpenAPIObject) {\n    this.schema = schema;\n  }\n\n  async validate({ pair, operation }: ValidatorParams) {\n    const { response } = pair;\n    // NOTE: There may be a worthwhile optimization here to cache these results to avoid re-parsing the schema for every request. As is, I don't think this is a big deal.\n    const parser = ResponseBodyParser.fromOperation(operation, { ajv });\n    const fetchResponse = mockttpToFetchResponse(response);\n    await parser.parse(fetchResponse);\n  }\n}\n\n/**\n * Find an operation in an OpenAPI schema that matches a request. This is done by comparing the request URL to the paths in the schema.\n * @param openApiSchema - The OpenAPI schema to search for the operation in.\n * @param request - The request to find the operation for.\n * @returns A tuple of the path and the operation object that matches the request.\n */\nexport function findOperationByRequest(\n  openApiSchema: OpenAPIObject,\n  request: CompletedRequest,\n): [string, OperationObject] | undefined {\n  const { url } = request;\n  const { pathname } = new URL(url);\n\n  const parts = pathname.split('/');\n  for (const [path, schema] of Object.entries(openApiSchema.paths)) {\n    const pathParts = path.split('/');\n    if (parts.length !== pathParts.length) {\n      continue;\n    }\n    let found = true;\n    for (let i = 0; i < parts.length; i++) {\n      if (pathParts[i] === parts[i]) {\n        continue;\n      }\n      // If the path part is a parameter, we can count it as a match. eg /api/{id} will match /api/1\n      if (pathParts[i].startsWith('{') && pathParts[i].endsWith('}')) {\n        continue;\n      }\n      found = false;\n      break;\n    }\n    if (!found) {\n      continue;\n    }\n    let matchingOperationType: OperationObject | undefined = undefined;\n    for (const [operationType, operation] of Object.entries(schema)) {\n      if (operationType === request.method.toLowerCase()) {\n        matchingOperationType = operation as OperationObject;\n        break;\n      }\n    }\n    if (!matchingOperationType) {\n      continue;\n    }\n    return [path, matchingOperationType];\n  }\n\n  return undefined;\n}\n\nexport class OpenApiProxyValidator {\n  schema: OpenAPIObject | undefined;\n  validators: Validator[] | undefined;\n\n  async initialize(url: string) {\n    this.schema = (await Parser.dereference(url)) as unknown as OpenAPIObject;\n    this.validators = [\n      new ParameterValidator(this.schema),\n      new RequestBodyValidator(this.schema),\n      new ResponseBodyValidator(this.schema),\n    ];\n  }\n\n  async validate(request: CompletedRequest, response: CompletedResponse) {\n    const operationPathTuple = findOperationByRequest(this.schema!, request);\n    if (!operationPathTuple) {\n      throw new OperationError(\n        { path: request.path, method: request.method } as Operation,\n        `No operation schema found for ${request.url}`,\n      );\n    }\n\n    const [path, operationSchema] = operationPathTuple;\n    const operation = { path, method: request.method, schema: operationSchema };\n\n    const validators = this.validators!;\n    await Promise.all(\n      validators.map(validator =>\n        validator.validate({\n          pair: { request, response },\n          operation,\n        }),\n      ),\n    );\n  }\n}\n"],"names":["Ajv","RequestBodyParser","mockttpToFetchRequest","ResponseBodyParser","mockttpToFetchResponse","Parser","ParameterValidator","OperationError"],"mappings":"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"}