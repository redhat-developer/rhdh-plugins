{"version":3,"file":"parameter-validation.cjs.js","sources":["../../src/schema/parameter-validation.ts"],"sourcesContent":["/*\n * Copyright 2024 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { OpenAPIObject, ParameterObject, SchemaObject } from 'openapi3-ts';\nimport {\n  Operation,\n  ParserOptions,\n  RequestParser,\n  Validator,\n  ValidatorParams,\n} from './types';\nimport Ajv from 'ajv';\nimport { OperationError, OperationParsingError } from './errors';\nimport { mockttpToFetchRequest } from './utils';\n\ntype ReferencelessSchemaObject = SchemaObject & { $ref?: never };\n\ntype ReferencelessParameterObject = Omit<ParameterObject, 'schema'> & {\n  schema: ReferencelessSchemaObject;\n};\n\nclass BaseParameterParser {\n  ajv: Ajv;\n  operation: Operation;\n  parameters: Record<string, ReferencelessParameterObject> = {};\n  constructor(\n    parameterIn: string,\n    operation: Operation,\n    options: ParserOptions,\n  ) {\n    this.ajv = options.ajv;\n    this.operation = operation;\n    const { schema, path, method } = operation;\n    const parameters = schema.parameters || [];\n    for (const parameter of parameters) {\n      if ('$ref' in parameter) {\n        throw new Error(\n          `[(${method}) ${path}] Reference objects are not supported`,\n        );\n      }\n\n      if (!parameter.schema) {\n        throw new OperationError(\n          operation,\n          'Schema not found for path parameter',\n        );\n      }\n      if ('$ref' in parameter.schema) {\n        throw new OperationError(\n          this.operation,\n          'Reference objects are not supported for parameters',\n        );\n      }\n      if (parameter.in === parameterIn) {\n        this.parameters[parameter.name] =\n          parameter as ReferencelessParameterObject;\n      }\n    }\n  }\n\n  /**\n   * Attempt to transform a string value to its expected type, this allows Ajv to perform validation. As these are parameters,\n   *  support for edge cases like nested type casting is not currently supported.\n   * @param value\n   * @param schema\n   * @returns\n   */\n  optimisticallyParseValue(value: string, schema: SchemaObject) {\n    if (schema.type === 'integer') {\n      return parseInt(value, 10);\n    }\n    if (schema.type === 'number') {\n      return parseFloat(value);\n    }\n    if (schema.type === 'boolean') {\n      if (['true', 'false'].includes(value)) {\n        return value === 'true';\n      }\n      throw new Error('Invalid boolean value must be either \"true\" or \"false\"');\n    }\n    return value;\n  }\n}\n\nexport class QueryParameterParser\n  extends BaseParameterParser\n  implements RequestParser<Record<string, any>>\n{\n  constructor(operation: Operation, options: ParserOptions) {\n    super('query', operation, options);\n  }\n  async parse(request: Request) {\n    const { searchParams } = new URL(request.url);\n    const remainingQueryParameters = new Set<string>(searchParams.keys());\n    const queryParameters: Record<string, any> = {};\n\n    let parameterIterator = Object.entries(this.parameters);\n\n    const isFormExplode = (parameter: ReferencelessParameterObject) => {\n      return (\n        parameter.schema?.type === 'object' &&\n        (parameter.style === 'form' || !parameter.style) &&\n        parameter.explode\n      );\n    };\n\n    const regularParameters = parameterIterator.filter(\n      ([_, parameter]) => !isFormExplode(parameter),\n    );\n\n    const formExplodeParameters = parameterIterator.filter(([_, parameter]) =>\n      isFormExplode(parameter),\n    );\n\n    if (formExplodeParameters.length > 1) {\n      throw new OperationError(\n        this.operation,\n        'Ambiguous query parameters, you cannot have 2 form explode parameters',\n      );\n    }\n\n    // Sort the parameters so that form explode parameters are processed last.\n    parameterIterator = [...regularParameters, ...formExplodeParameters];\n\n    for (const [name, parameter] of parameterIterator) {\n      if (!parameter.schema) {\n        throw new OperationError(\n          this.operation,\n          'Schema not found for query parameter',\n        );\n      }\n      if ('$ref' in parameter.schema) {\n        throw new OperationError(\n          this.operation,\n          'Reference objects are not supported for parameters',\n        );\n      }\n      // eslint-disable-next-line prefer-const\n      let [param, indices]: [any | null, string[]] = this.#findQueryParameters(\n        this.parameters,\n        remainingQueryParameters,\n        searchParams,\n        name,\n      );\n      if (!!param) {\n        indices.forEach(index => remainingQueryParameters.delete(index));\n      }\n\n      // The query parameters can be either a single value or an array of values, try to wrangle them into the expected format if they're not explicitly an array.\n      if (parameter.schema.type !== 'array' && Array.isArray(param)) {\n        param = param.length > 0 ? param[0] : undefined;\n      }\n      if (\n        parameter.required &&\n        !indices.some(index => searchParams.has(index))\n      ) {\n        throw new OperationError(\n          this.operation,\n          `Required query parameter ${name} not found`,\n        );\n      } else if (!param && !parameter.required) {\n        continue;\n      }\n      if (param) {\n        // We do this here because all query parameters are strings but the schema will expect the real value.\n        param = this.optimisticallyParseValue(param, parameter.schema);\n      }\n      const validate = this.ajv.compile(parameter.schema);\n      const valid = validate(param);\n      if (!valid) {\n        throw new OperationParsingError(\n          this.operation,\n          'Query parameter',\n          validate.errors!,\n        );\n      }\n      queryParameters[name] = param;\n    }\n    if (remainingQueryParameters.size > 0) {\n      throw new OperationError(\n        this.operation,\n        `Unexpected query parameters: ${Array.from(\n          remainingQueryParameters,\n        ).join(', ')}`,\n      );\n    }\n    return queryParameters;\n  }\n\n  #findQueryParameters(\n    parameters: Record<string, ParameterObject>,\n    remainingQueryParameters: Set<string>,\n    searchParams: URLSearchParams,\n    name: string,\n  ): [any | null, string[]] {\n    const parameter = parameters[name];\n    const schema = parameter.schema as SchemaObject;\n\n    // Since getAll will return an empty array if the key is not found, we need to check if the key exists first.\n    const getIfExists = (key: string) =>\n      searchParams.has(key) ? searchParams.getAll(key) : null;\n\n    if (schema.type === 'array') {\n      // Form is the default array format.\n      if (\n        parameter.style === 'form' ||\n        typeof parameter.style === 'undefined'\n      ) {\n        // As is explode = true.\n        if (parameter.explode || typeof parameter.explode === 'undefined') {\n          // Support for qs explode format. Every value is stored as a separate query parameter.\n          if (!searchParams.has(name) && searchParams.has(`${name}[0]`)) {\n            const values: string[] = [];\n            const indices: string[] = [];\n            let index = 0;\n            while (searchParams.has(`${name}[${index}]`)) {\n              values.push(searchParams.get(`${name}[${index}]`)!);\n              indices.push(`${name}[${index}]`);\n              index++;\n            }\n            return [values, indices];\n          }\n          // If not qs format, grab all values with the same name from search params.\n          return [getIfExists(name), [name]];\n        }\n        // Add support for qs non-standard array format. This is helpful for search-backend, since that uses qs still.\n        if (!searchParams.has(name) && searchParams.has(`${name}[]`)) {\n          return [searchParams.get(`${name}[]`)?.split(','), [`${name}[]`]];\n        }\n        // Non-explode arrays should be comma separated.\n        if (searchParams.has(name) && searchParams.getAll(name).length > 1) {\n          throw new OperationError(\n            this.operation,\n            'Arrays must be comma separated in non-explode mode',\n          );\n        }\n        return [searchParams.get(name)?.split(','), [name]];\n      } else if (parameter.style === 'spaceDelimited') {\n        return [searchParams.get(name)?.split(' '), [name]];\n      } else if (parameter.style === 'pipeDelimited') {\n        return [searchParams.get(name)?.split('|'), [name]];\n      }\n      throw new OperationError(\n        this.operation,\n        'Unsupported style for array parameter',\n      );\n    }\n    if (schema.type === 'object') {\n      // Form is the default object format.\n      if (\n        parameter.style === 'form' ||\n        typeof parameter.style === 'undefined'\n      ) {\n        if (parameter.explode) {\n          // Object form/explode is a collection of disjoint keys, there's no mapping for what they are so we collect all of them.\n          // This means we need to run this as the last query parameter that is processed.\n          const obj: Record<string, string> = {};\n          const indices: string[] = [];\n          for (const [key, value] of searchParams.entries()) {\n            // Have we processed this query parameter as part of another parameter parsing? If not, consider it to be a part of this object.\n            if (!remainingQueryParameters.has(key)) {\n              continue;\n            }\n            indices.push(key);\n            obj[key] = value;\n          }\n          return [obj, indices];\n        }\n        // For non-explode, the schema is comma separated key,value \"pairs\", so filter=key1,value1,key2,value2 would parse to {key1: value1, key2: value2}.\n        const obj: Record<string, string> = {};\n        const value = searchParams.get(name);\n        if (value) {\n          const parts = value.split(',');\n          if (parts.length % 2 !== 0) {\n            throw new OperationError(\n              this.operation,\n              'Invalid object query parameter, must have an even number of key-value pairs',\n            );\n          }\n          for (let i = 0; i < parts.length; i += 2) {\n            obj[parts[i]] = parts[i + 1];\n          }\n        }\n        return [obj, [name]];\n      } else if (parameter.style === 'deepObject') {\n        // Deep object is a nested object structure, so we need to parse the keys to build the object.\n        // example: ?filter[key1]=value1&filter[key2]=value2 => { key1: value1, key2: value2 }\n        const obj: Record<string, any> = {};\n        const indices: string[] = [];\n        for (const [key, value] of searchParams.entries()) {\n          if (key.startsWith(`${name}[`)) {\n            indices.push(key);\n            const parts = key.split('[');\n            let currentLayer = obj;\n            for (let partIndex = 1; partIndex < parts.length - 1; partIndex++) {\n              const part = parts[partIndex];\n              if (!part.includes(']')) {\n                throw new OperationError(\n                  this.operation,\n                  `Invalid object parameter, missing closing bracket for key \"${key}\"`,\n                );\n              }\n              const objKey = part.split(']')[0];\n              if (!currentLayer[objKey]) {\n                currentLayer[objKey] = {};\n              }\n              currentLayer = currentLayer[objKey];\n            }\n            const lastPart = parts[parts.length - 1];\n            if (!lastPart.includes(']')) {\n              throw new OperationError(\n                this.operation,\n                `Invalid object parameter, missing closing bracket for key \"${key}\"`,\n              );\n            }\n            currentLayer[lastPart.split(']')[0]] = value;\n          }\n        }\n        return [obj, indices];\n      }\n      throw new OperationError(\n        this.operation,\n        `Unsupported style for object parameter, \"${parameter.style}\"`,\n      );\n    }\n    // For everything else, just return the value.\n    return [getIfExists(name), [name]];\n  }\n}\n\nexport class HeaderParameterParser\n  extends BaseParameterParser\n  implements RequestParser<Record<string, any>>\n{\n  constructor(operation: Operation, options: ParserOptions) {\n    super('header', operation, options);\n  }\n  async parse(request: Request) {\n    const headerParameters: Record<string, any> = {};\n    for (const [name, parameter] of Object.entries(this.parameters)) {\n      const header = request.headers.get(name);\n      if (!header) {\n        if (parameter.required) {\n          throw new OperationError(\n            this.operation,\n            `Header parameter ${name} not found`,\n          );\n        }\n        continue;\n      }\n      if (!parameter.schema) {\n        throw new OperationError(\n          this.operation,\n          'Schema not found for header parameter',\n        );\n      }\n      if ('$ref' in parameter.schema) {\n        throw new OperationError(\n          this.operation,\n          'Reference objects are not supported for parameters',\n        );\n      }\n      const validate = this.ajv.compile(parameter.schema);\n      const valid = validate(header);\n\n      if (!valid) {\n        throw new OperationParsingError(\n          this.operation,\n          'Header parameter',\n          validate.errors!,\n        );\n      }\n      headerParameters[name] = header;\n    }\n    return headerParameters;\n  }\n}\n\nexport class PathParameterParser\n  extends BaseParameterParser\n  implements RequestParser<Record<string, any>>\n{\n  constructor(operation: Operation, options: ParserOptions) {\n    super('path', operation, options);\n  }\n  async parse(request: Request) {\n    const { pathname } = new URL(request.url);\n    const params = PathParameterParser.parsePath({\n      operation: this.operation,\n      path: pathname,\n      schema: this.operation.path,\n    });\n    const pathParameters: Record<string, any> = {};\n    for (const [name, parameter] of Object.entries(this.parameters)) {\n      let param: string | number | boolean = params[name];\n      if (!param && parameter.required) {\n        throw new OperationError(\n          this.operation,\n          `Path parameter ${name} not found`,\n        );\n      } else if (!params[name] && !parameter.required) {\n        continue;\n      }\n\n      if (param) {\n        param = this.optimisticallyParseValue(param, parameter.schema);\n      }\n\n      const validate = this.ajv.compile(parameter.schema);\n      const valid = validate(param);\n\n      if (!valid) {\n        throw new OperationParsingError(\n          this.operation,\n          'Path parameter',\n          validate.errors!,\n        );\n      }\n      pathParameters[name] = param;\n    }\n    return pathParameters;\n  }\n\n  static parsePath({\n    operation,\n    schema,\n    path,\n  }: {\n    operation: Operation;\n    schema: string;\n    path: string;\n  }) {\n    const parts = path.split('/');\n    const pathParts = schema.split('/');\n    if (parts.length !== pathParts.length) {\n      throw new OperationError(operation, 'Path parts do not match');\n    }\n    const params: Record<string, string> = {};\n    for (let i = 0; i < parts.length; i++) {\n      if (pathParts[i] === parts[i]) {\n        continue;\n      }\n      if (pathParts[i].startsWith('{') && pathParts[i].endsWith('}')) {\n        params[pathParts[i].slice(1, -1)] = parts[i];\n        continue;\n      }\n      break;\n    }\n    return params;\n  }\n}\n\nexport class ParameterValidator implements Validator {\n  schema: OpenAPIObject;\n  cache: Record<string, any> = {};\n  constructor(schema: OpenAPIObject) {\n    this.schema = schema;\n  }\n\n  async validate({ pair: { request, response }, operation }: ValidatorParams) {\n    if (response.statusCode === 400) {\n      // If the response is a 400, then the request is invalid and we shouldn't validate the parameters\n      return;\n    }\n\n    const ajv = new Ajv();\n    const queryParser = new QueryParameterParser(operation, { ajv });\n    const headerParser = new HeaderParameterParser(operation, { ajv });\n    const pathParser = new PathParameterParser(operation, { ajv });\n\n    const fetchRequest = mockttpToFetchRequest(request);\n\n    await Promise.all([\n      queryParser.parse(fetchRequest),\n      headerParser.parse(fetchRequest),\n      pathParser.parse(fetchRequest),\n    ]);\n  }\n}\n"],"names":["OperationError","OperationParsingError","obj","value","Ajv","mockttpToFetchRequest"],"mappings":"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"}