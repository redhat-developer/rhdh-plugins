'use strict';

var pluginScaffolderNode = require('@backstage/plugin-scaffolder-node');
var util = require('../util.cjs.js');
var gitlabGroupEnsureExists_examples = require('./gitlabGroupEnsureExists.examples.cjs.js');

const createGitlabGroupEnsureExistsAction = (options) => {
  const { integrations } = options;
  return pluginScaffolderNode.createTemplateAction({
    id: "gitlab:group:ensureExists",
    description: "Ensures a Gitlab group exists",
    supportsDryRun: true,
    examples: gitlabGroupEnsureExists_examples.examples,
    schema: {
      input: {
        repoUrl: (z) => z.string({
          description: `Accepts the format 'gitlab.com?repo=project_name&owner=group_name' where 'project_name' is the repository name and 'group_name' is a group or username`
        }),
        token: (z) => z.string({
          description: "The token to use for authorization to GitLab"
        }).optional(),
        path: (z) => z.array(
          z.string().or(
            z.object({
              name: z.string(),
              slug: z.string()
            })
          ),
          {
            description: "A path of group names or objects (name and slug) that is ensured to exist"
          }
        ).min(1)
      },
      output: {
        groupId: (z) => z.number({
          description: "The id of the innermost sub-group"
        }).optional()
      }
    },
    async handler(ctx) {
      if (ctx.isDryRun) {
        ctx.output("groupId", 42);
        return;
      }
      const { token, repoUrl, path } = ctx.input;
      const { host } = util.parseRepoUrl(repoUrl, integrations);
      const api = util.getClient({ host, integrations, token });
      let currentPath = null;
      let parentId = null;
      for (const { name, slug } of pathIterator(path)) {
        const fullPath = currentPath ? `${currentPath}/${slug}` : slug;
        const result = await api.Groups.search(
          fullPath
        );
        const subGroup = result.find(
          (searchPathElem) => searchPathElem.full_path === fullPath
        );
        if (!subGroup) {
          ctx.logger.info(`creating missing group ${fullPath}`);
          parentId = await ctx.checkpoint({
            key: `ensure.${name}.${slug}.${parentId}`,
            // eslint-disable-next-line no-loop-func
            fn: async () => {
              return (await api.Groups.create(
                name,
                slug,
                parentId ? {
                  parentId
                } : {}
              ))?.id;
            }
          });
        } else {
          parentId = subGroup.id;
        }
        currentPath = fullPath;
      }
      if (parentId !== null) {
        ctx.output("groupId", parentId);
      }
    }
  });
};
function* pathIterator(items) {
  for (const item of items) {
    if (typeof item === "string") {
      const parts = item.split("/");
      for (const part of parts) {
        yield { name: part, slug: part };
      }
    } else {
      yield item;
    }
  }
}

exports.createGitlabGroupEnsureExistsAction = createGitlabGroupEnsureExistsAction;
//# sourceMappingURL=gitlabGroupEnsureExists.cjs.js.map
