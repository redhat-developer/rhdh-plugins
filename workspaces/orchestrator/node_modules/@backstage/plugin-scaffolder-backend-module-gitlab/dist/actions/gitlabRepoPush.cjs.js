'use strict';

var path = require('path');
var errors = require('@backstage/errors');
var backendPluginApi = require('@backstage/backend-plugin-api');
var pluginScaffolderNode = require('@backstage/plugin-scaffolder-node');
var helpers = require('./helpers.cjs.js');
var gitlabRepoPush_examples = require('./gitlabRepoPush.examples.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var path__default = /*#__PURE__*/_interopDefaultCompat(path);

const createGitlabRepoPushAction = (options) => {
  const { integrations } = options;
  return pluginScaffolderNode.createTemplateAction({
    id: "gitlab:repo:push",
    examples: gitlabRepoPush_examples.examples,
    schema: {
      input: {
        repoUrl: (z) => z.string({
          description: `Accepts the format 'gitlab.com?repo=project_name&owner=group_name' where 'project_name' is the repository name and 'group_name' is a group or username`
        }),
        branchName: (z) => z.string({
          description: "The branch name for the commit"
        }),
        commitMessage: (z) => z.string({
          description: `The commit message`
        }),
        sourcePath: (z) => z.string({
          description: "Subdirectory of working directory to copy changes from"
        }).optional(),
        targetPath: (z) => z.string({
          description: "Subdirectory of repository to apply changes to"
        }).optional(),
        token: (z) => z.string({
          description: "The token to use for authorization to GitLab"
        }).optional(),
        commitAction: (z) => z.enum(["create", "update", "delete"], {
          description: "The action to be used for git commit. Defaults to create, but can be set to update or delete"
        }).optional()
      },
      output: {
        projectid: (z) => z.string({
          description: "Gitlab Project id/Name(slug)"
        }),
        projectPath: (z) => z.string({
          description: "Gitlab Project path"
        }),
        commitHash: (z) => z.string({
          description: "The git commit hash of the commit"
        })
      }
    },
    async handler(ctx) {
      const {
        branchName,
        repoUrl,
        targetPath,
        sourcePath,
        token,
        commitAction
      } = ctx.input;
      const { owner, repo, project } = pluginScaffolderNode.parseRepoUrl(repoUrl, integrations);
      const repoID = project ? project : `${owner}/${repo}`;
      const api = helpers.createGitlabApi({
        integrations,
        token,
        repoUrl
      });
      let fileRoot;
      if (sourcePath) {
        fileRoot = backendPluginApi.resolveSafeChildPath(ctx.workspacePath, sourcePath);
      } else {
        fileRoot = ctx.workspacePath;
      }
      const fileContents = await pluginScaffolderNode.serializeDirectoryContents(fileRoot, {
        gitignore: true
      });
      const actions = fileContents.map((file) => ({
        action: commitAction ?? "create",
        filePath: targetPath ? path__default.default.posix.join(targetPath, file.path) : file.path,
        encoding: "base64",
        content: file.content.toString("base64"),
        execute_filemode: file.executable
      }));
      const branchExists = await ctx.checkpoint({
        key: `branch.exists.${repoID}.${branchName}`,
        fn: async () => {
          try {
            await api.Branches.show(repoID, branchName);
            return true;
          } catch (e) {
            if (e.cause?.response?.status !== 404) {
              throw new errors.InputError(
                `Failed to check status of branch '${branchName}'. Please make sure that branch already exists or Backstage has permissions to create one. ${helpers.getErrorMessage(
                  e
                )}`
              );
            }
          }
          return false;
        }
      });
      if (!branchExists) {
        try {
          const projects = await api.Projects.show(repoID);
          const { default_branch: defaultBranch } = projects;
          await api.Branches.create(repoID, branchName, String(defaultBranch));
        } catch (e) {
          throw new errors.InputError(
            `The branch '${branchName}' was not found and creation failed with error. Please make sure that branch already exists or Backstage has permissions to create one. ${helpers.getErrorMessage(
              e
            )}`
          );
        }
      }
      try {
        const commitId = await ctx.checkpoint({
          key: `commit.create.${repoID}.${branchName}`,
          fn: async () => {
            const commit = await api.Commits.create(
              repoID,
              branchName,
              ctx.input.commitMessage,
              actions
            );
            return commit.id;
          }
        });
        ctx.output("projectid", repoID);
        ctx.output("projectPath", repoID);
        ctx.output("commitHash", commitId);
      } catch (e) {
        if (commitAction !== "create") {
          throw new errors.InputError(
            `Committing the changes to ${branchName} failed. Please verify that all files you're trying to modify exist in the repository. ${helpers.getErrorMessage(
              e
            )}`
          );
        }
        throw new errors.InputError(
          `Committing the changes to ${branchName} failed. Please check that none of the files created by the template already exists. ${helpers.getErrorMessage(
            e
          )}`
        );
      }
    }
  });
};

exports.createGitlabRepoPushAction = createGitlabRepoPushAction;
//# sourceMappingURL=gitlabRepoPush.cjs.js.map
