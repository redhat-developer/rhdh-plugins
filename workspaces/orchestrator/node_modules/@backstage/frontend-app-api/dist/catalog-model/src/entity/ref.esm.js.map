{"version":3,"file":"ref.esm.js","sources":["../../../../../catalog-model/src/entity/ref.ts"],"sourcesContent":["/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DEFAULT_NAMESPACE } from './constants';\nimport { CompoundEntityRef } from '../types';\nimport { Entity } from './Entity';\n\nfunction parseRefString(ref: string): {\n  kind?: string;\n  namespace?: string;\n  name: string;\n} {\n  let colonI = ref.indexOf(':');\n  const slashI = ref.indexOf('/');\n\n  // If the / is ahead of the :, treat the rest as the name\n  if (slashI !== -1 && slashI < colonI) {\n    colonI = -1;\n  }\n\n  const kind = colonI === -1 ? undefined : ref.slice(0, colonI);\n  const namespace = slashI === -1 ? undefined : ref.slice(colonI + 1, slashI);\n  const name = ref.slice(Math.max(colonI + 1, slashI + 1));\n\n  if (kind === '' || namespace === '' || name === '') {\n    throw new TypeError(\n      `Entity reference \"${ref}\" was not on the form [<kind>:][<namespace>/]<name>`,\n    );\n  }\n\n  return { kind, namespace, name };\n}\n\n/**\n * Extracts the kind, namespace and name that form the compound entity ref\n * triplet of the given entity.\n *\n * @public\n * @param entity - An entity\n * @returns The compound entity ref\n */\nexport function getCompoundEntityRef(entity: Entity): CompoundEntityRef {\n  return {\n    kind: entity.kind,\n    namespace: entity.metadata.namespace || DEFAULT_NAMESPACE,\n    name: entity.metadata.name,\n  };\n}\n\n/**\n * Parses an entity reference, either on string or compound form, and returns\n * a structure with a name, and optional kind and namespace.\n *\n * @remarks\n *\n * The context object can contain default values for the kind and namespace,\n * that will be used if the input reference did not specify any.\n *\n * @public\n * @param ref - The reference to parse\n * @param context - The context of defaults that the parsing happens within\n * @returns The compound form of the reference\n */\nexport function parseEntityRef(\n  ref: string | { kind?: string; namespace?: string; name: string },\n  context?: {\n    /** The default kind, if none is given in the reference */\n    defaultKind?: string;\n    /** The default namespace, if none is given in the reference */\n    defaultNamespace?: string;\n  },\n): CompoundEntityRef {\n  if (!ref) {\n    throw new Error(`Entity reference must not be empty`);\n  }\n\n  const defaultKind = context?.defaultKind;\n  const defaultNamespace = context?.defaultNamespace || DEFAULT_NAMESPACE;\n\n  let kind: string | undefined;\n  let namespace: string | undefined;\n  let name: string | undefined;\n\n  if (typeof ref === 'string') {\n    const parsed = parseRefString(ref);\n    kind = parsed.kind ?? defaultKind;\n    namespace = parsed.namespace ?? defaultNamespace;\n    name = parsed.name;\n  } else {\n    kind = ref.kind ?? defaultKind;\n    namespace = ref.namespace ?? defaultNamespace;\n    name = ref.name;\n  }\n\n  if (!kind) {\n    const textual = JSON.stringify(ref);\n    throw new Error(\n      `Entity reference ${textual} had missing or empty kind (e.g. did not start with \"component:\" or similar)`,\n    );\n  } else if (!namespace) {\n    const textual = JSON.stringify(ref);\n    throw new Error(\n      `Entity reference ${textual} had missing or empty namespace`,\n    );\n  } else if (!name) {\n    const textual = JSON.stringify(ref);\n    throw new Error(`Entity reference ${textual} had missing or empty name`);\n  }\n\n  return { kind, namespace, name };\n}\n\n/**\n * Takes an entity or entity name/reference, and returns the string form of an\n * entity ref.\n *\n * @remarks\n *\n * This function creates a canonical and unique reference to the entity, converting\n * all parts of the name to lowercase and inserts the default namespace if needed.\n * It is typically not the best way to represent the entity reference to the user.\n *\n * @public\n * @param ref - The reference to serialize\n * @returns The same reference on either string or compound form\n */\nexport function stringifyEntityRef(\n  ref: Entity | { kind: string; namespace?: string; name: string },\n): string {\n  let kind;\n  let namespace;\n  let name;\n\n  if ('metadata' in ref) {\n    kind = ref.kind;\n    namespace = ref.metadata.namespace ?? DEFAULT_NAMESPACE;\n    name = ref.metadata.name;\n  } else {\n    kind = ref.kind;\n    namespace = ref.namespace ?? DEFAULT_NAMESPACE;\n    name = ref.name;\n  }\n\n  return `${kind.toLocaleLowerCase('en-US')}:${namespace.toLocaleLowerCase(\n    'en-US',\n  )}/${name.toLocaleLowerCase('en-US')}`;\n}\n"],"names":[],"mappings":"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"}