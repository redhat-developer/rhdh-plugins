import { createFrontendPlugin } from '@backstage/frontend-plugin-api';
import { isInternalFrontendModule, toInternalFrontendModule } from '../frontend-plugin-api/src/wiring/createFrontendModule.esm.js';
import { toInternalExtension } from '../frontend-plugin-api/src/wiring/resolveExtensionDefinition.esm.js';
import { OpaqueFrontendPlugin } from '../frontend-internal/src/wiring/InternalFrontendPlugin.esm.js';

function resolveAppNodeSpecs(options) {
  const {
    builtinExtensions = [],
    parameters = [],
    forbidden = /* @__PURE__ */ new Set(),
    features = [],
    collector
  } = options;
  const plugins = features.filter(OpaqueFrontendPlugin.isType);
  const modules = features.filter(isInternalFrontendModule);
  const filterForbidden = (extension) => {
    if (forbidden.has(extension.id)) {
      collector.report({
        code: "EXTENSION_IGNORED",
        message: `It is forbidden to override the '${extension.id}' extension, attempted by the '${extension.plugin.id}' plugin`,
        context: {
          plugin: extension.plugin,
          extensionId: extension.id
        }
      });
      return false;
    }
    return true;
  };
  const pluginExtensions = plugins.flatMap((plugin) => {
    return OpaqueFrontendPlugin.toInternal(plugin).extensions.map((extension) => ({
      ...extension,
      plugin
    })).filter(filterForbidden);
  });
  const moduleExtensions = modules.flatMap(
    (mod) => toInternalFrontendModule(mod).extensions.flatMap((extension) => {
      const plugin = plugins.find((p) => p.id === mod.pluginId);
      if (!plugin) {
        return [];
      }
      return [{ ...extension, plugin }];
    }).filter(filterForbidden)
  );
  const appPlugin = plugins.find((plugin) => plugin.id === "app") ?? createFrontendPlugin({
    pluginId: "app"
  });
  const configuredExtensions = [
    ...pluginExtensions.map(({ plugin, ...extension }) => {
      const internalExtension = toInternalExtension(extension);
      return {
        extension: internalExtension,
        params: {
          plugin,
          source: plugin,
          attachTo: internalExtension.attachTo,
          disabled: internalExtension.disabled,
          config: void 0
        }
      };
    }),
    ...builtinExtensions.map((extension) => {
      const internalExtension = toInternalExtension(extension);
      return {
        extension: internalExtension,
        params: {
          source: appPlugin,
          plugin: appPlugin,
          attachTo: internalExtension.attachTo,
          disabled: internalExtension.disabled,
          config: void 0
        }
      };
    })
  ];
  for (const extension of moduleExtensions) {
    const internalExtension = toInternalExtension(extension);
    const index = configuredExtensions.findIndex(
      (e) => e.extension.id === extension.id
    );
    if (index !== -1) {
      configuredExtensions[index].extension = internalExtension;
      configuredExtensions[index].params.attachTo = internalExtension.attachTo;
      configuredExtensions[index].params.disabled = internalExtension.disabled;
    } else {
      configuredExtensions.push({
        extension: internalExtension,
        params: {
          plugin: extension.plugin,
          source: extension.plugin,
          attachTo: internalExtension.attachTo,
          disabled: internalExtension.disabled,
          config: void 0
        }
      });
    }
  }
  const seenExtensionIds = /* @__PURE__ */ new Set();
  const deduplicatedExtensions = configuredExtensions.filter(
    ({ extension, params }) => {
      if (seenExtensionIds.has(extension.id)) {
        collector.report({
          code: "EXTENSION_IGNORED",
          message: `The '${extension.id}' extension from the '${params.plugin.id}' plugin is a duplicate and will be ignored`,
          context: {
            plugin: params.plugin,
            extensionId: extension.id
          }
        });
        return false;
      }
      seenExtensionIds.add(extension.id);
      return true;
    }
  );
  const order = /* @__PURE__ */ new Map();
  for (const overrideParam of parameters) {
    const extensionId = overrideParam.id;
    if (forbidden.has(extensionId)) {
      collector.report({
        code: "INVALID_EXTENSION_CONFIG_KEY",
        message: `Configuration of the '${extensionId}' extension is forbidden`,
        context: {
          extensionId
        }
      });
      continue;
    }
    const existing = deduplicatedExtensions.find(
      (e) => e.extension.id === extensionId
    );
    if (existing) {
      if (overrideParam.attachTo) {
        existing.params.attachTo = overrideParam.attachTo;
      }
      if (overrideParam.config) {
        existing.params.config = overrideParam.config;
      }
      if (Boolean(existing.params.disabled) !== Boolean(overrideParam.disabled)) {
        existing.params.disabled = Boolean(overrideParam.disabled);
      }
      order.set(extensionId, existing);
    } else {
      collector.report({
        code: "INVALID_EXTENSION_CONFIG_KEY",
        message: `Extension ${extensionId} does not exist`,
        context: {
          extensionId
        }
      });
    }
  }
  const orderedExtensions = [
    ...order.values(),
    ...deduplicatedExtensions.filter((e) => !order.has(e.extension.id))
  ];
  return orderedExtensions.map((param) => ({
    id: param.extension.id,
    attachTo: param.params.attachTo,
    extension: param.extension,
    disabled: param.params.disabled,
    plugin: param.params.plugin,
    source: param.params.source,
    config: param.params.config
  }));
}

export { resolveAppNodeSpecs };
//# sourceMappingURL=resolveAppNodeSpecs.esm.js.map
