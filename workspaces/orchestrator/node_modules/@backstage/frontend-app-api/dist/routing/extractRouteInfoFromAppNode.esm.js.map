{"version":3,"file":"extractRouteInfoFromAppNode.esm.js","sources":["../../src/routing/extractRouteInfoFromAppNode.ts"],"sourcesContent":["/*\n * Copyright 2023 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { RouteRef, coreExtensionData } from '@backstage/frontend-plugin-api';\nimport { BackstageRouteObject } from './types';\nimport { AppNode } from '@backstage/frontend-plugin-api';\nimport {\n  createExactRouteAliasResolver,\n  RouteAliasResolver,\n} from './RouteAliasResolver';\n\n/** @internal */\nexport type RouteInfo = {\n  routePaths: Map<RouteRef, string>;\n  routeParents: Map<RouteRef, RouteRef | undefined>;\n  routeObjects: BackstageRouteObject[];\n  routeAliasResolver: RouteAliasResolver;\n};\n\n// We always add a child that matches all subroutes but without any route refs. This makes\n// sure that we're always able to match each route no matter how deep the navigation goes.\n// The route resolver then takes care of selecting the most specific match in order to find\n// mount points that are as deep in the routing tree as possible.\nexport const MATCH_ALL_ROUTE: BackstageRouteObject = {\n  caseSensitive: false,\n  path: '*',\n  element: 'match-all', // These elements aren't used, so we add in a bit of debug information\n  routeRefs: new Set(),\n};\n\n// Joins a list of paths together, avoiding trailing and duplicate slashes\nexport function joinPaths(...paths: string[]): string {\n  const normalized = paths.join('/').replace(/\\/\\/+/g, '/');\n  if (normalized !== '/' && normalized.endsWith('/')) {\n    return normalized.slice(0, -1);\n  }\n  return normalized;\n}\n\nexport function extractRouteInfoFromAppNode(\n  node: AppNode,\n  routeAliasResolver: RouteAliasResolver,\n): RouteInfo {\n  // This tracks the route path for each route ref, the value is the route path relative to the parent ref\n  const routePaths = new Map<RouteRef, string>();\n  // This tracks the parents of each route ref. To find the full path of any route ref you traverse\n  // upwards in this tree and substitute each route ref for its route path along then way.\n  const routeParents = new Map<RouteRef, RouteRef | undefined>();\n  // This route object tree is passed to react-router in order to be able to look up the current route\n  // ref or extension/source based on our current location.\n  const routeObjects = new Array<BackstageRouteObject>();\n  // This tracks all resolved route aliases. By storing and re-using the resolutions here we make sure that it's not\n  // possible to pass an aliased route ref directly to the resolver, e.g. `useRouteRef(createRouteRef({ aliasFor: 'example.root' }))`\n  const routeAliases = new Map<RouteRef, RouteRef | undefined>();\n\n  function visit(\n    current: AppNode,\n    collectedPath?: string,\n    foundRefForCollectedPath: boolean = false,\n    parentRef?: RouteRef,\n    candidateParentRef?: RouteRef,\n    parentObj?: BackstageRouteObject,\n  ) {\n    const routePath = current.instance\n      ?.getData(coreExtensionData.routePath)\n      ?.replace(/^\\//, '');\n\n    const foundRouteRef = current.instance?.getData(coreExtensionData.routeRef);\n    const routeRef = routeAliasResolver(foundRouteRef, current.spec.plugin?.id);\n    if (foundRouteRef && routeRef !== foundRouteRef) {\n      routeAliases.set(foundRouteRef, routeRef);\n    }\n\n    const parentChildren = parentObj?.children ?? routeObjects;\n    let currentObj = parentObj;\n\n    let newCollectedPath = collectedPath;\n    let newFoundRefForCollectedPath = foundRefForCollectedPath;\n\n    let newParentRef = parentRef;\n    let newCandidateParentRef = candidateParentRef;\n\n    // Whenever a route path is encountered, a new node is created in the routing tree.\n    if (routePath !== undefined) {\n      currentObj = {\n        path: routePath,\n        element: 'mounted',\n        routeRefs: new Set<RouteRef>(),\n        caseSensitive: false,\n        children: [MATCH_ALL_ROUTE],\n        appNode: current,\n      };\n      parentChildren.push(currentObj);\n\n      // Each route path that we discover creates a new node in the routing tree, at that point\n      // we also switch out our candidate parent ref to be the active one.\n      newParentRef = candidateParentRef;\n      newCandidateParentRef = undefined;\n\n      // We need to collect and concatenate route paths until the path has been assigned a route ref:\n      // Once we find a route ref the collection starts over from an empty path, that way each route\n      // path assignment only contains the diff from the parent ref.\n      if (newFoundRefForCollectedPath) {\n        newCollectedPath = routePath;\n        newFoundRefForCollectedPath = false;\n      } else {\n        newCollectedPath = collectedPath\n          ? joinPaths(collectedPath, routePath)\n          : routePath;\n      }\n    }\n\n    // Whenever a route ref is encountered, we need to give it a route path and position in the ref tree.\n    if (routeRef) {\n      // The first route ref we find after encountering a route path is selected to be used as the\n      // parent ref further down the tree. We don't start using this candidate ref until we encounter\n      // another route path though, at which point we repeat the process and select another candidate.\n      if (!newCandidateParentRef) {\n        newCandidateParentRef = routeRef;\n      }\n\n      // Check if we've encountered any route paths since the closest route ref, in that case we assign\n      // that path to this and following route refs until we encounter another route path.\n      if (newCollectedPath !== undefined) {\n        routePaths.set(routeRef, newCollectedPath);\n        newFoundRefForCollectedPath = true;\n      }\n\n      routeParents.set(routeRef, newParentRef);\n      currentObj?.routeRefs.add(routeRef);\n    }\n\n    for (const children of current.edges.attachments.values()) {\n      for (const child of children) {\n        visit(\n          child,\n          newCollectedPath,\n          newFoundRefForCollectedPath,\n          newParentRef,\n          newCandidateParentRef,\n          currentObj,\n        );\n      }\n    }\n  }\n\n  visit(node);\n\n  return {\n    routePaths,\n    routeParents,\n    routeObjects,\n    routeAliasResolver: createExactRouteAliasResolver(routeAliases),\n  };\n}\n"],"names":[],"mappings":";;;AAoCO,MAAM,eAAA,GAAwC;AAAA,EACnD,aAAA,EAAe,KAAA;AAAA,EACf,IAAA,EAAM,GAAA;AAAA,EACN,OAAA,EAAS,WAAA;AAAA;AAAA,EACT,SAAA,sBAAe,GAAA;AACjB;AAGO,SAAS,aAAa,KAAA,EAAyB;AACpD,EAAA,MAAM,aAAa,KAAA,CAAM,IAAA,CAAK,GAAG,CAAA,CAAE,OAAA,CAAQ,UAAU,GAAG,CAAA;AACxD,EAAA,IAAI,UAAA,KAAe,GAAA,IAAO,UAAA,CAAW,QAAA,CAAS,GAAG,CAAA,EAAG;AAClD,IAAA,OAAO,UAAA,CAAW,KAAA,CAAM,CAAA,EAAG,EAAE,CAAA;AAAA,EAC/B;AACA,EAAA,OAAO,UAAA;AACT;AAEO,SAAS,2BAAA,CACd,MACA,kBAAA,EACW;AAEX,EAAA,MAAM,UAAA,uBAAiB,GAAA,EAAsB;AAG7C,EAAA,MAAM,YAAA,uBAAmB,GAAA,EAAoC;AAG7D,EAAA,MAAM,YAAA,GAAe,IAAI,KAAA,EAA4B;AAGrD,EAAA,MAAM,YAAA,uBAAmB,GAAA,EAAoC;AAE7D,EAAA,SAAS,MACP,OAAA,EACA,aAAA,EACA,2BAAoC,KAAA,EACpC,SAAA,EACA,oBACA,SAAA,EACA;AACA,IAAA,MAAM,SAAA,GAAY,QAAQ,QAAA,EACtB,OAAA,CAAQ,kBAAkB,SAAS,CAAA,EACnC,OAAA,CAAQ,KAAA,EAAO,EAAE,CAAA;AAErB,IAAA,MAAM,aAAA,GAAgB,OAAA,CAAQ,QAAA,EAAU,OAAA,CAAQ,kBAAkB,QAAQ,CAAA;AAC1E,IAAA,MAAM,WAAW,kBAAA,CAAmB,aAAA,EAAe,OAAA,CAAQ,IAAA,CAAK,QAAQ,EAAE,CAAA;AAC1E,IAAA,IAAI,aAAA,IAAiB,aAAa,aAAA,EAAe;AAC/C,MAAA,YAAA,CAAa,GAAA,CAAI,eAAe,QAAQ,CAAA;AAAA,IAC1C;AAEA,IAAA,MAAM,cAAA,GAAiB,WAAW,QAAA,IAAY,YAAA;AAC9C,IAAA,IAAI,UAAA,GAAa,SAAA;AAEjB,IAAA,IAAI,gBAAA,GAAmB,aAAA;AACvB,IAAA,IAAI,2BAAA,GAA8B,wBAAA;AAElC,IAAA,IAAI,YAAA,GAAe,SAAA;AACnB,IAAA,IAAI,qBAAA,GAAwB,kBAAA;AAG5B,IAAA,IAAI,cAAc,MAAA,EAAW;AAC3B,MAAA,UAAA,GAAa;AAAA,QACX,IAAA,EAAM,SAAA;AAAA,QACN,OAAA,EAAS,SAAA;AAAA,QACT,SAAA,sBAAe,GAAA,EAAc;AAAA,QAC7B,aAAA,EAAe,KAAA;AAAA,QACf,QAAA,EAAU,CAAC,eAAe,CAAA;AAAA,QAC1B,OAAA,EAAS;AAAA,OACX;AACA,MAAA,cAAA,CAAe,KAAK,UAAU,CAAA;AAI9B,MAAA,YAAA,GAAe,kBAAA;AACf,MAAA,qBAAA,GAAwB,MAAA;AAKxB,MAAA,IAAI,2BAAA,EAA6B;AAC/B,QAAA,gBAAA,GAAmB,SAAA;AACnB,QAAA,2BAAA,GAA8B,KAAA;AAAA,MAChC,CAAA,MAAO;AACL,QAAA,gBAAA,GAAmB,aAAA,GACf,SAAA,CAAU,aAAA,EAAe,SAAS,CAAA,GAClC,SAAA;AAAA,MACN;AAAA,IACF;AAGA,IAAA,IAAI,QAAA,EAAU;AAIZ,MAAA,IAAI,CAAC,qBAAA,EAAuB;AAC1B,QAAA,qBAAA,GAAwB,QAAA;AAAA,MAC1B;AAIA,MAAA,IAAI,qBAAqB,MAAA,EAAW;AAClC,QAAA,UAAA,CAAW,GAAA,CAAI,UAAU,gBAAgB,CAAA;AACzC,QAAA,2BAAA,GAA8B,IAAA;AAAA,MAChC;AAEA,MAAA,YAAA,CAAa,GAAA,CAAI,UAAU,YAAY,CAAA;AACvC,MAAA,UAAA,EAAY,SAAA,CAAU,IAAI,QAAQ,CAAA;AAAA,IACpC;AAEA,IAAA,KAAA,MAAW,QAAA,IAAY,OAAA,CAAQ,KAAA,CAAM,WAAA,CAAY,QAAO,EAAG;AACzD,MAAA,KAAA,MAAW,SAAS,QAAA,EAAU;AAC5B,QAAA,KAAA;AAAA,UACE,KAAA;AAAA,UACA,gBAAA;AAAA,UACA,2BAAA;AAAA,UACA,YAAA;AAAA,UACA,qBAAA;AAAA,UACA;AAAA,SACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,EAAA,KAAA,CAAM,IAAI,CAAA;AAEV,EAAA,OAAO;AAAA,IACL,UAAA;AAAA,IACA,YAAA;AAAA,IACA,YAAA;AAAA,IACA,kBAAA,EAAoB,8BAA8B,YAAY;AAAA,GAChE;AACF;;;;"}