import { toInternalRouteRef } from '../frontend-plugin-api/src/routing/RouteRef.esm.js';

function createRouteAliasResolver(routeRefsById) {
  const resolver = (routeRef, pluginId) => {
    if (!routeRef) {
      return void 0;
    }
    let currentRef = routeRef;
    for (let i = 0; i < 100; i++) {
      const alias = toInternalRouteRef(currentRef).alias;
      if (alias) {
        if (pluginId) {
          const [aliasPluginId] = alias.split(".");
          if (aliasPluginId !== pluginId) {
            throw new Error(
              `Refused to resolve alias '${alias}' for ${currentRef} as it points to a different plugin, the expected plugin is '${pluginId}' but the alias points to '${aliasPluginId}'`
            );
          }
        }
        const aliasRef = routeRefsById.routes.get(alias);
        if (!aliasRef) {
          throw new Error(
            `Unable to resolve RouteRef alias '${alias}' for ${currentRef}`
          );
        }
        if (aliasRef.$$type === "@backstage/SubRouteRef") {
          throw new Error(
            `RouteRef alias '${alias}' for ${currentRef} points to a SubRouteRef, which is not supported`
          );
        }
        currentRef = aliasRef;
      } else {
        return currentRef;
      }
    }
    throw new Error(`Alias loop detected for ${routeRef}`);
  };
  return resolver;
}
function createExactRouteAliasResolver(routeAliases) {
  const resolver = (routeRef) => {
    if (routeRef && routeAliases.has(routeRef)) {
      return routeAliases.get(routeRef);
    }
    return routeRef;
  };
  return resolver;
}

export { createExactRouteAliasResolver, createRouteAliasResolver };
//# sourceMappingURL=RouteAliasResolver.esm.js.map
