import { generatePath, matchRoutes } from 'react-router-dom';
import mapValues from 'lodash/mapValues';
import { isRouteRef } from '../frontend-plugin-api/src/routing/RouteRef.esm.js';
import { isSubRouteRef, toInternalSubRouteRef } from '../frontend-plugin-api/src/routing/SubRouteRef.esm.js';
import { isExternalRouteRef, toInternalExternalRouteRef } from '../frontend-plugin-api/src/routing/ExternalRouteRef.esm.js';

function joinPaths(...paths) {
  const normalized = paths.join("/").replace(/\/\/+/g, "/");
  if (normalized !== "/" && normalized.endsWith("/")) {
    return normalized.slice(0, -1);
  }
  return normalized;
}
function resolveTargetRef(targetRouteRef, routePaths, routeBindings, routeRefsById) {
  let ref = targetRouteRef;
  let path = "";
  if (isExternalRouteRef(ref)) {
    let resolvedRoute = routeBindings.get(ref);
    if (!resolvedRoute) {
      const internal = toInternalExternalRouteRef(ref);
      const defaultTarget = internal.getDefaultTarget();
      if (defaultTarget) {
        resolvedRoute = routeRefsById.get(defaultTarget);
      }
    }
    if (!resolvedRoute) {
      return [void 0, ""];
    }
    ref = resolvedRoute;
  }
  if (isSubRouteRef(ref)) {
    const internal = toInternalSubRouteRef(ref);
    path = ref.path;
    ref = internal.getParent();
  }
  if (!isRouteRef(ref)) {
    throw new Error(
      `Unexpectedly resolved ${targetRouteRef} to a non-route ref ${ref}`
    );
  }
  const resolvedPath = routePaths.get(ref);
  if (resolvedPath === void 0) {
    return [void 0, ""];
  }
  return [ref, path ? joinPaths(resolvedPath, path) : resolvedPath];
}
function resolveBasePath(targetRef, sourceLocation, routePaths, routeParents, routeObjects) {
  const match = matchRoutes(routeObjects, sourceLocation) ?? [];
  const refDiffList = Array();
  let matchIndex = -1;
  for (let targetSearchRef = targetRef; targetSearchRef; targetSearchRef = routeParents.get(targetSearchRef)) {
    matchIndex = match.findIndex(
      (m) => m.route.routeRefs.has(targetSearchRef)
    );
    if (matchIndex !== -1) {
      break;
    }
    refDiffList.unshift(targetSearchRef);
  }
  if (refDiffList.length === 0) {
    matchIndex -= 1;
  }
  const parentPath = matchIndex === -1 ? "" : match[matchIndex].pathname;
  const diffPaths = refDiffList.slice(0, -1).map((ref) => {
    const path = routePaths.get(ref);
    if (path === void 0) {
      throw new Error(`No path for ${ref}`);
    }
    if (path.includes(":")) {
      throw new Error(
        `Cannot route to ${targetRef} with parent ${ref} as it has parameters`
      );
    }
    return path;
  });
  return `${joinPaths(parentPath, ...diffPaths)}/`;
}
class RouteResolver {
  constructor(routePaths, routeParents, routeObjects, routeBindings, appBasePath, routeAliasResolver, routeRefsById) {
    this.routePaths = routePaths;
    this.routeParents = routeParents;
    this.routeObjects = routeObjects;
    this.routeBindings = routeBindings;
    this.appBasePath = appBasePath;
    this.routeAliasResolver = routeAliasResolver;
    this.routeRefsById = routeRefsById;
  }
  resolve(anyRouteRef, options) {
    const [targetRef, targetPath] = resolveTargetRef(
      anyRouteRef?.$$type === "@backstage/RouteRef" ? this.routeAliasResolver(anyRouteRef) : anyRouteRef,
      this.routePaths,
      this.routeBindings,
      this.routeRefsById
    );
    if (!targetRef) {
      return void 0;
    }
    const relativeSourceLocation = this.trimPath(options?.sourcePath ?? "");
    const basePath = resolveBasePath(
      targetRef,
      relativeSourceLocation,
      this.routePaths,
      this.routeParents,
      this.routeObjects
    );
    const routeFunc = (...[params]) => {
      const encodedParams = params && mapValues(params, (value) => {
        if (typeof value === "string") {
          return value.replaceAll(/[&?#;\/]/g, (c) => encodeURIComponent(c));
        }
        return value;
      });
      return joinPaths(basePath, generatePath(targetPath, encodedParams));
    };
    return routeFunc;
  }
  trimPath(targetPath) {
    if (!targetPath) {
      return targetPath;
    }
    if (targetPath.startsWith(this.appBasePath)) {
      return targetPath.slice(this.appBasePath.length);
    }
    return targetPath;
  }
}

export { RouteResolver, joinPaths };
//# sourceMappingURL=RouteResolver.esm.js.map
