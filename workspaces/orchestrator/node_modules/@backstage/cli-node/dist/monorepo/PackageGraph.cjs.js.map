{"version":3,"file":"PackageGraph.cjs.js","sources":["../../src/monorepo/PackageGraph.ts"],"sourcesContent":["/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport path from 'path';\nimport { getPackages, Package } from '@manypkg/get-packages';\nimport { paths } from '../util';\nimport { PackageRole } from '../roles';\nimport { GitUtils } from '../git';\nimport { Lockfile } from './Lockfile';\nimport { JsonValue } from '@backstage/types';\n\n/**\n * A list of the feature types we want to extract from the project\n * and include in the metadata\n *\n * @public\n */\nexport const packageFeatureType = [\n  '@backstage/BackendFeature',\n  '@backstage/BackstagePlugin',\n  '@backstage/FrontendPlugin',\n  '@backstage/FrontendModule',\n] as const;\n\n/**\n * @public\n */\nexport type BackstagePackageFeatureType = (typeof packageFeatureType)[number];\n\n/**\n * Known fields in Backstage package.json files.\n *\n * @public\n */\nexport interface BackstagePackageJson {\n  name: string;\n  version: string;\n  private?: boolean;\n\n  main?: string;\n  module?: string;\n  types?: string;\n\n  scripts?: {\n    [key: string]: string;\n  };\n  // The `bundled` field is a field known within Backstage, it means\n  // that the package bundles all of its dependencies in its build output.\n  bundled?: boolean;\n\n  type?: 'module' | 'commonjs';\n\n  backstage?: {\n    role?: PackageRole;\n    moved?: string;\n\n    /**\n     * If set to `true`, the package will be treated as an internal package\n     * where any imports will be inlined into the consuming package.\n     *\n     * When set to `true`, the top-level `private` field must be set to `true`\n     * as well.\n     */\n    inline?: boolean;\n\n    /**\n     * The ID of the plugin if this is a plugin package. Must always be set for plugin and module packages, and may be set for library packages. A `null` value means that the package is explicitly not a plugin package.\n     */\n    pluginId?: string | null;\n\n    /**\n     * The parent plugin package of a module. Must always and only be set for module packages.\n     */\n    pluginPackage?: string;\n\n    /**\n     * All packages that are part of the plugin. Must always and only be set for plugin packages and plugin library packages.\n     */\n    pluginPackages?: string[];\n\n    /**\n     * The feature types exported from the package, indexed by path.\n     */\n    features?: Record<string, BackstagePackageFeatureType>;\n  };\n\n  exports?: JsonValue;\n  typesVersions?: Record<string, Record<string, string[]>>;\n\n  files?: string[];\n\n  publishConfig?: {\n    access?: 'public' | 'restricted';\n    directory?: string;\n    registry?: string;\n  };\n\n  repository?:\n    | string\n    | {\n        type: string;\n        url: string;\n        directory: string;\n      };\n\n  dependencies?: {\n    [key: string]: string;\n  };\n  peerDependencies?: {\n    [key: string]: string;\n  };\n  devDependencies?: {\n    [key: string]: string;\n  };\n  optionalDependencies?: {\n    [key: string]: string;\n  };\n}\n\n/**\n * A local Backstage monorepo package\n *\n * @public\n */\nexport type BackstagePackage = {\n  dir: string;\n  packageJson: BackstagePackageJson;\n};\n\n/**\n * A local package in the monorepo package graph.\n *\n * @public\n */\nexport type PackageGraphNode = {\n  /** The name of the package */\n  name: string;\n  /** The directory of the package */\n  dir: string;\n  /** The package data of the package itself */\n  packageJson: BackstagePackageJson;\n\n  /** All direct local dependencies of the package */\n  allLocalDependencies: Map<string, PackageGraphNode>;\n  /** All direct local dependencies that will be present in the published package */\n  publishedLocalDependencies: Map<string, PackageGraphNode>;\n  /** Local dependencies */\n  localDependencies: Map<string, PackageGraphNode>;\n  /** Local devDependencies */\n  localDevDependencies: Map<string, PackageGraphNode>;\n  /** Local optionalDependencies */\n  localOptionalDependencies: Map<string, PackageGraphNode>;\n\n  /** All direct incoming local dependencies of the package */\n  allLocalDependents: Map<string, PackageGraphNode>;\n  /** All direct incoming local dependencies that will be present in the published package */\n  publishedLocalDependents: Map<string, PackageGraphNode>;\n  /** Incoming local dependencies */\n  localDependents: Map<string, PackageGraphNode>;\n  /** Incoming local devDependencies */\n  localDevDependents: Map<string, PackageGraphNode>;\n  /** Incoming local optionalDependencies */\n  localOptionalDependents: Map<string, PackageGraphNode>;\n};\n\n/**\n * Represents a local Backstage monorepo package graph.\n *\n * @public\n */\nexport class PackageGraph extends Map<string, PackageGraphNode> {\n  /**\n   * Lists all local packages in a monorepo.\n   */\n  static async listTargetPackages(): Promise<BackstagePackage[]> {\n    const { packages } = await getPackages(paths.targetDir);\n\n    return packages as BackstagePackage[];\n  }\n\n  /**\n   * Creates a package graph from a list of local packages.\n   */\n  static fromPackages(packages: Package[]): PackageGraph {\n    const graph = new PackageGraph();\n\n    // Add all local packages to the graph\n    for (const pkg of packages) {\n      const name = pkg.packageJson.name;\n      const existingPkg = graph.get(name);\n      if (existingPkg) {\n        throw new Error(\n          `Duplicate package name '${name}' at ${pkg.dir} and ${existingPkg.dir}`,\n        );\n      }\n\n      graph.set(name, {\n        name,\n        dir: pkg.dir,\n        packageJson: pkg.packageJson as BackstagePackageJson,\n\n        allLocalDependencies: new Map(),\n        publishedLocalDependencies: new Map(),\n        localDependencies: new Map(),\n        localDevDependencies: new Map(),\n        localOptionalDependencies: new Map(),\n\n        allLocalDependents: new Map(),\n        publishedLocalDependents: new Map(),\n        localDependents: new Map(),\n        localDevDependents: new Map(),\n        localOptionalDependents: new Map(),\n      });\n    }\n\n    // Populate the local dependency structure\n    for (const node of graph.values()) {\n      for (const depName of Object.keys(node.packageJson.dependencies || {})) {\n        const depPkg = graph.get(depName);\n        if (depPkg) {\n          node.allLocalDependencies.set(depName, depPkg);\n          node.publishedLocalDependencies.set(depName, depPkg);\n          node.localDependencies.set(depName, depPkg);\n\n          depPkg.allLocalDependents.set(node.name, node);\n          depPkg.publishedLocalDependents.set(node.name, node);\n          depPkg.localDependents.set(node.name, node);\n        }\n      }\n      for (const depName of Object.keys(\n        node.packageJson.devDependencies || {},\n      )) {\n        const depPkg = graph.get(depName);\n        if (depPkg) {\n          node.allLocalDependencies.set(depName, depPkg);\n          node.localDevDependencies.set(depName, depPkg);\n\n          depPkg.allLocalDependents.set(node.name, node);\n          depPkg.localDevDependents.set(node.name, node);\n        }\n      }\n      for (const depName of Object.keys(\n        node.packageJson.optionalDependencies || {},\n      )) {\n        const depPkg = graph.get(depName);\n        if (depPkg) {\n          node.allLocalDependencies.set(depName, depPkg);\n          node.publishedLocalDependencies.set(depName, depPkg);\n          node.localOptionalDependencies.set(depName, depPkg);\n\n          depPkg.allLocalDependents.set(node.name, node);\n          depPkg.publishedLocalDependents.set(node.name, node);\n          depPkg.localOptionalDependents.set(node.name, node);\n        }\n      }\n    }\n\n    return graph;\n  }\n\n  /**\n   * Traverses the package graph and collects a set of package names.\n   *\n   * The traversal starts at the provided list names, and continues\n   * throughout all the names returned by the `collectFn`, which is\n   * called once for each seen package.\n   */\n  collectPackageNames(\n    startingPackageNames: string[],\n    collectFn: (pkg: PackageGraphNode) => Iterable<string> | undefined,\n  ): Set<string> {\n    const targets = new Set<string>();\n    const searchNames = startingPackageNames.slice();\n\n    while (searchNames.length) {\n      const name = searchNames.pop()!;\n\n      if (targets.has(name)) {\n        continue;\n      }\n\n      const node = this.get(name);\n      if (!node) {\n        throw new Error(`Package '${name}' not found`);\n      }\n\n      targets.add(name);\n\n      const collected = collectFn(node);\n      if (collected) {\n        searchNames.push(...collected);\n      }\n    }\n\n    return targets;\n  }\n\n  /**\n   * Lists all packages that have changed since a given git ref.\n   *\n   * @remarks\n   *\n   * If the `analyzeLockfile` option is set to true, the change detection will\n   * also consider changes to the dependency management lockfile.\n   */\n  async listChangedPackages(options: {\n    ref: string;\n    analyzeLockfile?: boolean;\n  }) {\n    const changedFiles = await GitUtils.listChangedFiles(options.ref);\n\n    const dirMap = new Map(\n      Array.from(this.values()).map(pkg => [\n        // relative from root, convert to posix, and add a / at the end\n        path\n          .relative(paths.targetRoot, pkg.dir)\n          .split(path.sep)\n          .join(path.posix.sep) + path.posix.sep,\n        pkg,\n      ]),\n    );\n    const packageDirs = Array.from(dirMap.keys());\n\n    const result = new Array<PackageGraphNode>();\n    let searchIndex = 0;\n\n    changedFiles.sort();\n    packageDirs.sort();\n\n    for (const packageDir of packageDirs) {\n      // Skip through changes that appear before our package dir\n      while (\n        searchIndex < changedFiles.length &&\n        changedFiles[searchIndex] < packageDir\n      ) {\n        searchIndex += 1;\n      }\n\n      // Check if we arrived at a match, otherwise we move on to the next package dir\n      if (changedFiles[searchIndex]?.startsWith(packageDir)) {\n        searchIndex += 1;\n\n        result.push(dirMap.get(packageDir)!);\n\n        // Skip through the rest of the changed files for the same package\n        while (changedFiles[searchIndex]?.startsWith(packageDir)) {\n          searchIndex += 1;\n        }\n      }\n    }\n\n    if (changedFiles.includes('yarn.lock') && options.analyzeLockfile) {\n      // Load the lockfile in the working tree and the one at the ref and diff them\n      let thisLockfile: Lockfile;\n      let otherLockfile: Lockfile;\n      try {\n        thisLockfile = await Lockfile.load(\n          paths.resolveTargetRoot('yarn.lock'),\n        );\n        otherLockfile = Lockfile.parse(\n          await GitUtils.readFileAtRef('yarn.lock', options.ref),\n        );\n      } catch (error) {\n        console.warn(\n          `Failed to read lockfiles, assuming all packages have changed, ${error}`,\n        );\n        return Array.from(this.values());\n      }\n      const diff = thisLockfile.diff(otherLockfile);\n\n      // Create a simplified dependency graph only keeps track of package names\n      const graph = thisLockfile.createSimplifiedDependencyGraph();\n\n      // Merge the dependency graph from the other lockfile into this one in\n      // order to be able to detect removals accurately.\n      {\n        const otherGraph = thisLockfile.createSimplifiedDependencyGraph();\n        for (const [name, dependencies] of otherGraph) {\n          const node = graph.get(name);\n          if (node) {\n            dependencies.forEach(d => node.add(d));\n          } else {\n            graph.set(name, dependencies);\n          }\n        }\n      }\n\n      // The check is simplified by only considering the package names rather\n      // than the exact version range queries that were changed.\n      // TODO(Rugvip): Use a more exact check\n      const changedPackages = new Set(\n        [...diff.added, ...diff.changed, ...diff.removed].map(e => e.name),\n      );\n\n      // Starting with our set of changed packages from the diff, we loop through\n      // the full graph and add any package that has a dependency on a changed package.\n      // We keep looping until all transitive dependencies have been detected.\n      let changed = false;\n      do {\n        changed = false;\n        for (const [name, dependencies] of graph) {\n          if (changedPackages.has(name)) {\n            continue;\n          }\n          for (const dep of dependencies) {\n            if (changedPackages.has(dep)) {\n              changed = true;\n              changedPackages.add(name);\n              break;\n            }\n          }\n        }\n      } while (changed);\n\n      // Add all local packages that had a transitive dependency change to the result set\n      for (const node of this.values()) {\n        if (changedPackages.has(node.name) && !result.includes(node)) {\n          result.push(node);\n        }\n      }\n    }\n\n    return result;\n  }\n}\n"],"names":["getPackages","paths","GitUtils","path","Lockfile"],"mappings":"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"}