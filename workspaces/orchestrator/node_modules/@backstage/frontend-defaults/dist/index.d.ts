import * as react from 'react';
import { ReactNode, JSX } from 'react';
import { FrontendFeature, FrontendFeatureLoader, ConfigApi, ExtensionFactoryMiddleware } from '@backstage/frontend-plugin-api';
import { CreateAppRouteBinder, FrontendPluginInfoResolver, AppError, AppErrorTypes } from '@backstage/frontend-app-api';
import { Config } from '@backstage/config';

/**
 * Options for {@link createApp}.
 *
 * @public
 */
interface CreateAppOptions {
    /**
     * The list of features to load.
     */
    features?: (FrontendFeature | FrontendFeatureLoader)[];
    /**
     * Allows for the binding of plugins' external route refs within the app.
     */
    bindRoutes?(context: {
        bind: CreateAppRouteBinder;
    }): void;
    /**
     * Advanced, more rarely used options.
     */
    advanced?: {
        /**
         * If set to true, the system will silently accept and move on if
         * encountering config for extensions that do not exist. The default is to
         * reject such config to help catch simple mistakes.
         *
         * This flag can be useful in some scenarios where you have a dynamic set of
         * extensions enabled at different times, but also increases the risk of
         * accidentally missing e.g. simple typos in your config.
         */
        allowUnknownExtensionConfig?: boolean;
        /**
         * Sets a custom config loader, replacing the builtin one.
         *
         * This can be used e.g. if you have the need to source config out of custom
         * storages.
         */
        configLoader?: () => Promise<{
            config: ConfigApi;
        }>;
        /**
         * Applies one or more middleware on every extension, as they are added to
         * the application.
         *
         * This is an advanced use case for modifying extension data on the fly as
         * it gets emitted by extensions being instantiated.
         */
        extensionFactoryMiddleware?: ExtensionFactoryMiddleware | ExtensionFactoryMiddleware[];
        /**
         * The element to render while loading the app (waiting for config, features, etc).
         *
         * This is the `<Progress />` component from `@backstage/core-components` by default.
         * If set to `null` then no loading fallback element is rendered at all.
         */
        loadingElement?: ReactNode;
        /**
         * Allows for customizing how plugin info is retrieved.
         */
        pluginInfoResolver?: FrontendPluginInfoResolver;
    };
}
/**
 * Creates a new Backstage frontend app instance. See https://backstage.io/docs/frontend-system/building-apps/index
 *
 * @public
 */
declare function createApp(options?: CreateAppOptions): {
    createRoot(): JSX.Element;
};

/**
 * @public
 * @deprecated Use {@link @backstage/plugin-app/alpha#appModulePublicSignIn} instead.
 */
declare function createPublicSignInApp(options?: CreateAppOptions): {
    createRoot(): react.JSX.Element;
};

/**
 * @public
 */
declare function discoverAvailableFeatures(config: Config): {
    features: (FrontendFeature | FrontendFeatureLoader)[];
};

/** @public */
declare function resolveAsyncFeatures(options: {
    config: Config;
    features?: (FrontendFeature | FrontendFeatureLoader)[];
}): Promise<{
    features: FrontendFeature[];
}>;

/**
 * If there are any unrecoverable errors in the app, this will return an error page in the form of a JSX element.
 *
 * If there are any recoverable errors, they will always be logged as warnings in the console.
 * @public
 */
declare function maybeCreateErrorPage(app: {
    errors?: AppError[];
}, options?: {
    warningCodes?: Array<keyof AppErrorTypes>;
}): JSX.Element | undefined;

export { type CreateAppOptions, createApp, createPublicSignInApp, discoverAvailableFeatures, maybeCreateErrorPage, resolveAsyncFeatures };
