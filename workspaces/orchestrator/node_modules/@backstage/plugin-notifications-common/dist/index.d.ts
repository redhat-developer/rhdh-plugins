import { JsonValue } from '@backstage/types';
import { Config } from '@backstage/config';

/** @public */
type NotificationSeverity = 'critical' | 'high' | 'normal' | 'low';
/** @public */
type NotificationPayload = {
    /**
     * Notification title
     */
    title: string;
    /**
     * Optional longer description for the notification
     */
    description?: string;
    /**
     * Optional link where the notification is pointing to
     */
    link?: string;
    /**
     * Notification severity, defaults to 'normal'
     */
    severity?: NotificationSeverity;
    /**
     * Optional notification topic
     */
    topic?: string;
    /**
     * Notification scope, can be used to re-send same notifications in case
     * the scope and origin matches.
     */
    scope?: string;
    /**
     * Optional notification icon
     */
    icon?: string;
    /**
     * Optional additional customizable metadata.
     */
    metadata?: {
        [KMetadataKey in string]?: JsonValue;
    };
};
/** @public */
type Notification = {
    /**
     * Unique identifier for the notification
     */
    id: string;
    /**
     * The user entity reference that the notification is targeted to or null
     * for broadcast notifications
     */
    user: string | null;
    /**
     * Notification creation date
     */
    created: Date;
    /**
     * If user has saved the notification, the date when it was saved
     */
    saved?: Date;
    /**
     * If user has read the notification, the date when it was read
     */
    read?: Date;
    /**
     * If the notification has been updated due to it being in the same scope
     * and from same origin as previous notification, the date when it was updated
     */
    updated?: Date;
    /**
     * Origin of the notification as in the reference to sender
     */
    origin: string;
    /**
     * Actual notification payload
     */
    payload: NotificationPayload;
};
/** @public */
type NotificationStatus = {
    /**
     * Total number of unread notifications for the user
     */
    unread: number;
    /**
     * Total number of read notifications for the user
     */
    read: number;
};
/** @public */
type NewNotificationSignal = {
    action: 'new_notification';
    notification_id: string;
};
/** @public */
type NotificationReadSignal = {
    action: 'notification_read' | 'notification_unread';
    notification_ids: string[];
};
/** @public */
type NotificationSignal = NewNotificationSignal | NotificationReadSignal;
/**
 * @public
 */
type NotificationProcessorFilters = {
    minSeverity?: NotificationSeverity;
    maxSeverity?: NotificationSeverity;
    excludedTopics?: string[];
};
/**
 * @public
 */
type TopicSetting = {
    id: string;
    enabled: boolean;
};
/**
 * @public
 */
type OriginSetting = {
    id: string;
    enabled: boolean;
    topics?: TopicSetting[];
};
/**
 * @public
 */
type ChannelSetting = {
    id: string;
    origins: OriginSetting[];
};
/**
 * @public
 */
type NotificationSettings = {
    channels: ChannelSetting[];
};

/** Ordered list of severities used by the Notifications.
 *
 * @public */
declare const notificationSeverities: NotificationSeverity[];

/** @public */
declare const getProcessorFiltersFromConfig: (config: Config) => NotificationProcessorFilters;

/** @public */
declare const isNotificationsEnabledFor: (settings: NotificationSettings, channelId: string, originId: string, topicId: string | null) => boolean;

export { type ChannelSetting, type NewNotificationSignal, type Notification, type NotificationPayload, type NotificationProcessorFilters, type NotificationReadSignal, type NotificationSettings, type NotificationSeverity, type NotificationSignal, type NotificationStatus, type OriginSetting, type TopicSetting, getProcessorFiltersFromConfig, isNotificationsEnabledFor, notificationSeverities };
