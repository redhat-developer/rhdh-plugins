'use strict';

var catalogModel = require('@backstage/catalog-model');
var alpha = require('@backstage/plugin-catalog-common/alpha');
var stream = require('stream');
var config = require('./config.cjs.js');
var defaultCatalogCollatorEntityTransformer = require('./defaultCatalogCollatorEntityTransformer.cjs.js');

class DefaultCatalogCollatorFactory {
  type = "software-catalog";
  visibilityPermission = alpha.catalogEntityReadPermission;
  locationTemplate;
  filter;
  batchSize;
  catalog;
  entityTransformer;
  auth;
  static fromConfig(configRoot, options) {
    const configOptions = config.readCollatorConfigOptions(configRoot);
    return new DefaultCatalogCollatorFactory({
      locationTemplate: configOptions.locationTemplate,
      filter: configOptions.filter,
      batchSize: configOptions.batchSize,
      entityTransformer: options.entityTransformer,
      auth: options.auth,
      catalog: options.catalog
    });
  }
  constructor(options) {
    const {
      auth,
      batchSize,
      locationTemplate,
      filter,
      catalog,
      entityTransformer
    } = options;
    this.locationTemplate = locationTemplate;
    this.filter = filter;
    this.batchSize = batchSize;
    this.catalog = catalog;
    this.entityTransformer = entityTransformer ?? defaultCatalogCollatorEntityTransformer.defaultCatalogCollatorEntityTransformer;
    this.auth = auth;
  }
  async getCollator() {
    return stream.Readable.from(this.execute());
  }
  async *execute() {
    let entitiesRetrieved = 0;
    let cursor = void 0;
    do {
      const response = await this.catalog.queryEntities(
        {
          filter: this.filter,
          limit: this.batchSize,
          ...cursor ? { cursor } : {}
        },
        { credentials: await this.auth.getOwnServiceCredentials() }
      );
      cursor = response.pageInfo.nextCursor;
      entitiesRetrieved += response.items.length;
      for (const entity of response.items) {
        yield {
          ...this.entityTransformer(entity),
          authorization: {
            resourceRef: catalogModel.stringifyEntityRef(entity)
          },
          location: this.applyArgsToFormat(this.locationTemplate, {
            namespace: encodeURIComponent(
              entity.metadata.namespace || "default"
            ),
            kind: encodeURIComponent(entity.kind),
            name: encodeURIComponent(entity.metadata.name)
          })
        };
      }
    } while (cursor);
  }
  applyArgsToFormat(format, args) {
    let formatted = format;
    for (const [key, value] of Object.entries(args)) {
      formatted = formatted.replace(`:${key}`, value);
    }
    return formatted.toLowerCase();
  }
}

exports.DefaultCatalogCollatorFactory = DefaultCatalogCollatorFactory;
//# sourceMappingURL=DefaultCatalogCollatorFactory.cjs.js.map
