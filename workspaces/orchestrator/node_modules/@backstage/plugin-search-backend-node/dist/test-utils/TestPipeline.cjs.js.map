{"version":3,"file":"TestPipeline.cjs.js","sources":["../../src/test-utils/TestPipeline.ts"],"sourcesContent":["/*\n * Copyright 2022 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { IndexableDocument } from '@backstage/plugin-search-common';\nimport { pipeline, Readable, Transform, Writable } from 'stream';\n\n/**\n * Object resolved after a test pipeline is executed.\n * @public\n */\nexport type TestPipelineResult = {\n  /**\n   * If an error was emitted by the pipeline, it will be set here.\n   */\n  error: unknown;\n\n  /**\n   * A list of documents collected at the end of the pipeline. If the subject\n   * under test is an indexer, this will be an empty array (because your\n   * indexer should have received the documents instead).\n   */\n  documents: IndexableDocument[];\n};\n\n/**\n * Test utility for Backstage Search collators, decorators, and indexers.\n *\n * @example\n * An example test checking that a collator provides expected documents.\n * ```\n * it('provides expected documents', async () => {\n *   const testSubject = await yourCollatorFactory.getCollator();\n *   const pipeline = TestPipeline.fromCollator(testSubject);\n *\n *   const { documents } = await pipeline.execute();\n *\n *   expect(documents).toHaveLength(2);\n * })\n * ```\n *\n * @example\n * An example test checking that a decorator behaves as expected.\n * ```\n * it('filters private documents', async () => {\n *   const testSubject = await yourDecoratorFactory.getDecorator();\n *   const pipeline = TestPipeline\n *     .fromDecorator(testSubject)\n *     .withDocuments([{ title: 'Private', location: '/private', text: '' }]);\n *\n *   const { documents } = await pipeline.execute();\n *\n *   expect(documents).toHaveLength(0);\n * })\n * ```\n *\n * @public\n */\nexport class TestPipeline {\n  private collator?: Readable;\n  private decorator?: Transform;\n  private indexer?: Writable;\n\n  private constructor({\n    collator,\n    decorator,\n    indexer,\n  }: {\n    collator?: Readable;\n    decorator?: Transform;\n    indexer?: Writable;\n  }) {\n    this.collator = collator;\n    this.decorator = decorator;\n    this.indexer = indexer;\n  }\n\n  /**\n   * Provide the collator, decorator, or indexer to be tested.\n   *\n   * @deprecated Use `fromCollator`, `fromDecorator` or `fromIndexer` static\n   *   methods to create a test pipeline instead.\n   */\n  static withSubject(subject: Readable | Transform | Writable) {\n    if (subject instanceof Transform) {\n      return new TestPipeline({ decorator: subject });\n    }\n\n    if (subject instanceof Writable) {\n      return new TestPipeline({ indexer: subject });\n    }\n\n    if (subject.readable || subject instanceof Readable) {\n      return new TestPipeline({ collator: subject });\n    }\n\n    throw new Error(\n      'Unknown test subject: are you passing a readable, writable, or transform stream?',\n    );\n  }\n\n  /**\n   * Create a test pipeline given a collator you want to test.\n   */\n  static fromCollator(collator: Readable) {\n    return new TestPipeline({ collator });\n  }\n\n  /**\n   * Add a collator to the test pipeline.\n   */\n  withCollator(collator: Readable): this {\n    this.collator = collator;\n    return this;\n  }\n\n  /**\n   * Create a test pipeline given a decorator you want to test.\n   */\n  static fromDecorator(decorator: Transform) {\n    return new TestPipeline({ decorator });\n  }\n\n  /**\n   * Add a decorator to the test pipeline.\n   */\n  withDecorator(decorator: Transform): this {\n    this.decorator = decorator;\n    return this;\n  }\n\n  /**\n   * Create a test pipeline given an indexer you want to test.\n   */\n  static fromIndexer(indexer: Writable) {\n    return new TestPipeline({ indexer });\n  }\n\n  /**\n   * Add an indexer to the test pipeline.\n   */\n  withIndexer(indexer: Writable): this {\n    this.indexer = indexer;\n    return this;\n  }\n\n  /**\n   * Provide documents for testing decorators and indexers.\n   */\n  withDocuments(documents: IndexableDocument[]): TestPipeline {\n    if (this.collator) {\n      throw new Error('Cannot provide documents when testing a collator.');\n    }\n\n    // Set a naive readable stream that just pushes all given documents.\n    this.collator = new Readable({ objectMode: true });\n    this.collator._read = () => {};\n    process.nextTick(() => {\n      documents.forEach(document => {\n        this.collator!.push(document);\n      });\n      this.collator!.push(null);\n    });\n\n    return this;\n  }\n\n  /**\n   * Execute the test pipeline so that you can make assertions about the result\n   * or behavior of the given test subject.\n   */\n  async execute(): Promise<TestPipelineResult> {\n    const documents: IndexableDocument[] = [];\n    if (!this.collator) {\n      throw new Error(\n        'Cannot execute pipeline without a collator or documents',\n      );\n    }\n\n    // If we are here and there is no indexer, we are testing a collator or a\n    // decorator. Set up a naive writable that captures documents in memory.\n    if (!this.indexer) {\n      this.indexer = new Writable({ objectMode: true });\n      this.indexer._write = (document: IndexableDocument, _, done) => {\n        documents.push(document);\n        done();\n      };\n    }\n\n    return new Promise<TestPipelineResult>(done => {\n      const pipes: (Readable | Transform | Writable)[] = [this.collator!];\n      if (this.decorator) {\n        pipes.push(this.decorator);\n      }\n      pipes.push(this.indexer!);\n\n      pipeline(pipes, (error: NodeJS.ErrnoException | null) => {\n        done({\n          error,\n          documents,\n        });\n      });\n    });\n  }\n}\n"],"names":["Transform","Writable","Readable","pipeline"],"mappings":"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"}