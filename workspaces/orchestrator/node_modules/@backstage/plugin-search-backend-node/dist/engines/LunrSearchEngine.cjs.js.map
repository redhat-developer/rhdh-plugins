{"version":3,"file":"LunrSearchEngine.cjs.js","sources":["../../src/engines/LunrSearchEngine.ts"],"sourcesContent":["/*\n * Copyright 2021 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  IndexableDocument,\n  IndexableResultSet,\n  SearchQuery,\n} from '@backstage/plugin-search-common';\nimport { QueryTranslator, SearchEngine } from '../types';\nimport { MissingIndexError } from '../errors';\nimport lunr from 'lunr';\nimport { v4 as uuid } from 'uuid';\nimport { LunrSearchEngineIndexer } from './LunrSearchEngineIndexer';\nimport { LoggerService } from '@backstage/backend-plugin-api';\n\n/**\n * Type of translated query for the Lunr Search Engine.\n * @public\n */\nexport type ConcreteLunrQuery = {\n  lunrQueryBuilder: lunr.Index.QueryBuilder;\n  documentTypes?: string[];\n  pageSize: number;\n};\n\ntype LunrResultEnvelope = {\n  result: lunr.Index.Result;\n  type: string;\n};\n\n/**\n * Translator responsible for translating search term and filters to a query that the Lunr Search Engine understands.\n * @public\n */\nexport type LunrQueryTranslator = (query: SearchQuery) => ConcreteLunrQuery;\n\n/**\n * Lunr specific search engine implementation.\n * @public\n */\nexport class LunrSearchEngine implements SearchEngine {\n  protected lunrIndices: Record<string, lunr.Index> = {};\n  protected docStore: Record<string, IndexableDocument>;\n  protected logger: LoggerService;\n  protected highlightPreTag: string;\n  protected highlightPostTag: string;\n\n  constructor(options: { logger: LoggerService }) {\n    this.logger = options.logger;\n    this.docStore = {};\n    const uuidTag = uuid();\n    this.highlightPreTag = `<${uuidTag}>`;\n    this.highlightPostTag = `</${uuidTag}>`;\n  }\n\n  protected translator: QueryTranslator = ({\n    term,\n    filters,\n    types,\n    pageLimit,\n  }: SearchQuery): ConcreteLunrQuery => {\n    const pageSize = pageLimit || 25;\n\n    return {\n      lunrQueryBuilder: q => {\n        const termToken = lunr.tokenizer(term);\n\n        // Support for typeahead search is based on https://github.com/olivernn/lunr.js/issues/256#issuecomment-295407852\n        // look for an exact match and apply a large positive boost\n        q.term(termToken, {\n          usePipeline: true,\n          boost: 100,\n        });\n        // look for terms that match the beginning of this term and apply a\n        // medium boost\n        q.term(termToken, {\n          usePipeline: false,\n          boost: 10,\n          wildcard: lunr.Query.wildcard.TRAILING,\n        });\n        // look for terms that match with an edit distance of 2 and apply a\n        // small boost\n        q.term(termToken, {\n          usePipeline: false,\n          editDistance: 2,\n          boost: 1,\n        });\n\n        if (filters) {\n          Object.entries(filters).forEach(([field, fieldValue]) => {\n            if (!q.allFields.includes(field)) {\n              // Throw for unknown field, as this will be a non match\n              throw new Error(`unrecognised field ${field}`);\n            }\n            // Arrays are poorly supported, but we can make it better for single-item arrays,\n            // which should be a common case\n            const value =\n              Array.isArray(fieldValue) && fieldValue.length === 1\n                ? fieldValue[0]\n                : fieldValue;\n\n            // Require that the given field has the given value\n            if (['string', 'number', 'boolean'].includes(typeof value)) {\n              q.term(\n                lunr\n                  .tokenizer(value?.toString())\n                  .map(lunr.stopWordFilter)\n                  .filter(element => element !== undefined),\n                {\n                  presence: lunr.Query.presence.REQUIRED,\n                  fields: [field],\n                },\n              );\n            } else if (Array.isArray(value)) {\n              // Illustrate how multi-value filters could work.\n              // But warn that Lurn supports this poorly.\n              this.logger.warn(\n                `Non-scalar filter value used for field ${field}. Consider using a different Search Engine for better results.`,\n              );\n              q.term(lunr.tokenizer(value), {\n                presence: lunr.Query.presence.OPTIONAL,\n                fields: [field],\n              });\n            } else {\n              // Log a warning or something about unknown filter value\n              this.logger.warn(`Unknown filter type used on field ${field}`);\n            }\n          });\n        }\n      },\n      documentTypes: types,\n      pageSize,\n    };\n  };\n\n  setTranslator(translator: LunrQueryTranslator) {\n    this.translator = translator;\n  }\n\n  async getIndexer(type: string) {\n    const indexer = new LunrSearchEngineIndexer();\n    const indexerLogger = this.logger.child({ documentType: type });\n    let errorThrown: Error | undefined;\n\n    indexer.on('error', err => {\n      errorThrown = err;\n    });\n\n    indexer.on('close', () => {\n      // Once the stream is closed, build the index and store the documents in\n      // memory for later retrieval.\n      const newDocuments = indexer.getDocumentStore();\n      const docStoreExists = this.lunrIndices[type] !== undefined;\n      const documentsIndexed = Object.keys(newDocuments).length;\n\n      // Do not set the index if there was an error or if no documents were\n      // indexed. This ensures search continues to work for an index, even in\n      // case of transient issues in underlying collators.\n      if (!errorThrown && documentsIndexed > 0) {\n        this.lunrIndices[type] = indexer.buildIndex();\n        this.docStore = { ...this.docStore, ...newDocuments };\n      } else {\n        indexerLogger.warn(\n          `Index for ${type} was not ${\n            docStoreExists ? 'replaced' : 'created'\n          }: ${\n            errorThrown\n              ? 'an error was encountered'\n              : 'indexer received 0 documents'\n          }`,\n        );\n      }\n    });\n\n    return indexer;\n  }\n\n  async query(query: SearchQuery): Promise<IndexableResultSet> {\n    const { lunrQueryBuilder, documentTypes, pageSize } = this.translator(\n      query,\n    ) as ConcreteLunrQuery;\n\n    const results: LunrResultEnvelope[] = [];\n\n    const indexKeys = Object.keys(this.lunrIndices).filter(\n      type => !documentTypes || documentTypes.includes(type),\n    );\n\n    if (documentTypes?.length && !indexKeys.length) {\n      throw new MissingIndexError(\n        `Missing index for ${documentTypes?.toString()}. This could be because the index hasn't been created yet or there was a problem during index creation.`,\n      );\n    }\n\n    // Iterate over the filtered list of this.lunrIndex keys.\n    indexKeys.forEach(type => {\n      try {\n        results.push(\n          ...this.lunrIndices[type].query(lunrQueryBuilder).map(result => {\n            return {\n              result: result,\n              type: type,\n            };\n          }),\n        );\n      } catch (err) {\n        // if a field does not exist on a index, we can see that as a no-match\n        if (\n          err instanceof Error &&\n          err.message.startsWith('unrecognised field')\n        ) {\n          return;\n        }\n        throw err;\n      }\n    });\n\n    // Sort results.\n    results.sort((doc1, doc2) => {\n      return doc2.result.score - doc1.result.score;\n    });\n\n    // Perform paging\n    const { page } = decodePageCursor(query.pageCursor);\n    const offset = page * pageSize;\n    const hasPreviousPage = page > 0;\n    const hasNextPage = results.length > offset + pageSize;\n    const nextPageCursor = hasNextPage\n      ? encodePageCursor({ page: page + 1 })\n      : undefined;\n    const previousPageCursor = hasPreviousPage\n      ? encodePageCursor({ page: page - 1 })\n      : undefined;\n\n    // Translate results into IndexableResultSet\n    const realResultSet: IndexableResultSet = {\n      results: results.slice(offset, offset + pageSize).map((d, index) => ({\n        type: d.type,\n        document: this.docStore[d.result.ref],\n        rank: page * pageSize + index + 1,\n        highlight: {\n          preTag: this.highlightPreTag,\n          postTag: this.highlightPostTag,\n          fields: parseHighlightFields({\n            preTag: this.highlightPreTag,\n            postTag: this.highlightPostTag,\n            doc: this.docStore[d.result.ref],\n            positionMetadata: d.result.matchData.metadata as any,\n          }),\n        },\n      })),\n      numberOfResults: results.length,\n      nextPageCursor,\n      previousPageCursor,\n    };\n\n    return realResultSet;\n  }\n}\n\nexport function decodePageCursor(pageCursor?: string): { page: number } {\n  if (!pageCursor) {\n    return { page: 0 };\n  }\n\n  return {\n    page: Number(Buffer.from(pageCursor, 'base64').toString('utf-8')),\n  };\n}\n\nexport function encodePageCursor({ page }: { page: number }): string {\n  return Buffer.from(`${page}`, 'utf-8').toString('base64');\n}\n\ntype ParseHighlightFieldsProps = {\n  preTag: string;\n  postTag: string;\n  doc: any;\n  positionMetadata: {\n    [term: string]: {\n      [field: string]: {\n        position: number[][];\n      };\n    };\n  };\n};\n\nexport function parseHighlightFields({\n  preTag,\n  postTag,\n  doc,\n  positionMetadata,\n}: ParseHighlightFieldsProps): { [field: string]: string } {\n  // Merge the field positions across all query terms\n  const highlightFieldPositions = Object.values(positionMetadata).reduce(\n    (fieldPositions, metadata) => {\n      Object.keys(metadata).map(fieldKey => {\n        const validFieldMetadataPositions = metadata[\n          fieldKey\n        ]?.position?.filter(position => Array.isArray(position));\n        if (validFieldMetadataPositions.length) {\n          fieldPositions[fieldKey] = fieldPositions[fieldKey] ?? [];\n          fieldPositions[fieldKey].push(...validFieldMetadataPositions);\n        }\n      });\n\n      return fieldPositions;\n    },\n    {} as { [field: string]: number[][] },\n  );\n\n  return Object.fromEntries(\n    Object.entries(highlightFieldPositions).map(([field, positions]) => {\n      positions.sort((a, b) => b[0] - a[0]);\n\n      const highlightedField = positions.reduce((content, pos) => {\n        return (\n          `${String(content).substring(0, pos[0])}${preTag}` +\n          `${String(content).substring(pos[0], pos[0] + pos[1])}` +\n          `${postTag}${String(content).substring(pos[0] + pos[1])}`\n        );\n      }, doc[field] ?? '');\n\n      return [field, highlightedField];\n    }),\n  );\n}\n"],"names":["uuid","lunr","LunrSearchEngineIndexer","MissingIndexError"],"mappings":"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"}