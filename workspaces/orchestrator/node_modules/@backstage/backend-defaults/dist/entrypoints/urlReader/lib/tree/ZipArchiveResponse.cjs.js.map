{"version":3,"file":"ZipArchiveResponse.cjs.js","sources":["../../../../../src/entrypoints/urlReader/lib/tree/ZipArchiveResponse.ts"],"sourcesContent":["/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  UrlReaderServiceReadTreeResponse,\n  UrlReaderServiceReadTreeResponseDirOptions,\n  UrlReaderServiceReadTreeResponseFile,\n} from '@backstage/backend-plugin-api';\nimport archiver from 'archiver';\nimport yauzl, { Entry } from 'yauzl';\nimport fs from 'fs-extra';\nimport platformPath from 'path';\nimport { Readable } from 'stream';\nimport { streamToBuffer } from './util';\nimport { resolveSafeChildPath } from '@backstage/backend-plugin-api';\n\n/**\n * Wraps a zip archive stream into a tree response reader.\n */\nexport class ZipArchiveResponse implements UrlReaderServiceReadTreeResponse {\n  private read = false;\n\n  constructor(\n    private readonly stream: Readable,\n    private readonly subPath: string,\n    private readonly workDir: string,\n    public readonly etag: string,\n    private readonly filter?: (path: string, info: { size: number }) => boolean,\n  ) {\n    if (subPath) {\n      if (!subPath.endsWith('/')) {\n        this.subPath += '/';\n      }\n      if (subPath.startsWith('/')) {\n        throw new TypeError(\n          `ZipArchiveResponse subPath must not start with a /, got '${subPath}'`,\n        );\n      }\n    }\n\n    this.etag = etag;\n  }\n\n  // Make sure the input stream is only read once\n  private onlyOnce() {\n    if (this.read) {\n      throw new Error('Response has already been read');\n    }\n    this.read = true;\n  }\n\n  // File path relative to the root extracted directory or a sub directory if subpath is set.\n  private getInnerPath(path: string): string {\n    return path.slice(this.subPath.length);\n  }\n\n  private shouldBeIncluded(entry: Entry): boolean {\n    if (this.subPath) {\n      if (!entry.fileName.startsWith(this.subPath)) {\n        return false;\n      }\n    }\n    if (this.filter) {\n      return this.filter(this.getInnerPath(entry.fileName), {\n        size: entry.uncompressedSize,\n      });\n    }\n    return true;\n  }\n\n  private async streamToTemporaryFile(\n    stream: Readable,\n  ): Promise<{ fileName: string; cleanup: () => Promise<void> }> {\n    const tmpDir = await fs.mkdtemp(\n      platformPath.join(this.workDir, 'backstage-tmp'),\n    );\n    const tmpFile = platformPath.join(tmpDir, 'tmp.zip');\n\n    const writeStream = fs.createWriteStream(tmpFile);\n\n    return new Promise((resolve, reject) => {\n      writeStream.on('error', reject);\n      writeStream.on('finish', () => {\n        writeStream.end();\n        resolve({\n          fileName: tmpFile,\n          cleanup: () => fs.rm(tmpDir, { recursive: true }),\n        });\n      });\n      stream.pipe(writeStream);\n    });\n  }\n\n  private forEveryZipEntry(\n    zip: string,\n    callback: (entry: Entry, content: Readable) => Promise<void>,\n  ): Promise<void> {\n    return new Promise((resolve, reject) => {\n      yauzl.open(zip, { lazyEntries: true }, (err, zipfile) => {\n        if (err || !zipfile) {\n          reject(err || new Error(`Failed to open zip file ${zip}`));\n          return;\n        }\n\n        zipfile.on('entry', async (entry: Entry) => {\n          // Check that the file is not a directory, and that is matches the filter.\n          if (!entry.fileName.endsWith('/') && this.shouldBeIncluded(entry)) {\n            zipfile.openReadStream(entry, async (openErr, readStream) => {\n              if (openErr || !readStream) {\n                reject(\n                  openErr ||\n                    new Error(`Failed to open zip entry ${entry.fileName}`),\n                );\n                return;\n              }\n\n              await callback(entry, readStream);\n              zipfile.readEntry();\n            });\n          } else {\n            zipfile.readEntry();\n          }\n        });\n        zipfile.once('end', () => resolve());\n        zipfile.on('error', e => reject(e));\n        zipfile.readEntry();\n      });\n    });\n  }\n\n  async files(): Promise<UrlReaderServiceReadTreeResponseFile[]> {\n    this.onlyOnce();\n    const files = Array<UrlReaderServiceReadTreeResponseFile>();\n    const temporary = await this.streamToTemporaryFile(this.stream);\n\n    await this.forEveryZipEntry(temporary.fileName, async (entry, content) => {\n      files.push({\n        path: this.getInnerPath(entry.fileName),\n        content: async () => await streamToBuffer(content),\n        lastModifiedAt: entry.lastModFileTime\n          ? new Date(entry.lastModFileTime)\n          : undefined,\n      });\n    });\n\n    await temporary.cleanup();\n\n    return files;\n  }\n\n  async archive(): Promise<Readable> {\n    this.onlyOnce();\n\n    if (!this.subPath) {\n      return this.stream;\n    }\n\n    const archive = archiver('zip');\n    const temporary = await this.streamToTemporaryFile(this.stream);\n\n    await this.forEveryZipEntry(temporary.fileName, async (entry, content) => {\n      archive.append(await streamToBuffer(content), {\n        name: this.getInnerPath(entry.fileName),\n      });\n    });\n\n    archive.finalize();\n\n    await temporary.cleanup();\n\n    return archive;\n  }\n\n  async dir(\n    options?: UrlReaderServiceReadTreeResponseDirOptions,\n  ): Promise<string> {\n    this.onlyOnce();\n    const dir =\n      options?.targetDir ??\n      (await fs.mkdtemp(platformPath.join(this.workDir, 'backstage-')));\n\n    const temporary = await this.streamToTemporaryFile(this.stream);\n\n    await this.forEveryZipEntry(temporary.fileName, async (entry, content) => {\n      const entryPath = this.getInnerPath(entry.fileName);\n      const dirname = platformPath.dirname(entryPath);\n\n      if (dirname) {\n        await fs.mkdirp(resolveSafeChildPath(dir, dirname));\n      }\n      return new Promise(async (resolve, reject) => {\n        const file = fs.createWriteStream(resolveSafeChildPath(dir, entryPath));\n        file.on('finish', resolve);\n\n        content.on('error', reject);\n        content.pipe(file);\n      });\n    });\n\n    await temporary.cleanup();\n\n    return dir;\n  }\n}\n"],"names":["fs","platformPath","yauzl","streamToBuffer","archiver","resolveSafeChildPath"],"mappings":"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"}