'use strict';

var errors = require('@backstage/errors');
var cron = require('cron');
var luxon = require('luxon');
var util = require('./util.cjs.js');

class LocalTaskWorker {
  constructor(taskId, fn, logger) {
    this.taskId = taskId;
    this.fn = fn;
    this.logger = logger;
  }
  abortWait;
  #taskState = {
    status: "idle"
  };
  #workerState = {
    status: "idle"
  };
  start(settings, options) {
    this.logger.info(
      `Task worker starting: ${this.taskId}, ${JSON.stringify(settings)}`
    );
    (async () => {
      let attemptNum = 1;
      for (; ; ) {
        try {
          await this.performInitialWait(settings, options.signal);
          while (!options.signal.aborted) {
            const startTime = process.hrtime();
            await this.runOnce(settings, options.signal);
            const timeTaken = process.hrtime(startTime);
            await this.waitUntilNext(
              settings,
              (timeTaken[0] + timeTaken[1] / 1e9) * 1e3,
              options.signal
            );
          }
          this.logger.info(`Task worker finished: ${this.taskId}`);
          attemptNum = 0;
          break;
        } catch (e) {
          attemptNum += 1;
          this.logger.warn(
            `Task worker failed unexpectedly, attempt number ${attemptNum}, ${e}`
          );
          await util.sleep(luxon.Duration.fromObject({ seconds: 1 }));
        }
      }
    })();
  }
  trigger() {
    if (!this.abortWait) {
      throw new errors.ConflictError(`Task ${this.taskId} is currently running`);
    }
    this.abortWait.abort();
  }
  taskState() {
    return this.#taskState;
  }
  workerState() {
    return this.#workerState;
  }
  /**
   * Does the once-at-startup initial wait, if configured.
   */
  async performInitialWait(settings, signal) {
    if (settings.initialDelayDuration) {
      const parsedDuration = luxon.Duration.fromISO(settings.initialDelayDuration);
      this.#taskState = {
        status: "idle",
        startsAt: luxon.DateTime.utc().plus(parsedDuration).toISO(),
        lastRunEndedAt: this.#taskState.lastRunEndedAt,
        lastRunError: this.#taskState.lastRunError
      };
      this.#workerState = {
        status: "initial-wait"
      };
      await this.sleep(parsedDuration, signal);
    }
  }
  /**
   * Makes a single attempt at running the task to completion.
   */
  async runOnce(settings, signal) {
    const taskAbortController = util.delegateAbortController(signal);
    const timeoutDuration = luxon.Duration.fromISO(settings.timeoutAfterDuration);
    const timeoutHandle = setTimeout(() => {
      taskAbortController.abort();
    }, timeoutDuration.as("milliseconds"));
    this.#taskState = {
      status: "running",
      startedAt: luxon.DateTime.utc().toISO(),
      timesOutAt: luxon.DateTime.utc().plus(timeoutDuration).toISO(),
      lastRunEndedAt: this.#taskState.lastRunEndedAt,
      lastRunError: this.#taskState.lastRunError
    };
    this.#workerState = {
      status: "running"
    };
    try {
      await this.fn(taskAbortController.signal);
      this.#taskState.lastRunEndedAt = luxon.DateTime.utc().toISO();
      this.#taskState.lastRunError = void 0;
    } catch (e) {
      this.#taskState.lastRunEndedAt = luxon.DateTime.utc().toISO();
      this.#taskState.lastRunError = util.serializeError(e);
    }
    clearTimeout(timeoutHandle);
    taskAbortController.abort();
  }
  /**
   * Sleeps until it's time to run the task again.
   */
  async waitUntilNext(settings, lastRunMillis, signal) {
    if (signal.aborted) {
      return;
    }
    const isCron = !settings.cadence.startsWith("P");
    let dt;
    if (isCron) {
      const nextRun = +new cron.CronTime(settings.cadence).sendAt().toJSDate();
      dt = nextRun - Date.now();
    } else {
      dt = luxon.Duration.fromISO(settings.cadence).as("milliseconds") - lastRunMillis;
    }
    dt = Math.max(dt, 0);
    const startsAt = luxon.DateTime.now().plus(luxon.Duration.fromMillis(dt));
    this.#taskState = {
      status: "idle",
      startsAt: startsAt.toISO(),
      lastRunEndedAt: this.#taskState.lastRunEndedAt,
      lastRunError: this.#taskState.lastRunError
    };
    this.#workerState = {
      status: "idle"
    };
    this.logger.debug(
      `task: ${this.taskId} will next occur around ${startsAt}`
    );
    await this.sleep(luxon.Duration.fromMillis(dt), signal);
  }
  async sleep(duration, abortSignal) {
    this.abortWait = util.delegateAbortController(abortSignal);
    await util.sleep(duration, this.abortWait.signal);
    this.abortWait.abort();
    this.abortWait = void 0;
  }
}

exports.LocalTaskWorker = LocalTaskWorker;
//# sourceMappingURL=LocalTaskWorker.cjs.js.map
