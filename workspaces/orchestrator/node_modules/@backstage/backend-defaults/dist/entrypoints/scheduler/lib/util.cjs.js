'use strict';

var errors = require('@backstage/errors');
var luxon = require('luxon');

const TRACER_ID = "backstage-service-scheduler";
function validateId(id) {
  if (typeof id !== "string" || !id.trim()) {
    throw new errors.InputError(`${id} is not a valid ID, expected non-empty string`);
  }
}
function dbTime(t) {
  if (typeof t === "string") {
    return luxon.DateTime.fromSQL(t);
  }
  return luxon.DateTime.fromJSDate(t);
}
function nowPlus(duration, knex) {
  const seconds = duration?.as("seconds") ?? 0;
  if (!seconds) {
    return knex.fn.now();
  }
  if (knex.client.config.client.includes("sqlite3")) {
    return knex.raw(`datetime('now', ?)`, [`${seconds} seconds`]);
  }
  if (knex.client.config.client.includes("mysql")) {
    return knex.raw(`now() + interval ${seconds} second`);
  }
  return knex.raw(`now() + interval '${seconds} seconds'`);
}
async function sleep(duration, abortSignal) {
  if (abortSignal?.aborted) {
    return;
  }
  await new Promise((resolve) => {
    let timeoutHandle = void 0;
    const done = () => {
      if (timeoutHandle) {
        clearTimeout(timeoutHandle);
      }
      abortSignal?.removeEventListener("abort", done);
      resolve();
    };
    timeoutHandle = setTimeout(done, duration.as("milliseconds"));
    abortSignal?.addEventListener("abort", done);
  });
}
function delegateAbortController(parent) {
  const delegate = new AbortController();
  if (parent) {
    if (parent.aborted) {
      delegate.abort();
    } else {
      const onParentAborted = () => {
        delegate.abort();
      };
      const onChildAborted = () => {
        parent.removeEventListener("abort", onParentAborted);
      };
      parent.addEventListener("abort", onParentAborted, { once: true });
      delegate.signal.addEventListener("abort", onChildAborted, { once: true });
    }
  }
  return delegate;
}
function serializeError(error) {
  return JSON.stringify(
    errors.serializeError(error, {
      includeStack: process.env.NODE_ENV === "development"
    })
  );
}

exports.TRACER_ID = TRACER_ID;
exports.dbTime = dbTime;
exports.delegateAbortController = delegateAbortController;
exports.nowPlus = nowPlus;
exports.serializeError = serializeError;
exports.sleep = sleep;
exports.validateId = validateId;
//# sourceMappingURL=util.cjs.js.map
