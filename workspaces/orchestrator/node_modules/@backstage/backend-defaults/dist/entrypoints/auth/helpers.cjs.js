'use strict';

var crypto = require('crypto');

function createCredentialsWithServicePrincipal(sub, token, accessRestrictions) {
  const principal = createServicePrincipal(sub, accessRestrictions);
  const result = {
    $$type: "@backstage/BackstageCredentials",
    version: "v1",
    principal
  };
  Object.defineProperties(result, {
    token: {
      enumerable: false,
      configurable: true,
      writable: true,
      value: token
    },
    toString: {
      enumerable: false,
      configurable: true,
      writable: true,
      value: () => `backstageCredentials{${principal}}`
    }
  });
  return result;
}
function createCredentialsWithUserPrincipal(sub, token, expiresAt, actor) {
  const principal = createUserPrincipal(
    sub,
    actor ? createServicePrincipal(actor) : void 0
  );
  const result = {
    $$type: "@backstage/BackstageCredentials",
    version: "v1",
    expiresAt,
    principal
  };
  Object.defineProperties(result, {
    token: {
      enumerable: false,
      configurable: true,
      writable: true,
      value: token
    },
    toString: {
      enumerable: false,
      configurable: true,
      writable: true,
      value: () => `backstageCredentials{${principal}}`
    }
  });
  return result;
}
function createCredentialsWithNonePrincipal() {
  const principal = createNonePrincipal();
  const result = {
    $$type: "@backstage/BackstageCredentials",
    version: "v1",
    principal
  };
  Object.defineProperties(result, {
    toString: {
      enumerable: false,
      configurable: true,
      writable: true,
      value: () => `backstageCredentials{${principal}}`
    }
  });
  return result;
}
function toInternalBackstageCredentials(credentials) {
  if (credentials.$$type !== "@backstage/BackstageCredentials") {
    throw new Error("Invalid credential type");
  }
  const internalCredentials = credentials;
  if (internalCredentials.version !== "v1") {
    throw new Error(
      `Invalid credential version ${internalCredentials.version}`
    );
  }
  return internalCredentials;
}
function createServicePrincipal(sub, accessRestrictions) {
  const result = {
    type: "service",
    subject: sub,
    accessRestrictions
  };
  Object.defineProperties(result, {
    toString: {
      enumerable: false,
      configurable: true,
      writable: true,
      value: () => {
        let parts = sub;
        if (accessRestrictions) {
          const hash = crypto.createHash("sha256").update(JSON.stringify(accessRestrictions)).digest("base64").replace(/=+$/, "");
          parts += `,accessRestrictions=${hash}`;
        }
        return `servicePrincipal{${parts}}`;
      }
    }
  });
  return result;
}
function createUserPrincipal(userEntityRef, actor) {
  const result = {
    type: "user",
    userEntityRef,
    actor
  };
  Object.defineProperties(result, {
    toString: {
      enumerable: false,
      configurable: true,
      writable: true,
      value: () => {
        let parts = userEntityRef;
        if (actor) {
          parts += `,actor={${actor}}`;
        }
        return `userPrincipal{${parts}}`;
      }
    }
  });
  return result;
}
function createNonePrincipal() {
  const result = {
    type: "none"
  };
  Object.defineProperties(result, {
    toString: {
      enumerable: false,
      configurable: true,
      writable: true,
      value: () => "nonePrincipal"
    }
  });
  return result;
}

exports.createCredentialsWithNonePrincipal = createCredentialsWithNonePrincipal;
exports.createCredentialsWithServicePrincipal = createCredentialsWithServicePrincipal;
exports.createCredentialsWithUserPrincipal = createCredentialsWithUserPrincipal;
exports.toInternalBackstageCredentials = toInternalBackstageCredentials;
//# sourceMappingURL=helpers.cjs.js.map
