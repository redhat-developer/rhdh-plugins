{"version":3,"file":"SrvResolvers.cjs.js","sources":["../../../src/entrypoints/discovery/SrvResolvers.ts"],"sourcesContent":["/*\n * Copyright 2025 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ForwardedError, InputError, NotFoundError } from '@backstage/errors';\nimport { resolveSrv, SrvRecord } from 'dns';\n\nconst PROTOCOL_SUFFIX = '+srv:';\n\n/**\n * Helps with resolution and caching of SRV lookups.\n *\n * Supports URLs on the form `http+srv://myplugin.services.region.example.net/api/myplugin`\n */\nexport class SrvResolvers {\n  readonly #cache: Map<string, Promise<SrvRecord[]>>;\n  readonly #cacheTtlMillis: number;\n  readonly #resolveSrv: (host: string) => Promise<SrvRecord[]>;\n\n  constructor(options?: {\n    resolveSrv?: (host: string) => Promise<SrvRecord[]>;\n    cacheTtlMillis?: number;\n  }) {\n    this.#cache = new Map();\n    this.#cacheTtlMillis = options?.cacheTtlMillis ?? 1000;\n    this.#resolveSrv =\n      options?.resolveSrv ??\n      (host =>\n        new Promise((resolve, reject) => {\n          resolveSrv(host, (err, result) => {\n            if (err) {\n              reject(err);\n            } else {\n              resolve(result);\n            }\n          });\n        }));\n  }\n\n  isSrvUrl(url: string): boolean {\n    try {\n      this.#parseSrvUrl(url);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Get a resolver function for a given SRV form URL.\n   *\n   * @param url An SRV form URL, e.g. `http+srv://myplugin.services.region.example.net/api/myplugin`\n   * @returns A function that returns resolved URLs, e.g. `http://1234abcd.region.example.net:8080/api/myplugin`\n   */\n  getResolver(url: string): () => Promise<string> {\n    const { protocol, host, path } = this.#parseSrvUrl(url);\n    return () =>\n      this.#resolveHost(host).then(\n        resolved => `${protocol}://${resolved}${path}`,\n      );\n  }\n\n  /**\n   * Attempts to parse out the relevant parts of an SRV URL.\n   */\n  #parseSrvUrl(url: string): { protocol: string; host: string; path: string } {\n    let parsedUrl: URL;\n    try {\n      parsedUrl = new URL(url);\n    } catch {\n      throw new InputError(\n        `SRV resolver expected a valid URL starting with http(s)+srv:// but got '${url}'`,\n      );\n    }\n    if (!parsedUrl.protocol?.endsWith(PROTOCOL_SUFFIX) || !parsedUrl.hostname) {\n      throw new InputError(\n        `SRV resolver expected a URL with protocol http(s)+srv:// but got '${url}'`,\n      );\n    }\n    if (parsedUrl.port) {\n      throw new InputError(\n        `SRV resolver URLs cannot contain a port but got '${url}'`,\n      );\n    }\n    if (parsedUrl.username || parsedUrl.password) {\n      throw new InputError(\n        `SRV resolver URLs cannot contain username or password but got '${url}'`,\n      );\n    }\n    if (parsedUrl.search || parsedUrl.hash) {\n      throw new InputError(\n        `SRV resolver URLs cannot contain search params or a hash but got '${url}'`,\n      );\n    }\n\n    const protocol = parsedUrl.protocol.substring(\n      0,\n      parsedUrl.protocol.length - PROTOCOL_SUFFIX.length,\n    );\n    const host = parsedUrl.hostname;\n    const path = parsedUrl.pathname.replace(/\\/+$/, '');\n\n    if (!['http', 'https'].includes(protocol)) {\n      throw new InputError(\n        `SRV URLs must be based on http or https but got '${url}'`,\n      );\n    }\n\n    return { protocol, host, path };\n  }\n\n  /**\n   * Resolves a single SRV record name to a host:port string.\n   */\n  #resolveHost(host: string): Promise<string> {\n    let records = this.#cache.get(host);\n    if (!records) {\n      records = this.#resolveSrv(host).then(\n        result => {\n          if (!result.length) {\n            throw new NotFoundError(`No SRV records found for ${host}`);\n          }\n          return result;\n        },\n        err => {\n          throw new ForwardedError(`Failed SRV resolution for ${host}`, err);\n        },\n      );\n      this.#cache.set(host, records);\n      setTimeout(() => {\n        this.#cache.delete(host);\n      }, this.#cacheTtlMillis);\n    }\n\n    return records.then(rs => {\n      const r = this.#pickRandomRecord(rs);\n      return `${r.name}:${r.port}`;\n    });\n  }\n\n  /**\n   * Among a set of records, pick one at random.\n   *\n   * This assumes that the set is not empty.\n   *\n   * Since this contract only ever returns a single record, the best it can do\n   * is to pick weighted-randomly among the highest-priority records. In order\n   * to be smarter than that, the caller would have to be able to make decisions\n   * on the whole set of records.\n   */\n  #pickRandomRecord(allRecords: SrvRecord[]): SrvRecord {\n    // Lowest priority number means highest priority\n    const lowestPriority = allRecords.reduce(\n      (acc, r) => Math.min(acc, r.priority),\n      Number.MAX_SAFE_INTEGER,\n    );\n    const records = allRecords.filter(r => r.priority === lowestPriority);\n\n    const totalWeight = records.reduce((acc, r) => acc + r.weight, 0);\n    const targetWeight = Math.random() * totalWeight;\n\n    // Just as a fallback, we expect the loop below to always find a result\n    let result = records[0];\n    let currentWeight = 0;\n\n    for (const record of records) {\n      currentWeight += record.weight;\n      if (targetWeight <= currentWeight) {\n        result = record;\n        break;\n      }\n    }\n\n    return result;\n  }\n}\n"],"names":["resolveSrv","InputError","NotFoundError","ForwardedError"],"mappings":"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"}