'use strict';

var events = require('events');

class InfinispanKeyvStore extends events.EventEmitter {
  clientPromise;
  logger;
  defaultTtl;
  resolvedClient = null;
  namespace;
  // Keyv expects this
  constructor(options) {
    super();
    this.clientPromise = options.clientPromise;
    this.logger = options.logger.child({ class: InfinispanKeyvStore.name });
    this.defaultTtl = options.defaultTtl;
    this.clientPromise.then((client) => {
      this.resolvedClient = client;
      if (typeof client.on === "function") {
        client.on("error", (error) => {
          this.logger.error("Native Infinispan client reported an error.", {
            error: error.message
          });
          this.emit("error", error);
        });
      } else {
        this.logger.warn(
          'Native Infinispan client does not appear to support .on("error") event listening.'
        );
      }
    }).catch((err) => {
      this.logger.error(
        "Failed to resolve Infinispan client promise in constructor.",
        { error: err.message }
      );
      this.emit("error", err);
    });
  }
  async getClient() {
    if (this.resolvedClient) {
      return this.resolvedClient;
    }
    this.resolvedClient = await this.clientPromise;
    return this.resolvedClient;
  }
  async get(key) {
    this.logger.debug(`Getting key: ${key}`);
    try {
      const client = await this.getClient();
      const value = await client.get(key);
      if (value === null || value === void 0) {
        this.logger.debug(`Key not found or value is null/undefined: ${key}`);
        return void 0;
      }
      this.logger.debug(`Successfully retrieved key: ${key}`);
      return value;
    } catch (error) {
      this.logger.error(`Error getting key '${key}' from Infinispan.`, {
        error: error.message
      });
      this.emit(
        "error",
        error instanceof Error ? error : new Error(String(error))
      );
      throw error;
    }
  }
  async set(key, value, ttl) {
    this.logger.debug(`Setting key: ${key}`, { ttl });
    this.logger.debug(`Setting key: ${key}`, { ttlInput: ttl });
    const currentTtl = ttl ?? this.defaultTtl;
    this.logger.debug(`Calculated currentTtl for key ${key}: ${currentTtl}ms`);
    const storeOptions = {};
    if (typeof currentTtl === "number" && currentTtl > 0) {
      storeOptions.lifespan = `${currentTtl}ms`;
    } else if (typeof currentTtl === "string") {
      storeOptions.lifespan = currentTtl;
    }
    try {
      const client = await this.getClient();
      await client.put(key, value, storeOptions);
      this.logger.debug(`Successfully set key: ${key}`);
    } catch (error) {
      this.logger.error(`Error setting key '${key}' in Infinispan.`, {
        error: error.message
      });
      this.emit(
        "error",
        error instanceof Error ? error : new Error(String(error))
      );
      throw error;
    }
  }
  async delete(key) {
    this.logger.debug(`Deleting key: ${key}`);
    try {
      const client = await this.getClient();
      const deleted = await client.remove(key);
      this.logger.debug(`Key deletion status for '${key}': ${deleted}`);
      return deleted;
    } catch (error) {
      this.logger.error(`Error deleting key '${key}' from Infinispan.`, {
        error: error.message
      });
      this.emit(
        "error",
        error instanceof Error ? error : new Error(String(error))
      );
      throw error;
    }
  }
  async clear() {
    this.logger.info("Clearing all entries from Infinispan cache.");
    try {
      const client = await this.getClient();
      await client.clear();
      this.logger.info("Infinispan cache cleared successfully.");
    } catch (error) {
      this.logger.error("Error clearing Infinispan cache.", {
        error: error.message
      });
      this.emit(
        "error",
        error instanceof Error ? error : new Error(String(error))
      );
      throw error;
    }
  }
  // This disconnect is for the Keyv store instance, but the actual client is shared.
  // The CacheManager should handle the shared client's disconnection.
  // However, if Keyv calls this, we shouldn't error.
  async disconnect() {
    this.logger.info(
      "InfinispanKeyvStore disconnect called. Shared client managed by CacheManager."
    );
    return Promise.resolve();
  }
}

exports.InfinispanKeyvStore = InfinispanKeyvStore;
//# sourceMappingURL=InfinispanKeyvStore.cjs.js.map
