{"version":3,"file":"utils.cjs.js","sources":["../../../src/entrypoints/rootLogger/utils.ts"],"sourcesContent":["/*\n * Copyright 2025 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { TransformableInfo } from 'logform';\nimport { WinstonLoggerLevelOverrideMatchers } from './types';\n\n/** Parse a slash-delimited regex like `/pattern/flags` into a RegExp, or null if not a regex-string */\nconst parseRegex = (s: string): RegExp | null => {\n  if (!s.startsWith('/')) return null;\n  const lastSlash = s.lastIndexOf('/');\n  if (lastSlash <= 0) return null;\n\n  const pattern = s.slice(1, lastSlash);\n  const flags = s.slice(lastSlash + 1);\n\n  try {\n    return new RegExp(pattern, flags);\n  } catch {\n    return null; // fall back to treating it as a plain string\n  }\n};\n\n/**\n * Create a predicate function that determines whether a log field matches a given matcher.\n *\n * The matcher can be:\n * - A string (exact match or regex pattern delimited by slashes, e.g. `/pattern/`)\n * - A non-string value (compared by strict equality)\n * - An array of matchers (returns true if any matcher matches)\n *\n * @param matcher - The matcher or array of matchers to compare against the log field.\n * @returns A function that takes a log field and returns `true` if it matches the matcher, otherwise `false`.\n */\nconst createLogFieldMatcher = (\n  matcher: WinstonLoggerLevelOverrideMatchers[0],\n): ((logField: unknown) => boolean) => {\n  // Array of matchers: create predicates for each element and OR them together\n  if (Array.isArray(matcher)) {\n    const fns = matcher.map(m => createLogFieldMatcher(m));\n    return (logField: unknown) => fns.some(fn => fn(logField));\n  }\n\n  // Non-string matcher: strict equality\n  if (typeof matcher !== 'string') {\n    return (logField: unknown) => logField === matcher;\n  }\n\n  // String matcher: maybe a slash-delimited regex (/pattern/flags)\n  const regex = parseRegex(matcher);\n  if (regex) {\n    return (logField: unknown) =>\n      typeof logField === 'string' && regex.test(logField);\n  }\n\n  // Plain string matcher: strict equality\n  return (logField: unknown) => logField === matcher;\n};\n\n/**\n * Create a predicate function that determines whether a log entry matches\n * all specified override matchers.\n *\n * Iterates over each key-matcher pair in the provided `matchers` object,\n * retrieves the corresponding field from the `log` object, and checks if\n * the field matches the matcher using `isLogFieldMatching`. Returns `true`\n * only if all matchers are satisfied.\n *\n * @param matchers - An object where each key corresponds to a log field and each value is a matcher to test against that field.\n * @returns A function that takes a log entry and returns `true` if it matches all specified matchers, otherwise `false`.\n */\nexport const createLogMatcher = (\n  matchers: WinstonLoggerLevelOverrideMatchers,\n): ((log: TransformableInfo) => boolean) => {\n  const logFieldMatchers = Object.entries(matchers).map(([key, m]) => {\n    const fn = createLogFieldMatcher(m);\n    return [key, fn] as const;\n  });\n\n  return (log: TransformableInfo) =>\n    logFieldMatchers.every(([key, fn]) => fn(log[key]));\n};\n"],"names":[],"mappings":";;AAoBA,MAAM,UAAA,GAAa,CAAC,CAAA,KAA6B;AAC/C,EAAA,IAAI,CAAC,CAAA,CAAE,UAAA,CAAW,GAAG,GAAG,OAAO,IAAA;AAC/B,EAAA,MAAM,SAAA,GAAY,CAAA,CAAE,WAAA,CAAY,GAAG,CAAA;AACnC,EAAA,IAAI,SAAA,IAAa,GAAG,OAAO,IAAA;AAE3B,EAAA,MAAM,OAAA,GAAU,CAAA,CAAE,KAAA,CAAM,CAAA,EAAG,SAAS,CAAA;AACpC,EAAA,MAAM,KAAA,GAAQ,CAAA,CAAE,KAAA,CAAM,SAAA,GAAY,CAAC,CAAA;AAEnC,EAAA,IAAI;AACF,IAAA,OAAO,IAAI,MAAA,CAAO,OAAA,EAAS,KAAK,CAAA;AAAA,EAClC,CAAA,CAAA,MAAQ;AACN,IAAA,OAAO,IAAA;AAAA,EACT;AACF,CAAA;AAaA,MAAM,qBAAA,GAAwB,CAC5B,OAAA,KACqC;AAErC,EAAA,IAAI,KAAA,CAAM,OAAA,CAAQ,OAAO,CAAA,EAAG;AAC1B,IAAA,MAAM,MAAM,OAAA,CAAQ,GAAA,CAAI,CAAA,CAAA,KAAK,qBAAA,CAAsB,CAAC,CAAC,CAAA;AACrD,IAAA,OAAO,CAAC,QAAA,KAAsB,GAAA,CAAI,KAAK,CAAA,EAAA,KAAM,EAAA,CAAG,QAAQ,CAAC,CAAA;AAAA,EAC3D;AAGA,EAAA,IAAI,OAAO,YAAY,QAAA,EAAU;AAC/B,IAAA,OAAO,CAAC,aAAsB,QAAA,KAAa,OAAA;AAAA,EAC7C;AAGA,EAAA,MAAM,KAAA,GAAQ,WAAW,OAAO,CAAA;AAChC,EAAA,IAAI,KAAA,EAAO;AACT,IAAA,OAAO,CAAC,QAAA,KACN,OAAO,aAAa,QAAA,IAAY,KAAA,CAAM,KAAK,QAAQ,CAAA;AAAA,EACvD;AAGA,EAAA,OAAO,CAAC,aAAsB,QAAA,KAAa,OAAA;AAC7C,CAAA;AAcO,MAAM,gBAAA,GAAmB,CAC9B,QAAA,KAC0C;AAC1C,EAAA,MAAM,gBAAA,GAAmB,MAAA,CAAO,OAAA,CAAQ,QAAQ,CAAA,CAAE,IAAI,CAAC,CAAC,GAAA,EAAK,CAAC,CAAA,KAAM;AAClE,IAAA,MAAM,EAAA,GAAK,sBAAsB,CAAC,CAAA;AAClC,IAAA,OAAO,CAAC,KAAK,EAAE,CAAA;AAAA,EACjB,CAAC,CAAA;AAED,EAAA,OAAO,CAAC,GAAA,KACN,gBAAA,CAAiB,KAAA,CAAM,CAAC,CAAC,GAAA,EAAK,EAAE,CAAA,KAAM,EAAA,CAAG,GAAA,CAAI,GAAG,CAAC,CAAC,CAAA;AACtD;;;;"}