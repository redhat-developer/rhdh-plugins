{"version":3,"file":"traversal.esm.js","sources":["../../src/extensions/traversal.ts"],"sourcesContent":["/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { isValidElement, ReactNode, ReactElement, Children } from 'react';\n\nexport type Discoverer = (element: ReactElement) => ReactNode;\n\nexport type Collector<Result, Context> = () => {\n  accumulator: Result;\n  visit(\n    accumulator: Result,\n    element: ReactElement,\n    parent: ReactElement | undefined,\n    context: Context,\n  ): Context;\n};\n\n/**\n * A function that allows you to traverse a tree of React elements using\n * varying methods to discover child nodes and collect data along the way.\n */\nexport function traverseElementTree<Results>(options: {\n  root: ReactNode;\n  discoverers: Discoverer[];\n  collectors: { [name in keyof Results]: Collector<Results[name], any> };\n}): Results {\n  const collectors: {\n    [name in string]: ReturnType<Collector<any, any>>;\n  } = {};\n\n  // Bootstrap all collectors, initializing the accumulators and providing the visitor function\n  for (const name in options.collectors) {\n    if (options.collectors.hasOwnProperty(name)) {\n      collectors[name] = options.collectors[name]();\n    }\n  }\n\n  // Internal representation of an element in the tree that we're iterating over\n  type QueueItem = {\n    node: ReactNode;\n    parent: ReactElement | undefined;\n    contexts: { [name in string]: unknown };\n  };\n\n  const queue = [\n    {\n      node: Children.toArray(options.root),\n      parent: undefined,\n      contexts: {},\n    } as QueueItem,\n  ];\n\n  while (queue.length !== 0) {\n    const { node, parent, contexts } = queue.shift()!;\n\n    // While the parent and the element we pass on to collectors and discoverers\n    // have been validated and are known to be React elements, the child nodes\n    // emitted by the discoverers are not.\n    Children.forEach(node, element => {\n      if (!isValidElement(element)) {\n        return;\n      }\n\n      const nextContexts: QueueItem['contexts'] = {};\n\n      // Collectors populate their result data using the current node, and compute\n      // context for the next iteration\n      for (const name in collectors) {\n        if (collectors.hasOwnProperty(name)) {\n          const collector = collectors[name];\n\n          nextContexts[name] = collector.visit(\n            collector.accumulator,\n            element,\n            parent,\n            contexts[name],\n          );\n        }\n      }\n\n      // Discoverers provide ways to continue the traversal from the current element\n      for (const discoverer of options.discoverers) {\n        const children = discoverer(element);\n        if (children) {\n          queue.push({\n            node: children,\n            parent: element,\n            contexts: nextContexts,\n          });\n        }\n      }\n    });\n  }\n\n  return Object.fromEntries(\n    Object.entries(collectors).map(([name, c]) => [name, c.accumulator]),\n  ) as Results;\n}\n\nexport function createCollector<Result, Context>(\n  accumulatorFactory: () => Result,\n  visit: ReturnType<Collector<Result, Context>>['visit'],\n): Collector<Result, Context> {\n  return () => ({ accumulator: accumulatorFactory(), visit });\n}\n\nexport function childDiscoverer(element: ReactElement): ReactNode {\n  return element.props?.children;\n}\n\nexport function routeElementDiscoverer(element: ReactElement): ReactNode {\n  if (element.props?.path && element.props?.element) {\n    return element.props?.element;\n  }\n  return undefined;\n}\n"],"names":[],"mappings":";;AAkCO,SAAS,oBAA6B,OAAA,EAIjC;AACV,EAAA,MAAM,aAEF,EAAC;AAGL,EAAA,KAAA,MAAW,IAAA,IAAQ,QAAQ,UAAA,EAAY;AACrC,IAAA,IAAI,OAAA,CAAQ,UAAA,CAAW,cAAA,CAAe,IAAI,CAAA,EAAG;AAC3C,MAAA,UAAA,CAAW,IAAI,CAAA,GAAI,OAAA,CAAQ,UAAA,CAAW,IAAI,CAAA,EAAE;AAAA,IAC9C;AAAA,EACF;AASA,EAAA,MAAM,KAAA,GAAQ;AAAA,IACZ;AAAA,MACE,IAAA,EAAM,QAAA,CAAS,OAAA,CAAQ,OAAA,CAAQ,IAAI,CAAA;AAAA,MACnC,MAAA,EAAQ,MAAA;AAAA,MACR,UAAU;AAAC;AACb,GACF;AAEA,EAAA,OAAO,KAAA,CAAM,WAAW,CAAA,EAAG;AACzB,IAAA,MAAM,EAAE,IAAA,EAAM,MAAA,EAAQ,QAAA,EAAS,GAAI,MAAM,KAAA,EAAM;AAK/C,IAAA,QAAA,CAAS,OAAA,CAAQ,MAAM,CAAA,OAAA,KAAW;AAChC,MAAA,IAAI,CAAC,cAAA,CAAe,OAAO,CAAA,EAAG;AAC5B,QAAA;AAAA,MACF;AAEA,MAAA,MAAM,eAAsC,EAAC;AAI7C,MAAA,KAAA,MAAW,QAAQ,UAAA,EAAY;AAC7B,QAAA,IAAI,UAAA,CAAW,cAAA,CAAe,IAAI,CAAA,EAAG;AACnC,UAAA,MAAM,SAAA,GAAY,WAAW,IAAI,CAAA;AAEjC,UAAA,YAAA,CAAa,IAAI,IAAI,SAAA,CAAU,KAAA;AAAA,YAC7B,SAAA,CAAU,WAAA;AAAA,YACV,OAAA;AAAA,YACA,MAAA;AAAA,YACA,SAAS,IAAI;AAAA,WACf;AAAA,QACF;AAAA,MACF;AAGA,MAAA,KAAA,MAAW,UAAA,IAAc,QAAQ,WAAA,EAAa;AAC5C,QAAA,MAAM,QAAA,GAAW,WAAW,OAAO,CAAA;AACnC,QAAA,IAAI,QAAA,EAAU;AACZ,UAAA,KAAA,CAAM,IAAA,CAAK;AAAA,YACT,IAAA,EAAM,QAAA;AAAA,YACN,MAAA,EAAQ,OAAA;AAAA,YACR,QAAA,EAAU;AAAA,WACX,CAAA;AAAA,QACH;AAAA,MACF;AAAA,IACF,CAAC,CAAA;AAAA,EACH;AAEA,EAAA,OAAO,MAAA,CAAO,WAAA;AAAA,IACZ,MAAA,CAAO,OAAA,CAAQ,UAAU,CAAA,CAAE,IAAI,CAAC,CAAC,IAAA,EAAM,CAAC,CAAA,KAAM,CAAC,IAAA,EAAM,CAAA,CAAE,WAAW,CAAC;AAAA,GACrE;AACF;AAEO,SAAS,eAAA,CACd,oBACA,KAAA,EAC4B;AAC5B,EAAA,OAAO,OAAO,EAAE,WAAA,EAAa,kBAAA,IAAsB,KAAA,EAAM,CAAA;AAC3D;AAEO,SAAS,gBAAgB,OAAA,EAAkC;AAChE,EAAA,OAAO,QAAQ,KAAA,EAAO,QAAA;AACxB;AAEO,SAAS,uBAAuB,OAAA,EAAkC;AACvE,EAAA,IAAI,OAAA,CAAQ,KAAA,EAAO,IAAA,IAAQ,OAAA,CAAQ,OAAO,OAAA,EAAS;AACjD,IAAA,OAAO,QAAQ,KAAA,EAAO,OAAA;AAAA,EACxB;AACA,EAAA,OAAO,MAAA;AACT;;;;"}