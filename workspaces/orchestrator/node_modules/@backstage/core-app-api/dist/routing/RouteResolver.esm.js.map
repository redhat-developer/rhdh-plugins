{"version":3,"file":"RouteResolver.esm.js","sources":["../../src/routing/RouteResolver.ts"],"sourcesContent":["/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { generatePath, matchRoutes } from 'react-router-dom';\nimport {\n  AnyRouteRef,\n  BackstageRouteObject,\n  AnyParams,\n  RouteFunc,\n  routeRefType,\n  isRouteRef,\n  isSubRouteRef,\n  isExternalRouteRef,\n} from './types';\nimport {\n  RouteRef,\n  ExternalRouteRef,\n  SubRouteRef,\n} from '@backstage/core-plugin-api';\nimport { joinPaths } from './helpers';\nimport mapValues from 'lodash/mapValues';\n\n/**\n * Resolves the absolute route ref that our target route ref is pointing pointing to, as well\n * as the relative target path.\n *\n * Returns an undefined target ref if one could not be fully resolved.\n */\nfunction resolveTargetRef(\n  anyRouteRef: AnyRouteRef,\n  routePaths: Map<RouteRef, string>,\n  routeBindings: Map<AnyRouteRef, AnyRouteRef | undefined>,\n): readonly [RouteRef | undefined, string] {\n  // First we figure out which absolute route ref we're dealing with, an if there was an sub route path to append.\n  // For sub routes it will be the parent path, while for external routes it will be the bound route.\n  let targetRef: RouteRef;\n  let subRoutePath = '';\n  if (isRouteRef(anyRouteRef)) {\n    targetRef = anyRouteRef;\n  } else if (isSubRouteRef(anyRouteRef)) {\n    targetRef = anyRouteRef.parent;\n    subRoutePath = anyRouteRef.path;\n  } else if (isExternalRouteRef(anyRouteRef)) {\n    const resolvedRoute = routeBindings.get(anyRouteRef);\n    if (!resolvedRoute) {\n      return [undefined, ''];\n    }\n    if (isRouteRef(resolvedRoute)) {\n      targetRef = resolvedRoute;\n    } else if (isSubRouteRef(resolvedRoute)) {\n      targetRef = resolvedRoute.parent;\n      subRoutePath = resolvedRoute.path;\n    } else {\n      throw new Error(\n        `ExternalRouteRef was bound to invalid target, ${resolvedRoute}`,\n      );\n    }\n  } else if (anyRouteRef[routeRefType]) {\n    throw new Error(\n      `Unknown or invalid route ref type, ${anyRouteRef[routeRefType]}`,\n    );\n  } else {\n    throw new Error(`Unknown object passed to useRouteRef, got ${anyRouteRef}`);\n  }\n\n  // Bail if no absolute path could be resolved\n  if (!targetRef) {\n    return [undefined, ''];\n  }\n\n  // Find the path that our target route is bound to\n  const resolvedPath = routePaths.get(targetRef);\n  if (resolvedPath === undefined) {\n    return [undefined, ''];\n  }\n\n  // SubRouteRefs join the path from the parent route with its own path\n  const targetPath = joinPaths(resolvedPath, subRoutePath);\n  return [targetRef, targetPath];\n}\n\n/**\n * Resolves the complete base path for navigating to the target RouteRef.\n */\nfunction resolveBasePath(\n  targetRef: RouteRef,\n  sourceLocation: Parameters<typeof matchRoutes>[1],\n  routePaths: Map<RouteRef, string>,\n  routeParents: Map<RouteRef, RouteRef | undefined>,\n  routeObjects: BackstageRouteObject[],\n) {\n  // While traversing the app element tree we build up the routeObjects structure\n  // used here. It is the same kind of structure that react-router creates, with the\n  // addition that associated route refs are stored throughout the tree. This lets\n  // us look up all route refs that can be reached from our source location.\n  // Because of the similar route object structure, we can use `matchRoutes` from\n  // react-router to do the lookup of our current location.\n  const match = matchRoutes(routeObjects, sourceLocation) ?? [];\n\n  // While we search for a common routing root between our current location and\n  // the target route, we build a list of all route refs we find that we need\n  // to traverse to reach the target.\n  const refDiffList = Array<RouteRef>();\n\n  let matchIndex = -1;\n  for (\n    let targetSearchRef: RouteRef | undefined = targetRef;\n    targetSearchRef;\n    targetSearchRef = routeParents.get(targetSearchRef)\n  ) {\n    // The match contains a list of all ancestral route refs present at our current location\n    // Starting at the desired target ref and traversing back through its parents, we search\n    // for a target ref that is present in the match for our current location. When a match\n    // is found it means we have found a common base to resolve the route from.\n    matchIndex = match.findIndex(m =>\n      (m.route as BackstageRouteObject).routeRefs.has(targetSearchRef!),\n    );\n    if (matchIndex !== -1) {\n      break;\n    }\n\n    // Every time we move a step up in the ancestry of the target ref, we add the current ref\n    // to the diff list, which ends up being the list of route refs to traverse form the common base\n    // in order to reach our target.\n    refDiffList.unshift(targetSearchRef);\n  }\n\n  // If our target route is present in the initial match we need to construct the final path\n  // from the parent of the matched route segment. That's to allow the caller of the route\n  // function to supply their own params.\n  if (refDiffList.length === 0) {\n    matchIndex -= 1;\n  }\n\n  // This is the part of the route tree that the target and source locations have in common.\n  // We re-use the existing pathname directly along with all params.\n  const parentPath = matchIndex === -1 ? '' : match[matchIndex].pathname;\n\n  // This constructs the mid section of the path using paths resolved from all route refs\n  // we need to traverse to reach our target except for the very last one. None of these\n  // paths are allowed to require any parameters, as the caller would have no way of knowing\n  // what parameters those are.\n  const diffPaths = refDiffList.slice(0, -1).map(ref => {\n    const path = routePaths.get(ref);\n    if (path === undefined) {\n      throw new Error(`No path for ${ref}`);\n    }\n    if (path.includes(':')) {\n      throw new Error(\n        `Cannot route to ${targetRef} with parent ${ref} as it has parameters`,\n      );\n    }\n    return path;\n  });\n\n  return `${joinPaths(parentPath, ...diffPaths)}/`;\n}\n\nexport class RouteResolver {\n  constructor(\n    private readonly routePaths: Map<RouteRef, string>,\n    private readonly routeParents: Map<RouteRef, RouteRef | undefined>,\n    private readonly routeObjects: BackstageRouteObject[],\n    private readonly routeBindings: Map<\n      ExternalRouteRef,\n      RouteRef | SubRouteRef\n    >,\n    private readonly appBasePath: string, // base path without a trailing slash\n  ) {}\n\n  resolve<Params extends AnyParams>(\n    anyRouteRef:\n      | RouteRef<Params>\n      | SubRouteRef<Params>\n      | ExternalRouteRef<Params, any>,\n    sourceLocation: Parameters<typeof matchRoutes>[1],\n  ): RouteFunc<Params> | undefined {\n    // First figure out what our target absolute ref is, as well as our target path.\n    const [targetRef, targetPath] = resolveTargetRef(\n      anyRouteRef,\n      this.routePaths,\n      this.routeBindings,\n    );\n    if (!targetRef) {\n      return undefined;\n    }\n\n    // The location that we get passed in uses the full path, so start by trimming off\n    // the app base path prefix in case we're running the app on a sub-path.\n    let relativeSourceLocation: Parameters<typeof matchRoutes>[1];\n    if (typeof sourceLocation === 'string') {\n      relativeSourceLocation = this.trimPath(sourceLocation);\n    } else if (sourceLocation.pathname) {\n      relativeSourceLocation = {\n        ...sourceLocation,\n        pathname: this.trimPath(sourceLocation.pathname),\n      };\n    } else {\n      relativeSourceLocation = sourceLocation;\n    }\n\n    // Next we figure out the base path, which is the combination of the common parent path\n    // between our current location and our target location, as well as the additional path\n    // that is the difference between the parent path and the base of our target location.\n    const basePath =\n      this.appBasePath +\n      resolveBasePath(\n        targetRef,\n        relativeSourceLocation,\n        this.routePaths,\n        this.routeParents,\n        this.routeObjects,\n      );\n\n    const routeFunc: RouteFunc<Params> = (...[params]) => {\n      // We selectively encode some some known-dangerous characters in the\n      // params. The reason that we don't perform a blanket `encodeURIComponent`\n      // here is that this encoding was added defensively long after the initial\n      // release of this code. There's likely to be many users of this code that\n      // already encode their parameters knowing that this code didn't do this\n      // for them in the past. Therefore, we are extra careful NOT to include\n      // the percent character in this set, even though that might seem like a\n      // bad idea.\n      const encodedParams =\n        params &&\n        mapValues(params, value => {\n          if (typeof value === 'string') {\n            return value.replaceAll(/[&?#;\\/]/g, c => encodeURIComponent(c));\n          }\n          return value;\n        });\n      return joinPaths(basePath, generatePath(targetPath, encodedParams));\n    };\n    return routeFunc;\n  }\n\n  private trimPath(targetPath: string) {\n    if (!targetPath) {\n      return targetPath;\n    }\n\n    if (targetPath.startsWith(this.appBasePath)) {\n      return targetPath.slice(this.appBasePath.length);\n    }\n    return targetPath;\n  }\n}\n"],"names":[],"mappings":"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"}