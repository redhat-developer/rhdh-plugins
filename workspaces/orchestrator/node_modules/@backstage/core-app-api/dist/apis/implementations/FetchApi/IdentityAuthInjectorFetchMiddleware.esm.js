class IdentityAuthInjectorFetchMiddleware {
  constructor(identityApi, allowUrl, headerName, headerValue) {
    this.identityApi = identityApi;
    this.allowUrl = allowUrl;
    this.headerName = headerName;
    this.headerValue = headerValue;
  }
  static create(options) {
    const matcher = buildMatcher(options);
    const headerName = options.header?.name || "authorization";
    const headerValue = options.header?.value || ((token) => `Bearer ${token}`);
    return new IdentityAuthInjectorFetchMiddleware(
      options.identityApi,
      matcher,
      headerName,
      headerValue
    );
  }
  /**
   * Returns an array of plugin URL prefixes derived from the static `discovery`
   * configuration, to be used as `urlPrefixAllowlist` option of {@link create}.
   */
  static getDiscoveryUrlPrefixes(config) {
    const endpointConfigs = config.getOptionalConfigArray("discovery.endpoints") || [];
    return endpointConfigs.flatMap((c) => {
      const target = typeof c.get("target") === "object" ? c.getString("target.external") : c.getString("target");
      const plugins = c.getStringArray("plugins");
      return plugins.map(
        (pluginId) => target.replace(/\{\{\s*pluginId\s*\}\}/g, pluginId)
      );
    });
  }
  apply(next) {
    return async (input, init) => {
      const request = new Request(input, init);
      const { token } = await this.identityApi.getCredentials();
      if (request.headers.get(this.headerName) || typeof token !== "string" || !token || !this.allowUrl(request.url)) {
        return next(input, init);
      }
      request.headers.set(this.headerName, this.headerValue(token));
      return next(request);
    };
  }
}
function buildMatcher(options) {
  if (options.allowUrl) {
    return options.allowUrl;
  } else if (options.urlPrefixAllowlist) {
    return buildPrefixMatcher(options.urlPrefixAllowlist);
  } else if (options.config) {
    return buildPrefixMatcher([
      options.config.getString("backend.baseUrl"),
      ...IdentityAuthInjectorFetchMiddleware.getDiscoveryUrlPrefixes(
        options.config
      )
    ]);
  }
  return () => false;
}
function buildPrefixMatcher(prefixes) {
  const trimmedPrefixes = prefixes.map((prefix) => prefix.replace(/\/$/, ""));
  return (url) => trimmedPrefixes.some(
    (prefix) => url === prefix || url.startsWith(`${prefix}/`)
  );
}

export { IdentityAuthInjectorFetchMiddleware };
//# sourceMappingURL=IdentityAuthInjectorFetchMiddleware.esm.js.map
