'use strict';

var config = require('@backstage/config');
var luxon = require('luxon');
var backendCommon = require('@backstage/backend-common');
var lodash = require('lodash');
var backendPluginApi = require('@backstage/backend-plugin-api');
var errors = require('@backstage/errors');
var cron = require('cron');
var uuid = require('uuid');
var zod = require('zod');
var api = require('@opentelemetry/api');

function readDuration(config$1, key) {
  if (typeof config$1.get(key) === "string") {
    const value = config$1.getString(key);
    const duration = luxon.Duration.fromISO(value);
    if (!duration.isValid) {
      throw new Error(`Invalid duration: ${value}`);
    }
    return duration.toObject();
  }
  return config.readDurationFromConfig(config$1, { key });
}
function readFrequency(config, key) {
  const value = config.get(key);
  if (typeof value === "object" && value.cron) {
    return value;
  }
  if (typeof value === "object" && value.trigger === "manual") {
    return { trigger: "manual" };
  }
  return readDuration(config, key);
}
function readTaskScheduleDefinitionFromConfig(config) {
  const frequency = readFrequency(config, "frequency");
  const timeout = readDuration(config, "timeout");
  const initialDelay = config.has("initialDelay") ? readDuration(config, "initialDelay") : void 0;
  const scope = config.getOptionalString("scope");
  if (scope && !["global", "local"].includes(scope)) {
    throw new Error(
      `Only "global" or "local" are allowed for TaskScheduleDefinition.scope, but got: ${scope}`
    );
  }
  return {
    frequency,
    timeout,
    initialDelay,
    scope
  };
}

const DB_MIGRATIONS_TABLE = "backstage_backend_tasks__knex_migrations";
const DB_TASKS_TABLE = "backstage_backend_tasks__tasks";

async function migrateBackendTasks(knex) {
  const migrationsDir = backendPluginApi.resolvePackagePath(
    "@backstage/backend-tasks",
    "migrations"
  );
  await knex.migrate.latest({
    directory: migrationsDir,
    tableName: DB_MIGRATIONS_TABLE
  });
}

function validateId(id) {
  if (typeof id !== "string" || !id.trim()) {
    throw new errors.InputError(`${id} is not a valid ID, expected non-empty string`);
  }
}
function nowPlus(duration, knex) {
  const seconds = duration?.as("seconds") ?? 0;
  if (!seconds) {
    return knex.fn.now();
  }
  if (knex.client.config.client.includes("sqlite3")) {
    return knex.raw(`datetime('now', ?)`, [`${seconds} seconds`]);
  }
  if (knex.client.config.client.includes("mysql")) {
    return knex.raw(`now() + interval ${seconds} second`);
  }
  return knex.raw(`now() + interval '${seconds} seconds'`);
}
async function sleep(duration, abortSignal) {
  if (abortSignal?.aborted) {
    return;
  }
  await new Promise((resolve) => {
    let timeoutHandle = void 0;
    const done = () => {
      if (timeoutHandle) {
        clearTimeout(timeoutHandle);
      }
      abortSignal?.removeEventListener("abort", done);
      resolve();
    };
    timeoutHandle = setTimeout(done, duration.as("milliseconds"));
    abortSignal?.addEventListener("abort", done);
  });
}
function delegateAbortController(parent) {
  const delegate = new AbortController();
  if (parent) {
    if (parent.aborted) {
      delegate.abort();
    } else {
      const onParentAborted = () => {
        delegate.abort();
      };
      const onChildAborted = () => {
        parent.removeEventListener("abort", onParentAborted);
      };
      parent.addEventListener("abort", onParentAborted, { once: true });
      delegate.signal.addEventListener("abort", onChildAborted, { once: true });
    }
  }
  return delegate;
}

class LocalTaskWorker {
  constructor(taskId, fn, logger) {
    this.taskId = taskId;
    this.fn = fn;
    this.logger = logger;
  }
  abortWait;
  start(settings, options) {
    this.logger.info(
      `Task worker starting: ${this.taskId}, ${JSON.stringify(settings)}`
    );
    (async () => {
      let attemptNum = 1;
      for (; ; ) {
        try {
          if (settings.initialDelayDuration) {
            await this.sleep(
              luxon.Duration.fromISO(settings.initialDelayDuration),
              options?.signal
            );
          }
          while (!options?.signal?.aborted) {
            const startTime = process.hrtime();
            await this.runOnce(settings, options?.signal);
            const timeTaken = process.hrtime(startTime);
            await this.waitUntilNext(
              settings,
              (timeTaken[0] + timeTaken[1] / 1e9) * 1e3,
              options?.signal
            );
          }
          this.logger.info(`Task worker finished: ${this.taskId}`);
          attemptNum = 0;
          break;
        } catch (e) {
          attemptNum += 1;
          this.logger.warn(
            `Task worker failed unexpectedly, attempt number ${attemptNum}, ${e}`
          );
          await sleep(luxon.Duration.fromObject({ seconds: 1 }));
        }
      }
    })();
  }
  trigger() {
    if (!this.abortWait) {
      throw new errors.ConflictError(`Task ${this.taskId} is currently running`);
    }
    this.abortWait.abort();
  }
  /**
   * Makes a single attempt at running the task to completion.
   */
  async runOnce(settings, signal) {
    const taskAbortController = delegateAbortController(signal);
    const timeoutHandle = setTimeout(() => {
      taskAbortController.abort();
    }, luxon.Duration.fromISO(settings.timeoutAfterDuration).as("milliseconds"));
    try {
      await this.fn(taskAbortController.signal);
    } catch (e) {
    }
    clearTimeout(timeoutHandle);
    taskAbortController.abort();
  }
  /**
   * Sleeps until it's time to run the task again.
   */
  async waitUntilNext(settings, lastRunMillis, signal) {
    if (signal?.aborted) {
      return;
    }
    const isCron = !settings.cadence.startsWith("P");
    let dt;
    if (isCron) {
      const nextRun = +new cron.CronTime(settings.cadence).sendAt().toJSDate();
      dt = nextRun - Date.now();
    } else {
      dt = luxon.Duration.fromISO(settings.cadence).as("milliseconds") - lastRunMillis;
    }
    dt = Math.max(dt, 0);
    this.logger.debug(
      `task: ${this.taskId} will next occur around ${luxon.DateTime.now().plus(
        luxon.Duration.fromMillis(dt)
      )}`
    );
    await this.sleep(luxon.Duration.fromMillis(dt), signal);
  }
  async sleep(duration, abortSignal) {
    this.abortWait = delegateAbortController(abortSignal);
    await sleep(duration, this.abortWait.signal);
    this.abortWait.abort();
    this.abortWait = void 0;
  }
}

function isValidOptionalDurationString(d) {
  try {
    return !d || luxon.Duration.fromISO(d).isValid;
  } catch {
    return false;
  }
}
function isValidCronFormat(c) {
  try {
    if (!c) {
      return false;
    }
    new cron.CronTime(c);
    return true;
  } catch {
    return false;
  }
}
function isValidTrigger(t) {
  return t === "manual";
}
zod.z.object({
  version: zod.z.literal(1),
  initialDelayDuration: zod.z.string().optional().refine(isValidOptionalDurationString, {
    message: "Invalid duration, expecting ISO Period"
  }),
  recurringAtMostEveryDuration: zod.z.string().refine(isValidOptionalDurationString, {
    message: "Invalid duration, expecting ISO Period"
  }),
  timeoutAfterDuration: zod.z.string().refine(isValidOptionalDurationString, {
    message: "Invalid duration, expecting ISO Period"
  })
});
const taskSettingsV2Schema = zod.z.object({
  version: zod.z.literal(2),
  cadence: zod.z.string().refine(isValidCronFormat, { message: "Invalid cron" }).or(
    zod.z.string().refine(isValidTrigger, {
      message: "Invalid trigger, expecting 'manual'"
    })
  ).or(
    zod.z.string().refine(isValidOptionalDurationString, {
      message: "Invalid duration, expecting ISO Period"
    })
  ),
  timeoutAfterDuration: zod.z.string().refine(isValidOptionalDurationString, {
    message: "Invalid duration, expecting ISO Period"
  }),
  initialDelayDuration: zod.z.string().optional().refine(isValidOptionalDurationString, {
    message: "Invalid duration, expecting ISO Period"
  })
});

const DEFAULT_WORK_CHECK_FREQUENCY = luxon.Duration.fromObject({ seconds: 5 });
class TaskWorker {
  constructor(taskId, fn, knex, logger, workCheckFrequency = DEFAULT_WORK_CHECK_FREQUENCY) {
    this.taskId = taskId;
    this.fn = fn;
    this.knex = knex;
    this.logger = logger;
    this.workCheckFrequency = workCheckFrequency;
  }
  async start(settings, options) {
    try {
      await this.persistTask(settings);
    } catch (e) {
      throw new Error(`Failed to persist task, ${e}`);
    }
    this.logger.info(
      `Task worker starting: ${this.taskId}, ${JSON.stringify(settings)}`
    );
    let workCheckFrequency = this.workCheckFrequency;
    const isDuration = settings?.cadence.startsWith("P");
    if (isDuration) {
      const cadence = luxon.Duration.fromISO(settings.cadence);
      if (cadence < workCheckFrequency) {
        workCheckFrequency = cadence;
      }
    }
    let attemptNum = 1;
    (async () => {
      for (; ; ) {
        try {
          if (settings.initialDelayDuration) {
            await sleep(
              luxon.Duration.fromISO(settings.initialDelayDuration),
              options?.signal
            );
          }
          while (!options?.signal?.aborted) {
            const runResult = await this.runOnce(options?.signal);
            if (runResult.result === "abort") {
              break;
            }
            await sleep(workCheckFrequency, options?.signal);
          }
          this.logger.info(`Task worker finished: ${this.taskId}`);
          attemptNum = 0;
          break;
        } catch (e) {
          attemptNum += 1;
          this.logger.warn(
            `Task worker failed unexpectedly, attempt number ${attemptNum}, ${e}`
          );
          await sleep(luxon.Duration.fromObject({ seconds: 1 }));
        }
      }
    })();
  }
  static async trigger(knex, taskId) {
    const rows = await knex(DB_TASKS_TABLE).select(knex.raw(1)).where("id", "=", taskId);
    if (rows.length !== 1) {
      throw new errors.NotFoundError(`Task ${taskId} does not exist`);
    }
    const updatedRows = await knex(DB_TASKS_TABLE).where("id", "=", taskId).whereNull("current_run_ticket").update({
      next_run_start_at: knex.fn.now()
    });
    if (updatedRows < 1) {
      throw new errors.ConflictError(`Task ${taskId} is currently running`);
    }
  }
  /**
   * Makes a single attempt at running the task to completion, if ready.
   *
   * @returns The outcome of the attempt
   */
  async runOnce(signal) {
    const findResult = await this.findReadyTask();
    if (findResult.result === "not-ready-yet" || findResult.result === "abort") {
      return findResult;
    }
    const taskSettings = findResult.settings;
    const ticket = uuid.v4();
    const claimed = await this.tryClaimTask(ticket, taskSettings);
    if (!claimed) {
      return { result: "not-ready-yet" };
    }
    const taskAbortController = delegateAbortController(signal);
    const timeoutHandle = setTimeout(() => {
      taskAbortController.abort();
    }, luxon.Duration.fromISO(taskSettings.timeoutAfterDuration).as("milliseconds"));
    try {
      await this.fn(taskAbortController.signal);
      taskAbortController.abort();
    } catch (e) {
      this.logger.error(e);
      await this.tryReleaseTask(ticket, taskSettings);
      return { result: "failed" };
    } finally {
      clearTimeout(timeoutHandle);
    }
    await this.tryReleaseTask(ticket, taskSettings);
    return { result: "completed" };
  }
  /**
   * Perform the initial store of the task info
   */
  async persistTask(settings) {
    taskSettingsV2Schema.parse(settings);
    const isManual = settings?.cadence === "manual";
    const isDuration = settings?.cadence.startsWith("P");
    const isCron = !isManual && !isDuration;
    let startAt;
    let nextStartAt;
    if (settings.initialDelayDuration) {
      startAt = nowPlus(
        luxon.Duration.fromISO(settings.initialDelayDuration),
        this.knex
      );
    }
    if (isCron) {
      const time = new cron.CronTime(settings.cadence).sendAt().minus({ seconds: 1 }).toUTC();
      nextStartAt = this.nextRunAtRaw(time);
      startAt ||= nextStartAt;
    } else if (isManual) {
      nextStartAt = this.knex.raw("null");
      startAt ||= nextStartAt;
    } else {
      startAt ||= this.knex.fn.now();
      nextStartAt = nowPlus(luxon.Duration.fromISO(settings.cadence), this.knex);
    }
    this.logger.debug(`task: ${this.taskId} configured to run at: ${startAt}`);
    const settingsJson = JSON.stringify(settings);
    await this.knex(DB_TASKS_TABLE).insert({
      id: this.taskId,
      settings_json: settingsJson,
      next_run_start_at: startAt
    }).onConflict("id").merge(
      this.knex.client.config.client.includes("mysql") ? {
        settings_json: settingsJson,
        next_run_start_at: this.knex.raw(
          `CASE WHEN ?? < ?? THEN ?? ELSE ?? END`,
          [
            nextStartAt,
            "next_run_start_at",
            nextStartAt,
            "next_run_start_at"
          ]
        )
      } : {
        settings_json: this.knex.ref("excluded.settings_json"),
        next_run_start_at: this.knex.raw(
          `CASE WHEN ?? < ?? THEN ?? ELSE ?? END`,
          [
            nextStartAt,
            `${DB_TASKS_TABLE}.next_run_start_at`,
            nextStartAt,
            `${DB_TASKS_TABLE}.next_run_start_at`
          ]
        )
      }
    );
  }
  /**
   * Check if the task is ready to run
   */
  async findReadyTask() {
    const [row] = await this.knex(DB_TASKS_TABLE).where("id", "=", this.taskId).select({
      settingsJson: "settings_json",
      ready: this.knex.raw(
        `CASE
            WHEN next_run_start_at <= ? AND current_run_ticket IS NULL THEN TRUE
            ELSE FALSE
          END`,
        [this.knex.fn.now()]
      )
    });
    if (!row) {
      this.logger.info(
        "No longer able to find task; aborting and assuming that it has been unregistered or expired"
      );
      return { result: "abort" };
    } else if (!row.ready) {
      return { result: "not-ready-yet" };
    }
    try {
      const obj = JSON.parse(row.settingsJson);
      const settings = taskSettingsV2Schema.parse(obj);
      return { result: "ready", settings };
    } catch (e) {
      this.logger.info(
        `Task "${this.taskId}" is no longer able to parse task settings; aborting and assuming that a newer version of the task has been issued and being handled by other workers, ${e}`
      );
      return { result: "abort" };
    }
  }
  /**
   * Attempts to claim a task that's ready for execution, on this worker's
   * behalf. We should not attempt to perform the work unless the claim really
   * goes through.
   *
   * @param ticket - A globally unique string that changes for each invocation
   * @param settings - The settings of the task to claim
   * @returns True if it was successfully claimed
   */
  async tryClaimTask(ticket, settings) {
    const startedAt = this.knex.fn.now();
    const expiresAt = settings.timeoutAfterDuration ? nowPlus(luxon.Duration.fromISO(settings.timeoutAfterDuration), this.knex) : this.knex.raw("null");
    const rows = await this.knex(DB_TASKS_TABLE).where("id", "=", this.taskId).whereNull("current_run_ticket").update({
      current_run_ticket: ticket,
      current_run_started_at: startedAt,
      current_run_expires_at: expiresAt
    });
    return rows === 1;
  }
  async tryReleaseTask(ticket, settings) {
    const isManual = settings?.cadence === "manual";
    const isDuration = settings?.cadence.startsWith("P");
    const isCron = !isManual && !isDuration;
    let nextRun;
    if (isCron) {
      const time = new cron.CronTime(settings.cadence).sendAt().toUTC();
      this.logger.debug(`task: ${this.taskId} will next occur around ${time}`);
      nextRun = this.nextRunAtRaw(time);
    } else if (isManual) {
      nextRun = this.knex.raw("null");
    } else {
      const dt = luxon.Duration.fromISO(settings.cadence).as("seconds");
      this.logger.debug(
        `task: ${this.taskId} will next occur around ${luxon.DateTime.now().plus({
          seconds: dt
        })}`
      );
      if (this.knex.client.config.client.includes("sqlite3")) {
        nextRun = this.knex.raw(
          `max(datetime(next_run_start_at, ?), datetime('now'))`,
          [`+${dt} seconds`]
        );
      } else if (this.knex.client.config.client.includes("mysql")) {
        nextRun = this.knex.raw(
          `greatest(next_run_start_at + interval ${dt} second, now())`
        );
      } else {
        nextRun = this.knex.raw(
          `greatest(next_run_start_at + interval '${dt} seconds', now())`
        );
      }
    }
    const rows = await this.knex(DB_TASKS_TABLE).where("id", "=", this.taskId).where("current_run_ticket", "=", ticket).update({
      next_run_start_at: nextRun,
      current_run_ticket: this.knex.raw("null"),
      current_run_started_at: this.knex.raw("null"),
      current_run_expires_at: this.knex.raw("null")
    });
    return rows === 1;
  }
  nextRunAtRaw(time) {
    if (this.knex.client.config.client.includes("sqlite3")) {
      return this.knex.raw("datetime(?)", [time.toISO()]);
    } else if (this.knex.client.config.client.includes("mysql")) {
      return this.knex.raw(`?`, [time.toSQL({ includeOffset: false })]);
    }
    return this.knex.raw(`?`, [time.toISO()]);
  }
}

class PluginTaskSchedulerImpl {
  constructor(databaseFactory, logger) {
    this.databaseFactory = databaseFactory;
    this.logger = logger;
    const meter = api.metrics.getMeter("default");
    this.counter = meter.createCounter("backend_tasks.task.runs.count", {
      description: "Total number of times a task has been run"
    });
    this.duration = meter.createHistogram("backend_tasks.task.runs.duration", {
      description: "Histogram of task run durations",
      unit: "seconds"
    });
  }
  localTasksById = /* @__PURE__ */ new Map();
  allScheduledTasks = [];
  counter;
  duration;
  async triggerTask(id) {
    const localTask = this.localTasksById.get(id);
    if (localTask) {
      localTask.trigger();
      return;
    }
    const knex = await this.databaseFactory();
    await TaskWorker.trigger(knex, id);
  }
  async scheduleTask(task) {
    validateId(task.id);
    const scope = task.scope ?? "global";
    const settings = {
      version: 2,
      cadence: parseDuration(task.frequency),
      initialDelayDuration: task.initialDelay && parseDuration(task.initialDelay),
      timeoutAfterDuration: parseDuration(task.timeout)
    };
    if (scope === "global") {
      const knex = await this.databaseFactory();
      const worker = new TaskWorker(
        task.id,
        this.wrapInMetrics(task.fn, { labels: { taskId: task.id, scope } }),
        knex,
        this.logger.child({ task: task.id })
      );
      await worker.start(settings, { signal: task.signal });
    } else {
      const worker = new LocalTaskWorker(
        task.id,
        this.wrapInMetrics(task.fn, { labels: { taskId: task.id, scope } }),
        this.logger.child({ task: task.id })
      );
      worker.start(settings, { signal: task.signal });
      this.localTasksById.set(task.id, worker);
    }
    this.allScheduledTasks.push({
      id: task.id,
      scope,
      settings
    });
  }
  createScheduledTaskRunner(schedule) {
    return {
      run: async (task) => {
        await this.scheduleTask({ ...task, ...schedule });
      }
    };
  }
  async getScheduledTasks() {
    return this.allScheduledTasks;
  }
  wrapInMetrics(fn, opts) {
    return async (abort) => {
      const labels = {
        ...opts.labels
      };
      this.counter.add(1, { ...labels, result: "started" });
      const startTime = process.hrtime();
      try {
        await fn(abort);
        labels.result = "completed";
      } catch (ex) {
        labels.result = "failed";
        throw ex;
      } finally {
        const delta = process.hrtime(startTime);
        const endTime = delta[0] + delta[1] / 1e9;
        this.counter.add(1, labels);
        this.duration.record(endTime, labels);
      }
    };
  }
}
function parseDuration(frequency) {
  if ("cron" in frequency) {
    return frequency.cron;
  }
  if ("trigger" in frequency) {
    return frequency.trigger;
  }
  const parsed = luxon.Duration.isDuration(frequency) ? frequency : luxon.Duration.fromObject(frequency);
  if (!parsed.isValid) {
    throw new Error(
      `Invalid duration, ${parsed.invalidReason}: ${parsed.invalidExplanation}`
    );
  }
  return parsed.toISO();
}

class PluginTaskSchedulerJanitor {
  knex;
  waitBetweenRuns;
  logger;
  constructor(options) {
    this.knex = options.knex;
    this.waitBetweenRuns = options.waitBetweenRuns;
    this.logger = options.logger;
  }
  async start(abortSignal) {
    while (!abortSignal?.aborted) {
      try {
        await this.runOnce();
      } catch (e) {
        this.logger.warn(`Error while performing janitorial tasks, ${e}`);
      }
      await sleep(this.waitBetweenRuns, abortSignal);
    }
  }
  async runOnce() {
    const dbNull = this.knex.raw("null");
    const configClient = this.knex.client.config.client;
    let tasks;
    if (configClient.includes("sqlite3") || configClient.includes("mysql")) {
      tasks = await this.knex(DB_TASKS_TABLE).select("id").where("current_run_expires_at", "<", this.knex.fn.now());
      await this.knex(DB_TASKS_TABLE).whereIn(
        "id",
        tasks.map((t) => t.id)
      ).update({
        current_run_ticket: dbNull,
        current_run_started_at: dbNull,
        current_run_expires_at: dbNull
      });
    } else {
      tasks = await this.knex(DB_TASKS_TABLE).where("current_run_expires_at", "<", this.knex.fn.now()).update({
        current_run_ticket: dbNull,
        current_run_started_at: dbNull,
        current_run_expires_at: dbNull
      }).returning(["id"]);
    }
    if (typeof tasks === "number") {
      if (tasks > 0) {
        this.logger.warn(`${tasks} tasks timed out and were lost`);
      }
    } else {
      for (const { id } of tasks) {
        this.logger.warn(`Task timed out and was lost: ${id}`);
      }
    }
  }
}

class TaskScheduler {
  constructor(databaseManager, logger) {
    this.databaseManager = databaseManager;
    this.logger = logger;
  }
  /**
   * @deprecated
   * It is only used by the legacy backend system, and should not be used in the new backend system.
   */
  static fromConfig(config, options) {
    const databaseManager = options?.databaseManager ?? backendCommon.DatabaseManager.fromConfig(config);
    const logger = (options?.logger || backendCommon.getRootLogger()).child({
      type: "taskManager"
    });
    return new TaskScheduler(databaseManager, logger);
  }
  /**
   * Instantiates a task manager instance for the given plugin.
   *
   * @param pluginId - The unique ID of the plugin, for example "catalog"
   * @returns A {@link PluginTaskScheduler} instance
   * @deprecated Please migrate to the new backend system, and depend on `coreServices.scheduler` from  `@backstage/backend-plugin-api` instead, or use `DefaultSchedulerService` from `@backstage/backend-defaults`
   */
  forPlugin(pluginId) {
    return TaskScheduler.forPlugin({
      pluginId,
      databaseManager: this.databaseManager.forPlugin(pluginId),
      logger: this.logger
    });
  }
  /**
   * @deprecated Please migrate to the new backend system, and depend on `coreServices.scheduler` from  `@backstage/backend-plugin-api` instead, or use `DefaultSchedulerService` from `@backstage/backend-defaults`
   */
  static forPlugin(opts) {
    const databaseFactory = lodash.once(async () => {
      const knex = await opts.databaseManager.getClient();
      if (!opts.databaseManager.migrations?.skip) {
        await migrateBackendTasks(knex);
      }
      if (process.env.NODE_ENV !== "test") {
        const janitor = new PluginTaskSchedulerJanitor({
          knex,
          waitBetweenRuns: luxon.Duration.fromObject({ minutes: 1 }),
          logger: opts.logger
        });
        janitor.start();
      }
      return knex;
    });
    return new PluginTaskSchedulerImpl(databaseFactory, opts.logger);
  }
}

exports.TaskScheduler = TaskScheduler;
exports.readTaskScheduleDefinitionFromConfig = readTaskScheduleDefinitionFromConfig;
//# sourceMappingURL=index.cjs.js.map
