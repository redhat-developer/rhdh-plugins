'use strict';

var config = require('@backstage/config');
var luxon = require('luxon');
var paths = require('./cjs/paths-D7KGMZeP.cjs.js');
var cliCommon = require('@backstage/cli-common');
require('@backstage/errors');
require('path');
require('fs');

function createServiceRef(options) {
  const { id, scope = "plugin", multiton = false, defaultFactory } = options;
  return {
    id,
    scope,
    multiton,
    get T() {
      throw new Error(`tried to read ServiceRef.T of ${this}`);
    },
    toString() {
      return `serviceRef{${options.id}}`;
    },
    $$type: "@backstage/ServiceRef",
    __defaultFactory: defaultFactory
  };
}
function createServiceFactory(options) {
  const configCallback = typeof options === "function" ? options : () => options;
  const factory = (o) => {
    const anyConf = configCallback(o);
    if (anyConf.service.scope === "root") {
      const c2 = anyConf;
      return {
        $$type: "@backstage/BackendFeature",
        version: "v1",
        featureType: "service",
        service: c2.service,
        initialization: c2.initialization,
        deps: c2.deps,
        factory: async (deps) => c2.factory(deps)
      };
    }
    const c = anyConf;
    return {
      $$type: "@backstage/BackendFeature",
      version: "v1",
      featureType: "service",
      service: c.service,
      initialization: c.initialization,
      ..."createRootContext" in c ? {
        createRootContext: async (deps) => c?.createRootContext?.(deps)
      } : {},
      deps: c.deps,
      factory: async (deps, ctx) => c.factory(deps, ctx)
    };
  };
  return Object.assign(factory, factory(void 0));
}

exports.coreServices = void 0;
((coreServices2) => {
  coreServices2.auth = createServiceRef({
    id: "core.auth"
  });
  coreServices2.userInfo = createServiceRef({
    id: "core.userInfo"
  });
  coreServices2.cache = createServiceRef({
    id: "core.cache"
  });
  coreServices2.rootConfig = createServiceRef({ id: "core.rootConfig", scope: "root" });
  coreServices2.database = createServiceRef({ id: "core.database" });
  coreServices2.discovery = createServiceRef({ id: "core.discovery" });
  coreServices2.rootHealth = createServiceRef({ id: "core.rootHealth", scope: "root" });
  coreServices2.httpAuth = createServiceRef({ id: "core.httpAuth" });
  coreServices2.httpRouter = createServiceRef({ id: "core.httpRouter" });
  coreServices2.lifecycle = createServiceRef({ id: "core.lifecycle" });
  coreServices2.logger = createServiceRef({ id: "core.logger" });
  coreServices2.permissions = createServiceRef({ id: "core.permissions" });
  coreServices2.pluginMetadata = createServiceRef({ id: "core.pluginMetadata" });
  coreServices2.rootHttpRouter = createServiceRef({ id: "core.rootHttpRouter", scope: "root" });
  coreServices2.rootLifecycle = createServiceRef({ id: "core.rootLifecycle", scope: "root" });
  coreServices2.rootLogger = createServiceRef({ id: "core.rootLogger", scope: "root" });
  coreServices2.scheduler = createServiceRef({ id: "core.scheduler" });
  coreServices2.tokenManager = createServiceRef({ id: "core.tokenManager" });
  coreServices2.urlReader = createServiceRef({ id: "core.urlReader" });
  coreServices2.identity = createServiceRef({ id: "core.identity" });
})(exports.coreServices || (exports.coreServices = {}));

function readDuration(config$1, key) {
  if (typeof config$1.get(key) === "string") {
    const value = config$1.getString(key);
    const duration = luxon.Duration.fromISO(value);
    if (!duration.isValid) {
      throw new Error(`Invalid duration: ${value}`);
    }
    return duration.toObject();
  }
  return config.readDurationFromConfig(config$1, { key });
}
function readFrequency(config, key) {
  const value = config.get(key);
  if (typeof value === "object" && value.cron) {
    return value;
  }
  if (typeof value === "object" && value.trigger === "manual") {
    return { trigger: "manual" };
  }
  return readDuration(config, key);
}
function readSchedulerServiceTaskScheduleDefinitionFromConfig(config) {
  const frequency = readFrequency(config, "frequency");
  const timeout = readDuration(config, "timeout");
  const initialDelay = config.has("initialDelay") ? readDuration(config, "initialDelay") : void 0;
  const scope = config.getOptionalString("scope");
  if (scope && !["global", "local"].includes(scope)) {
    throw new Error(
      `Only "global" or "local" are allowed for TaskScheduleDefinition.scope, but got: ${scope}`
    );
  }
  return {
    frequency,
    timeout,
    initialDelay,
    scope
  };
}

function isDatabaseConflictError(e) {
  const message = e?.message;
  return typeof message === "string" && (/SQLITE_CONSTRAINT(?:_UNIQUE)?: UNIQUE/.test(message) || /UNIQUE constraint failed:/.test(message) || /unique constraint/.test(message) || /Duplicate entry/.test(message));
}

function createBackendModule(options) {
  function getRegistrations() {
    const extensionPoints = [];
    let init = void 0;
    options.register({
      registerExtensionPoint(ext, impl) {
        if (init) {
          throw new Error("registerExtensionPoint called after registerInit");
        }
        extensionPoints.push([ext, impl]);
      },
      registerInit(regInit) {
        if (init) {
          throw new Error("registerInit must only be called once");
        }
        init = {
          deps: regInit.deps,
          func: regInit.init
        };
      }
    });
    if (!init) {
      throw new Error(
        `registerInit was not called by register in ${options.moduleId} module for ${options.pluginId}`
      );
    }
    return [
      {
        type: "module",
        pluginId: options.pluginId,
        moduleId: options.moduleId,
        extensionPoints,
        init
      }
    ];
  }
  function backendFeatureCompatWrapper() {
    return backendFeatureCompatWrapper;
  }
  Object.assign(backendFeatureCompatWrapper, {
    $$type: "@backstage/BackendFeature",
    version: "v1",
    getRegistrations
  });
  return backendFeatureCompatWrapper;
}

function createBackendPlugin(options) {
  function getRegistrations() {
    const extensionPoints = [];
    let init = void 0;
    options.register({
      registerExtensionPoint(ext, impl) {
        if (init) {
          throw new Error("registerExtensionPoint called after registerInit");
        }
        extensionPoints.push([ext, impl]);
      },
      registerInit(regInit) {
        if (init) {
          throw new Error("registerInit must only be called once");
        }
        init = {
          deps: regInit.deps,
          func: regInit.init
        };
      }
    });
    if (!init) {
      throw new Error(
        `registerInit was not called by register in ${options.pluginId}`
      );
    }
    return [
      {
        type: "plugin",
        pluginId: options.pluginId,
        extensionPoints,
        init
      }
    ];
  }
  function backendFeatureCompatWrapper() {
    return backendFeatureCompatWrapper;
  }
  Object.assign(backendFeatureCompatWrapper, {
    $$type: "@backstage/BackendFeature",
    version: "v1",
    getRegistrations
  });
  return backendFeatureCompatWrapper;
}

function createExtensionPoint(options) {
  return {
    id: options.id,
    get T() {
      if (process.env.NODE_ENV === "test") {
        return null;
      }
      throw new Error(`tried to read ExtensionPoint.T of ${this}`);
    },
    toString() {
      return `extensionPoint{${options.id}}`;
    },
    $$type: "@backstage/ExtensionPoint"
  };
}

const MESSAGE_MARKER = "eHgtF5hmbrXyiEvo";
function describeParentCallSite(ErrorConstructor = Error) {
  const { stack } = new ErrorConstructor(MESSAGE_MARKER);
  if (!stack) {
    return "<unknown>";
  }
  const startIndex = stack.includes(MESSAGE_MARKER) ? stack.indexOf("\n") + 1 : 0;
  const secondEntryStart = stack.indexOf("\n", stack.indexOf("\n", startIndex) + 1) + 1;
  const secondEntryEnd = stack.indexOf("\n", secondEntryStart);
  const line = stack.substring(secondEntryStart, secondEntryEnd).trim();
  if (!line) {
    return "unknown";
  }
  if (line.includes("(")) {
    return line.substring(line.indexOf("(") + 1, line.indexOf(")"));
  }
  if (line.includes("@")) {
    return line.substring(line.indexOf("@") + 1);
  }
  return line;
}

function createBackendFeatureLoader(options) {
  return {
    $$type: "@backstage/BackendFeature",
    version: "v1",
    featureType: "loader",
    description: `created at '${describeParentCallSite()}'`,
    deps: options.deps,
    async loader(deps) {
      const it = await options.loader(deps);
      const result = new Array();
      for await (const item of it) {
        if ("$$type" in item && item.$$type === "@backstage/BackendFeature") {
          result.push(item);
        } else if ("default" in item) {
          result.push(item.default);
        } else {
          throw new Error(`Invalid item "${item}"`);
        }
      }
      return result;
    }
  };
}

exports.packagePathMocks = paths.packagePathMocks;
exports.resolvePackagePath = paths.resolvePackagePath;
exports.resolveSafeChildPath = paths.resolveSafeChildPath;
Object.defineProperty(exports, "isChildPath", {
  enumerable: true,
  get: function () { return cliCommon.isChildPath; }
});
exports.createBackendFeatureLoader = createBackendFeatureLoader;
exports.createBackendModule = createBackendModule;
exports.createBackendPlugin = createBackendPlugin;
exports.createExtensionPoint = createExtensionPoint;
exports.createServiceFactory = createServiceFactory;
exports.createServiceRef = createServiceRef;
exports.isDatabaseConflictError = isDatabaseConflictError;
exports.readSchedulerServiceTaskScheduleDefinitionFromConfig = readSchedulerServiceTaskScheduleDefinitionFromConfig;
//# sourceMappingURL=index.cjs.js.map
