{"version":3,"file":"types.cjs.js","sources":["../../../src/services/system/types.ts"],"sourcesContent":["/*\n * Copyright 2022 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { BackendFeature } from '../../types';\n\n/**\n * A reference to a backend service. You can use these references to mark\n * dependencies on services and having their implementations injected\n * automatically.\n *\n * @public\n */\nexport type ServiceRef<\n  TService,\n  TScope extends 'root' | 'plugin' = 'root' | 'plugin',\n  TInstances extends 'singleton' | 'multiton' = 'singleton' | 'multiton',\n> = {\n  id: string;\n\n  /**\n   * This determines the scope at which this service is available.\n   *\n   * Root scoped services are available to all other services but\n   * may only depend on other root scoped services.\n   *\n   * Plugin scoped services are only available to other plugin scoped\n   * services but may depend on all other services.\n   */\n  scope: TScope;\n\n  /**\n   * Marks whether the service is a multiton or not. Multiton services the\n   * opposite of singletons - they can be provided many times, and when depended\n   * on, you receive an array of all provided instances.\n   */\n  multiton?: TInstances extends 'multiton' ? true : false;\n\n  /**\n   * Utility for getting the type of the service, using `typeof serviceRef.T`.\n   * Attempting to actually read this value will result in an exception.\n   */\n  T: TService;\n\n  $$type: '@backstage/ServiceRef';\n};\n\n/** @public */\nexport interface ServiceFactory<\n  TService = unknown,\n  TScope extends 'plugin' | 'root' = 'plugin' | 'root',\n  TInstances extends 'singleton' | 'multiton' = 'singleton' | 'multiton',\n> extends BackendFeature {\n  service: ServiceRef<TService, TScope, TInstances>;\n}\n\n/** @internal */\nexport interface InternalServiceFactory<\n  TService = unknown,\n  TScope extends 'plugin' | 'root' = 'plugin' | 'root',\n  TInstances extends 'singleton' | 'multiton' = 'singleton' | 'multiton',\n> extends ServiceFactory<TService, TScope, TInstances> {\n  version: 'v1';\n  featureType: 'service';\n  initialization?: 'always' | 'lazy';\n  deps: { [key in string]: ServiceRef<unknown> };\n  createRootContext?(deps: { [key in string]: unknown }): Promise<unknown>;\n  factory(\n    deps: { [key in string]: unknown },\n    context: unknown,\n  ): Promise<TService>;\n}\n\n/** @public */\nexport interface ServiceRefOptions<\n  TService,\n  TScope extends 'root' | 'plugin',\n  TInstances extends 'singleton' | 'multiton',\n> {\n  id: string;\n  scope?: TScope;\n  multiton?: TInstances extends 'multiton' ? true : false;\n  defaultFactory?(\n    service: ServiceRef<TService, TScope>,\n  ): Promise<ServiceFactory>;\n}\n\n/**\n * Creates a new service definition. This overload is used to create plugin scoped services.\n *\n * @public\n */\nexport function createServiceRef<TService>(\n  options: ServiceRefOptions<TService, 'plugin', 'singleton'>,\n): ServiceRef<TService, 'plugin', 'singleton'>;\n\n/**\n * Creates a new service definition. This overload is used to create root scoped services.\n *\n * @public\n */\nexport function createServiceRef<TService>(\n  options: ServiceRefOptions<TService, 'root', 'singleton'>,\n): ServiceRef<TService, 'root', 'singleton'>;\n\n/**\n * Creates a new service definition. This overload is used to create plugin scoped services.\n *\n * @public\n */\nexport function createServiceRef<TService>(\n  options: ServiceRefOptions<TService, 'plugin', 'multiton'>,\n): ServiceRef<TService, 'plugin', 'multiton'>;\n\n/**\n * Creates a new service definition. This overload is used to create root scoped services.\n *\n * @public\n */\nexport function createServiceRef<TService>(\n  options: ServiceRefOptions<TService, 'root', 'multiton'>,\n): ServiceRef<TService, 'root', 'multiton'>;\nexport function createServiceRef<\n  TService,\n  TInstances extends 'singleton' | 'multiton',\n>(\n  options: ServiceRefOptions<TService, any, TInstances>,\n): ServiceRef<TService, any, TInstances> {\n  const { id, scope = 'plugin', multiton = false, defaultFactory } = options;\n  return {\n    id,\n    scope,\n    multiton,\n    get T(): TService {\n      throw new Error(`tried to read ServiceRef.T of ${this}`);\n    },\n    toString() {\n      return `serviceRef{${options.id}}`;\n    },\n    toJSON() {\n      // This avoids accidental calls to T happening e.g. in tests\n      return {\n        $$type: '@backstage/ServiceRef',\n        id,\n        scope,\n        multiton,\n      };\n    },\n    $$type: '@backstage/ServiceRef',\n    __defaultFactory: defaultFactory,\n  } as ServiceRef<TService, typeof scope, TInstances> & {\n    __defaultFactory?: (\n      service: ServiceRef<TService>,\n    ) => Promise<ServiceFactory<TService>>;\n  };\n}\n\n/** @ignore */\ntype ServiceRefsToInstances<\n  T extends { [key in string]: ServiceRef<unknown> },\n  TScope extends 'root' | 'plugin' = 'root' | 'plugin',\n> = {\n  [key in keyof T as T[key]['scope'] extends TScope\n    ? key\n    : never]: T[key]['multiton'] extends true | undefined\n    ? Array<T[key]['T']>\n    : T[key]['T'];\n};\n\n/** @public */\nexport interface RootServiceFactoryOptions<\n  TService,\n  TInstances extends 'singleton' | 'multiton',\n  TImpl extends TService,\n  TDeps extends { [name in string]: ServiceRef<unknown> },\n> {\n  /**\n   * The initialization strategy for the service factory. This service is root scoped and will use `always` by default.\n   *\n   * @remarks\n   *\n   * - `always` - The service will always be initialized regardless if it is used or not.\n   * - `lazy` - The service will only be initialized if it is depended on by a different service or feature.\n   *\n   * Service factories for root scoped services use `always` as the default, while plugin scoped services use `lazy`.\n   */\n  initialization?: 'always' | 'lazy';\n  service: ServiceRef<TService, 'root', TInstances>;\n  deps: TDeps;\n  factory(deps: ServiceRefsToInstances<TDeps, 'root'>): TImpl | Promise<TImpl>;\n}\n\n/** @public */\nexport interface PluginServiceFactoryOptions<\n  TService,\n  TInstances extends 'singleton' | 'multiton',\n  TContext,\n  TImpl extends TService,\n  TDeps extends { [name in string]: ServiceRef<unknown> },\n> {\n  /**\n   * The initialization strategy for the service factory. This service is plugin scoped and will use `lazy` by default.\n   *\n   * @remarks\n   *\n   * - `always` - The service will always be initialized regardless if it is used or not.\n   * - `lazy` - The service will only be initialized if it is depended on by a different service or feature.\n   *\n   * Service factories for root scoped services use `always` as the default, while plugin scoped services use `lazy`.\n   */\n  initialization?: 'always' | 'lazy';\n  service: ServiceRef<TService, 'plugin', TInstances>;\n  deps: TDeps;\n  createRootContext?(\n    deps: ServiceRefsToInstances<TDeps, 'root'>,\n  ): TContext | Promise<TContext>;\n  factory(\n    deps: ServiceRefsToInstances<TDeps>,\n    context: TContext,\n  ): TImpl | Promise<TImpl>;\n}\n\n/**\n * Creates a root scoped service factory without options.\n *\n * @public\n * @param options - The service factory configuration.\n */\nexport function createServiceFactory<\n  TService,\n  TInstances extends 'singleton' | 'multiton',\n  TImpl extends TService,\n  TDeps extends { [name in string]: ServiceRef<unknown, 'root'> },\n>(\n  options: RootServiceFactoryOptions<TService, TInstances, TImpl, TDeps>,\n): ServiceFactory<TService, 'root', TInstances>;\n/**\n * Creates a plugin scoped service factory without options.\n *\n * @public\n * @param options - The service factory configuration.\n */\nexport function createServiceFactory<\n  TService,\n  TInstances extends 'singleton' | 'multiton',\n  TImpl extends TService,\n  TDeps extends { [name in string]: ServiceRef<unknown> },\n  TContext = undefined,\n>(\n  options: PluginServiceFactoryOptions<\n    TService,\n    TInstances,\n    TContext,\n    TImpl,\n    TDeps\n  >,\n): ServiceFactory<TService, 'plugin', TInstances>;\nexport function createServiceFactory<\n  TService,\n  TInstances extends 'singleton' | 'multiton',\n  TImpl extends TService,\n  TDeps extends { [name in string]: ServiceRef<unknown> },\n  TContext,\n>(\n  options:\n    | RootServiceFactoryOptions<TService, TInstances, TImpl, TDeps>\n    | PluginServiceFactoryOptions<TService, TInstances, TContext, TImpl, TDeps>,\n): ServiceFactory<TService, 'root' | 'plugin', 'singleton' | 'multiton'> {\n  if (options.service.scope === 'root') {\n    const c = options as RootServiceFactoryOptions<\n      TService,\n      TInstances,\n      TImpl,\n      TDeps\n    >;\n    return {\n      $$type: '@backstage/BackendFeature',\n      version: 'v1',\n      featureType: 'service',\n      service: c.service,\n      initialization: c.initialization,\n      deps: options.deps,\n      factory: async (deps: ServiceRefsToInstances<TDeps, 'root'>) =>\n        c.factory(deps),\n    } as InternalServiceFactory<TService, 'root', TInstances>;\n  }\n  const c = options as PluginServiceFactoryOptions<\n    TService,\n    TInstances,\n    TContext,\n    TImpl,\n    TDeps\n  >;\n  return {\n    $$type: '@backstage/BackendFeature',\n    version: 'v1',\n    featureType: 'service',\n    service: c.service,\n    initialization: c.initialization,\n    ...('createRootContext' in options\n      ? {\n          createRootContext: async (\n            deps: ServiceRefsToInstances<TDeps, 'root'>,\n          ) => c?.createRootContext?.(deps),\n        }\n      : {}),\n    deps: options.deps,\n    factory: async (deps: ServiceRefsToInstances<TDeps>, ctx: TContext) =>\n      c.factory(deps, ctx),\n  } as InternalServiceFactory<TService, 'plugin', TInstances>;\n}\n"],"names":["c"],"mappings":";;AAsIO,SAAS,iBAId,OAAA,EACuC;AACvC,EAAA,MAAM,EAAE,EAAA,EAAI,KAAA,GAAQ,UAAU,QAAA,GAAW,KAAA,EAAO,gBAAe,GAAI,OAAA;AACnE,EAAA,OAAO;AAAA,IACL,EAAA;AAAA,IACA,KAAA;AAAA,IACA,QAAA;AAAA,IACA,IAAI,CAAA,GAAc;AAChB,MAAA,MAAM,IAAI,KAAA,CAAM,CAAA,8BAAA,EAAiC,IAAI,CAAA,CAAE,CAAA;AAAA,IACzD,CAAA;AAAA,IACA,QAAA,GAAW;AACT,MAAA,OAAO,CAAA,WAAA,EAAc,QAAQ,EAAE,CAAA,CAAA,CAAA;AAAA,IACjC,CAAA;AAAA,IACA,MAAA,GAAS;AAEP,MAAA,OAAO;AAAA,QACL,MAAA,EAAQ,uBAAA;AAAA,QACR,EAAA;AAAA,QACA,KAAA;AAAA,QACA;AAAA,OACF;AAAA,IACF,CAAA;AAAA,IACA,MAAA,EAAQ,uBAAA;AAAA,IACR,gBAAA,EAAkB;AAAA,GACpB;AAKF;AAsGO,SAAS,qBAOd,OAAA,EAGuE;AACvE,EAAA,IAAI,OAAA,CAAQ,OAAA,CAAQ,KAAA,KAAU,MAAA,EAAQ;AACpC,IAAA,MAAMA,EAAAA,GAAI,OAAA;AAMV,IAAA,OAAO;AAAA,MACL,MAAA,EAAQ,2BAAA;AAAA,MACR,OAAA,EAAS,IAAA;AAAA,MACT,WAAA,EAAa,SAAA;AAAA,MACb,SAASA,EAAAA,CAAE,OAAA;AAAA,MACX,gBAAgBA,EAAAA,CAAE,cAAA;AAAA,MAClB,MAAM,OAAA,CAAQ,IAAA;AAAA,MACd,OAAA,EAAS,OAAO,IAAA,KACdA,EAAAA,CAAE,QAAQ,IAAI;AAAA,KAClB;AAAA,EACF;AACA,EAAA,MAAM,CAAA,GAAI,OAAA;AAOV,EAAA,OAAO;AAAA,IACL,MAAA,EAAQ,2BAAA;AAAA,IACR,OAAA,EAAS,IAAA;AAAA,IACT,WAAA,EAAa,SAAA;AAAA,IACb,SAAS,CAAA,CAAE,OAAA;AAAA,IACX,gBAAgB,CAAA,CAAE,cAAA;AAAA,IAClB,GAAI,uBAAuB,OAAA,GACvB;AAAA,MACE,iBAAA,EAAmB,OACjB,IAAA,KACG,CAAA,EAAG,oBAAoB,IAAI;AAAA,QAElC,EAAC;AAAA,IACL,MAAM,OAAA,CAAQ,IAAA;AAAA,IACd,SAAS,OAAO,IAAA,EAAqC,QACnD,CAAA,CAAE,OAAA,CAAQ,MAAM,GAAG;AAAA,GACvB;AACF;;;;;"}