{"version":3,"file":"testUtils.cjs.js","sources":["../src/testUtils.ts"],"sourcesContent":["/*\n * Copyright 2023 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { packagePathMocks } from './paths';\nimport { posix as posixPath, resolve as resolvePath } from 'path';\n\n/** @public */\nexport interface PackagePathResolutionOverride {\n  /** Restores the normal behavior of resolvePackagePath */\n  restore(): void;\n}\n\n/** @public */\nexport interface OverridePackagePathResolutionOptions {\n  /** The name of the package to mock the resolved path of */\n  packageName: string;\n\n  /** A replacement for the root package path */\n  path?: string;\n\n  /**\n   * Replacements for package sub-paths, each key must be an exact match of the posix-style path\n   * that is being resolved within the package.\n   *\n   * For example, code calling `resolvePackagePath('x', 'foo', 'bar')` would match only the following\n   * configuration: `overridePackagePathResolution({ packageName: 'x', paths: { 'foo/bar': baz } })`\n   */\n  paths?: { [path in string]: string | (() => string) };\n}\n\n/**\n * This utility helps you override the paths returned by `resolvePackagePath` for a given package.\n *\n * @public\n */\nexport function overridePackagePathResolution(\n  options: OverridePackagePathResolutionOptions,\n): PackagePathResolutionOverride {\n  const name = options.packageName;\n\n  if (packagePathMocks.has(name)) {\n    throw new Error(\n      `Tried to override resolution for '${name}' more than once for package '${name}'`,\n    );\n  }\n\n  packagePathMocks.set(name, paths => {\n    const joinedPath = posixPath.join(...paths);\n    const localResolver = options.paths?.[joinedPath];\n    if (localResolver) {\n      return typeof localResolver === 'function'\n        ? localResolver()\n        : localResolver;\n    }\n    if (options.path) {\n      return resolvePath(options.path, ...paths);\n    }\n    return undefined;\n  });\n\n  return {\n    restore() {\n      packagePathMocks.delete(name);\n    },\n  };\n}\n"],"names":["packagePathMocks","posixPath","resolvePath"],"mappings":";;;;;AAgDO,SAAS,8BACd,OAAA,EAC+B;AAC/B,EAAA,MAAM,OAAO,OAAA,CAAQ,WAAA;AAErB,EAAA,IAAIA,sBAAA,CAAiB,GAAA,CAAI,IAAI,CAAA,EAAG;AAC9B,IAAA,MAAM,IAAI,KAAA;AAAA,MACR,CAAA,kCAAA,EAAqC,IAAI,CAAA,8BAAA,EAAiC,IAAI,CAAA,CAAA;AAAA,KAChF;AAAA,EACF;AAEA,EAAAA,sBAAA,CAAiB,GAAA,CAAI,MAAM,CAAA,KAAA,KAAS;AAClC,IAAA,MAAM,UAAA,GAAaC,UAAA,CAAU,IAAA,CAAK,GAAG,KAAK,CAAA;AAC1C,IAAA,MAAM,aAAA,GAAgB,OAAA,CAAQ,KAAA,GAAQ,UAAU,CAAA;AAChD,IAAA,IAAI,aAAA,EAAe;AACjB,MAAA,OAAO,OAAO,aAAA,KAAkB,UAAA,GAC5B,aAAA,EAAc,GACd,aAAA;AAAA,IACN;AACA,IAAA,IAAI,QAAQ,IAAA,EAAM;AAChB,MAAA,OAAOC,YAAA,CAAY,OAAA,CAAQ,IAAA,EAAM,GAAG,KAAK,CAAA;AAAA,IAC3C;AACA,IAAA,OAAO,MAAA;AAAA,EACT,CAAC,CAAA;AAED,EAAA,OAAO;AAAA,IACL,OAAA,GAAU;AACR,MAAAF,sBAAA,CAAiB,OAAO,IAAI,CAAA;AAAA,IAC9B;AAAA,GACF;AACF;;;;"}