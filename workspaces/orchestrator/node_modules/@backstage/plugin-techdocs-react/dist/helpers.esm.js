import { getCompoundEntityRef, parseEntityRef } from '@backstage/catalog-model';
import { TECHDOCS_EXTERNAL_PATH_ANNOTATION, TECHDOCS_EXTERNAL_ANNOTATION } from '@backstage/plugin-techdocs-common';

function toLowercaseEntityRefMaybe(entityRef, config) {
  if (config.getOptionalBoolean("techdocs.legacyUseCaseSensitiveTripletPaths"))
    return entityRef;
  entityRef.kind = entityRef.kind.toLocaleLowerCase();
  entityRef.name = entityRef.name.toLocaleLowerCase();
  entityRef.namespace = entityRef.namespace.toLocaleLowerCase();
  return entityRef;
}
function getEntityRootTechDocsPath(entity) {
  let path = entity.metadata.annotations?.[TECHDOCS_EXTERNAL_PATH_ANNOTATION];
  if (!path) {
    return "";
  }
  if (!path.startsWith("/")) {
    path = `/${path}`;
  }
  return path;
}
const buildTechDocsURL = (entity, routeFunc) => {
  if (!routeFunc) {
    return void 0;
  }
  let { namespace, kind, name } = getCompoundEntityRef(entity);
  if (entity.metadata.annotations?.[TECHDOCS_EXTERNAL_ANNOTATION]) {
    try {
      const techdocsRef = parseEntityRef(
        entity.metadata.annotations?.[TECHDOCS_EXTERNAL_ANNOTATION]
      );
      namespace = techdocsRef.namespace;
      kind = techdocsRef.kind;
      name = techdocsRef.name;
    } catch {
    }
  }
  const url = routeFunc({
    namespace,
    kind,
    name
  });
  const path = getEntityRootTechDocsPath(entity);
  return `${url}${path}`;
};

export { buildTechDocsURL, getEntityRootTechDocsPath, toLowercaseEntityRefMaybe };
//# sourceMappingURL=helpers.esm.js.map
