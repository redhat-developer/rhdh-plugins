'use strict';

var pluginScaffolderNode = require('@backstage/plugin-scaffolder-node');
var webhooks = require('@octokit/webhooks');
var errors = require('@backstage/errors');
var octokit = require('octokit');
var util = require('../util.cjs.js');
var githubWebhook_examples = require('./githubWebhook.examples.cjs.js');

function createGithubWebhookAction(options) {
  const { integrations, defaultWebhookSecret, githubCredentialsProvider } = options;
  const eventNames = webhooks.emitterEventNames.filter((event) => !event.includes("."));
  return pluginScaffolderNode.createTemplateAction({
    id: "github:webhook",
    description: "Creates webhook for a repository on GitHub.",
    examples: githubWebhook_examples.examples,
    supportsDryRun: true,
    schema: {
      input: {
        repoUrl: (z) => z.string({
          description: "Accepts the format `github.com?repo=reponame&owner=owner` where `reponame` is the new repository name and `owner` is an organization or username"
        }),
        webhookUrl: (z) => z.string({
          description: "The URL to which the payloads will be delivered"
        }),
        webhookSecret: (z) => z.string({
          description: "Webhook secret value. The default can be provided internally in action creation"
        }).optional(),
        events: (z) => z.union([
          z.array(z.enum(eventNames), {
            description: "Determines what events the hook is triggered for. Default: `[push]`"
          }),
          z.array(z.literal("*"), {
            description: 'Determines what events the hook is triggered for. Use "*" for all events. Default: `[push]`'
          })
        ]).default(["push"]).optional(),
        active: (z) => z.boolean({
          description: "Determines if notifications are sent when the webhook is triggered. Default: `true`"
        }).default(true).optional(),
        contentType: (z) => z.enum(["form", "json"], {
          description: "The media type used to serialize the payloads. The default is `form`"
        }).default("form").optional(),
        insecureSsl: (z) => z.boolean({
          description: "Determines whether the SSL certificate of the host for url will be verified when delivering payloads. Default `false`"
        }).default(false).optional(),
        token: (z) => z.string({
          description: "The `GITHUB_TOKEN` to use for authorization to GitHub"
        }).optional()
      }
    },
    async handler(ctx) {
      const {
        repoUrl,
        webhookUrl,
        webhookSecret = defaultWebhookSecret,
        events = ["push"],
        active = true,
        contentType = "form",
        insecureSsl = false,
        token: providedToken
      } = ctx.input;
      ctx.logger.info(`Creating webhook ${webhookUrl} for repo ${repoUrl}`);
      const { host, owner, repo } = pluginScaffolderNode.parseRepoUrl(repoUrl, integrations);
      if (!owner) {
        throw new errors.InputError("Invalid repository owner provided in repoUrl");
      }
      const octokitOptions = await util.getOctokitOptions({
        integrations,
        credentialsProvider: githubCredentialsProvider,
        host,
        owner,
        repo,
        token: providedToken
      });
      const client = new octokit.Octokit({
        ...octokitOptions,
        log: ctx.logger
      });
      if (ctx.isDryRun) {
        ctx.logger.info(`Dry run complete`);
        return;
      }
      try {
        const insecure_ssl = insecureSsl ? "1" : "0";
        await ctx.checkpoint({
          key: `create.webhhook.${owner}.${repo}.${webhookUrl}`,
          fn: async () => {
            await client.rest.repos.createWebhook({
              owner,
              repo,
              config: {
                url: webhookUrl,
                content_type: contentType,
                secret: webhookSecret,
                insecure_ssl
              },
              events,
              active
            });
          }
        });
        ctx.logger.info(`Webhook '${webhookUrl}' created successfully`);
      } catch (e) {
        errors.assertError(e);
        ctx.logger.warn(
          `Failed: create webhook '${webhookUrl}' on repo: '${repo}', ${e.message}`
        );
      }
    }
  });
}

exports.createGithubWebhookAction = createGithubWebhookAction;
//# sourceMappingURL=githubWebhook.cjs.js.map
