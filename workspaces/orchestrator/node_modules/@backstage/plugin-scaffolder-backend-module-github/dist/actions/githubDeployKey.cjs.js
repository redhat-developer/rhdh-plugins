'use strict';

var errors = require('@backstage/errors');
var pluginScaffolderNode = require('@backstage/plugin-scaffolder-node');
var util = require('../util.cjs.js');
var octokit = require('octokit');
var Sodium = require('libsodium-wrappers');
var githubDeployKey_examples = require('./githubDeployKey.examples.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var Sodium__default = /*#__PURE__*/_interopDefaultCompat(Sodium);

function createGithubDeployKeyAction(options) {
  const { integrations } = options;
  return pluginScaffolderNode.createTemplateAction({
    id: "github:deployKey:create",
    description: "Creates and stores Deploy Keys",
    examples: githubDeployKey_examples.examples,
    schema: {
      input: {
        repoUrl: (z) => z.string({
          description: "Accepts the format `github.com?repo=reponame&owner=owner` where `reponame` is the new repository name and `owner` is an organization or username"
        }),
        publicKey: (z) => z.string({
          description: "Generated from `ssh-keygen`.  Begins with `ssh-rsa`, `ecdsa-sha2-nistp256`, `ecdsa-sha2-nistp384`, `ecdsa-sha2-nistp521`, `ssh-ed25519`, `sk-ecdsa-sha2-nistp256@openssh.com`, or `sk-ssh-ed25519@openssh.com`."
        }),
        privateKey: (z) => z.string({
          description: "SSH Private Key generated from `ssh-keygen`"
        }),
        deployKeyName: (z) => z.string({
          description: `Name of the Deploy Key`
        }),
        privateKeySecretName: (z) => z.string({
          description: "Name of the GitHub Secret to store the private key related to the Deploy Key.  Defaults to: `KEY_NAME_PRIVATE_KEY` where `KEY_NAME` is the name of the Deploy Key"
        }).optional(),
        token: (z) => z.string({
          description: "The token to use for authorization to GitHub"
        }).optional()
      },
      output: {
        privateKeySecretName: (z) => z.string({
          description: "The GitHub Action Repo Secret Name for the Private Key"
        })
      }
    },
    async handler(ctx) {
      const {
        repoUrl,
        publicKey,
        privateKey,
        deployKeyName,
        privateKeySecretName = `${deployKeyName.split(" ").join("_").toLocaleUpperCase("en-US")}_PRIVATE_KEY`,
        token: providedToken
      } = ctx.input;
      const { host, owner, repo } = pluginScaffolderNode.parseRepoUrl(repoUrl, integrations);
      if (!owner) {
        throw new errors.InputError(`No owner provided for repo ${repoUrl}`);
      }
      const octokitOptions = await util.getOctokitOptions({
        integrations,
        token: providedToken,
        host,
        owner,
        repo
      });
      const client = new octokit.Octokit({
        ...octokitOptions,
        log: ctx.logger
      });
      await ctx.checkpoint({
        key: `create.deploy.key.${owner}.${repo}.${publicKey}`,
        fn: async () => {
          await client.rest.repos.createDeployKey({
            owner,
            repo,
            title: deployKeyName,
            key: publicKey
          });
        }
      });
      const { key, keyId } = await ctx.checkpoint({
        key: `get.repo.public.key.${owner}.${repo}`,
        fn: async () => {
          const publicKeyResponse = await client.rest.actions.getRepoPublicKey({
            owner,
            repo
          });
          return {
            key: publicKeyResponse.data.key,
            keyId: publicKeyResponse.data.key_id
          };
        }
      });
      await Sodium__default.default.ready;
      const binaryKey = Sodium__default.default.from_base64(
        key,
        Sodium__default.default.base64_variants.ORIGINAL
      );
      const binarySecret = Sodium__default.default.from_string(privateKey);
      const encryptedBinarySecret = Sodium__default.default.crypto_box_seal(
        binarySecret,
        binaryKey
      );
      const encryptedBase64Secret = Sodium__default.default.to_base64(
        encryptedBinarySecret,
        Sodium__default.default.base64_variants.ORIGINAL
      );
      await ctx.checkpoint({
        key: `create.or.update.repo.secret.${owner}.${repo}.${keyId}`,
        fn: async () => {
          await client.rest.actions.createOrUpdateRepoSecret({
            owner,
            repo,
            secret_name: privateKeySecretName,
            encrypted_value: encryptedBase64Secret,
            key_id: keyId
          });
        }
      });
      ctx.output("privateKeySecretName", privateKeySecretName);
    }
  });
}

exports.createGithubDeployKeyAction = createGithubDeployKeyAction;
//# sourceMappingURL=githubDeployKey.cjs.js.map
