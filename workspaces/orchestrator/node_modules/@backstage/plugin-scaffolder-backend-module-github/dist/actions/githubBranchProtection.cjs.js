'use strict';

var errors = require('@backstage/errors');
var pluginScaffolderNode = require('@backstage/plugin-scaffolder-node');
var githubBranchProtection_examples = require('./githubBranchProtection.examples.cjs.js');
var inputProperties = require('./inputProperties.cjs.js');
var util = require('../util.cjs.js');
var octokit = require('octokit');
var gitHelpers = require('./gitHelpers.cjs.js');

function createGithubBranchProtectionAction(options) {
  const { integrations } = options;
  return pluginScaffolderNode.createTemplateAction({
    id: "github:branch-protection:create",
    description: "Configures Branch Protection",
    examples: githubBranchProtection_examples.examples,
    schema: {
      input: {
        repoUrl: inputProperties.repoUrl,
        branch: inputProperties.branch,
        enforceAdmins: inputProperties.protectEnforceAdmins,
        requiredApprovingReviewCount: inputProperties.requiredApprovingReviewCount,
        requireCodeOwnerReviews: inputProperties.requireCodeOwnerReviews,
        dismissStaleReviews: inputProperties.dismissStaleReviews,
        bypassPullRequestAllowances: inputProperties.bypassPullRequestAllowances,
        restrictions: inputProperties.restrictions,
        requiredStatusCheckContexts: inputProperties.requiredStatusCheckContexts,
        requireBranchesToBeUpToDate: inputProperties.requireBranchesToBeUpToDate,
        requiredConversationResolution: inputProperties.requiredConversationResolution,
        requireLastPushApproval: inputProperties.requireLastPushApproval,
        requiredCommitSigning: inputProperties.requiredCommitSigning,
        requiredLinearHistory: inputProperties.requiredLinearHistory,
        token: inputProperties.token
      }
    },
    async handler(ctx) {
      const {
        repoUrl,
        branch,
        enforceAdmins = true,
        requiredApprovingReviewCount = 1,
        requireCodeOwnerReviews = false,
        dismissStaleReviews = false,
        bypassPullRequestAllowances,
        restrictions,
        requiredStatusCheckContexts = [],
        requireBranchesToBeUpToDate = true,
        requiredConversationResolution = false,
        requireLastPushApproval = false,
        requiredCommitSigning = false,
        requiredLinearHistory = false,
        token: providedToken
      } = ctx.input;
      const { host, owner, repo } = pluginScaffolderNode.parseRepoUrl(repoUrl, integrations);
      if (!owner) {
        throw new errors.InputError(`No owner provided for repo ${repoUrl}`);
      }
      const octokitOptions = await util.getOctokitOptions({
        integrations,
        token: providedToken,
        host,
        owner,
        repo
      });
      const client = new octokit.Octokit({
        ...octokitOptions,
        log: ctx.logger
      });
      const defaultBranch = await ctx.checkpoint({
        key: `read.default.branch.${owner}.${repo}`,
        fn: async () => {
          const repository = await client.rest.repos.get({
            owner,
            repo
          });
          return repository.data.default_branch;
        }
      });
      await ctx.checkpoint({
        key: `enable.branch.protection.${owner}.${repo}`,
        fn: async () => {
          await gitHelpers.enableBranchProtectionOnDefaultRepoBranch({
            repoName: repo,
            client,
            owner,
            logger: ctx.logger,
            requireCodeOwnerReviews,
            bypassPullRequestAllowances,
            requiredApprovingReviewCount,
            restrictions,
            requiredStatusCheckContexts,
            requireBranchesToBeUpToDate,
            requiredConversationResolution,
            requireLastPushApproval,
            defaultBranch: branch ?? defaultBranch,
            enforceAdmins,
            dismissStaleReviews,
            requiredCommitSigning,
            requiredLinearHistory
          });
        }
      });
    }
  });
}

exports.createGithubBranchProtectionAction = createGithubBranchProtectionAction;
//# sourceMappingURL=githubBranchProtection.cjs.js.map
