'use strict';

var errors = require('@backstage/errors');
var octokit = require('octokit');
var pluginScaffolderNode = require('@backstage/plugin-scaffolder-node');
var helpers = require('./helpers.cjs.js');
var util = require('../util.cjs.js');
var inputProperties = require('./inputProperties.cjs.js');
var outputProperties = require('./outputProperties.cjs.js');
var githubRepoCreate_examples = require('./githubRepoCreate.examples.cjs.js');

function createGithubRepoCreateAction(options) {
  const { integrations, githubCredentialsProvider } = options;
  return pluginScaffolderNode.createTemplateAction({
    id: "github:repo:create",
    description: "Creates a GitHub repository.",
    examples: githubRepoCreate_examples.examples,
    schema: {
      input: {
        repoUrl: inputProperties.repoUrl,
        description: inputProperties.description,
        homepage: inputProperties.homepage,
        access: inputProperties.access,
        requireCodeOwnerReviews: inputProperties.requireCodeOwnerReviews,
        bypassPullRequestAllowances: inputProperties.bypassPullRequestAllowances,
        requiredApprovingReviewCount: inputProperties.requiredApprovingReviewCount,
        restrictions: inputProperties.restrictions,
        requiredStatusCheckContexts: inputProperties.requiredStatusCheckContexts,
        requireBranchesToBeUpToDate: inputProperties.requireBranchesToBeUpToDate,
        requiredConversationResolution: inputProperties.requiredConversationResolution,
        repoVisibility: inputProperties.repoVisibility,
        deleteBranchOnMerge: inputProperties.deleteBranchOnMerge,
        allowMergeCommit: inputProperties.allowMergeCommit,
        allowSquashMerge: inputProperties.allowSquashMerge,
        squashMergeCommitTitle: inputProperties.squashMergeCommitTitle,
        squashMergeCommitMessage: inputProperties.squashMergeCommitMessage,
        allowRebaseMerge: inputProperties.allowRebaseMerge,
        allowAutoMerge: inputProperties.allowAutoMerge,
        allowUpdateBranch: inputProperties.allowUpdateBranch,
        collaborators: inputProperties.collaborators,
        hasProjects: inputProperties.hasProjects,
        hasWiki: inputProperties.hasWiki,
        hasIssues: inputProperties.hasIssues,
        token: inputProperties.token,
        topics: inputProperties.topics,
        repoVariables: inputProperties.repoVariables,
        secrets: inputProperties.secrets,
        oidcCustomization: inputProperties.oidcCustomization,
        requiredCommitSigning: inputProperties.requiredCommitSigning,
        requiredLinearHistory: inputProperties.requiredLinearHistory,
        customProperties: inputProperties.customProperties,
        subscribe: inputProperties.subscribe
      },
      output: {
        remoteUrl: outputProperties.remoteUrl,
        repoContentsUrl: outputProperties.repoContentsUrl
      }
    },
    async handler(ctx) {
      const {
        repoUrl,
        description,
        homepage,
        access,
        repoVisibility = "private",
        deleteBranchOnMerge = false,
        allowMergeCommit = true,
        allowSquashMerge = true,
        squashMergeCommitTitle = "COMMIT_OR_PR_TITLE",
        squashMergeCommitMessage = "COMMIT_MESSAGES",
        allowRebaseMerge = true,
        allowAutoMerge = false,
        allowUpdateBranch = false,
        collaborators,
        hasProjects = void 0,
        hasWiki = void 0,
        hasIssues = void 0,
        topics,
        repoVariables,
        secrets,
        oidcCustomization,
        customProperties,
        subscribe,
        token: providedToken
      } = ctx.input;
      const { host, owner, repo } = pluginScaffolderNode.parseRepoUrl(repoUrl, integrations);
      if (!owner) {
        throw new errors.InputError("Invalid repository owner provided in repoUrl");
      }
      const octokitOptions = await util.getOctokitOptions({
        integrations,
        credentialsProvider: githubCredentialsProvider,
        token: providedToken,
        host,
        owner,
        repo
      });
      const client = new octokit.Octokit({
        ...octokitOptions,
        log: ctx.logger
      });
      const remoteUrl = await ctx.checkpoint({
        key: `create.repo.and.topics.${owner}.${repo}`,
        fn: async () => {
          const newRepo = await helpers.createGithubRepoWithCollaboratorsAndTopics(
            client,
            repo,
            owner,
            repoVisibility,
            description,
            homepage,
            deleteBranchOnMerge,
            allowMergeCommit,
            allowSquashMerge,
            squashMergeCommitTitle,
            squashMergeCommitMessage,
            allowRebaseMerge,
            allowAutoMerge,
            allowUpdateBranch,
            access,
            collaborators,
            hasProjects,
            hasWiki,
            hasIssues,
            topics,
            repoVariables,
            secrets,
            oidcCustomization,
            customProperties,
            subscribe,
            ctx.logger
          );
          return newRepo.clone_url;
        }
      });
      ctx.output("remoteUrl", remoteUrl);
    }
  });
}

exports.createGithubRepoCreateAction = createGithubRepoCreateAction;
//# sourceMappingURL=githubRepoCreate.cjs.js.map
