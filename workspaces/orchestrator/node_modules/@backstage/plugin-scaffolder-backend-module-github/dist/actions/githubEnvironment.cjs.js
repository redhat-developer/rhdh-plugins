'use strict';

var errors = require('@backstage/errors');
var pluginScaffolderNode = require('@backstage/plugin-scaffolder-node');
var util = require('../util.cjs.js');
var octokit = require('octokit');
var Sodium = require('libsodium-wrappers');
var gitHubEnvironment_examples = require('./gitHubEnvironment.examples.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var Sodium__default = /*#__PURE__*/_interopDefaultCompat(Sodium);

function createGithubEnvironmentAction(options) {
  const { integrations, catalog } = options;
  return pluginScaffolderNode.createTemplateAction({
    id: "github:environment:create",
    description: "Creates Deployment Environments",
    examples: gitHubEnvironment_examples.examples,
    schema: {
      input: {
        repoUrl: (z) => z.string({
          description: "Accepts the format `github.com?repo=reponame&owner=owner` where `reponame` is the new repository name and `owner` is an organization or username"
        }),
        name: (z) => z.string({
          description: `Name of the deployment environment to create`
        }),
        deploymentBranchPolicy: (z) => z.object(
          {
            protected_branches: z.boolean({
              description: "Whether only branches with branch protection rules can deploy to this environment. If `protected_branches` is `true`, `custom_branch_policies` must be `false`; if `protected_branches` is `false`, `custom_branch_policies` must be `true`."
            }),
            custom_branch_policies: z.boolean({
              description: "Whether only branches that match the specified name patterns can deploy to this environment. If `custom_branch_policies` is `true`, `protected_branches` must be `false`; if `custom_branch_policies` is `false`, `protected_branches` must be `true`."
            })
          },
          {
            description: "The type of deployment branch policy for this environment. To allow all branches to deploy, set to `null`."
          }
        ).optional(),
        customBranchPolicyNames: (z) => z.array(z.string(), {
          description: `The name pattern that branches must match in order to deploy to the environment.

Wildcard characters will not match \`/\`. For example, to match branches that begin with \`release/\` and contain an additional single slash, use \`release/*/*\`. For more information about pattern matching syntax, see the Ruby File.fnmatch documentation.`
        }).optional(),
        customTagPolicyNames: (z) => z.array(z.string(), {
          description: `The name pattern that tags must match in order to deploy to the environment.

Wildcard characters will not match \`/\`. For example, to match tags that begin with \`release/\` and contain an additional single slash, use \`release/*/*\`. For more information about pattern matching syntax, see the Ruby File.fnmatch documentation.`
        }).optional(),
        environmentVariables: (z) => z.record(z.string(), {
          description: `Environment variables attached to the deployment environment`
        }).optional(),
        secrets: (z) => z.record(z.string(), {
          description: `Secrets attached to the deployment environment`
        }).optional(),
        token: (z) => z.string({
          description: "The token to use for authorization to GitHub"
        }).optional(),
        waitTimer: (z) => z.number({
          description: "The time to wait before creating or updating the environment (in milliseconds)"
        }).optional(),
        preventSelfReview: (z) => z.boolean({
          description: "Whether to prevent self-review for this environment"
        }).optional(),
        reviewers: (z) => z.array(z.string(), {
          description: "Reviewers for this environment. Must be a list of Backstage entity references."
        }).optional()
      }
    },
    async handler(ctx) {
      const {
        repoUrl,
        name,
        deploymentBranchPolicy,
        customBranchPolicyNames,
        customTagPolicyNames,
        environmentVariables,
        secrets,
        token: providedToken,
        waitTimer,
        preventSelfReview,
        reviewers
      } = ctx.input;
      await new Promise((resolve) => setTimeout(resolve, 2e3));
      const { host, owner, repo } = pluginScaffolderNode.parseRepoUrl(repoUrl, integrations);
      if (!owner) {
        throw new errors.InputError(`No owner provided for repo ${repoUrl}`);
      }
      const octokitOptions = await util.getOctokitOptions({
        integrations,
        token: providedToken,
        host,
        owner,
        repo
      });
      const client = new octokit.Octokit({
        ...octokitOptions,
        log: ctx.logger
      });
      const repositoryId = await ctx.checkpoint({
        key: `get.repo.${owner}.${repo}`,
        fn: async () => {
          const repository = await client.rest.repos.get({
            owner,
            repo
          });
          return repository.data.id;
        }
      });
      const githubReviewers = [];
      if (reviewers) {
        let reviewersEntityRefs = [];
        const catalogResponse = await catalog.getEntitiesByRefs(
          {
            entityRefs: reviewers
          },
          {
            credentials: await ctx.getInitiatorCredentials()
          }
        );
        if (catalogResponse?.items?.length) {
          reviewersEntityRefs = catalogResponse.items;
        }
        for (const reviewerEntityRef of reviewersEntityRefs) {
          if (reviewerEntityRef?.kind === "User") {
            try {
              const userId = await ctx.checkpoint({
                key: `get.user.${reviewerEntityRef.metadata.name}`,
                fn: async () => {
                  const user = await client.rest.users.getByUsername({
                    username: reviewerEntityRef.metadata.name
                  });
                  return user.data.id;
                }
              });
              githubReviewers.push({
                type: "User",
                id: userId
              });
            } catch (error) {
              ctx.logger.error("User not found:", error);
            }
          } else if (reviewerEntityRef?.kind === "Group") {
            try {
              const teamId = await ctx.checkpoint({
                key: `get.team.${reviewerEntityRef.metadata.name}`,
                fn: async () => {
                  const team = await client.rest.teams.getByName({
                    org: owner,
                    team_slug: reviewerEntityRef.metadata.name
                  });
                  return team.data.id;
                }
              });
              githubReviewers.push({
                type: "Team",
                id: teamId
              });
            } catch (error) {
              ctx.logger.error("Team not found:", error);
            }
          }
        }
      }
      await ctx.checkpoint({
        key: `create.or.update.environment.${owner}.${repo}.${name}`,
        fn: async () => {
          await client.rest.repos.createOrUpdateEnvironment({
            owner,
            repo,
            environment_name: name,
            deployment_branch_policy: deploymentBranchPolicy ?? void 0,
            wait_timer: waitTimer ?? void 0,
            prevent_self_review: preventSelfReview ?? void 0,
            reviewers: githubReviewers.length ? githubReviewers : void 0
          });
        }
      });
      if (customBranchPolicyNames) {
        for (const item of customBranchPolicyNames) {
          await ctx.checkpoint({
            key: `create.deployment.branch.policy.branch.${owner}.${repo}.${name}.${item}`,
            fn: async () => {
              await client.rest.repos.createDeploymentBranchPolicy({
                owner,
                repo,
                type: "branch",
                environment_name: name,
                name: item
              });
            }
          });
        }
      }
      if (customTagPolicyNames) {
        for (const item of customTagPolicyNames) {
          await ctx.checkpoint({
            key: `create.deployment.branch.policy.tag.${owner}.${repo}.${name}.${item}`,
            fn: async () => {
              await client.rest.repos.createDeploymentBranchPolicy({
                owner,
                repo,
                type: "tag",
                environment_name: name,
                name: item
              });
            }
          });
        }
      }
      for (const [key, value] of Object.entries(environmentVariables ?? {})) {
        await ctx.checkpoint({
          key: `create.env.variable.${owner}.${repo}.${name}.${key}`,
          fn: async () => {
            await client.rest.actions.createEnvironmentVariable({
              repository_id: repositoryId,
              owner,
              repo,
              environment_name: name,
              name: key,
              value
            });
          }
        });
      }
      if (secrets) {
        const { publicKey, publicKeyId } = await ctx.checkpoint({
          key: `get.env.public.key.${owner}.${repo}.${name}`,
          fn: async () => {
            const publicKeyResponse = await client.rest.actions.getEnvironmentPublicKey({
              repository_id: repositoryId,
              owner,
              repo,
              environment_name: name
            });
            return {
              publicKey: publicKeyResponse.data.key,
              publicKeyId: publicKeyResponse.data.key_id
            };
          }
        });
        await Sodium__default.default.ready;
        const binaryKey = Sodium__default.default.from_base64(
          publicKey,
          Sodium__default.default.base64_variants.ORIGINAL
        );
        for (const [key, value] of Object.entries(secrets)) {
          const binarySecret = Sodium__default.default.from_string(value);
          const encryptedBinarySecret = Sodium__default.default.crypto_box_seal(
            binarySecret,
            binaryKey
          );
          const encryptedBase64Secret = Sodium__default.default.to_base64(
            encryptedBinarySecret,
            Sodium__default.default.base64_variants.ORIGINAL
          );
          await ctx.checkpoint({
            key: `create.or.update.env.secret.${owner}.${repo}.${name}.${key}`,
            fn: async () => {
              await client.rest.actions.createOrUpdateEnvironmentSecret({
                repository_id: repositoryId,
                owner,
                repo,
                environment_name: name,
                secret_name: key,
                encrypted_value: encryptedBase64Secret,
                key_id: publicKeyId
              });
            }
          });
        }
      }
    }
  });
}

exports.createGithubEnvironmentAction = createGithubEnvironmentAction;
//# sourceMappingURL=githubEnvironment.cjs.js.map
