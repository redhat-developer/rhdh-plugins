'use strict';

var CommandGraph = require('./CommandGraph.cjs.js');
var types$1 = require('./types.cjs.js');
var CommandRegistry = require('./CommandRegistry.cjs.js');
var commander = require('commander');
var version = require('../lib/version.cjs.js');
var chalk = require('chalk');
var errors = require('../lib/errors.cjs.js');
var errors$1 = require('@backstage/errors');
var types = require('util/types');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var chalk__default = /*#__PURE__*/_interopDefaultCompat(chalk);

class CliInitializer {
  graph = new CommandGraph.CommandGraph();
  commandRegistry = new CommandRegistry.CommandRegistry(this.graph);
  #uninitiazedFeatures = [];
  add(feature) {
    if (types.isPromise(feature)) {
      this.#uninitiazedFeatures.push(
        feature.then((f) => unwrapFeature(f.default))
      );
    } else {
      this.#uninitiazedFeatures.push(Promise.resolve(feature));
    }
  }
  async #register(feature) {
    if (types$1.OpaqueCliPlugin.isType(feature)) {
      const internal = types$1.OpaqueCliPlugin.toInternal(feature);
      await internal.init(this.commandRegistry);
    } else {
      throw new Error(`Unsupported feature type: ${feature.$$type}`);
    }
  }
  async #doInit() {
    const features = await Promise.all(this.#uninitiazedFeatures);
    for (const feature of features) {
      await this.#register(feature);
    }
  }
  /**
   * Actually parse argv and pass it to the command.
   */
  async run() {
    await this.#doInit();
    const programName = "backstage-cli";
    const program = new commander.Command();
    program.name(programName).version(version.version).allowUnknownOption(true).allowExcessArguments(true);
    const queue = this.graph.atDepth(0).map((node) => ({
      node,
      argParser: program
    }));
    while (queue.length) {
      const { node, argParser } = queue.shift();
      if (node.$$type === "@tree/root") {
        const treeParser = argParser.command(`${node.name} [command]`).description(node.name);
        queue.push(
          ...node.children.map((child) => ({
            node: child,
            argParser: treeParser
          }))
        );
      } else {
        argParser.command(node.name, { hidden: !!node.command.deprecated }).description(node.command.description).helpOption(false).allowUnknownOption(true).allowExcessArguments(true).action(async () => {
          try {
            const args = program.parseOptions(process.argv);
            const nonProcessArgs = args.operands.slice(2);
            const positionalArgs = [];
            let index = 0;
            for (let argIndex = 0; argIndex < nonProcessArgs.length; argIndex++) {
              if (argIndex === index && node.command.path[argIndex] === nonProcessArgs[argIndex]) {
                index += 1;
                continue;
              }
              positionalArgs.push(nonProcessArgs[argIndex]);
            }
            await node.command.execute({
              args: [...positionalArgs, ...args.unknown],
              info: {
                usage: [programName, ...node.command.path].join(" "),
                description: node.command.description
              }
            });
            process.exit(0);
          } catch (error) {
            errors.exitWithError(error);
          }
        });
      }
    }
    program.on("command:*", () => {
      console.log();
      console.log(chalk__default.default.red(`Invalid command: ${program.args.join(" ")}`));
      console.log();
      program.outputHelp();
      process.exit(1);
    });
    process.on("unhandledRejection", (rejection) => {
      errors.exitWithError(new errors$1.ForwardedError("Unhandled rejection", rejection));
    });
    program.parse(process.argv);
  }
}
function unwrapFeature(feature) {
  if ("$$type" in feature) {
    return feature;
  }
  if ("default" in feature) {
    return feature.default;
  }
  return feature;
}

exports.CliInitializer = CliInitializer;
exports.unwrapFeature = unwrapFeature;
//# sourceMappingURL=CliInitializer.cjs.js.map
