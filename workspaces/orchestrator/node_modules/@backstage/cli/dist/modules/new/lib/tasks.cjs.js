'use strict';

var chalk = require('chalk');
var ora = require('ora');
var util = require('util');
var child_process = require('child_process');
var errors = require('@backstage/errors');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var chalk__default = /*#__PURE__*/_interopDefaultCompat(chalk);
var ora__default = /*#__PURE__*/_interopDefaultCompat(ora);

const exec = util.promisify(child_process.exec);
const TASK_NAME_MAX_LENGTH = 14;
class Task {
  static log(name = "") {
    process.stderr.write(`${chalk__default.default.green(name)}
`);
  }
  static error(message = "") {
    process.stderr.write(`
${chalk__default.default.red(message)}

`);
  }
  static section(name) {
    const title = chalk__default.default.green(`${name}:`);
    process.stderr.write(`
 ${title}
`);
  }
  static exit(code = 0) {
    process.exit(code);
  }
  static async forItem(task, item, taskFunc) {
    const paddedTask = chalk__default.default.green(task.padEnd(TASK_NAME_MAX_LENGTH));
    const spinner = ora__default.default({
      prefixText: chalk__default.default.green(`  ${paddedTask}${chalk__default.default.cyan(item)}`),
      spinner: "arc",
      color: "green"
    }).start();
    try {
      const result = await taskFunc();
      spinner.succeed();
      return result;
    } catch (error) {
      spinner.fail();
      throw error;
    }
  }
  static async forCommand(command, options) {
    try {
      await Task.forItem("executing", command, async () => {
        await exec(command, { cwd: options?.cwd });
      });
    } catch (error) {
      errors.assertError(error);
      if (error.stderr) {
        process.stderr.write(error.stderr);
      }
      if (error.stdout) {
        process.stdout.write(error.stdout);
      }
      if (options?.optional) {
        Task.error(`Warning: Failed to execute command ${chalk__default.default.cyan(command)}`);
      } else {
        throw new Error(
          `Failed to execute command '${chalk__default.default.cyan(command)}', ${error}`
        );
      }
    }
  }
}

exports.Task = Task;
//# sourceMappingURL=tasks.cjs.js.map
