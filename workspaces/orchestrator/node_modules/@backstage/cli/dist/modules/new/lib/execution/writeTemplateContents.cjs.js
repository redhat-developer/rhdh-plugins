'use strict';

var fs = require('fs-extra');
var path = require('path');
var paths = require('../../../../lib/paths.cjs.js');
var errors = require('@backstage/errors');
var cliNode = require('@backstage/cli-node');
var PortableTemplater = require('./PortableTemplater.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var fs__default = /*#__PURE__*/_interopDefaultCompat(fs);

async function writeTemplateContents(template, input) {
  const targetDir = paths.paths.resolveTargetRoot(input.packagePath);
  if (await fs__default.default.pathExists(targetDir)) {
    throw new errors.InputError(`Package '${input.packagePath}' already exists`);
  }
  try {
    const isMonoRepo = await cliNode.isMonoRepo();
    const { role, ...roleValues } = input.roleParams;
    const templater = await PortableTemplater.PortableTemplater.create({
      values: {
        ...roleValues,
        packageName: input.packageName
      },
      templatedValues: template.values
    });
    if (!isMonoRepo) {
      await fs__default.default.writeJson(
        path.resolve(targetDir, "tsconfig.json"),
        {
          extends: "@backstage/cli/config/tsconfig.json",
          include: ["src", "dev", "migrations"],
          exclude: ["node_modules"],
          compilerOptions: {
            outDir: "dist-types",
            rootDir: "."
          }
        },
        { spaces: 2 }
      );
    }
    for (const file of template.files) {
      const destPath = path.resolve(targetDir, file.path);
      await fs__default.default.ensureDir(path.dirname(destPath));
      let content = file.syntax === "handlebars" ? templater.template(file.content) : file.content;
      if (file.path === "package.json") {
        try {
          content = injectPackageJsonInput(input, content);
        } catch (error) {
          throw new errors.ForwardedError(
            "Failed to transform templated package.json",
            error
          );
        }
      }
      await fs__default.default.writeFile(destPath, content).catch((error) => {
        throw new errors.ForwardedError(`Failed to copy file to ${destPath}`, error);
      });
    }
    return { targetDir };
  } catch (error) {
    await fs__default.default.rm(targetDir, { recursive: true, force: true, maxRetries: 10 });
    throw error;
  }
}
function injectPackageJsonInput(input, content) {
  const pkgJson = JSON.parse(content);
  const toAdd = new Array();
  if (pkgJson.version) {
    pkgJson.version = input.version;
  } else {
    toAdd.push(["version", input.version]);
  }
  if (pkgJson.license) {
    pkgJson.license = input.license;
  } else {
    toAdd.push(["license", input.license]);
  }
  if (input.private) {
    if (pkgJson.private === false) {
      pkgJson.private = true;
    } else if (!pkgJson.private) {
      toAdd.push(["private", true]);
    }
  } else {
    delete pkgJson.private;
  }
  if (input.publishRegistry) {
    if (pkgJson.publishConfig) {
      pkgJson.publishConfig = {
        ...pkgJson.publishConfig,
        registry: input.publishRegistry
      };
    } else {
      toAdd.push(["publishConfig", { registry: input.publishRegistry }]);
    }
  }
  const entries = Object.entries(pkgJson);
  const nameIndex = entries.findIndex(([name]) => name === "name");
  if (nameIndex === -1) {
    throw new Error("templated package.json does not contain a name field");
  }
  entries.splice(nameIndex + 1, 0, ...toAdd);
  return JSON.stringify(Object.fromEntries(entries), null, 2);
}

exports.injectPackageJsonInput = injectPackageJsonInput;
exports.writeTemplateContents = writeTemplateContents;
//# sourceMappingURL=writeTemplateContents.cjs.js.map
