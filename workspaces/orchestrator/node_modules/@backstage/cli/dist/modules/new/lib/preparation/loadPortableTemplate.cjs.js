'use strict';

var z = require('zod');
var fs = require('fs-extra');
var recursiveReaddir = require('recursive-readdir');
var path = require('path');
var node_path = require('node:path');
var yaml = require('yaml');
var paths = require('../../../../lib/paths.cjs.js');
var types = require('../types.cjs.js');
var errors = require('@backstage/errors');
var zodValidationError = require('zod-validation-error');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var fs__default = /*#__PURE__*/_interopDefaultCompat(fs);
var recursiveReaddir__default = /*#__PURE__*/_interopDefaultCompat(recursiveReaddir);

const templateDefinitionSchema = z.z.object({
  name: z.z.string(),
  role: z.z.enum(types.TEMPLATE_ROLES),
  description: z.z.string().optional(),
  values: z.z.record(z.z.string()).optional()
}).strict();
async function loadPortableTemplate(pointer) {
  if (pointer.target.match(/https?:\/\//)) {
    throw new Error("Remote templates are not supported yet");
  }
  const templateContent = await fs__default.default.readFile(paths.paths.resolveTargetRoot(pointer.target), "utf-8").catch((error) => {
    throw new errors.ForwardedError(
      `Failed to load template definition from '${pointer.target}'`,
      error
    );
  });
  const rawTemplate = yaml.parse(templateContent);
  const parsed = templateDefinitionSchema.safeParse(rawTemplate);
  if (!parsed.success) {
    throw new errors.ForwardedError(
      `Invalid template definition at '${pointer.target}'`,
      zodValidationError.fromZodError(parsed.error)
    );
  }
  const { role, values = {} } = parsed.data;
  const templatePath = path.resolve(node_path.dirname(pointer.target));
  const filePaths = await recursiveReaddir__default.default(templatePath).catch((error) => {
    throw new errors.ForwardedError(
      `Failed to load template contents from '${templatePath}'`,
      error
    );
  });
  const loadedFiles = new Array();
  for (const filePath of filePaths) {
    const path$1 = path.relative(templatePath, filePath);
    if (filePath === pointer.target) {
      continue;
    }
    const content = await fs__default.default.readFile(filePath, "utf-8").catch((error) => {
      throw new errors.ForwardedError(
        `Failed to load file contents from '${path$1}'`,
        error
      );
    });
    if (path$1.endsWith(".hbs")) {
      loadedFiles.push({
        path: path$1.slice(0, -4),
        content,
        syntax: "handlebars"
      });
    } else {
      loadedFiles.push({ path: path$1, content });
    }
  }
  return {
    name: pointer.name,
    role,
    files: loadedFiles,
    values
  };
}

exports.loadPortableTemplate = loadPortableTemplate;
//# sourceMappingURL=loadPortableTemplate.cjs.js.map
