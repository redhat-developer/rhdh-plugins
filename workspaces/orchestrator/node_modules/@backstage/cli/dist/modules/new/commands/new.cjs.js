'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var createNewPackage = require('../lib/createNewPackage.cjs.js');

var _new = async (opts) => {
  const {
    option: rawArgOptions,
    select: preselectedTemplateId,
    skipInstall,
    scope,
    private: isPrivate,
    ...otherGlobals
  } = opts;
  const prefilledParams = parseParams(rawArgOptions);
  let pluginInfix = void 0;
  let packagePrefix = void 0;
  if (scope) {
    packagePrefix = scope.includes("/") ? `@${scope}` : `@${scope}/`;
    pluginInfix = scope.includes("backstage") ? "plugin-" : "backstage-plugin-";
  }
  if (isPrivate === false || // set to false with --no-private flag
  Object.values(otherGlobals).filter(Boolean).length !== 0) {
    console.warn(
      `Global template configuration via CLI flags is deprecated, see https://backstage.io/docs/cli/new for information on how to configure package templating`
    );
  }
  await createNewPackage.createNewPackage({
    prefilledParams,
    preselectedTemplateId,
    configOverrides: {
      license: otherGlobals.license,
      version: otherGlobals.baseVersion,
      private: isPrivate,
      publishRegistry: otherGlobals.npmRegistry,
      packageNamePrefix: packagePrefix,
      packageNamePluginInfix: pluginInfix
    },
    skipInstall
  });
};
function parseParams(optionStrings) {
  const options = {};
  for (const str of optionStrings) {
    const [key] = str.split("=", 1);
    const value = str.slice(key.length + 1);
    if (!key || str[key.length] !== "=") {
      throw new Error(
        `Invalid option '${str}', must be of the format <key>=<value>`
      );
    }
    options[key] = value;
  }
  return options;
}

exports.default = _new;
//# sourceMappingURL=new.cjs.js.map
