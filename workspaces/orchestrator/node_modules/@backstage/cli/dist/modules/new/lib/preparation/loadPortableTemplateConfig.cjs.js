'use strict';

var fs = require('fs-extra');
var node_path = require('node:path');
var paths = require('../../../../lib/paths.cjs.js');
var defaultTemplates = require('../defaultTemplates.cjs.js');
var types = require('../types.cjs.js');
var yaml = require('yaml');
var z = require('zod');
var zodValidationError = require('zod-validation-error');
var errors = require('@backstage/errors');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var fs__default = /*#__PURE__*/_interopDefaultCompat(fs);

const defaults = {
  license: "Apache-2.0",
  version: "0.1.0",
  private: true,
  publishRegistry: void 0,
  packageNamePrefix: "@internal/",
  packageNamePluginInfix: "plugin-"
};
const newConfigSchema = z.z.object({
  templates: z.z.array(z.z.string()).optional(),
  globals: z.z.object({
    license: z.z.string().optional(),
    version: z.z.string().optional(),
    private: z.z.boolean().optional(),
    publishRegistry: z.z.string().optional(),
    namePrefix: z.z.string().optional(),
    namePluginInfix: z.z.string().optional()
  }).optional()
}).strict();
const pkgJsonWithNewConfigSchema = z.z.object({
  backstage: z.z.object({
    cli: z.z.object({
      new: newConfigSchema.optional()
    }).optional()
  }).optional()
});
async function loadPortableTemplateConfig(options = {}) {
  const { overrides = {} } = options;
  const pkgPath = options.packagePath ?? paths.paths.resolveTargetRoot("package.json");
  const pkgJson = await fs__default.default.readJson(pkgPath);
  const parsed = pkgJsonWithNewConfigSchema.safeParse(pkgJson);
  if (!parsed.success) {
    throw new errors.ForwardedError(
      `Failed to load templating configuration from '${pkgPath}'`,
      zodValidationError.fromZodError(parsed.error)
    );
  }
  const config = parsed.data.backstage?.cli?.new;
  const basePath = node_path.dirname(pkgPath);
  const templatePointerEntries = await Promise.all(
    (config?.templates ?? defaultTemplates.defaultTemplates).map(async (rawPointer) => {
      try {
        const templatePath = resolveLocalTemplatePath(rawPointer, basePath);
        const pointer = await peekLocalTemplateDefinition(templatePath);
        return { pointer, rawPointer };
      } catch (error) {
        throw new errors.ForwardedError(
          `Failed to load template definition '${rawPointer}'`,
          error
        );
      }
    })
  );
  const templateNameConflicts = /* @__PURE__ */ new Map();
  for (const { pointer, rawPointer } of templatePointerEntries) {
    const conflict = templateNameConflicts.get(pointer.name);
    if (conflict) {
      throw new Error(
        `Invalid template configuration, received conflicting template name '${pointer.name}' from '${conflict}' and '${rawPointer}'`
      );
    }
    templateNameConflicts.set(pointer.name, rawPointer);
  }
  return {
    isUsingDefaultTemplates: !config?.templates,
    templatePointers: templatePointerEntries.map(({ pointer }) => pointer),
    license: overrides.license ?? config?.globals?.license ?? defaults.license,
    version: overrides.version ?? config?.globals?.version ?? defaults.version,
    private: overrides.private ?? config?.globals?.private ?? defaults.private,
    publishRegistry: overrides.publishRegistry ?? config?.globals?.publishRegistry ?? defaults.publishRegistry,
    packageNamePrefix: overrides.packageNamePrefix ?? config?.globals?.namePrefix ?? defaults.packageNamePrefix,
    packageNamePluginInfix: overrides.packageNamePluginInfix ?? config?.globals?.namePluginInfix ?? defaults.packageNamePluginInfix
  };
}
function resolveLocalTemplatePath(pointer, basePath) {
  if (node_path.isAbsolute(pointer)) {
    throw new Error(`Template target may not be an absolute path`);
  }
  if (pointer.startsWith(".")) {
    return node_path.resolve(basePath, pointer, types.TEMPLATE_FILE_NAME);
  }
  return require.resolve(`${pointer}/${types.TEMPLATE_FILE_NAME}`, {
    paths: [basePath]
  });
}
const partialTemplateDefinitionSchema = z.z.object({
  name: z.z.string(),
  description: z.z.string().optional()
});
async function peekLocalTemplateDefinition(target) {
  const content = await fs__default.default.readFile(target, "utf8");
  const rawTemplate = yaml.parse(content);
  const parsed = partialTemplateDefinitionSchema.safeParse(rawTemplate);
  if (!parsed.success) {
    throw zodValidationError.fromZodError(parsed.error);
  }
  return {
    name: parsed.data.name,
    description: parsed.data.description,
    target
  };
}

exports.loadPortableTemplateConfig = loadPortableTemplateConfig;
//# sourceMappingURL=loadPortableTemplateConfig.cjs.js.map
