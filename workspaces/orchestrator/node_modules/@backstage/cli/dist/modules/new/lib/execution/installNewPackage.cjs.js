'use strict';

var fs = require('fs-extra');
var upperFirst = require('lodash/upperFirst');
var camelCase = require('lodash/camelCase');
var paths = require('../../../../lib/paths.cjs.js');
var tasks = require('../tasks.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var fs__default = /*#__PURE__*/_interopDefaultCompat(fs);
var upperFirst__default = /*#__PURE__*/_interopDefaultCompat(upperFirst);
var camelCase__default = /*#__PURE__*/_interopDefaultCompat(camelCase);

async function installNewPackage(input) {
  switch (input.roleParams.role) {
    case "web-library":
    case "node-library":
    case "common-library":
    case "plugin-web-library":
    case "plugin-node-library":
    case "plugin-common-library":
      return;
    // No installation action needed for library packages
    case "frontend-plugin":
      await addDependency(input, "packages/app/package.json");
      await tryAddFrontendLegacy(input);
      return;
    case "frontend-plugin-module":
      await addDependency(input, "packages/app/package.json");
      return;
    case "backend-plugin":
      await addDependency(input, "packages/backend/package.json");
      await tryAddBackend(input);
      return;
    case "backend-plugin-module":
      await addDependency(input, "packages/backend/package.json");
      await tryAddBackend(input);
      return;
    default:
      throw new Error(
        `Unsupported role ${input.roleParams.role}`
      );
  }
}
async function addDependency(input, path) {
  const pkgJsonPath = paths.paths.resolveTargetRoot(path);
  const pkgJson = await fs__default.default.readJson(pkgJsonPath).catch((error) => {
    if (error.code === "ENOENT") {
      return void 0;
    }
    throw error;
  });
  if (!pkgJson) {
    return;
  }
  try {
    pkgJson.dependencies = {
      ...pkgJson.dependencies,
      [input.packageName]: `workspace:^`
    };
    await fs__default.default.writeJson(path, pkgJson, { spaces: 2 });
  } catch (error) {
    throw new Error(`Failed to add package dependencies, ${error}`);
  }
}
async function tryAddFrontendLegacy(input) {
  const { roleParams } = input;
  if (roleParams.role !== "frontend-plugin") {
    throw new Error(
      "add-frontend-legacy can only be used for frontend plugins"
    );
  }
  const appDefinitionPath = paths.paths.resolveTargetRoot("packages/app/src/App.tsx");
  if (!await fs__default.default.pathExists(appDefinitionPath)) {
    return;
  }
  await tasks.Task.forItem("app", "adding import", async () => {
    const content = await fs__default.default.readFile(appDefinitionPath, "utf8");
    const revLines = content.split("\n").reverse();
    const lastImportIndex = revLines.findIndex(
      (line) => line.match(/ from ("|').*("|')/)
    );
    const lastRouteIndex = revLines.findIndex(
      (line) => line.match(/<\/FlatRoutes/)
    );
    if (lastImportIndex !== -1 && lastRouteIndex !== -1) {
      const extensionName = upperFirst__default.default(`${camelCase__default.default(roleParams.pluginId)}Page`);
      const importLine = `import { ${extensionName} } from '${input.packageName}';`;
      if (!content.includes(importLine)) {
        revLines.splice(lastImportIndex, 0, importLine);
      }
      const componentLine = `<Route path="/${roleParams.pluginId}" element={<${extensionName} />} />`;
      if (!content.includes(componentLine)) {
        const [indentation] = revLines[lastRouteIndex + 1].match(/^\s*/) ?? [];
        revLines.splice(lastRouteIndex + 1, 0, indentation + componentLine);
      }
      const newContent = revLines.reverse().join("\n");
      await fs__default.default.writeFile(appDefinitionPath, newContent, "utf8");
    }
  });
}
async function tryAddBackend(input) {
  const backendIndexPath = paths.paths.resolveTargetRoot(
    "packages/backend/src/index.ts"
  );
  if (!await fs__default.default.pathExists(backendIndexPath)) {
    return;
  }
  await tasks.Task.forItem("backend", `adding ${input.packageName}`, async () => {
    const content = await fs__default.default.readFile(backendIndexPath, "utf8");
    const lines = content.split("\n");
    const backendAddLine = `backend.add(import('${input.packageName}'));`;
    const backendStartIndex = lines.findIndex(
      (line) => line.match(/backend.start/)
    );
    if (backendStartIndex !== -1) {
      const [indentation] = lines[backendStartIndex].match(/^\s*/);
      lines.splice(backendStartIndex, 0, `${indentation}${backendAddLine}`);
      const newContent = lines.join("\n");
      await fs__default.default.writeFile(backendIndexPath, newContent, "utf8");
    }
  });
}

exports.installNewPackage = installNewPackage;
//# sourceMappingURL=installNewPackage.cjs.js.map
