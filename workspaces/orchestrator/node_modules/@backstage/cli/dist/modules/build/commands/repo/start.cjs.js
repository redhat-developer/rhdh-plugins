'use strict';

var cliNode = require('@backstage/cli-node');
var path = require('path');
var paths = require('../../../../lib/paths.cjs.js');
var resolveLinkedWorkspace = require('../package/start/resolveLinkedWorkspace.cjs.js');
var startPackage = require('../package/start/startPackage.cjs.js');
var util = require('util');

const ACCEPTED_PACKAGE_ROLES = [
  "frontend",
  "backend",
  "frontend-plugin",
  "backend-plugin"
];
async function command(namesOrPaths, options) {
  const targetPackages = await findTargetPackages(namesOrPaths, options.plugin);
  const packageOptions = await resolvePackageOptions(targetPackages, options);
  if (packageOptions.length === 0) {
    console.log("No packages found to start");
    return;
  }
  console.log(
    `Starting ${packageOptions.map(({ pkg }) => pkg.packageJson.name).join(", ")}`
  );
  await Promise.all(packageOptions.map((entry) => startPackage.startPackage(entry.options)));
}
async function findTargetPackages(namesOrPaths, pluginIds) {
  const targetPackages = new Array();
  const packages = await cliNode.PackageGraph.listTargetPackages();
  for (const pluginId of pluginIds) {
    const matchingPackages = packages.filter((pkg) => {
      return pluginId === pkg.packageJson.backstage?.pluginId && ACCEPTED_PACKAGE_ROLES.includes(pkg.packageJson.backstage.role);
    });
    if (matchingPackages.length === 0) {
      throw new Error(
        `Unable to find any plugin packages with plugin ID '${pluginId}'. Make sure backstage.pluginId is set in your package.json files by running 'yarn fix --publish'.`
      );
    }
    targetPackages.push(...matchingPackages);
  }
  if (targetPackages.length > 0) {
    return targetPackages;
  }
  for (const nameOrPath of namesOrPaths) {
    let matchingPackage = packages.find(
      (pkg) => nameOrPath === pkg.packageJson.name
    );
    if (!matchingPackage) {
      const absPath = paths.paths.resolveTargetRoot(nameOrPath);
      matchingPackage = packages.find(
        (pkg) => path.relative(pkg.dir, absPath) === ""
      );
    }
    if (!matchingPackage) {
      throw new Error(`Unable to find package by name '${nameOrPath}'`);
    }
    targetPackages.push(matchingPackage);
  }
  if (targetPackages.length > 0) {
    return targetPackages;
  }
  for (const role of ["frontend", "backend"]) {
    const matchingPackages = packages.filter(
      (pkg) => pkg.packageJson.backstage?.role === role
    );
    if (matchingPackages.length > 1) {
      const expectedPath = paths.paths.resolveTargetRoot(
        role === "frontend" ? "packages/app" : "packages/backend"
      );
      const matchByPath = matchingPackages.find(
        (pkg) => path.relative(expectedPath, pkg.dir) === ""
      );
      if (matchByPath) {
        targetPackages.push(matchByPath);
        continue;
      }
      throw new Error(
        `Found multiple packages with role '${role}' but none of the use the default path '${expectedPath}',choose which packages you want to run by passing the package names explicitly as arguments, for example 'yarn backstage-cli repo start my-app my-backend'.`
      );
    }
    targetPackages.push(...matchingPackages);
  }
  if (targetPackages.length > 0) {
    return targetPackages;
  }
  for (const role of ["frontend-plugin", "backend-plugin"]) {
    const matchingPackages = packages.filter(
      (pkg) => pkg.packageJson.backstage?.role === role
    );
    if (matchingPackages.length > 1) {
      throw new Error(
        `Found multiple packages with role '${role}', please choose which packages you want to run by passing the package names explicitly as arguments, for example 'yarn backstage-cli repo start my-plugin my-plugin-backend'.`
      );
    }
    targetPackages.push(...matchingPackages);
  }
  if (targetPackages.length > 0) {
    return targetPackages;
  }
  throw new Error(
    `Unable to find any packages with role 'frontend', 'backend', 'frontend-plugin', or 'backend-plugin'.`
  );
}
async function resolvePackageOptions(targetPackages, options) {
  const linkedWorkspace = await resolveLinkedWorkspace.resolveLinkedWorkspace(options.link);
  return targetPackages.flatMap((pkg) => {
    const startScript = pkg.packageJson.scripts?.start;
    if (!startScript) {
      console.log(
        `No start script found for package ${pkg.packageJson.name}, skipping...`
      );
      return [];
    }
    const { values: parsedOpts } = util.parseArgs({
      args: startScript.split(" "),
      strict: false,
      options: {
        config: {
          type: "string",
          multiple: true
        },
        require: {
          type: "string"
        }
      }
    });
    const parsedRequire = typeof parsedOpts.require === "string" ? parsedOpts.require : void 0;
    const parsedConfig = parsedOpts.config?.filter((c) => typeof c === "string") ?? [];
    return [
      {
        pkg,
        options: {
          role: pkg.packageJson.backstage?.role,
          targetDir: pkg.dir,
          configPaths: options.config.length > 0 ? options.config : parsedConfig,
          checksEnabled: false,
          linkedWorkspace,
          inspectEnabled: options.inspect,
          inspectBrkEnabled: options.inspectBrk,
          require: options.require ?? parsedRequire
        }
      }
    ];
  });
}

exports.command = command;
exports.findTargetPackages = findTargetPackages;
//# sourceMappingURL=start.cjs.js.map
