'use strict';

var chalk = require('chalk');
var fs = require('fs-extra');
var path = require('path');
var commonjs = require('@rollup/plugin-commonjs');
var resolve = require('@rollup/plugin-node-resolve');
var postcss = require('rollup-plugin-postcss');
var esbuild = require('rollup-plugin-esbuild');
var dts = require('rollup-plugin-dts');
var json = require('@rollup/plugin-json');
var yaml = require('@rollup/plugin-yaml');
var plugins = require('./plugins.cjs.js');
var types = require('./types.cjs.js');
var paths = require('../../../../lib/paths.cjs.js');
var entryPoints = require('../../../../lib/entryPoints.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var chalk__default = /*#__PURE__*/_interopDefaultCompat(chalk);
var fs__default = /*#__PURE__*/_interopDefaultCompat(fs);
var commonjs__default = /*#__PURE__*/_interopDefaultCompat(commonjs);
var resolve__default = /*#__PURE__*/_interopDefaultCompat(resolve);
var postcss__default = /*#__PURE__*/_interopDefaultCompat(postcss);
var esbuild__default = /*#__PURE__*/_interopDefaultCompat(esbuild);
var dts__default = /*#__PURE__*/_interopDefaultCompat(dts);
var json__default = /*#__PURE__*/_interopDefaultCompat(json);
var yaml__default = /*#__PURE__*/_interopDefaultCompat(yaml);

const SCRIPT_EXTS = [".js", ".jsx", ".ts", ".tsx"];
const MODULE_EXTS = [".mjs", ".mts"];
const COMMONJS_EXTS = [".cjs", ".cts"];
const MOD_EXT = ".mjs";
const CJS_EXT = ".cjs";
const CJS_JS_EXT = ".cjs.js";
function isFileImport(source) {
  if (source.startsWith(".")) {
    return true;
  }
  if (source.startsWith("/")) {
    return true;
  }
  if (source.match(/[a-z]:/i)) {
    return true;
  }
  return false;
}
function buildInternalImportPattern(options) {
  const inlinedPackages = options.workspacePackages.filter(
    (pkg) => pkg.packageJson.backstage?.inline
  );
  for (const { packageJson } of inlinedPackages) {
    if (!packageJson.private) {
      throw new Error(
        `Inlined package ${packageJson.name} must be marked as private`
      );
    }
  }
  const names = inlinedPackages.map((pkg) => pkg.packageJson.name);
  return new RegExp(`^(?:${names.join("|")})(?:$|/)`);
}
function multiOutputFormat() {
  return {
    name: "backstage-multi-output-format",
    generateBundle(opts, bundle) {
      const filter = opts.format === "cjs" ? (s) => s.endsWith(MOD_EXT) : (s) => !s.endsWith(MOD_EXT);
      for (const name in bundle) {
        if (filter(name)) {
          delete bundle[name];
          delete bundle[`${name}.map`];
        }
      }
    },
    renderDynamicImport(opts) {
      if (opts.format === "cjs") {
        return {
          left: "import(",
          right: ")"
        };
      }
      return void 0;
    }
  };
}
async function makeRollupConfigs(options) {
  const configs = new Array();
  const targetDir = options.targetDir ?? paths.paths.targetDir;
  let targetPkg = options.packageJson;
  if (!targetPkg) {
    const packagePath = path.resolve(targetDir, "package.json");
    targetPkg = await fs__default.default.readJson(packagePath);
  }
  const onwarn = ({ code, message }) => {
    if (code === "EMPTY_BUNDLE") {
      return;
    }
    if (options.logPrefix) {
      console.log(options.logPrefix + message);
    } else {
      console.log(message);
    }
  };
  const distDir = path.resolve(targetDir, "dist");
  const entryPoints$1 = entryPoints.readEntryPoints(targetPkg);
  const scriptEntryPoints = entryPoints$1.filter(
    (e) => SCRIPT_EXTS.includes(e.ext)
  );
  const internalImportPattern = buildInternalImportPattern(options);
  const external = (source, importer, isResolved) => Boolean(
    importer && !isResolved && !internalImportPattern.test(source) && !isFileImport(source)
  );
  if (options.outputs.has(types.Output.cjs) || options.outputs.has(types.Output.esm)) {
    const output = new Array();
    const mainFields = ["module", "main"];
    const rewriteNodeModules = (name) => name.replaceAll("node_modules", "node_modules_dist");
    if (options.outputs.has(types.Output.cjs)) {
      const defaultExt = targetPkg.type === "module" ? MOD_EXT : CJS_JS_EXT;
      const outputOpts = {
        dir: distDir,
        entryFileNames(chunkInfo) {
          const cleanName = rewriteNodeModules(chunkInfo.name);
          const inputId = chunkInfo.facadeModuleId;
          if (!inputId) {
            return cleanName + defaultExt;
          }
          const inputExt = path.extname(inputId);
          if (MODULE_EXTS.includes(inputExt)) {
            return cleanName + MOD_EXT;
          }
          if (COMMONJS_EXTS.includes(inputExt)) {
            return cleanName + CJS_EXT;
          }
          return cleanName + defaultExt;
        },
        sourcemap: true,
        preserveModules: true,
        preserveModulesRoot: `${targetDir}/src`,
        interop: "compat",
        exports: "named",
        plugins: [multiOutputFormat()]
      };
      output.push({
        ...outputOpts,
        format: "cjs"
      });
      output.push({
        ...outputOpts,
        format: "module"
      });
    }
    if (options.outputs.has(types.Output.esm)) {
      output.push({
        dir: distDir,
        entryFileNames: (chunkInfo) => `${rewriteNodeModules(chunkInfo.name)}.esm.js`,
        chunkFileNames: `esm/[name]-[hash].esm.js`,
        format: "module",
        sourcemap: true,
        preserveModules: true,
        preserveModulesRoot: `${targetDir}/src`
      });
      mainFields.unshift("browser");
    }
    configs.push({
      input: Object.fromEntries(
        scriptEntryPoints.map((e) => [e.name, path.resolve(targetDir, e.path)])
      ),
      output,
      onwarn,
      makeAbsoluteExternalsRelative: false,
      preserveEntrySignatures: "strict",
      // All module imports are always marked as external
      external,
      plugins: [
        resolve__default.default({
          mainFields,
          extensions: SCRIPT_EXTS
        }),
        commonjs__default.default({
          include: /node_modules/,
          exclude: [/\/[^/]+\.(?:stories|test)\.[^/]+$/]
        }),
        postcss__default.default(),
        plugins.forwardFileImports({
          exclude: /\.icon\.svg$/,
          include: [
            /\.svg$/,
            /\.png$/,
            /\.gif$/,
            /\.jpg$/,
            /\.jpeg$/,
            /\.webp$/,
            /\.eot$/,
            /\.woff$/,
            /\.woff2$/,
            /\.ttf$/,
            /\.md$/
          ]
        }),
        json__default.default(),
        yaml__default.default(),
        esbuild__default.default({
          target: "ES2022",
          minify: options.minify
        })
      ]
    });
  }
  if (options.outputs.has(types.Output.types)) {
    const input = Object.fromEntries(
      scriptEntryPoints.map((e) => [
        e.name,
        paths.paths.resolveTargetRoot(
          "dist-types",
          path.relative(paths.paths.targetRoot, targetDir),
          e.path.replace(/\.(?:ts|tsx)$/, ".d.ts")
        )
      ])
    );
    for (const path$1 of Object.values(input)) {
      const declarationsExist = await fs__default.default.pathExists(path$1);
      if (!declarationsExist) {
        const declarationPath = path.relative(targetDir, path$1);
        throw new Error(
          `No declaration files found at ${declarationPath}, be sure to run ${chalk__default.default.bgRed.white(
            "yarn tsc"
          )} to generate .d.ts files before packaging`
        );
      }
    }
    configs.push({
      input,
      output: {
        dir: distDir,
        entryFileNames: `[name].d.ts`,
        chunkFileNames: `types/[name]-[hash].d.ts`,
        format: "es"
      },
      external: (source, importer, isResolved) => /\.css|scss|sass|svg|eot|woff|woff2|ttf$/.test(source) || external(source, importer, isResolved),
      onwarn,
      plugins: [dts__default.default({ respectExternal: true })]
    });
  }
  return configs;
}

exports.makeRollupConfigs = makeRollupConfigs;
//# sourceMappingURL=config.cjs.js.map
