'use strict';

var chalk = require('chalk');
var fs = require('fs-extra');
var path = require('path');
var openBrowser = require('react-dev-utils/openBrowser');
var core = require('@rspack/core');
var devServer = require('@rspack/dev-server');
var paths$1 = require('../../../../lib/paths.cjs.js');
var config = require('../../../config/lib/config.cjs.js');
var config$1 = require('./config.cjs.js');
var packageDetection = require('./packageDetection.cjs.js');
var paths = require('./paths.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var chalk__default = /*#__PURE__*/_interopDefaultCompat(chalk);
var fs__default = /*#__PURE__*/_interopDefaultCompat(fs);
var openBrowser__default = /*#__PURE__*/_interopDefaultCompat(openBrowser);

async function serveBundle(options) {
  const paths$2 = paths.resolveBundlingPaths(options);
  const targetPkg = await fs__default.default.readJson(paths$2.targetPackageJson);
  if (options.verifyVersions) {
    if (targetPkg.dependencies?.["react-router"]?.includes("beta") || targetPkg.dependencies?.["react-router-dom"]?.includes("beta")) {
      console.warn(
        chalk__default.default.yellow(`
DEPRECATION WARNING: React Router Beta is deprecated and support for it will be removed in a future release.
                     Please migrate to use React Router v6 stable.
                     See https://backstage.io/docs/tutorials/react-router-stable-migration
`)
      );
    }
  }
  checkReactVersion();
  const { name } = await fs__default.default.readJson(
    path.resolve(options.targetDir ?? paths$1.paths.targetDir, "package.json")
  );
  let devServer$1 = void 0;
  let latestFrontendAppConfigs = [];
  const triggerReload = () => {
    if (devServer$1) {
      devServer$1.invalidate();
      if (!process.env.LEGACY_WEBPACK_BUILD) {
        devServer$1.sendMessage(
          devServer$1.webSocketServer?.clients ?? [],
          "static-changed"
        );
      }
    }
  };
  const cliConfig = await config.loadCliConfig({
    args: options.configPaths,
    targetDir: options.targetDir,
    fromPackage: name,
    withFilteredKeys: true,
    watch(appConfigs) {
      latestFrontendAppConfigs = appConfigs;
      triggerReload();
    }
  });
  latestFrontendAppConfigs = cliConfig.frontendAppConfigs;
  const appBaseUrl = cliConfig.frontendConfig.getOptionalString("app.baseUrl");
  const backendBaseUrl = cliConfig.frontendConfig.getOptionalString("backend.baseUrl");
  if (appBaseUrl && appBaseUrl === backendBaseUrl) {
    console.log(
      chalk__default.default.yellow(
        `\u26A0\uFE0F   Conflict between app baseUrl and backend baseUrl:

    app.baseUrl:     ${appBaseUrl}
    backend.baseUrl: ${backendBaseUrl}

    Must have unique hostname and/or ports.

    This can be resolved by changing app.baseUrl and backend.baseUrl to point to their respective local development ports.
`
      )
    );
  }
  const { frontendConfig, fullConfig } = cliConfig;
  const url = config$1.resolveBaseUrl(frontendConfig, options.moduleFederation);
  const { host, port } = config$1.resolveEndpoint(
    frontendConfig,
    options.moduleFederation
  );
  const detectedModulesEntryPoint = await packageDetection.createDetectedModulesEntryPoint({
    config: fullConfig,
    targetPath: paths$2.targetPath,
    watch() {
      triggerReload();
    }
  });
  const webpack = process.env.LEGACY_WEBPACK_BUILD ? require("webpack") : void 0;
  const commonConfigOptions = {
    ...options,
    checksEnabled: options.checksEnabled,
    isDev: true,
    baseUrl: url,
    frontendConfig,
    webpack,
    getFrontendAppConfigs: () => {
      return latestFrontendAppConfigs;
    }
  };
  const config$2 = await config$1.createConfig(paths$2, {
    ...commonConfigOptions,
    additionalEntryPoints: detectedModulesEntryPoint,
    moduleFederation: options.moduleFederation
  });
  const bundler = webpack ?? core.rspack;
  const DevServer = webpack ? require("webpack-dev-server") : devServer.RspackDevServer;
  if (webpack) {
    console.log(chalk__default.default.yellow(`\u26A0\uFE0F  WARNING: Using legacy WebPack dev server.`));
  }
  const publicPaths = await paths.resolveOptionalBundlingPaths({
    entry: "src/index-public-experimental",
    dist: "dist/public"
  });
  if (publicPaths) {
    console.log(
      chalk__default.default.yellow(
        `\u26A0\uFE0F  WARNING: The app /public entry point is an experimental feature that may receive immediate breaking changes.`
      )
    );
  }
  const compiler = publicPaths ? bundler([config$2, await config$1.createConfig(publicPaths, commonConfigOptions)]) : bundler(config$2);
  devServer$1 = new DevServer(
    {
      hot: !process.env.CI,
      devMiddleware: {
        publicPath: config$2.output?.publicPath,
        stats: "errors-warnings"
      },
      static: paths$2.targetPublic ? {
        publicPath: config$2.output?.publicPath,
        directory: paths$2.targetPublic
      } : void 0,
      historyApiFallback: options.moduleFederation?.mode === "remote" ? false : {
        // Paths with dots should still use the history fallback.
        // See https://github.com/facebookincubator/create-react-app/issues/387.
        disableDotRule: true,
        // The index needs to be rewritten relative to the new public path, including subroutes.
        index: `${config$2.output?.publicPath}index.html`
      },
      server: url.protocol === "https:" ? {
        type: "https",
        options: {
          cert: fullConfig.getOptionalString(
            "app.https.certificate.cert"
          ),
          key: fullConfig.getOptionalString("app.https.certificate.key")
        }
      } : {},
      host,
      port,
      proxy: targetPkg.proxy,
      // When the dev server is behind a proxy, the host and public hostname differ
      allowedHosts: [url.hostname],
      client: {
        webSocketURL: { hostname: host, port }
      },
      headers: {
        "Access-Control-Allow-Origin": "*",
        "Access-Control-Allow-Methods": "GET, OPTIONS",
        "Access-Control-Allow-Headers": "X-Requested-With, content-type, Authorization"
      }
    },
    compiler
  );
  await new Promise(async (resolve, reject) => {
    if (devServer$1) {
      devServer$1.startCallback((err) => {
        if (err) {
          reject(err);
          return;
        }
        resolve();
      });
    } else {
      resolve();
    }
  });
  if (!options.skipOpenBrowser) {
    openBrowser__default.default(url.href);
  }
  const waitForExit = async () => {
    for (const signal of ["SIGINT", "SIGTERM"]) {
      process.on(signal, () => {
        devServer$1?.stop();
        process.exit();
      });
    }
    return new Promise(() => {
    });
  };
  return waitForExit;
}
function checkReactVersion() {
  try {
    const reactPkgPath = require.resolve("react/package.json", {
      paths: [paths$1.paths.targetRoot]
    });
    const reactPkg = require(reactPkgPath);
    if (reactPkg.version.startsWith("16.")) {
      console.log(
        chalk__default.default.yellow(
          `
\u26A0\uFE0F                                                                           \u26A0\uFE0F
\u26A0\uFE0F You are using React version 16, which is deprecated for use in Backstage. \u26A0\uFE0F
\u26A0\uFE0F Please upgrade to React 17 by updating your packages/app dependencies.    \u26A0\uFE0F
\u26A0\uFE0F                                                                           \u26A0\uFE0F
`
        )
      );
    }
  } catch {
  }
}

exports.serveBundle = serveBundle;
//# sourceMappingURL=server.cjs.js.map
