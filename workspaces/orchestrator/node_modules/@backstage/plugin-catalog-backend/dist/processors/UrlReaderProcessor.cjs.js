'use strict';

var errors = require('@backstage/errors');
var limiterFactory = require('p-limit');
var pluginCatalogNode = require('@backstage/plugin-catalog-node');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var limiterFactory__default = /*#__PURE__*/_interopDefaultCompat(limiterFactory);

const CACHE_KEY = "v1";
class UrlReaderProcessor {
  constructor(options) {
    this.options = options;
    this.#limiter = limiterFactory__default.default(5);
  }
  // This limiter is used for only consuming a limited number of read streams
  // concurrently.
  #limiter;
  getProcessorName() {
    return "url-reader";
  }
  async readLocation(location, optional, emit, parser, cache) {
    if (location.type !== "url") {
      return false;
    }
    const cacheItem = await cache.get(CACHE_KEY);
    try {
      const { response, etag: newEtag } = await this.doRead(
        location.target,
        cacheItem?.etag
      );
      if (response.length === 0 && !optional) {
        emit(
          pluginCatalogNode.processingResult.notFoundError(
            location,
            `Unable to read ${location.type}, no matching files found for ${location.target}`
          )
        );
      }
      const parseResults = [];
      for (const item of response) {
        for await (const parseResult of parser({
          data: item.data,
          location: { type: location.type, target: item.url }
        })) {
          parseResults.push(parseResult);
          emit(parseResult);
        }
      }
      const isOnlyEntities = parseResults.every((r) => r.type === "entity");
      if (newEtag && isOnlyEntities) {
        await cache.set(CACHE_KEY, {
          etag: newEtag,
          value: parseResults
        });
      }
      emit(pluginCatalogNode.processingResult.refresh(`${location.type}:${location.target}`));
    } catch (error) {
      errors.assertError(error);
      const message = `Unable to read ${location.type}, ${error}`.substring(
        0,
        5e3
      );
      if (error.name === "NotModifiedError" && cacheItem) {
        for (const parseResult of cacheItem.value) {
          emit(parseResult);
        }
        emit(pluginCatalogNode.processingResult.refresh(`${location.type}:${location.target}`));
        await cache.set(CACHE_KEY, cacheItem);
      } else if (error.name === "NotFoundError") {
        if (!optional) {
          emit(pluginCatalogNode.processingResult.notFoundError(location, message));
        }
      } else {
        emit(pluginCatalogNode.processingResult.generalError(location, message));
      }
    }
    return true;
  }
  async doRead(location, etag) {
    const response = await this.options.reader.search(location, { etag });
    const output = response.files.map(async (file) => ({
      url: file.url,
      data: await this.#limiter(file.content)
    }));
    return { response: await Promise.all(output), etag: response.etag };
  }
}

exports.UrlReaderProcessor = UrlReaderProcessor;
//# sourceMappingURL=UrlReaderProcessor.cjs.js.map
