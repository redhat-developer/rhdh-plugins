{"version":3,"file":"DefaultCatalogProcessingOrchestrator.cjs.js","sources":["../../src/processing/DefaultCatalogProcessingOrchestrator.ts"],"sourcesContent":["/*\n * Copyright 2021 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Span, trace } from '@opentelemetry/api';\nimport {\n  Entity,\n  EntityPolicy,\n  LocationEntity,\n  parseLocationRef,\n  stringifyEntityRef,\n  stringifyLocationRef,\n} from '@backstage/catalog-model';\nimport {\n  assertError,\n  ConflictError,\n  InputError,\n  NotAllowedError,\n} from '@backstage/errors';\nimport { JsonValue } from '@backstage/types';\nimport { ScmIntegrationRegistry } from '@backstage/integration';\nimport path from 'path';\nimport { LocationSpec } from '@backstage/plugin-catalog-common';\nimport {\n  CatalogProcessor,\n  CatalogProcessorParser,\n  processingResult,\n} from '@backstage/plugin-catalog-node';\nimport {\n  CatalogProcessingOrchestrator,\n  EntityProcessingRequest,\n  EntityProcessingResult,\n} from './types';\nimport { ProcessorOutputCollector } from './ProcessorOutputCollector';\nimport {\n  getEntityLocationRef,\n  getEntityOriginLocationRef,\n  isLocationEntity,\n  isObject,\n  toAbsoluteUrl,\n  validateEntity,\n  validateEntityEnvelope,\n} from './util';\nimport { CatalogRulesEnforcer } from '../ingestion/CatalogRules';\nimport { ProcessorCacheManager } from './ProcessorCacheManager';\nimport {\n  addEntityAttributes,\n  TRACER_ID,\n  withActiveSpan,\n} from '../util/opentelemetry';\nimport { LoggerService } from '@backstage/backend-plugin-api';\n\nconst tracer = trace.getTracer(TRACER_ID);\n\ntype Context = {\n  entityRef: string;\n  location: LocationSpec;\n  originLocation: LocationSpec;\n  collector: ProcessorOutputCollector;\n  cache: ProcessorCacheManager;\n};\n\nfunction addProcessorAttributes(\n  span: Span,\n  stage: string,\n  processor: CatalogProcessor,\n) {\n  span.setAttribute('backstage.catalog.processor.stage', stage);\n  span.setAttribute(\n    'backstage.catalog.processor.name',\n    processor.getProcessorName(),\n  );\n}\n\nexport class DefaultCatalogProcessingOrchestrator\n  implements CatalogProcessingOrchestrator\n{\n  constructor(\n    private readonly options: {\n      processors: CatalogProcessor[];\n      integrations: ScmIntegrationRegistry;\n      logger: LoggerService;\n      parser: CatalogProcessorParser;\n      policy: EntityPolicy;\n      rulesEnforcer: CatalogRulesEnforcer;\n      legacySingleProcessorValidation: boolean;\n    },\n  ) {}\n\n  async process(\n    request: EntityProcessingRequest,\n  ): Promise<EntityProcessingResult> {\n    return this.processSingleEntity(request.entity, request.state);\n  }\n\n  private async processSingleEntity(\n    unprocessedEntity: Entity,\n    state: JsonValue | undefined,\n  ): Promise<EntityProcessingResult> {\n    const collector = new ProcessorOutputCollector(\n      this.options.logger,\n      unprocessedEntity,\n    );\n\n    // Cache that is scoped to the entity and processor\n    const cache = new ProcessorCacheManager(\n      isObject(state) && isObject(state.cache) ? state.cache : {},\n    );\n\n    try {\n      // This will be checked and mutated step by step below\n      let entity: Entity = unprocessedEntity;\n\n      // NOTE: At this early point, we can only rely on the envelope having to\n      // be valid; full entity + kind validation happens after the (potentially\n      // mutative) pre-steps. This means that the code below can't make a lot\n      // of assumptions about the data despite it using the Entity type.\n      try {\n        validateEntityEnvelope(entity);\n      } catch (e) {\n        throw new InputError(\n          `Entity envelope failed validation before processing`,\n          e,\n        );\n      }\n\n      // TODO: which one do we actually use for the location?\n      // source-location? - maybe probably doesn't exist yet?\n      const context: Context = {\n        entityRef: stringifyEntityRef(entity),\n        location: parseLocationRef(getEntityLocationRef(entity)),\n        originLocation: parseLocationRef(getEntityOriginLocationRef(entity)),\n        cache,\n        collector,\n      };\n\n      // Run the steps\n      entity = await this.runPreProcessStep(entity, context);\n      entity = await this.runPolicyStep(entity);\n      await this.runValidateStep(entity, context);\n      if (isLocationEntity(entity)) {\n        await this.runSpecialLocationStep(entity, context);\n      }\n      entity = await this.runPostProcessStep(entity, context);\n\n      // Check that any emitted entities are permitted to originate from that\n      // particular location according to the catalog rules\n      const collectorResults = context.collector.results();\n      for (const deferredEntity of collectorResults.deferredEntities) {\n        if (\n          !this.options.rulesEnforcer.isAllowed(\n            deferredEntity.entity,\n            context.originLocation,\n          )\n        ) {\n          throw new NotAllowedError(\n            `Entity ${stringifyEntityRef(\n              deferredEntity.entity,\n            )} at ${stringifyLocationRef(\n              context.location,\n            )}, originated at ${stringifyLocationRef(\n              context.originLocation,\n            )}, is not of an allowed kind for that location`,\n          );\n        }\n      }\n\n      return {\n        ...collectorResults,\n        completedEntity: entity,\n        state: { cache: cache.collect() },\n        ok: collectorResults.errors.length === 0,\n      };\n    } catch (error) {\n      assertError(error);\n      return {\n        ok: false,\n        errors: collector.results().errors.concat(error),\n      };\n    }\n  }\n\n  // Pre-process phase, used to populate entities with data that is required\n  // during the main processing step\n  private async runPreProcessStep(\n    entity: Entity,\n    context: Context,\n  ): Promise<Entity> {\n    return await withActiveSpan(tracer, 'ProcessingStage', async stageSpan => {\n      addEntityAttributes(stageSpan, entity);\n      stageSpan.setAttribute('backstage.catalog.processor.stage', 'preProcess');\n      let res = entity;\n\n      for (const processor of this.options.processors) {\n        if (processor.preProcessEntity) {\n          let innerRes = res;\n          res = await withActiveSpan(tracer, 'ProcessingStep', async span => {\n            addEntityAttributes(span, entity);\n            addProcessorAttributes(span, 'preProcessEntity', processor);\n            try {\n              innerRes = await processor.preProcessEntity!(\n                innerRes,\n                context.location,\n                context.collector.forProcessor(processor),\n                context.originLocation,\n                context.cache.forProcessor(processor),\n              );\n            } catch (e) {\n              throw new InputError(\n                `Processor ${processor.constructor.name} threw an error while preprocessing`,\n                e,\n              );\n            }\n            return innerRes;\n          });\n        }\n      }\n\n      return res;\n    });\n  }\n\n  /**\n   * Enforce entity policies making sure that entities conform to a general schema\n   */\n  private async runPolicyStep(entity: Entity): Promise<Entity> {\n    return await withActiveSpan(tracer, 'ProcessingStage', async stageSpan => {\n      addEntityAttributes(stageSpan, entity);\n      stageSpan.setAttribute(\n        'backstage.catalog.processor.stage',\n        'enforcePolicy',\n      );\n      let policyEnforcedEntity: Entity | undefined;\n\n      try {\n        policyEnforcedEntity = await this.options.policy.enforce(entity);\n      } catch (e) {\n        throw new InputError(\n          `Policy check failed for ${stringifyEntityRef(entity)}`,\n          e,\n        );\n      }\n\n      if (!policyEnforcedEntity) {\n        throw new Error(\n          `Policy unexpectedly returned no data for ${stringifyEntityRef(\n            entity,\n          )}`,\n        );\n      }\n\n      return policyEnforcedEntity;\n    });\n  }\n\n  /**\n   * Validate the given entity\n   */\n  private async runValidateStep(\n    entity: Entity,\n    context: Context,\n  ): Promise<void> {\n    return await withActiveSpan(tracer, 'ProcessingStage', async stageSpan => {\n      addEntityAttributes(stageSpan, entity);\n      stageSpan.setAttribute('backstage.catalog.processor.stage', 'validate');\n      // Double check that none of the previous steps tried to change something\n      // related to the entity ref, which would break downstream\n      if (stringifyEntityRef(entity) !== context.entityRef) {\n        throw new ConflictError(\n          'Fatal: The entity kind, namespace, or name changed during processing',\n        );\n      }\n\n      // Validate that the end result is a valid Entity at all\n      try {\n        validateEntity(entity);\n      } catch (e) {\n        throw new ConflictError(\n          `Entity envelope for ${context.entityRef} failed validation after preprocessing`,\n          e,\n        );\n      }\n\n      let valid = false;\n\n      for (const processor of this.options.processors) {\n        if (processor.validateEntityKind) {\n          try {\n            const thisValid = await withActiveSpan(\n              tracer,\n              'ProcessingStep',\n              async span => {\n                addEntityAttributes(span, entity);\n                addProcessorAttributes(span, 'validateEntityKind', processor);\n                return await processor.validateEntityKind!(entity);\n              },\n            );\n            if (thisValid) {\n              valid = true;\n              if (this.options.legacySingleProcessorValidation) {\n                break;\n              }\n            }\n          } catch (e) {\n            throw new InputError(\n              `Processor ${processor.constructor.name} threw an error while validating the entity ${context.entityRef}`,\n              e,\n            );\n          }\n        }\n      }\n\n      if (!valid) {\n        throw new InputError(\n          `No processor recognized the entity ${context.entityRef} as valid, possibly caused by a foreign kind or apiVersion`,\n        );\n      }\n    });\n  }\n\n  /**\n   * Backwards compatible processing of location entities\n   */\n  private async runSpecialLocationStep(\n    entity: LocationEntity,\n    context: Context,\n  ): Promise<void> {\n    return await withActiveSpan(tracer, 'ProcessingStage', async stageSpan => {\n      addEntityAttributes(stageSpan, entity);\n      stageSpan.setAttribute(\n        'backstage.catalog.processor.stage',\n        'readLocation',\n      );\n      const { type = context.location.type, presence = 'required' } =\n        entity.spec;\n      const targets = new Array<string>();\n      if (entity.spec.target) {\n        targets.push(entity.spec.target);\n      }\n      if (entity.spec.targets) {\n        targets.push(...entity.spec.targets);\n      }\n\n      for (const maybeRelativeTarget of targets) {\n        if (type === 'file' && maybeRelativeTarget.endsWith(path.sep)) {\n          context.collector.generic()(\n            processingResult.inputError(\n              context.location,\n              `LocationEntityProcessor cannot handle ${type} type location with target ${context.location.target} that ends with a path separator`,\n            ),\n          );\n          continue;\n        }\n        const target = toAbsoluteUrl(\n          this.options.integrations,\n          context.location,\n          type,\n          maybeRelativeTarget,\n        );\n\n        let didRead = false;\n        for (const processor of this.options.processors) {\n          if (processor.readLocation) {\n            try {\n              const read = await withActiveSpan(\n                tracer,\n                'ProcessingStep',\n                async span => {\n                  addEntityAttributes(span, entity);\n                  addProcessorAttributes(span, 'readLocation', processor);\n                  return await processor.readLocation!(\n                    {\n                      type,\n                      target,\n                      presence,\n                    },\n                    presence === 'optional',\n                    context.collector.forProcessor(processor),\n                    this.options.parser,\n                    context.cache.forProcessor(processor, target),\n                  );\n                },\n              );\n              if (read) {\n                didRead = true;\n                break;\n              }\n            } catch (e) {\n              throw new InputError(\n                `Processor ${processor.constructor.name} threw an error while reading ${type}:${target}`,\n                e,\n              );\n            }\n          }\n        }\n        if (!didRead) {\n          throw new InputError(\n            `No processor was able to handle reading of ${type}:${target}`,\n          );\n        }\n      }\n    });\n  }\n\n  /**\n   * Main processing step of the entity\n   */\n  private async runPostProcessStep(\n    entity: Entity,\n    context: Context,\n  ): Promise<Entity> {\n    return await withActiveSpan(tracer, 'ProcessingStage', async stageSpan => {\n      addEntityAttributes(stageSpan, entity);\n      stageSpan.setAttribute(\n        'backstage.catalog.processor.stage',\n        'postProcessEntity',\n      );\n      let res = entity;\n\n      for (const processor of this.options.processors) {\n        if (processor.postProcessEntity) {\n          let innerRes = res;\n          res = await withActiveSpan(tracer, 'ProcessingStep', async span => {\n            addEntityAttributes(span, entity);\n            addProcessorAttributes(span, 'postProcessEntity', processor);\n            try {\n              innerRes = await processor.postProcessEntity!(\n                innerRes,\n                context.location,\n                context.collector.forProcessor(processor),\n                context.cache.forProcessor(processor),\n              );\n            } catch (e) {\n              throw new InputError(\n                `Processor ${processor.constructor.name} threw an error while postprocessing`,\n                e,\n              );\n            }\n            return innerRes;\n          });\n        }\n      }\n\n      return res;\n    });\n  }\n}\n"],"names":["trace","TRACER_ID","ProcessorOutputCollector","ProcessorCacheManager","isObject","validateEntityEnvelope","InputError","stringifyEntityRef","parseLocationRef","getEntityLocationRef","getEntityOriginLocationRef","isLocationEntity","NotAllowedError","stringifyLocationRef","assertError","withActiveSpan","addEntityAttributes","ConflictError","validateEntity","path","processingResult","toAbsoluteUrl"],"mappings":"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"}