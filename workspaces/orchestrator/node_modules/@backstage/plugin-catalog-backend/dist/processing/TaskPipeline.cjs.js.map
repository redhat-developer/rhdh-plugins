{"version":3,"file":"TaskPipeline.cjs.js","sources":["../../src/processing/TaskPipeline.ts"],"sourcesContent":["/*\n * Copyright 2021 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { TRACER_ID, withActiveSpan } from '../util/opentelemetry';\nimport { trace } from '@opentelemetry/api';\n\nconst DEFAULT_POLLING_INTERVAL_MS = 1000;\nconst tracer = trace.getTracer(TRACER_ID);\n\ntype Options<T> = {\n  /**\n   * The callback used to load in new tasks. The number of items returned\n   * in the array must be at most `count` number of items, but may be lower.\n   *\n   * Any error thrown from this method fill be treated as an unhandled rejection.\n   */\n  loadTasks: (count: number) => Promise<Array<T>>;\n\n  /**\n   * The callback used to process a single item.\n   *\n   * Any error thrown from this method fill be treated as an unhandled rejection.\n   */\n  processTask: (item: T) => Promise<void>;\n\n  /**\n   * The target minimum number of items to process in parallel. Once the number\n   * of in-flight tasks reaches this count, more tasks will be loaded in.\n   */\n  lowWatermark: number;\n\n  /**\n   * The maximum number of items to process in parallel.\n   */\n  highWatermark: number;\n\n  /**\n   * The interval at which tasks are polled for in the background when\n   * there aren't enough tasks to load to satisfy the low watermark.\n   *\n   * @default 1000\n   */\n  pollingIntervalMs?: number;\n};\n\n/**\n * Creates a task processing pipeline which continuously loads in tasks to\n * keep the number of parallel in-flight tasks between a low and high watermark.\n *\n * @param options - The options for the pipeline.\n * @returns A stop function which when called halts all processing.\n */\nexport function startTaskPipeline<T>(options: Options<T>) {\n  const {\n    loadTasks,\n    processTask,\n    lowWatermark,\n    highWatermark,\n    pollingIntervalMs = DEFAULT_POLLING_INTERVAL_MS,\n  } = options;\n\n  if (lowWatermark >= highWatermark) {\n    throw new Error('lowWatermark must be lower than highWatermark');\n  }\n\n  // State is in an object so that it can be stably referenced from within\n  // callbacks below\n  const state = { inFlightCount: 0 };\n  const abortController = new AbortController();\n  const abortSignal = abortController.signal;\n\n  const barrier = createBarrier({\n    waitTimeoutMillis: pollingIntervalMs,\n    signal: abortSignal,\n  });\n\n  async function pipelineLoop() {\n    while (!abortSignal.aborted) {\n      if (state.inFlightCount <= lowWatermark) {\n        await withActiveSpan(tracer, 'TaskPipelineLoop', async span => {\n          const loadCount = highWatermark - state.inFlightCount;\n          const loadedItems = await Promise.resolve()\n            .then(() => loadTasks(loadCount))\n            .catch(() => {\n              // Silently swallow errors and go back to sleep to try again; we\n              // delegate to the loadTasks function itself to catch errors and log\n              // if it so desires\n              return [];\n            });\n          span.setAttribute('itemCount', loadedItems.length);\n          if (loadedItems.length && !abortSignal.aborted) {\n            state.inFlightCount += loadedItems.length;\n            for (const item of loadedItems) {\n              Promise.resolve()\n                .then(() => processTask(item))\n                .catch(() => {\n                  // Silently swallow errors and go back to sleep to try again; we\n                  // delegate to the processTask function itself to catch errors\n                  // and log if it so desires\n                })\n                .finally(() => {\n                  state.inFlightCount -= 1;\n                  barrier.release();\n                });\n            }\n          }\n        });\n      }\n      await barrier.wait();\n    }\n  }\n\n  pipelineLoop().catch(error => {\n    // This should be impossible, but if it did happen, it would signal a\n    // programming error inside the loop (errors should definitely be caught\n    // inside of it). Let's rethrow with more information, and let it be caught\n    // by the process' uncaught exception handler, which will log the occurrence\n    // at a high level.\n    throw new Error(`Unexpected error in processing pipeline loop`, error);\n  });\n\n  return () => {\n    abortController.abort();\n    barrier.destroy();\n  };\n}\n\n/**\n * Creates a barrier with a timeout, that can be awaited or prematurely\n * released either manually or by an abort signal.\n */\nexport function createBarrier(options: {\n  waitTimeoutMillis: number;\n  signal: AbortSignal;\n}): {\n  wait: () => Promise<void>;\n  release: () => void;\n  destroy: () => void;\n} {\n  const { waitTimeoutMillis, signal } = options;\n  const resolvers = new Set<() => void>();\n\n  function wait() {\n    if (signal.aborted || !(waitTimeoutMillis > 0)) {\n      return Promise.resolve();\n    }\n\n    return new Promise<void>(resolve => {\n      const timeoutHandle = setTimeout(done, waitTimeoutMillis);\n\n      function done() {\n        resolvers.delete(done);\n        clearTimeout(timeoutHandle);\n        resolve();\n      }\n\n      resolvers.add(done);\n    });\n  }\n\n  function release() {\n    const resolversToCall = new Set(resolvers);\n    resolvers.clear();\n    for (const resolver of resolversToCall) {\n      resolver();\n    }\n  }\n\n  signal.addEventListener('abort', release);\n\n  return {\n    wait,\n    release,\n    destroy: () => signal.removeEventListener('abort', release),\n  };\n}\n"],"names":["trace","TRACER_ID","withActiveSpan"],"mappings":"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"}