{"version":3,"file":"getDeferredStitchableEntities.cjs.js","sources":["../../../../src/database/operations/stitcher/getDeferredStitchableEntities.ts"],"sourcesContent":["/*\n * Copyright 2023 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { durationToMilliseconds, HumanDuration } from '@backstage/types';\nimport { Knex } from 'knex';\nimport { DateTime } from 'luxon';\nimport { timestampToDateTime } from '../../conversion';\nimport { DbRefreshStateRow } from '../../tables';\n\n// TODO(freben): There is no retry counter or similar. If items start\n// perpetually crashing during stitching, they'll just get silently retried over\n// and over again, for better or worse. This will be visible in metrics though.\n\n/**\n * Finds entities that are marked for deferred stitching.\n *\n * @remarks\n *\n * This assumes that the stitching strategy is set to deferred.\n *\n * They are expected to already have the next_stitch_ticket set (by\n * markForStitching) so that their tickets can be returned with each item.\n *\n * All returned items have their next_stitch_at updated to be moved forward by\n * the given timeout duration. This has the effect that they will be picked up\n * for stitching again in the future, if it hasn't completed by that point for\n * some reason (restarts, crashes, etc).\n */\nexport async function getDeferredStitchableEntities(options: {\n  knex: Knex | Knex.Transaction;\n  batchSize: number;\n  stitchTimeout: HumanDuration;\n}): Promise<\n  Array<{\n    entityRef: string;\n    stitchTicket: string;\n    stitchRequestedAt: DateTime; // the time BEFORE moving it forward by the timeout\n  }>\n> {\n  const { knex, batchSize, stitchTimeout } = options;\n\n  let itemsQuery = knex<DbRefreshStateRow>('refresh_state').select(\n    'entity_ref',\n    'next_stitch_at',\n    'next_stitch_ticket',\n  );\n\n  // This avoids duplication of work because of race conditions and is\n  // also fast because locked rows are ignored rather than blocking.\n  // It's only available in MySQL and PostgreSQL\n  if (['mysql', 'mysql2', 'pg'].includes(knex.client.config.client)) {\n    itemsQuery = itemsQuery.forUpdate().skipLocked();\n  }\n\n  const items = await itemsQuery\n    .whereNotNull('next_stitch_at')\n    .whereNotNull('next_stitch_ticket')\n    .where('next_stitch_at', '<=', knex.fn.now())\n    .orderBy('next_stitch_at', 'asc')\n    .limit(batchSize);\n\n  if (!items.length) {\n    return [];\n  }\n\n  await knex<DbRefreshStateRow>('refresh_state')\n    .whereIn(\n      'entity_ref',\n      items.map(i => i.entity_ref),\n    )\n    // avoid race condition where someone completes a stitch right between these statements\n    .whereNotNull('next_stitch_ticket')\n    .update({\n      next_stitch_at: nowPlus(knex, stitchTimeout),\n    });\n\n  return items.map(i => ({\n    entityRef: i.entity_ref,\n    stitchTicket: i.next_stitch_ticket!,\n    stitchRequestedAt: timestampToDateTime(i.next_stitch_at!),\n  }));\n}\n\nfunction nowPlus(knex: Knex, duration: HumanDuration): Knex.Raw {\n  const seconds = durationToMilliseconds(duration) / 1000;\n  if (knex.client.config.client.includes('sqlite3')) {\n    return knex.raw(`datetime('now', ?)`, [`${seconds} seconds`]);\n  } else if (knex.client.config.client.includes('mysql')) {\n    return knex.raw(`now() + interval ${seconds} second`);\n  }\n  return knex.raw(`now() + interval '${seconds} seconds'`);\n}\n"],"names":["timestampToDateTime","durationToMilliseconds"],"mappings":";;;;;AAyCA,eAAsB,8BAA8B,OAAA,EAUlD;AACA,EAAA,MAAM,EAAE,IAAA,EAAM,SAAA,EAAW,aAAA,EAAc,GAAI,OAAA;AAE3C,EAAA,IAAI,UAAA,GAAa,IAAA,CAAwB,eAAe,CAAA,CAAE,MAAA;AAAA,IACxD,YAAA;AAAA,IACA,gBAAA;AAAA,IACA;AAAA,GACF;AAKA,EAAA,IAAI,CAAC,OAAA,EAAS,QAAA,EAAU,IAAI,CAAA,CAAE,SAAS,IAAA,CAAK,MAAA,CAAO,MAAA,CAAO,MAAM,CAAA,EAAG;AACjE,IAAA,UAAA,GAAa,UAAA,CAAW,SAAA,EAAU,CAAE,UAAA,EAAW;AAAA,EACjD;AAEA,EAAA,MAAM,KAAA,GAAQ,MAAM,UAAA,CACjB,YAAA,CAAa,gBAAgB,CAAA,CAC7B,YAAA,CAAa,oBAAoB,CAAA,CACjC,KAAA,CAAM,gBAAA,EAAkB,MAAM,IAAA,CAAK,EAAA,CAAG,KAAK,CAAA,CAC3C,QAAQ,gBAAA,EAAkB,KAAK,CAAA,CAC/B,KAAA,CAAM,SAAS,CAAA;AAElB,EAAA,IAAI,CAAC,MAAM,MAAA,EAAQ;AACjB,IAAA,OAAO,EAAC;AAAA,EACV;AAEA,EAAA,MAAM,IAAA,CAAwB,eAAe,CAAA,CAC1C,OAAA;AAAA,IACC,YAAA;AAAA,IACA,KAAA,CAAM,GAAA,CAAI,CAAA,CAAA,KAAK,CAAA,CAAE,UAAU;AAAA,GAC7B,CAEC,YAAA,CAAa,oBAAoB,CAAA,CACjC,MAAA,CAAO;AAAA,IACN,cAAA,EAAgB,OAAA,CAAQ,IAAA,EAAM,aAAa;AAAA,GAC5C,CAAA;AAEH,EAAA,OAAO,KAAA,CAAM,IAAI,CAAA,CAAA,MAAM;AAAA,IACrB,WAAW,CAAA,CAAE,UAAA;AAAA,IACb,cAAc,CAAA,CAAE,kBAAA;AAAA,IAChB,iBAAA,EAAmBA,8BAAA,CAAoB,CAAA,CAAE,cAAe;AAAA,GAC1D,CAAE,CAAA;AACJ;AAEA,SAAS,OAAA,CAAQ,MAAY,QAAA,EAAmC;AAC9D,EAAA,MAAM,OAAA,GAAUC,4BAAA,CAAuB,QAAQ,CAAA,GAAI,GAAA;AACnD,EAAA,IAAI,KAAK,MAAA,CAAO,MAAA,CAAO,MAAA,CAAO,QAAA,CAAS,SAAS,CAAA,EAAG;AACjD,IAAA,OAAO,KAAK,GAAA,CAAI,CAAA,kBAAA,CAAA,EAAsB,CAAC,CAAA,EAAG,OAAO,UAAU,CAAC,CAAA;AAAA,EAC9D,WAAW,IAAA,CAAK,MAAA,CAAO,OAAO,MAAA,CAAO,QAAA,CAAS,OAAO,CAAA,EAAG;AACtD,IAAA,OAAO,IAAA,CAAK,GAAA,CAAI,CAAA,iBAAA,EAAoB,OAAO,CAAA,OAAA,CAAS,CAAA;AAAA,EACtD;AACA,EAAA,OAAO,IAAA,CAAK,GAAA,CAAI,CAAA,kBAAA,EAAqB,OAAO,CAAA,SAAA,CAAW,CAAA;AACzD;;;;"}