{"version":3,"file":"updateUnprocessedEntity.cjs.js","sources":["../../../../src/database/operations/refreshState/updateUnprocessedEntity.ts"],"sourcesContent":["/*\n * Copyright 2022 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Entity, stringifyEntityRef } from '@backstage/catalog-model';\nimport { Knex } from 'knex';\nimport { DbRefreshStateRow } from '../../tables';\n\n/**\n * Attempts to update an existing refresh state row, returning true if it was\n * updated and false if there was no entity with a matching ref and location key.\n *\n * Updating the entity will also cause it to be scheduled for immediate processing.\n */\nexport async function updateUnprocessedEntity(options: {\n  tx: Knex | Knex.Transaction;\n  entity: Entity;\n  hash: string;\n  locationKey?: string;\n}): Promise<boolean> {\n  const { tx, entity, hash, locationKey } = options;\n\n  const entityRef = stringifyEntityRef(entity);\n  const serializedEntity = JSON.stringify(entity);\n\n  const refreshResult = await tx<DbRefreshStateRow>('refresh_state')\n    .update({\n      unprocessed_entity: serializedEntity,\n      unprocessed_hash: hash,\n      location_key: locationKey,\n      last_discovery_at: tx.fn.now(),\n      // We only get to this point if a processed entity actually had any changes, or\n      // if an entity provider requested this mutation, meaning that we can safely\n      // bump the deferred entities to the front of the queue for immediate processing.\n      next_update_at: tx.fn.now(),\n    })\n    .where('entity_ref', entityRef)\n    .andWhere(inner => {\n      if (!locationKey) {\n        return inner.whereNull('location_key');\n      }\n      return inner\n        .where('location_key', locationKey)\n        .orWhereNull('location_key');\n    });\n\n  return refreshResult === 1;\n}\n"],"names":["stringifyEntityRef"],"mappings":";;;;AA0BA,eAAsB,wBAAwB,OAAA,EAKzB;AACnB,EAAA,MAAM,EAAE,EAAA,EAAI,MAAA,EAAQ,IAAA,EAAM,aAAY,GAAI,OAAA;AAE1C,EAAA,MAAM,SAAA,GAAYA,gCAAmB,MAAM,CAAA;AAC3C,EAAA,MAAM,gBAAA,GAAmB,IAAA,CAAK,SAAA,CAAU,MAAM,CAAA;AAE9C,EAAA,MAAM,aAAA,GAAgB,MAAM,EAAA,CAAsB,eAAe,EAC9D,MAAA,CAAO;AAAA,IACN,kBAAA,EAAoB,gBAAA;AAAA,IACpB,gBAAA,EAAkB,IAAA;AAAA,IAClB,YAAA,EAAc,WAAA;AAAA,IACd,iBAAA,EAAmB,EAAA,CAAG,EAAA,CAAG,GAAA,EAAI;AAAA;AAAA;AAAA;AAAA,IAI7B,cAAA,EAAgB,EAAA,CAAG,EAAA,CAAG,GAAA;AAAI,GAC3B,CAAA,CACA,KAAA,CAAM,cAAc,SAAS,CAAA,CAC7B,SAAS,CAAA,KAAA,KAAS;AACjB,IAAA,IAAI,CAAC,WAAA,EAAa;AAChB,MAAA,OAAO,KAAA,CAAM,UAAU,cAAc,CAAA;AAAA,IACvC;AACA,IAAA,OAAO,MACJ,KAAA,CAAM,cAAA,EAAgB,WAAW,CAAA,CACjC,YAAY,cAAc,CAAA;AAAA,EAC/B,CAAC,CAAA;AAEH,EAAA,OAAO,aAAA,KAAkB,CAAA;AAC3B;;;;"}