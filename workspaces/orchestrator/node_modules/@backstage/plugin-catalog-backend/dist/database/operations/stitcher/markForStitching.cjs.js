'use strict';

var splitToChunks = require('lodash/chunk');
var uuid = require('uuid');
var errors = require('@backstage/errors');
var promises = require('timers/promises');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var splitToChunks__default = /*#__PURE__*/_interopDefaultCompat(splitToChunks);

const UPDATE_CHUNK_SIZE = 100;
const DEADLOCK_RETRY_ATTEMPTS = 3;
const DEADLOCK_BASE_DELAY_MS = 25;
const POSTGRES_DEADLOCK_SQLSTATE = "40P01";
function isDeadlockError(knex, e) {
  if (knex.client.config.client.includes("pg")) {
    return errors.isError(e) && e.code === POSTGRES_DEADLOCK_SQLSTATE;
  }
  return false;
}
async function markForStitching(options) {
  const entityRefs = sortSplit(options.entityRefs);
  const entityIds = sortSplit(options.entityIds);
  const knex = options.knex;
  const mode = options.strategy.mode;
  if (mode === "immediate") {
    for (const chunk of entityRefs) {
      await knex.table("final_entities").update({
        hash: "force-stitching"
      }).whereIn(
        "entity_id",
        knex("refresh_state").select("entity_id").whereIn("entity_ref", chunk)
      );
      await retryOnDeadlock(async () => {
        await knex.table("refresh_state").update({
          result_hash: "force-stitching",
          next_update_at: knex.fn.now()
        }).whereIn("entity_ref", chunk);
      }, knex);
    }
    for (const chunk of entityIds) {
      await knex.table("final_entities").update({
        hash: "force-stitching"
      }).whereIn("entity_id", chunk);
      await retryOnDeadlock(async () => {
        await knex.table("refresh_state").update({
          result_hash: "force-stitching",
          next_update_at: knex.fn.now()
        }).whereIn("entity_id", chunk);
      }, knex);
    }
  } else if (mode === "deferred") {
    const ticket = uuid.v4();
    for (const chunk of entityRefs) {
      await retryOnDeadlock(async () => {
        await knex("refresh_state").update({
          next_stitch_at: knex.fn.now(),
          next_stitch_ticket: ticket
        }).whereIn("entity_ref", chunk);
      }, knex);
    }
    for (const chunk of entityIds) {
      await retryOnDeadlock(async () => {
        await knex("refresh_state").update({
          next_stitch_at: knex.fn.now(),
          next_stitch_ticket: ticket
        }).whereIn("entity_id", chunk);
      }, knex);
    }
  } else {
    throw new Error(`Unknown stitching strategy mode ${mode}`);
  }
}
function sortSplit(input) {
  if (!input) {
    return [];
  }
  const array = Array.isArray(input) ? input.slice() : [...input];
  array.sort();
  return splitToChunks__default.default(array, UPDATE_CHUNK_SIZE);
}
async function retryOnDeadlock(fn, knex, retries = DEADLOCK_RETRY_ATTEMPTS, baseMs = DEADLOCK_BASE_DELAY_MS) {
  let attempt = 0;
  for (; ; ) {
    try {
      return await fn();
    } catch (e) {
      if (isDeadlockError(knex, e) && attempt < retries) {
        await promises.setTimeout(baseMs * Math.pow(2, attempt));
        attempt++;
        continue;
      }
      throw e;
    }
  }
}

exports.markForStitching = markForStitching;
//# sourceMappingURL=markForStitching.cjs.js.map
