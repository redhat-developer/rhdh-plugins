{"version":3,"file":"insertUnprocessedEntity.cjs.js","sources":["../../../../src/database/operations/refreshState/insertUnprocessedEntity.ts"],"sourcesContent":["/*\n * Copyright 2022 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Entity, stringifyEntityRef } from '@backstage/catalog-model';\nimport { Knex } from 'knex';\nimport { DbRefreshStateRow } from '../../tables';\nimport { v4 as uuid } from 'uuid';\nimport {\n  LoggerService,\n  isDatabaseConflictError,\n} from '@backstage/backend-plugin-api';\n\n/**\n * Attempts to insert a new refresh state row for the given entity, returning\n * true if successful and false if there was a conflict.\n */\nexport async function insertUnprocessedEntity(options: {\n  tx: Knex | Knex.Transaction;\n  entity: Entity;\n  hash: string;\n  locationKey?: string;\n  logger: LoggerService;\n}): Promise<boolean> {\n  const { tx, entity, hash, logger, locationKey } = options;\n\n  const entityRef = stringifyEntityRef(entity);\n  const serializedEntity = JSON.stringify(entity);\n\n  try {\n    let query = tx<DbRefreshStateRow>('refresh_state').insert({\n      entity_id: uuid(),\n      entity_ref: entityRef,\n      unprocessed_entity: serializedEntity,\n      unprocessed_hash: hash,\n      errors: '',\n      location_key: locationKey,\n      next_update_at: tx.fn.now(),\n      last_discovery_at: tx.fn.now(),\n    });\n\n    // TODO(Rugvip): only tested towards MySQL, Postgres and SQLite.\n    // We have to do this because the only way to detect if there was a conflict with\n    // SQLite is to catch the error, while Postgres needs to ignore the conflict to not\n    // break the ongoing transaction.\n    if (tx.client.config.client.includes('pg')) {\n      query = query.onConflict('entity_ref').ignore() as any; // type here does not match runtime\n    }\n\n    // Postgres gives as an object with rowCount, SQLite gives us an array\n    const result: { rowCount?: number; length?: number } = await query;\n    return result.rowCount === 1 || result.length === 1;\n  } catch (error) {\n    // SQLite, or MySQL reached this rather than the rowCount check above\n    if (!isDatabaseConflictError(error)) {\n      throw error;\n    } else {\n      logger.debug(`Unable to insert a new refresh state row, ${error}`);\n      return false;\n    }\n  }\n}\n"],"names":["stringifyEntityRef","uuid","isDatabaseConflictError"],"mappings":";;;;;;AA6BA,eAAsB,wBAAwB,OAAA,EAMzB;AACnB,EAAA,MAAM,EAAE,EAAA,EAAI,MAAA,EAAQ,IAAA,EAAM,MAAA,EAAQ,aAAY,GAAI,OAAA;AAElD,EAAA,MAAM,SAAA,GAAYA,gCAAmB,MAAM,CAAA;AAC3C,EAAA,MAAM,gBAAA,GAAmB,IAAA,CAAK,SAAA,CAAU,MAAM,CAAA;AAE9C,EAAA,IAAI;AACF,IAAA,IAAI,KAAA,GAAQ,EAAA,CAAsB,eAAe,CAAA,CAAE,MAAA,CAAO;AAAA,MACxD,WAAWC,OAAA,EAAK;AAAA,MAChB,UAAA,EAAY,SAAA;AAAA,MACZ,kBAAA,EAAoB,gBAAA;AAAA,MACpB,gBAAA,EAAkB,IAAA;AAAA,MAClB,MAAA,EAAQ,EAAA;AAAA,MACR,YAAA,EAAc,WAAA;AAAA,MACd,cAAA,EAAgB,EAAA,CAAG,EAAA,CAAG,GAAA,EAAI;AAAA,MAC1B,iBAAA,EAAmB,EAAA,CAAG,EAAA,CAAG,GAAA;AAAI,KAC9B,CAAA;AAMD,IAAA,IAAI,GAAG,MAAA,CAAO,MAAA,CAAO,MAAA,CAAO,QAAA,CAAS,IAAI,CAAA,EAAG;AAC1C,MAAA,KAAA,GAAQ,KAAA,CAAM,UAAA,CAAW,YAAY,CAAA,CAAE,MAAA,EAAO;AAAA,IAChD;AAGA,IAAA,MAAM,SAAiD,MAAM,KAAA;AAC7D,IAAA,OAAO,MAAA,CAAO,QAAA,KAAa,CAAA,IAAK,MAAA,CAAO,MAAA,KAAW,CAAA;AAAA,EACpD,SAAS,KAAA,EAAO;AAEd,IAAA,IAAI,CAACC,wCAAA,CAAwB,KAAK,CAAA,EAAG;AACnC,MAAA,MAAM,KAAA;AAAA,IACR,CAAA,MAAO;AACL,MAAA,MAAA,CAAO,KAAA,CAAM,CAAA,0CAAA,EAA6C,KAAK,CAAA,CAAE,CAAA;AACjE,MAAA,OAAO,KAAA;AAAA,IACT;AAAA,EACF;AACF;;;;"}