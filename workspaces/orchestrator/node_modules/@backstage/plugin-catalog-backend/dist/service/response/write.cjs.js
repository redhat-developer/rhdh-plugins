'use strict';

var types = require('@backstage/types');
var errors = require('@backstage/errors');
var process = require('./process.cjs.js');

const JSON_CONTENT_TYPE = "application/json; charset=utf-8";
function writeSingleEntityResponse(res, response, notFoundMessage) {
  if (response.type === "object") {
    if (!response.entities[0]) {
      throw new errors.NotFoundError(notFoundMessage);
    }
    res.json(response.entities[0]);
  } else {
    if (!response.entities[0]) {
      throw new errors.NotFoundError(notFoundMessage);
    }
    res.setHeader("Content-Type", JSON_CONTENT_TYPE);
    res.end(response.entities[0]);
  }
}
async function writeEntitiesResponse(options) {
  const { res, responseWrapper, alwaysUseObjectMode } = options;
  const writer = createResponseDataWriter(res);
  const items = alwaysUseObjectMode ? process.processEntitiesResponseItems(options.items, (e) => e) : options.items;
  if (items.type === "object") {
    res.json(
      responseWrapper ? responseWrapper?.(items.entities) : items.entities
    );
    return;
  }
  res.setHeader("Content-Type", JSON_CONTENT_TYPE);
  let trailing = "";
  if (responseWrapper) {
    const marker = `__MARKER_${Math.random().toString(36).slice(2, 10)}__`;
    const wrapped = JSON.stringify(responseWrapper(marker));
    const parts = wrapped.split(`"${marker}"`);
    if (parts.length !== 2) {
      throw new Error(
        `Entity items response was incorrectly wrapped into ${parts.length} different parts`
      );
    }
    res.write(parts[0], "utf8");
    trailing = parts[1];
  }
  let first = true;
  for (const entity of items.entities) {
    const prefix = first ? "[" : ",";
    first = false;
    if (await writer(prefix + entity) === "closed") {
      return;
    }
  }
  res.end(`${first ? "[" : ""}]${trailing}`);
}
function createResponseDataWriter(res) {
  let drainPromise;
  const closePromise = new Promise((resolve) => {
    function onClose() {
      res.off("drain", onDrain);
      res.off("close", onClose);
      resolve("closed");
    }
    function onDrain() {
      drainPromise?.resolve("ok");
      drainPromise = void 0;
    }
    res.on("drain", onDrain);
    res.on("close", onClose);
  });
  return async (data) => {
    if (drainPromise) {
      throw new Error(
        "Attempted overlapping write while waiting for previous write to drain"
      );
    }
    if (res.write(data, "utf8")) {
      return "ok";
    }
    if (res.closed) {
      return "closed";
    }
    drainPromise = types.createDeferred();
    return Promise.race([drainPromise, closePromise]);
  };
}

exports.createResponseDataWriter = createResponseDataWriter;
exports.writeEntitiesResponse = writeEntitiesResponse;
exports.writeSingleEntityResponse = writeSingleEntityResponse;
//# sourceMappingURL=write.cjs.js.map
