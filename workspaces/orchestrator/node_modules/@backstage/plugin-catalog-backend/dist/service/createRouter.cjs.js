'use strict';

var catalogModel = require('@backstage/catalog-model');
var errors = require('@backstage/errors');
var yn = require('yn');
var zod = require('zod');
var util$1 = require('../processing/util.cjs.js');
var router = require('../schema/openapi/generated/router.cjs.js');
var AuthorizedValidationService = require('./AuthorizedValidationService.cjs.js');
var entitiesBatchRequest = require('./request/entitiesBatchRequest.cjs.js');
var basicEntityFilter = require('./request/basicEntityFilter.cjs.js');
var parseEntityFilterParams = require('./request/parseEntityFilterParams.cjs.js');
var parseEntityTransformParams = require('./request/parseEntityTransformParams.cjs.js');
var parseQueryEntitiesParams = require('./request/parseQueryEntitiesParams.cjs.js');
var parseEntityFacetParams = require('./request/parseEntityFacetParams.cjs.js');
var parseEntityOrderParams = require('./request/parseEntityOrderParams.cjs.js');
var parseEntityPaginationParams = require('./request/parseEntityPaginationParams.cjs.js');
var write = require('./response/write.cjs.js');
var createEntityArrayJsonStream = require('./response/createEntityArrayJsonStream.cjs.js');
var util = require('./util.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var yn__default = /*#__PURE__*/_interopDefaultCompat(yn);

async function createRouter(options) {
  const router$1 = await router.createOpenApiRouter({
    validatorOptions: {
      // We want the spec to be up to date with the expected value, but the return type needs
      //  to be controlled by the router implementation not the request validator.
      ignorePaths: /^\/validate-entity\/?$/
    }
  });
  const {
    entitiesCatalog,
    locationAnalyzer,
    locationService,
    orchestrator,
    refreshService,
    config,
    logger,
    permissionIntegrationRouter,
    permissionsService,
    auth,
    httpAuth,
    auditor,
    enableRelationsCompatibility = false
  } = options;
  const readonlyEnabled = config.getOptionalBoolean("catalog.readonly") || false;
  if (readonlyEnabled) {
    logger.info("Catalog is running in readonly mode");
  }
  if (refreshService) {
    router$1.post("/refresh", async (req, res) => {
      const { authorizationToken, ...restBody } = req.body;
      const auditorEvent = await auditor?.createEvent({
        eventId: "entity-mutate",
        severityLevel: "medium",
        meta: {
          queryType: "refresh",
          entityRef: restBody.entityRef
        },
        request: req
      });
      try {
        const credentials = authorizationToken ? await auth.authenticate(authorizationToken) : await httpAuth.credentials(req);
        await refreshService.refresh({
          ...restBody,
          credentials
        });
        await auditorEvent?.success();
        res.status(200).end();
      } catch (err) {
        await auditorEvent?.fail({ error: err });
        throw err;
      }
    });
  }
  if (permissionIntegrationRouter) {
    router$1.use(permissionIntegrationRouter);
  }
  if (entitiesCatalog) {
    router$1.get("/entities", async (req, res) => {
      const auditorEvent = await auditor?.createEvent({
        eventId: "entity-fetch",
        request: req,
        meta: {
          queryType: "all",
          query: req.query
        }
      });
      try {
        const filter = parseEntityFilterParams.parseEntityFilterParams(req.query);
        const fields = parseEntityTransformParams.parseEntityTransformParams(req.query);
        const order = parseEntityOrderParams.parseEntityOrderParams(req.query);
        const pagination = parseEntityPaginationParams.parseEntityPaginationParams(req.query);
        const credentials = await httpAuth.credentials(req);
        if (pagination || enableRelationsCompatibility === true) {
          const { entities, pageInfo } = await entitiesCatalog.entities({
            filter,
            fields,
            order,
            pagination,
            credentials
          });
          if (pageInfo.hasNextPage) {
            const url = new URL(`http://ignored${req.url}`);
            url.searchParams.delete("offset");
            url.searchParams.set("after", pageInfo.endCursor);
            res.setHeader(
              "link",
              `<${url.pathname}${url.search}>; rel="next"`
            );
          }
          await auditorEvent?.success();
          await write.writeEntitiesResponse({
            res,
            items: entities,
            alwaysUseObjectMode: enableRelationsCompatibility
          });
          return;
        }
        const responseStream = createEntityArrayJsonStream.createEntityArrayJsonStream(res);
        const limit = 1e4;
        let cursor;
        try {
          let currentWrite = void 0;
          do {
            const result = await entitiesCatalog.queryEntities(
              !cursor ? {
                credentials,
                fields,
                limit,
                filter,
                orderFields: order,
                skipTotalItems: true
              } : { credentials, fields, limit, cursor }
            );
            if (await currentWrite === "closed") {
              return;
            }
            if (result.items.entities.length) {
              currentWrite = responseStream.send(result.items);
            }
            cursor = result.pageInfo?.nextCursor;
          } while (cursor);
          await currentWrite;
          await auditorEvent?.success();
          responseStream.complete();
        } finally {
          responseStream.close();
        }
      } catch (err) {
        await auditorEvent?.fail({
          error: err
        });
        throw err;
      }
    }).get("/entities/by-query", async (req, res) => {
      const auditorEvent = await auditor?.createEvent({
        eventId: "entity-fetch",
        request: req,
        meta: {
          queryType: "by-query"
        }
      });
      try {
        const { items, pageInfo, totalItems } = await entitiesCatalog.queryEntities({
          limit: req.query.limit,
          offset: req.query.offset,
          ...parseQueryEntitiesParams.parseQueryEntitiesParams(req.query),
          credentials: await httpAuth.credentials(req)
        });
        const meta = {
          totalItems,
          pageInfo: {
            ...pageInfo.nextCursor && {
              nextCursor: util.encodeCursor(pageInfo.nextCursor)
            },
            ...pageInfo.prevCursor && {
              prevCursor: util.encodeCursor(pageInfo.prevCursor)
            }
          }
        };
        await auditorEvent?.success({
          // Let's not log out the entities since this can make the log very big
          meta
        });
        await write.writeEntitiesResponse({
          res,
          items,
          alwaysUseObjectMode: enableRelationsCompatibility,
          responseWrapper: (entities) => ({
            items: entities,
            ...meta
          })
        });
      } catch (err) {
        await auditorEvent?.fail({
          error: err
        });
        throw err;
      }
    }).get("/entities/by-uid/:uid", async (req, res) => {
      const { uid } = req.params;
      const auditorEvent = await auditor?.createEvent({
        eventId: "entity-fetch",
        request: req,
        meta: {
          queryType: "by-uid",
          uid
        }
      });
      try {
        const { entities } = await entitiesCatalog.entities({
          filter: basicEntityFilter.basicEntityFilter({ "metadata.uid": uid }),
          credentials: await httpAuth.credentials(req)
        });
        write.writeSingleEntityResponse(res, entities, `No entity with uid ${uid}`);
        await auditorEvent?.success({
          meta: {
            // stringify to entity refs
            entities: entities.entities.reduce((arr, element) => {
              if (!element) {
                return arr;
              }
              if (typeof element === "string") {
                arr.push(element);
                return arr;
              }
              arr.push(catalogModel.stringifyEntityRef(element));
              return arr;
            }, [])
          }
        });
      } catch (err) {
        await auditorEvent?.fail({
          error: err
        });
        throw err;
      }
    }).delete("/entities/by-uid/:uid", async (req, res) => {
      const { uid } = req.params;
      const auditorEvent = await auditor?.createEvent({
        eventId: "entity-mutate",
        severityLevel: "medium",
        request: req,
        meta: {
          actionType: "delete",
          uid
        }
      });
      try {
        await entitiesCatalog.removeEntityByUid(uid, {
          credentials: await httpAuth.credentials(req)
        });
        await auditorEvent?.success();
        res.status(204).end();
      } catch (err) {
        await auditorEvent?.fail({
          error: err
        });
        throw err;
      }
    }).get("/entities/by-name/:kind/:namespace/:name", async (req, res) => {
      const { kind, namespace, name } = req.params;
      const entityRef = catalogModel.stringifyEntityRef({ kind, namespace, name });
      const auditorEvent = await auditor?.createEvent({
        eventId: "entity-fetch",
        request: req,
        meta: {
          queryType: "by-name",
          entityRef
        }
      });
      try {
        const { items } = await entitiesCatalog.entitiesBatch({
          entityRefs: [catalogModel.stringifyEntityRef({ kind, namespace, name })],
          credentials: await httpAuth.credentials(req)
        });
        await auditorEvent?.success();
        write.writeSingleEntityResponse(
          res,
          items,
          `No entity named '${name}' found, with kind '${kind}' in namespace '${namespace}'`
        );
      } catch (err) {
        await auditorEvent?.fail({
          error: err
        });
        throw err;
      }
    }).get(
      "/entities/by-name/:kind/:namespace/:name/ancestry",
      async (req, res) => {
        const { kind, namespace, name } = req.params;
        const entityRef = catalogModel.stringifyEntityRef({ kind, namespace, name });
        const auditorEvent = await auditor?.createEvent({
          eventId: "entity-fetch",
          request: req,
          meta: {
            actionType: "ancestry",
            entityRef
          }
        });
        try {
          const response = await entitiesCatalog.entityAncestry(entityRef, {
            credentials: await httpAuth.credentials(req)
          });
          await auditorEvent?.success({
            meta: {
              rootEntityRef: response.rootEntityRef,
              ancestry: response.items.map((ancestryLink) => {
                return {
                  entityRef: catalogModel.stringifyEntityRef(ancestryLink.entity),
                  parentEntityRefs: ancestryLink.parentEntityRefs
                };
              })
            }
          });
          res.status(200).json(response);
        } catch (err) {
          await auditorEvent?.fail({
            error: err
          });
          throw err;
        }
      }
    ).post("/entities/by-refs", async (req, res) => {
      const auditorEvent = await auditor?.createEvent({
        eventId: "entity-fetch",
        request: req,
        meta: {
          queryType: "by-refs"
        }
      });
      try {
        const request = entitiesBatchRequest.entitiesBatchRequest(req);
        const { items } = await entitiesCatalog.entitiesBatch({
          entityRefs: request.entityRefs,
          filter: parseEntityFilterParams.parseEntityFilterParams(req.query),
          fields: parseEntityTransformParams.parseEntityTransformParams(req.query, request.fields),
          credentials: await httpAuth.credentials(req)
        });
        await auditorEvent?.success({
          meta: {
            ...request
          }
        });
        await write.writeEntitiesResponse({
          res,
          items,
          alwaysUseObjectMode: enableRelationsCompatibility,
          responseWrapper: (entities) => ({
            items: entities
          })
        });
      } catch (err) {
        await auditorEvent?.fail({
          error: err
        });
        throw err;
      }
    }).get("/entity-facets", async (req, res) => {
      const auditorEvent = await auditor?.createEvent({
        eventId: "entity-facets",
        request: req
      });
      try {
        const response = await entitiesCatalog.facets({
          filter: parseEntityFilterParams.parseEntityFilterParams(req.query),
          facets: parseEntityFacetParams.parseEntityFacetParams(req.query),
          credentials: await httpAuth.credentials(req)
        });
        await auditorEvent?.success();
        res.status(200).json(response);
      } catch (err) {
        await auditorEvent?.fail({
          error: err
        });
        throw err;
      }
    });
  }
  if (locationService) {
    router$1.post("/locations", async (req, res) => {
      const location = await util.validateRequestBody(req, util.locationInput);
      const dryRun = yn__default.default(req.query.dryRun, { default: false });
      const auditorEvent = await auditor?.createEvent({
        eventId: "location-mutate",
        severityLevel: dryRun ? "low" : "medium",
        request: req,
        meta: {
          actionType: "create",
          location,
          isDryRun: dryRun
        }
      });
      try {
        if (!dryRun) {
          util.disallowReadonlyMode(readonlyEnabled);
        }
        const output = await locationService.createLocation(
          location,
          dryRun,
          {
            credentials: await httpAuth.credentials(req)
          }
        );
        await auditorEvent?.success({
          meta: {
            location: output.location
          }
        });
        res.status(201).json(output);
      } catch (err) {
        await auditorEvent?.fail({
          error: err,
          meta: {
            location,
            isDryRun: dryRun
          }
        });
        throw err;
      }
    }).get("/locations", async (req, res) => {
      const auditorEvent = await auditor?.createEvent({
        eventId: "location-fetch",
        request: req,
        meta: {
          queryType: "all"
        }
      });
      try {
        const locations = await locationService.listLocations({
          credentials: await httpAuth.credentials(req)
        });
        await auditorEvent?.success();
        res.status(200).json(locations.map((l) => ({ data: l })));
      } catch (err) {
        await auditorEvent?.fail({
          error: err
        });
        throw err;
      }
    }).get("/locations/:id", async (req, res) => {
      const { id } = req.params;
      const auditorEvent = await auditor?.createEvent({
        eventId: "location-fetch",
        request: req,
        meta: {
          queryType: "by-id",
          id
        }
      });
      try {
        const output = await locationService.getLocation(id, {
          credentials: await httpAuth.credentials(req)
        });
        await auditorEvent?.success({
          meta: {
            output
          }
        });
        res.status(200).json(output);
      } catch (err) {
        await auditorEvent?.fail({
          error: err
        });
        throw err;
      }
    }).delete("/locations/:id", async (req, res) => {
      const { id } = req.params;
      const auditorEvent = await auditor?.createEvent({
        eventId: "location-mutate",
        severityLevel: "medium",
        request: req,
        meta: {
          actionType: "delete",
          id
        }
      });
      util.disallowReadonlyMode(readonlyEnabled);
      try {
        await locationService.deleteLocation(id, {
          credentials: await httpAuth.credentials(req)
        });
        await auditorEvent?.success();
        res.status(204).end();
      } catch (err) {
        await auditorEvent?.fail({
          error: err
        });
        throw err;
      }
    }).get("/locations/by-entity/:kind/:namespace/:name", async (req, res) => {
      const { kind, namespace, name } = req.params;
      const locationRef = `${kind}:${namespace}/${name}`;
      const auditorEvent = await auditor?.createEvent({
        eventId: "location-fetch",
        request: req,
        meta: {
          queryType: "by-entity",
          locationRef
        }
      });
      try {
        const output = await locationService.getLocationByEntity(
          { kind, namespace, name },
          { credentials: await httpAuth.credentials(req) }
        );
        await auditorEvent?.success({
          meta: {
            output
          }
        });
        res.status(200).json(output);
      } catch (err) {
        await auditorEvent?.fail({
          error: err
        });
        throw err;
      }
    });
  }
  if (locationAnalyzer) {
    router$1.post("/analyze-location", async (req, res) => {
      const auditorEvent = await auditor?.createEvent({
        eventId: "location-analyze",
        request: req
      });
      try {
        const body = await util.validateRequestBody(
          req,
          zod.z.object({
            location: util.locationInput,
            catalogFilename: zod.z.string().optional()
          })
        );
        const schema = zod.z.object({
          location: util.locationInput,
          catalogFilename: zod.z.string().optional()
        });
        const credentials = await httpAuth.credentials(req);
        const parsedBody = schema.parse(body);
        try {
          const output = await locationAnalyzer.analyzeLocation(
            parsedBody,
            credentials
          );
          await auditorEvent?.success({
            meta: {
              output
            }
          });
          res.status(200).json(output);
        } catch (err) {
          if (
            // Catch errors from parse-url library.
            err.name === "Error" && "subject_url" in err
          ) {
            throw new errors.InputError("The given location.target is not a URL");
          }
          throw err;
        }
      } catch (err) {
        await auditorEvent?.fail({
          error: err
        });
        throw err;
      }
    });
  }
  if (orchestrator) {
    router$1.post("/validate-entity", async (req, res) => {
      const auditorEvent = await auditor?.createEvent({
        eventId: "entity-validate",
        request: req
      });
      try {
        const bodySchema = zod.z.object({
          entity: zod.z.unknown(),
          location: zod.z.string()
        });
        let body;
        let entity;
        let location;
        try {
          body = await util.validateRequestBody(req, bodySchema);
          entity = util$1.validateEntityEnvelope(body.entity);
          location = catalogModel.parseLocationRef(body.location);
          if (location.type !== "url")
            throw new TypeError(
              `Invalid location ref ${body.location}, only 'url:<target>' is supported, e.g. url:https://host/path`
            );
        } catch (err) {
          await auditorEvent?.fail({
            error: err
          });
          return res.status(400).json({
            errors: [errors.serializeError(err)]
          });
        }
        const credentials = await httpAuth.credentials(req);
        const authorizedValidationService = new AuthorizedValidationService.AuthorizedValidationService(
          orchestrator,
          permissionsService
        );
        const processingResult = await authorizedValidationService.process(
          {
            entity: {
              ...entity,
              metadata: {
                ...entity.metadata,
                annotations: {
                  [catalogModel.ANNOTATION_LOCATION]: body.location,
                  [catalogModel.ANNOTATION_ORIGIN_LOCATION]: body.location,
                  ...entity.metadata.annotations
                }
              }
            }
          },
          credentials
        );
        if (!processingResult.ok) {
          const errors$1 = processingResult.errors.map((e) => errors.serializeError(e));
          await auditorEvent?.fail({
            // TODO(Rugvip): Seems like there aren't proper types for AggregateError yet
            error: AggregateError(errors$1, "Could not validate entity")
          });
          res.status(400).json({
            errors: errors$1
          });
        }
        await auditorEvent?.success();
        return res.status(200).end();
      } catch (err) {
        await auditorEvent?.fail({
          error: err
        });
        throw err;
      }
    });
  }
  return router$1;
}

exports.createRouter = createRouter;
//# sourceMappingURL=createRouter.cjs.js.map
