import * as _backstage_frontend_plugin_api from '@backstage/frontend-plugin-api';
import { RouteRef, ExtensionDefinition } from '@backstage/frontend-plugin-api';
import * as react from 'react';
import { JSX as JSX$1, ReactNode, ComponentType } from 'react';
import { Entity } from '@backstage/catalog-model';
import { IconLinkVerticalProps } from '@backstage/core-components';
import { JsonValue } from '@backstage/types';
import * as _backstage_core_plugin_api_alpha from '@backstage/core-plugin-api/alpha';
import { ResourcePermission } from '@backstage/plugin-permission-common';

/**
 * Returns true if the `owner` argument is a direct owner on the `entity` argument.
 *
 * @alpha
 * @remarks
 *
 * Note that this ownership is not the same as using the claims in the auth-resolver, it only will take into account ownership as expressed by direct entity relations.
 * It doesn't know anything about the additional groups that a user might belong to which the claims contain.
 */
declare function isOwnerOf(owner: Entity, entity: Entity): boolean;

/**
 * Creates Catalog Filter Extensions
 * @alpha
 */
declare const CatalogFilterBlueprint: _backstage_frontend_plugin_api.ExtensionBlueprint<{
    kind: "catalog-filter";
    params: {
        loader: () => Promise<JSX.Element>;
    };
    output: _backstage_frontend_plugin_api.ExtensionDataRef<react.JSX.Element, "core.reactElement", {}>;
    inputs: {};
    config: {};
    configInput: {};
    dataRefs: never;
}>;

/**
 * @alpha
 * Default entity content groups.
 */
declare const defaultEntityContentGroups: {
    overview: string;
    documentation: string;
    development: string;
    deployment: string;
    operation: string;
    observability: string;
};
/** @alpha */
type EntityCardType = 'summary' | 'info' | 'content';

/** @alpha */
type EntityPredicate = EntityPredicateExpression | EntityPredicatePrimitive | {
    $all: EntityPredicate[];
} | {
    $any: EntityPredicate[];
} | {
    $not: EntityPredicate;
};
/** @alpha */
type EntityPredicateExpression = {
    [KPath in string]: EntityPredicateValue;
} & {
    [KPath in `$${string}`]: never;
};
/** @alpha */
type EntityPredicateValue = EntityPredicatePrimitive | {
    $exists: boolean;
} | {
    $in: EntityPredicatePrimitive[];
} | {
    $contains: EntityPredicateExpression;
};
/** @alpha */
type EntityPredicatePrimitive = string | number | boolean;

/**
 * Convert an entity predicate to a filter function that can be used to filter entities.
 * @alpha
 */
declare function entityPredicateToFilterFunction<T extends JsonValue>(entityPredicate: EntityPredicate): (value: T) => boolean;

/**
 * @alpha
 * A blueprint for creating cards for the entity pages in the catalog.
 */
declare const EntityCardBlueprint: _backstage_frontend_plugin_api.ExtensionBlueprint<{
    kind: "entity-card";
    params: {
        loader: () => Promise<JSX.Element>;
        filter?: string | EntityPredicate | ((entity: Entity) => boolean);
        type?: EntityCardType;
    };
    output: _backstage_frontend_plugin_api.ExtensionDataRef<react.JSX.Element, "core.reactElement", {}> | _backstage_frontend_plugin_api.ExtensionDataRef<(entity: Entity) => boolean, "catalog.entity-filter-function", {
        optional: true;
    }> | _backstage_frontend_plugin_api.ExtensionDataRef<string, "catalog.entity-filter-expression", {
        optional: true;
    }> | _backstage_frontend_plugin_api.ExtensionDataRef<EntityCardType, "catalog.entity-card-type", {
        optional: true;
    }>;
    inputs: {};
    config: {
        filter: EntityPredicate | undefined;
        type: "content" | "summary" | "info" | undefined;
    };
    configInput: {
        filter?: EntityPredicate | undefined;
        type?: "content" | "summary" | "info" | undefined;
    };
    dataRefs: {
        filterFunction: _backstage_frontend_plugin_api.ConfigurableExtensionDataRef<(entity: Entity) => boolean, "catalog.entity-filter-function", {}>;
        filterExpression: _backstage_frontend_plugin_api.ConfigurableExtensionDataRef<string, "catalog.entity-filter-expression", {}>;
        type: _backstage_frontend_plugin_api.ConfigurableExtensionDataRef<EntityCardType, "catalog.entity-card-type", {}>;
    };
}>;

/**
 * @alpha
 * Creates an EntityContent extension.
 */
declare const EntityContentBlueprint: _backstage_frontend_plugin_api.ExtensionBlueprint<{
    kind: "entity-content";
    params: {
        /**
         * @deprecated Use the `path` param instead.
         */
        defaultPath?: [Error: `Use the 'path' param instead`];
        path: string;
        /**
         * @deprecated Use the `path` param instead.
         */
        defaultTitle?: [Error: `Use the 'title' param instead`];
        title: string;
        /**
         * @deprecated Use the `path` param instead.
         */
        defaultGroup?: [Error: `Use the 'group' param instead`];
        group?: keyof typeof defaultEntityContentGroups | (string & {});
        loader: () => Promise<JSX.Element>;
        routeRef?: RouteRef;
        filter?: string | EntityPredicate | ((entity: Entity) => boolean);
    };
    output: _backstage_frontend_plugin_api.ExtensionDataRef<string, "core.routing.path", {}> | _backstage_frontend_plugin_api.ExtensionDataRef<react.JSX.Element, "core.reactElement", {}> | _backstage_frontend_plugin_api.ExtensionDataRef<RouteRef<_backstage_frontend_plugin_api.AnyRouteRefParams>, "core.routing.ref", {
        optional: true;
    }> | _backstage_frontend_plugin_api.ExtensionDataRef<(entity: Entity) => boolean, "catalog.entity-filter-function", {
        optional: true;
    }> | _backstage_frontend_plugin_api.ExtensionDataRef<string, "catalog.entity-filter-expression", {
        optional: true;
    }> | _backstage_frontend_plugin_api.ExtensionDataRef<string, "catalog.entity-content-title", {}> | _backstage_frontend_plugin_api.ExtensionDataRef<string, "catalog.entity-content-group", {
        optional: true;
    }>;
    inputs: {};
    config: {
        path: string | undefined;
        title: string | undefined;
        filter: EntityPredicate | undefined;
        group: string | false | undefined;
    };
    configInput: {
        filter?: EntityPredicate | undefined;
        title?: string | undefined;
        path?: string | undefined;
        group?: string | false | undefined;
    };
    dataRefs: {
        title: _backstage_frontend_plugin_api.ConfigurableExtensionDataRef<string, "catalog.entity-content-title", {}>;
        filterFunction: _backstage_frontend_plugin_api.ConfigurableExtensionDataRef<(entity: Entity) => boolean, "catalog.entity-filter-function", {}>;
        filterExpression: _backstage_frontend_plugin_api.ConfigurableExtensionDataRef<string, "catalog.entity-filter-expression", {}>;
        group: _backstage_frontend_plugin_api.ConfigurableExtensionDataRef<string, "catalog.entity-content-group", {}>;
    };
}>;

/** @alpha */
interface EntityContentLayoutProps {
    cards: Array<{
        type?: EntityCardType;
        element: JSX$1.Element;
    }>;
}
/** @alpha */
declare const EntityContentLayoutBlueprint: _backstage_frontend_plugin_api.ExtensionBlueprint<{
    kind: "entity-content-layout";
    params: {
        filter?: string | EntityPredicate | ((entity: Entity) => boolean);
        loader: () => Promise<(props: EntityContentLayoutProps) => JSX$1.Element>;
    };
    output: _backstage_frontend_plugin_api.ExtensionDataRef<(entity: Entity) => boolean, "catalog.entity-filter-function", {
        optional: true;
    }> | _backstage_frontend_plugin_api.ExtensionDataRef<string, "catalog.entity-filter-expression", {
        optional: true;
    }> | _backstage_frontend_plugin_api.ExtensionDataRef<(props: EntityContentLayoutProps) => React.JSX.Element, "catalog.entity-content-layout.component", {}>;
    inputs: {};
    config: {
        type: string | undefined;
        filter: EntityPredicate | undefined;
    };
    configInput: {
        filter?: EntityPredicate | undefined;
        type?: string | undefined;
    };
    dataRefs: {
        filterFunction: _backstage_frontend_plugin_api.ConfigurableExtensionDataRef<(entity: Entity) => boolean, "catalog.entity-filter-function", {}>;
        filterExpression: _backstage_frontend_plugin_api.ConfigurableExtensionDataRef<string, "catalog.entity-filter-expression", {}>;
        component: _backstage_frontend_plugin_api.ConfigurableExtensionDataRef<(props: EntityContentLayoutProps) => React.JSX.Element, "catalog.entity-content-layout.component", {}>;
    };
}>;

/** @alpha */
declare const EntityHeaderBlueprint: _backstage_frontend_plugin_api.ExtensionBlueprint<{
    kind: "entity-header";
    params: {
        loader: () => Promise<JSX.Element>;
        filter?: EntityPredicate | ((entity: Entity) => boolean);
    };
    output: _backstage_frontend_plugin_api.ExtensionDataRef<(entity: Entity) => boolean, "catalog.entity-filter-function", {
        optional: true;
    }> | _backstage_frontend_plugin_api.ExtensionDataRef<string, "catalog.entity-filter-expression", {
        optional: true;
    }> | _backstage_frontend_plugin_api.ExtensionDataRef<react.JSX.Element, "core.reactElement", {
        optional: true;
    }>;
    inputs: {};
    config: {
        filter: EntityPredicate | undefined;
    };
    configInput: {
        filter?: EntityPredicate | undefined;
    };
    dataRefs: {
        filterFunction: _backstage_frontend_plugin_api.ConfigurableExtensionDataRef<(entity: Entity) => boolean, "catalog.entity-filter-function", {}>;
        element: _backstage_frontend_plugin_api.ConfigurableExtensionDataRef<react.JSX.Element, "core.reactElement", {}>;
    };
}>;

/** @alpha */
type UseProps = () => {
    title: ReactNode;
    href: string;
    disabled?: boolean;
} | {
    title: ReactNode;
    onClick: () => void | Promise<void>;
    disabled?: boolean;
};
/** @alpha */
type EntityContextMenuItemParams = {
    useProps: UseProps;
    icon: JSX$1.Element;
    filter?: EntityPredicate | ((entity: Entity) => boolean);
};
/** @alpha */
declare const EntityContextMenuItemBlueprint: _backstage_frontend_plugin_api.ExtensionBlueprint<{
    kind: "entity-context-menu-item";
    params: EntityContextMenuItemParams;
    output: _backstage_frontend_plugin_api.ExtensionDataRef<JSX$1.Element, "core.reactElement", {}> | _backstage_frontend_plugin_api.ExtensionDataRef<(entity: Entity) => boolean, "catalog.entity-filter-function", {
        optional: true;
    }>;
    inputs: {};
    config: {
        filter: EntityPredicate | undefined;
    };
    configInput: {
        filter?: EntityPredicate | undefined;
    };
    dataRefs: {
        filterFunction: _backstage_frontend_plugin_api.ConfigurableExtensionDataRef<(entity: Entity) => boolean, "catalog.entity-filter-function", {}>;
    };
}>;

/** @alpha */
declare const EntityIconLinkBlueprint: _backstage_frontend_plugin_api.ExtensionBlueprint<{
    kind: "entity-icon-link";
    params: {
        useProps: () => Omit<IconLinkVerticalProps, "color">;
        filter?: EntityPredicate | ((entity: Entity) => boolean);
    };
    output: _backstage_frontend_plugin_api.ExtensionDataRef<(entity: Entity) => boolean, "catalog.entity-filter-function", {
        optional: true;
    }> | _backstage_frontend_plugin_api.ExtensionDataRef<string, "catalog.entity-filter-expression", {
        optional: true;
    }> | _backstage_frontend_plugin_api.ExtensionDataRef<() => IconLinkVerticalProps, "entity-icon-link-props", {}>;
    inputs: {};
    config: {
        label: string | undefined;
        title: string | undefined;
        filter: EntityPredicate | undefined;
    };
    configInput: {
        filter?: EntityPredicate | undefined;
        label?: string | undefined;
        title?: string | undefined;
    };
    dataRefs: {
        useProps: _backstage_frontend_plugin_api.ConfigurableExtensionDataRef<() => IconLinkVerticalProps, "entity-icon-link-props", {}>;
        filterFunction: _backstage_frontend_plugin_api.ConfigurableExtensionDataRef<(entity: Entity) => boolean, "catalog.entity-filter-function", {}>;
        filterExpression: _backstage_frontend_plugin_api.ConfigurableExtensionDataRef<string, "catalog.entity-filter-expression", {}>;
    };
}>;

/** @alpha */
declare function convertLegacyEntityCardExtension(LegacyExtension: ComponentType<{}>, overrides?: {
    name?: string;
    filter?: string | EntityPredicate | ((entity: Entity) => boolean);
    type?: EntityCardType;
}): ExtensionDefinition;

/** @alpha */
declare function convertLegacyEntityContentExtension(LegacyExtension: ComponentType<{}>, overrides?: {
    name?: string;
    filter?: string | EntityPredicate | ((entity: Entity) => boolean);
    path?: string;
    title?: string;
    /**
     * @deprecated Use the `path` param instead.
     */
    defaultPath?: [Error: `Use the 'path' override instead`];
    /**
     * @deprecated Use the `path` param instead.
     */
    defaultTitle?: [Error: `Use the 'title' override instead`];
}): ExtensionDefinition;

/** @alpha */
declare const catalogReactTranslationRef: _backstage_core_plugin_api_alpha.TranslationRef<"catalog-react", {
    readonly "catalogFilter.title": "Filters";
    readonly "catalogFilter.buttonTitle": "Filters";
    readonly "entityKindPicker.title": "Kind";
    readonly "entityKindPicker.errorMessage": "Failed to load entity kinds";
    readonly "entityLifecyclePicker.title": "Lifecycle";
    readonly "entityNamespacePicker.title": "Namespace";
    readonly "entityOwnerPicker.title": "Owner";
    readonly "entityProcessingStatusPicker.title": "Processing Status";
    readonly "entityTagPicker.title": "Tags";
    readonly "entityPeekAheadPopover.title": "Drill into the entity to see all of the tags.";
    readonly "entityPeekAheadPopover.entityCardActionsTitle": "Show details";
    readonly "entityPeekAheadPopover.emailCardAction.title": "Email {{email}}";
    readonly "entityPeekAheadPopover.emailCardAction.subTitle": "mailto {{email}}";
    readonly "entitySearchBar.placeholder": "Search";
    readonly "entityTypePicker.title": "Type";
    readonly "entityTypePicker.errorMessage": "Failed to load entity types";
    readonly "entityTypePicker.optionAllTitle": "all";
    readonly "favoriteEntity.addToFavorites": "Add to favorites";
    readonly "favoriteEntity.removeFromFavorites": "Remove from favorites";
    readonly "inspectEntityDialog.title": "Entity Inspector";
    readonly "inspectEntityDialog.closeButtonTitle": "Close";
    readonly "inspectEntityDialog.ancestryPage.title": "Ancestry";
    readonly "inspectEntityDialog.colocatedPage.title": "Colocated";
    readonly "inspectEntityDialog.colocatedPage.description": "These are the entities that are colocated with this entity - as in, they originated from the same data source (e.g. came from the same YAML file), or from the same origin (e.g. the originally registered URL).";
    readonly "inspectEntityDialog.colocatedPage.alertNoLocation": "Entity had no location information.";
    readonly "inspectEntityDialog.colocatedPage.alertNoEntity": "There were no other entities on this location.";
    readonly "inspectEntityDialog.jsonPage.title": "Entity as JSON";
    readonly "inspectEntityDialog.jsonPage.description": "This is the raw entity data as received from the catalog, on JSON form.";
    readonly "inspectEntityDialog.overviewPage.title": "Overview";
    readonly "inspectEntityDialog.yamlPage.title": "Entity as YAML";
    readonly "inspectEntityDialog.yamlPage.description": "This is the raw entity data as received from the catalog, on YAML form.";
    readonly "unregisterEntityDialog.title": "Are you sure you want to unregister this entity?";
    readonly "unregisterEntityDialog.cancelButtonTitle": "Cancel";
    readonly "unregisterEntityDialog.deleteButtonTitle": "Delete Entity";
    readonly "unregisterEntityDialog.deleteEntitySuccessMessage": "Removed entity {{entityName}}";
    readonly "unregisterEntityDialog.onlyDeleteStateTitle": "This entity does not seem to originate from a registered location. You therefore only have the option to delete it outright from the catalog.";
    readonly "unregisterEntityDialog.errorStateTitle": "Internal error: Unknown state";
    readonly "unregisterEntityDialog.bootstrapState.title": "You cannot unregister this entity, since it originates from a protected Backstage configuration (location \"{{location}}\"). If you believe this is in error, please contact the {{appTitle}} integrator.";
    readonly "unregisterEntityDialog.bootstrapState.advancedDescription": "You have the option to delete the entity itself from the catalog. Note that this should only be done if you know that the catalog file has been deleted at, or moved from, its origin location. If that is not the case, the entity will reappear shortly as the next refresh round is performed by the catalog.";
    readonly "unregisterEntityDialog.bootstrapState.advancedOptions": "Advanced Options";
    readonly "unregisterEntityDialog.unregisterState.title": "This action will unregister the following entities:";
    readonly "unregisterEntityDialog.unregisterState.description": "To undo, just re-register the entity in {{appTitle}}.";
    readonly "unregisterEntityDialog.unregisterState.subTitle": "Located at the following location:";
    readonly "unregisterEntityDialog.unregisterState.advancedDescription": "You also have the option to delete the entity itself from the catalog. Note that this should only be done if you know that the catalog file has been deleted at, or moved from, its origin location. If that is not the case, the entity will reappear shortly as the next refresh round is performed by the catalog.";
    readonly "unregisterEntityDialog.unregisterState.advancedOptions": "Advanced Options";
    readonly "unregisterEntityDialog.unregisterState.unregisterButtonTitle": "Unregister Location";
    readonly "userListPicker.defaultOrgName": "Company";
    readonly "userListPicker.orgFilterAllLabel": "All";
    readonly "userListPicker.personalFilter.title": "Personal";
    readonly "userListPicker.personalFilter.ownedLabel": "Owned";
    readonly "userListPicker.personalFilter.starredLabel": "Starred";
    readonly "entityTableColumnTitle.name": "Name";
    readonly "entityTableColumnTitle.type": "Type";
    readonly "entityTableColumnTitle.label": "Label";
    readonly "entityTableColumnTitle.title": "Title";
    readonly "entityTableColumnTitle.description": "Description";
    readonly "entityTableColumnTitle.domain": "Domain";
    readonly "entityTableColumnTitle.system": "System";
    readonly "entityTableColumnTitle.tags": "Tags";
    readonly "entityTableColumnTitle.namespace": "Namespace";
    readonly "entityTableColumnTitle.lifecycle": "Lifecycle";
    readonly "entityTableColumnTitle.owner": "Owner";
    readonly "entityTableColumnTitle.targets": "Targets";
}>;

/**
 * A thin wrapper around the
 * {@link @backstage/plugin-permission-react#usePermission} hook which uses the
 * current entity in context to make an authorization request for the given
 * {@link @backstage/plugin-catalog-common#CatalogEntityPermission}.
 *
 * Note: this hook blocks the permission request until the entity has loaded in
 * context. If you have the entityRef and need concurrent requests, use the
 * `usePermission` hook directly.
 * @alpha
 */
declare function useEntityPermission(permission: ResourcePermission<'catalog-entity'>): {
    loading: boolean;
    allowed: boolean;
    error?: Error;
};

/**
 * @alpha
 */
type EntityTableColumnTitleProps = {
    translationKey: 'name' | 'system' | 'owner' | 'type' | 'lifecycle' | 'namespace' | 'description' | 'tags' | 'targets' | 'title' | 'label' | 'domain';
};
/**
 * @alpha
 */
declare const EntityTableColumnTitle: ({ translationKey, }: EntityTableColumnTitleProps) => "Title" | "System" | "Domain" | "Lifecycle" | "Namespace" | "Owner" | "Tags" | "Type" | "Name" | "Description" | "Targets" | "Label";

export { CatalogFilterBlueprint, EntityCardBlueprint, type EntityCardType, EntityContentBlueprint, EntityContentLayoutBlueprint, type EntityContentLayoutProps, EntityContextMenuItemBlueprint, type EntityContextMenuItemParams, EntityHeaderBlueprint, EntityIconLinkBlueprint, type EntityPredicate, type EntityPredicateExpression, type EntityPredicatePrimitive, type EntityPredicateValue, EntityTableColumnTitle, type EntityTableColumnTitleProps, type UseProps, catalogReactTranslationRef, convertLegacyEntityCardExtension, convertLegacyEntityContentExtension, defaultEntityContentGroups, entityPredicateToFilterFunction, isOwnerOf, useEntityPermission };
