{"version":3,"file":"EntityCardBlueprint.esm.js","sources":["../../../src/alpha/blueprints/EntityCardBlueprint.ts"],"sourcesContent":["/*\n * Copyright 2024 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  ExtensionBoundary,\n  coreExtensionData,\n  createExtensionBlueprint,\n} from '@backstage/frontend-plugin-api';\nimport {\n  entityFilterFunctionDataRef,\n  entityFilterExpressionDataRef,\n  entityCardTypeDataRef,\n  entityCardTypes,\n  EntityCardType,\n} from './extensionData';\nimport { createEntityPredicateSchema } from '../predicates/createEntityPredicateSchema';\nimport { EntityPredicate } from '../predicates';\nimport { resolveEntityFilterData } from './resolveEntityFilterData';\nimport { Entity } from '@backstage/catalog-model';\n\n/**\n * @alpha\n * A blueprint for creating cards for the entity pages in the catalog.\n */\nexport const EntityCardBlueprint = createExtensionBlueprint({\n  kind: 'entity-card',\n  attachTo: { id: 'entity-content:catalog/overview', input: 'cards' },\n  output: [\n    coreExtensionData.reactElement,\n    entityFilterFunctionDataRef.optional(),\n    entityFilterExpressionDataRef.optional(),\n    entityCardTypeDataRef.optional(),\n  ],\n  dataRefs: {\n    filterFunction: entityFilterFunctionDataRef,\n    filterExpression: entityFilterExpressionDataRef,\n    type: entityCardTypeDataRef,\n  },\n  config: {\n    schema: {\n      filter: z =>\n        z.union([z.string(), createEntityPredicateSchema(z)]).optional(),\n      type: z => z.enum(entityCardTypes).optional(),\n    },\n  },\n  *factory(\n    {\n      loader,\n      filter,\n      type,\n    }: {\n      loader: () => Promise<JSX.Element>;\n      filter?: string | EntityPredicate | ((entity: Entity) => boolean);\n      type?: EntityCardType;\n    },\n    { node, config },\n  ) {\n    yield coreExtensionData.reactElement(ExtensionBoundary.lazy(node, loader));\n\n    yield* resolveEntityFilterData(filter, config, node);\n\n    const finalType = config.type ?? type;\n    if (finalType) {\n      yield entityCardTypeDataRef(finalType);\n    }\n  },\n});\n"],"names":[],"mappings":";;;;;AAqCO,MAAM,sBAAsB,wBAAA,CAAyB;AAAA,EAC1D,IAAA,EAAM,aAAA;AAAA,EACN,QAAA,EAAU,EAAE,EAAA,EAAI,iCAAA,EAAmC,OAAO,OAAA,EAAQ;AAAA,EAClE,MAAA,EAAQ;AAAA,IACN,iBAAA,CAAkB,YAAA;AAAA,IAClB,4BAA4B,QAAA,EAAS;AAAA,IACrC,8BAA8B,QAAA,EAAS;AAAA,IACvC,sBAAsB,QAAA;AAAS,GACjC;AAAA,EACA,QAAA,EAAU;AAAA,IACR,cAAA,EAAgB,2BAAA;AAAA,IAChB,gBAAA,EAAkB,6BAAA;AAAA,IAClB,IAAA,EAAM;AAAA,GACR;AAAA,EACA,MAAA,EAAQ;AAAA,IACN,MAAA,EAAQ;AAAA,MACN,MAAA,EAAQ,CAAA,CAAA,KACN,CAAA,CAAE,KAAA,CAAM,CAAC,CAAA,CAAE,MAAA,EAAO,EAAG,2BAAA,CAA4B,CAAC,CAAC,CAAC,EAAE,QAAA,EAAS;AAAA,MACjE,MAAM,CAAA,CAAA,KAAK,CAAA,CAAE,IAAA,CAAK,eAAe,EAAE,QAAA;AAAS;AAC9C,GACF;AAAA,EACA,CAAC,OAAA,CACC;AAAA,IACE,MAAA;AAAA,IACA,MAAA;AAAA,IACA;AAAA,GACF,EAKA,EAAE,IAAA,EAAM,MAAA,EAAO,EACf;AACA,IAAA,MAAM,kBAAkB,YAAA,CAAa,iBAAA,CAAkB,IAAA,CAAK,IAAA,EAAM,MAAM,CAAC,CAAA;AAEzE,IAAA,OAAO,uBAAA,CAAwB,MAAA,EAAQ,MAAA,EAAQ,IAAI,CAAA;AAEnD,IAAA,MAAM,SAAA,GAAY,OAAO,IAAA,IAAQ,IAAA;AACjC,IAAA,IAAI,SAAA,EAAW;AACb,MAAA,MAAM,sBAAsB,SAAS,CAAA;AAAA,IACvC;AAAA,EACF;AACF,CAAC;;;;"}