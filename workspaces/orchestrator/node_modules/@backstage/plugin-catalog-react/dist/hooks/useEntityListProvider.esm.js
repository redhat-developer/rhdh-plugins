import { jsx } from 'react/jsx-runtime';
import { useApi } from '@backstage/core-plugin-api';
import { compact, isEqual } from 'lodash';
import qs from 'qs';
import { createContext, useState, useMemo, useEffect, useCallback, useContext } from 'react';
import { useLocation } from 'react-router-dom';
import useAsyncFn from 'react-use/esm/useAsyncFn';
import useDebounce from 'react-use/esm/useDebounce';
import useMountedState from 'react-use/esm/useMountedState';
import { catalogApiRef } from '../api.esm.js';
import { reduceEntityFilters, reduceCatalogFilters, reduceBackendCatalogFilters } from '../utils/filters.esm.js';

const EntityListContext = createContext(void 0);
const EntityListProvider = (props) => {
  const isMounted = useMountedState();
  const catalogApi = useApi(catalogApiRef);
  const [requestedFilters, setRequestedFilters] = useState(
    {}
  );
  const location = useLocation();
  const getPaginationMode = () => {
    if (props.pagination === true) {
      return "cursor";
    }
    return typeof props.pagination === "object" ? props.pagination.mode ?? "cursor" : "none";
  };
  const paginationMode = getPaginationMode();
  const paginationLimit = typeof props.pagination === "object" ? props.pagination.limit ?? 20 : 20;
  const {
    queryParameters,
    cursor: initialCursor,
    offset: initialOffset,
    limit: initialLimit
  } = useMemo(() => {
    const parsed = qs.parse(location.search, {
      ignoreQueryPrefix: true
    });
    let limit2 = paginationLimit;
    if (typeof parsed.limit === "string") {
      const queryLimit = Number.parseInt(parsed.limit, 10);
      if (!isNaN(queryLimit)) {
        limit2 = queryLimit;
      }
    }
    const offset2 = typeof parsed.offset === "string" && paginationMode === "offset" ? Number.parseInt(parsed.offset, 10) : void 0;
    return {
      queryParameters: parsed.filters ?? {},
      cursor: typeof parsed.cursor === "string" && paginationMode === "cursor" ? parsed.cursor : void 0,
      offset: paginationMode === "offset" && offset2 && !isNaN(offset2) ? offset2 : void 0,
      limit: limit2
    };
  }, [paginationMode, location.search, paginationLimit]);
  const [cursor, setCursor] = useState(initialCursor);
  const [offset, setOffset] = useState(initialOffset);
  const [limit, setLimit] = useState(initialLimit);
  const [outputState, setOutputState] = useState(
    () => {
      return {
        appliedFilters: {},
        entities: [],
        backendEntities: [],
        pageInfo: {},
        offset,
        limit
      };
    }
  );
  const [{ value: resolvedValue, loading, error }, refresh] = useAsyncFn(
    async () => {
      const kindValue = requestedFilters.kind?.value?.toLocaleLowerCase("en-US");
      const adjustedFilters = kindValue === "user" || kindValue === "group" ? { ...requestedFilters, owners: void 0 } : requestedFilters;
      const compacted = compact(Object.values(adjustedFilters));
      if (paginationMode !== "none") {
        if (cursor) {
          if (cursor !== outputState.appliedCursor) {
            const entityFilter = reduceEntityFilters(compacted);
            const response = await catalogApi.queryEntities({
              cursor,
              limit
            });
            return {
              appliedFilters: requestedFilters,
              appliedCursor: cursor,
              backendEntities: response.items,
              entities: response.items.filter(entityFilter),
              pageInfo: response.pageInfo,
              totalItems: response.totalItems
            };
          }
        } else {
          const entityFilter = reduceEntityFilters(compacted);
          const backendFilter = reduceCatalogFilters(compacted);
          const previousBackendFilter = reduceCatalogFilters(
            compact(Object.values(outputState.appliedFilters))
          );
          if (paginationMode === "offset" && (outputState.limit !== limit || outputState.offset !== offset) || !isEqual(previousBackendFilter, backendFilter)) {
            const response = await catalogApi.queryEntities({
              ...backendFilter,
              limit,
              offset
            });
            return {
              appliedFilters: requestedFilters,
              backendEntities: response.items,
              entities: response.items.filter(entityFilter),
              pageInfo: response.pageInfo,
              totalItems: response.totalItems,
              limit,
              offset
            };
          }
        }
      } else {
        const entityFilter = reduceEntityFilters(compacted);
        const backendFilter = reduceBackendCatalogFilters(compacted);
        const previousBackendFilter = reduceBackendCatalogFilters(
          compact(Object.values(outputState.appliedFilters))
        );
        if (!isEqual(previousBackendFilter, backendFilter)) {
          const response = await catalogApi.getEntities({
            filter: backendFilter
          });
          const entities2 = response.items.filter(entityFilter);
          return {
            appliedFilters: requestedFilters,
            backendEntities: response.items,
            entities: entities2,
            totalItems: entities2.length
          };
        }
        const entities = outputState.backendEntities.filter(entityFilter);
        return {
          appliedFilters: requestedFilters,
          backendEntities: outputState.backendEntities,
          entities,
          totalItems: entities.length
        };
      }
      return void 0;
    },
    [
      catalogApi,
      queryParameters,
      requestedFilters,
      outputState,
      cursor,
      paginationMode,
      limit,
      offset
    ],
    { loading: true }
  );
  useDebounce(refresh, 10, [requestedFilters, cursor, limit, offset]);
  useEffect(() => {
    if (resolvedValue === void 0) {
      return;
    }
    setOutputState(resolvedValue);
    if (isMounted()) {
      const queryParams = Object.keys(requestedFilters).reduce(
        (params, key) => {
          const filter = requestedFilters[key];
          if (filter?.toQueryValue) {
            params[key] = filter.toQueryValue();
          }
          return params;
        },
        {}
      );
      const oldParams = qs.parse(location.search, {
        ignoreQueryPrefix: true
      });
      const newParams = qs.stringify(
        {
          ...oldParams,
          filters: queryParams,
          ...paginationMode === "none" ? {} : { cursor, limit, offset }
        },
        { addQueryPrefix: true, arrayFormat: "repeat" }
      );
      const newUrl = `${window.location.pathname}${newParams}`;
      window.history?.replaceState(null, document.title, newUrl);
    }
  }, [
    cursor,
    isMounted,
    limit,
    location.search,
    offset,
    requestedFilters,
    resolvedValue,
    paginationMode
  ]);
  const updateFilters = useCallback(
    (update) => {
      if (paginationMode === "cursor") {
        setCursor(void 0);
      } else if (paginationMode === "offset") {
        setOffset(0);
      }
      setRequestedFilters((prevFilters) => {
        const newFilters = typeof update === "function" ? update(prevFilters) : update;
        return { ...prevFilters, ...newFilters };
      });
    },
    [paginationMode]
  );
  const pageInfo = useMemo(() => {
    if (paginationMode !== "cursor") {
      return void 0;
    }
    const prevCursor = outputState.pageInfo?.prevCursor;
    const nextCursor = outputState.pageInfo?.nextCursor;
    return {
      prev: prevCursor ? () => setCursor(prevCursor) : void 0,
      next: nextCursor ? () => setCursor(nextCursor) : void 0
    };
  }, [paginationMode, outputState.pageInfo]);
  const value = useMemo(
    () => ({
      filters: outputState.appliedFilters,
      entities: outputState.entities,
      backendEntities: outputState.backendEntities,
      updateFilters,
      queryParameters,
      loading,
      error,
      pageInfo,
      totalItems: outputState.totalItems,
      limit,
      offset,
      setLimit,
      setOffset,
      paginationMode
    }),
    [
      outputState,
      updateFilters,
      queryParameters,
      loading,
      error,
      pageInfo,
      limit,
      offset,
      paginationMode,
      setLimit,
      setOffset
    ]
  );
  return /* @__PURE__ */ jsx(EntityListContext.Provider, { value, children: props.children });
};
function useEntityList() {
  const context = useContext(EntityListContext);
  if (!context)
    throw new Error("useEntityList must be used within EntityListProvider");
  return context;
}

export { EntityListContext, EntityListProvider, useEntityList };
//# sourceMappingURL=useEntityListProvider.esm.js.map
