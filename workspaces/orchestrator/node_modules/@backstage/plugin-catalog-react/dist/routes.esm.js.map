{"version":3,"file":"routes.esm.js","sources":["../src/routes.ts"],"sourcesContent":["/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Entity,\n  DEFAULT_NAMESPACE,\n  CompoundEntityRef,\n  parseEntityRef,\n} from '@backstage/catalog-model';\nimport { createRouteRef } from '@backstage/core-plugin-api';\nimport { getOrCreateGlobalSingleton } from '@backstage/version-bridge';\n\n/**\n * A stable route ref that points to the catalog page for an individual entity.\n *\n * This `RouteRef` can be imported and used directly, and does not need to be referenced\n * via an `ExternalRouteRef`.\n *\n * If you want to replace the `EntityPage` from `@backstage/catalog-plugin` in your app,\n * you need to use the `entityRouteRef` as the mount point instead of your own.\n * @public\n */\nexport const entityRouteRef = getOrCreateGlobalSingleton(\n  'catalog:entity-route-ref',\n  () =>\n    createRouteRef({\n      id: 'catalog:entity',\n      params: ['namespace', 'kind', 'name'],\n    }),\n);\n\n/**\n * Configurable options for `entityRouteParams`\n * @public\n */\nexport type EntityRouteParamsOptions = {\n  encodeParams?: boolean;\n};\n\n/**\n * Utility function to get suitable route params for entityRoute, given an\n * @public\n */\nexport function entityRouteParams(\n  entityOrRef: Entity | CompoundEntityRef | string,\n  options?: EntityRouteParamsOptions,\n) {\n  let kind;\n  let namespace;\n  let name;\n\n  if (typeof entityOrRef === 'string') {\n    const parsed = parseEntityRef(entityOrRef);\n    kind = parsed.kind;\n    namespace = parsed.namespace;\n    name = parsed.name;\n  } else if ('metadata' in entityOrRef) {\n    kind = entityOrRef.kind;\n    namespace = entityOrRef.metadata.namespace;\n    name = entityOrRef.metadata.name;\n  } else {\n    kind = entityOrRef.kind;\n    namespace = entityOrRef.namespace;\n    name = entityOrRef.name;\n  }\n\n  kind = kind.toLocaleLowerCase('en-US');\n  namespace = namespace?.toLocaleLowerCase('en-US') ?? DEFAULT_NAMESPACE;\n\n  const { encodeParams = false } = options || {};\n  if (encodeParams) {\n    kind = encodeURIComponent(kind);\n    namespace = encodeURIComponent(namespace);\n    name = encodeURIComponent(name);\n  }\n\n  return {\n    kind,\n    namespace,\n    name,\n  } as const;\n}\n"],"names":[],"mappings":";;;;AAmCO,MAAM,cAAA,GAAiB,0BAAA;AAAA,EAC5B,0BAAA;AAAA,EACA,MACE,cAAA,CAAe;AAAA,IACb,EAAA,EAAI,gBAAA;AAAA,IACJ,MAAA,EAAQ,CAAC,WAAA,EAAa,MAAA,EAAQ,MAAM;AAAA,GACrC;AACL;AAcO,SAAS,iBAAA,CACd,aACA,OAAA,EACA;AACA,EAAA,IAAI,IAAA;AACJ,EAAA,IAAI,SAAA;AACJ,EAAA,IAAI,IAAA;AAEJ,EAAA,IAAI,OAAO,gBAAgB,QAAA,EAAU;AACnC,IAAA,MAAM,MAAA,GAAS,eAAe,WAAW,CAAA;AACzC,IAAA,IAAA,GAAO,MAAA,CAAO,IAAA;AACd,IAAA,SAAA,GAAY,MAAA,CAAO,SAAA;AACnB,IAAA,IAAA,GAAO,MAAA,CAAO,IAAA;AAAA,EAChB,CAAA,MAAA,IAAW,cAAc,WAAA,EAAa;AACpC,IAAA,IAAA,GAAO,WAAA,CAAY,IAAA;AACnB,IAAA,SAAA,GAAY,YAAY,QAAA,CAAS,SAAA;AACjC,IAAA,IAAA,GAAO,YAAY,QAAA,CAAS,IAAA;AAAA,EAC9B,CAAA,MAAO;AACL,IAAA,IAAA,GAAO,WAAA,CAAY,IAAA;AACnB,IAAA,SAAA,GAAY,WAAA,CAAY,SAAA;AACxB,IAAA,IAAA,GAAO,WAAA,CAAY,IAAA;AAAA,EACrB;AAEA,EAAA,IAAA,GAAO,IAAA,CAAK,kBAAkB,OAAO,CAAA;AACrC,EAAA,SAAA,GAAY,SAAA,EAAW,iBAAA,CAAkB,OAAO,CAAA,IAAK,iBAAA;AAErD,EAAA,MAAM,EAAE,YAAA,GAAe,KAAA,EAAM,GAAI,WAAW,EAAC;AAC7C,EAAA,IAAI,YAAA,EAAc;AAChB,IAAA,IAAA,GAAO,mBAAmB,IAAI,CAAA;AAC9B,IAAA,SAAA,GAAY,mBAAmB,SAAS,CAAA;AACxC,IAAA,IAAA,GAAO,mBAAmB,IAAI,CAAA;AAAA,EAChC;AAEA,EAAA,OAAO;AAAA,IACL,IAAA;AAAA,IACA,SAAA;AAAA,IACA;AAAA,GACF;AACF;;;;"}