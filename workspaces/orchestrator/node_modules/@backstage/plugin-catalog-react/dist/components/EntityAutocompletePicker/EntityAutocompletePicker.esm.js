import { jsx } from 'react/jsx-runtime';
import Box from '@material-ui/core/Box';
import { makeStyles } from '@material-ui/core/styles';
import { useMemo, useState, useEffect } from 'react';
import { useApi } from '@backstage/core-plugin-api';
import useAsync from 'react-use/esm/useAsync';
import { catalogApiRef } from '../../api.esm.js';
import { EntityAutocompletePickerOption } from './EntityAutocompletePickerOption.esm.js';
import { useEntityList } from '../../hooks/useEntityListProvider.esm.js';
import { reduceBackendCatalogFilters } from '../../utils/filters.esm.js';
import { CatalogAutocomplete } from '../CatalogAutocomplete/CatalogAutocomplete.esm.js';
import { isEqual } from 'lodash';

const useStyles = makeStyles(
  {
    root: {},
    label: {
      textTransform: "none",
      fontWeight: "bold"
    }
  },
  { name: "CatalogReactEntityAutocompletePicker" }
);
function EntityAutocompletePicker(props) {
  const {
    label,
    name,
    path,
    showCounts,
    Filter,
    InputProps,
    initialSelectedOptions = [],
    filtersForAvailableValues = ["kind"],
    hidden
  } = props;
  const classes = useStyles();
  const {
    updateFilters,
    filters,
    queryParameters: { [name]: queryParameter }
  } = useEntityList();
  const catalogApi = useApi(catalogApiRef);
  const availableValuesFilters = filtersForAvailableValues.map(
    (f) => filters[f]
  );
  const { value: availableValues } = useAsync(async () => {
    const facet = path;
    const { facets } = await catalogApi.getEntityFacets({
      facets: [facet],
      filter: reduceBackendCatalogFilters(
        availableValuesFilters.filter(Boolean)
      )
    });
    return Object.fromEntries(
      facets[facet].map(({ value, count }) => [value, count])
    );
  }, [...availableValuesFilters]);
  const queryParameters = useMemo(
    () => [queryParameter].flat().filter(Boolean),
    [queryParameter]
  );
  const filteredOptions = filters[name]?.values;
  const [selectedOptions, setSelectedOptions] = useState(
    queryParameters.length ? queryParameters : filteredOptions ?? initialSelectedOptions
  );
  useEffect(() => {
    if (queryParameters.length) {
      setSelectedOptions(queryParameters);
    }
  }, [queryParameters]);
  const availableOptions = Object.keys(availableValues ?? {});
  const shouldAddFilter = selectedOptions.length && availableOptions.length;
  useEffect(() => {
    updateFilters({
      [name]: shouldAddFilter ? new Filter(selectedOptions) : void 0
    });
  }, [name, shouldAddFilter, selectedOptions, Filter, updateFilters]);
  useEffect(() => {
    if (!shouldAddFilter) return;
    const newSelectedOptions = filteredOptions ?? [];
    if (!isEqual(newSelectedOptions, selectedOptions)) {
      setSelectedOptions(newSelectedOptions);
    }
  }, [filteredOptions]);
  const filter = filters[name];
  if (filter && typeof filter === "object" && !("values" in filter) || !availableOptions.length) {
    return null;
  }
  return hidden ? null : /* @__PURE__ */ jsx(Box, { className: classes.root, pb: 1, pt: 1, children: /* @__PURE__ */ jsx(
    CatalogAutocomplete,
    {
      multiple: true,
      disableCloseOnSelect: true,
      label,
      name: `${String(name)}-picker`,
      options: availableOptions,
      value: selectedOptions,
      TextFieldProps: InputProps,
      onChange: (_event, options) => setSelectedOptions(options),
      renderOption: (option, { selected }) => /* @__PURE__ */ jsx(
        EntityAutocompletePickerOption,
        {
          selected,
          value: option,
          availableOptions: availableValues,
          showCounts: !!showCounts
        }
      )
    }
  ) });
}

export { EntityAutocompletePicker };
//# sourceMappingURL=EntityAutocompletePicker.esm.js.map
