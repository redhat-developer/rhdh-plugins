import { jsxs, Fragment, jsx } from 'react/jsx-runtime';
import { ANNOTATION_LOCATION, ANNOTATION_ORIGIN_LOCATION, stringifyEntityRef } from '@backstage/catalog-model';
import { Progress, ResponseErrorPanel } from '@backstage/core-components';
import { useApi } from '@backstage/core-plugin-api';
import DialogContentText from '@material-ui/core/DialogContentText';
import List from '@material-ui/core/List';
import ListItem from '@material-ui/core/ListItem';
import { makeStyles } from '@material-ui/core/styles';
import Alert from '@material-ui/lab/Alert';
import useAsync from 'react-use/esm/useAsync';
import { catalogApiRef } from '../../../api.esm.js';
import { EntityRefLink } from '../../EntityRefLink/EntityRefLink.esm.js';
import 'react';
import 'lodash/get';
import { KeyValueListItem, ListItemText } from './common.esm.js';
import { catalogReactTranslationRef } from '../../../translation.esm.js';
import { useTranslationRef } from '@backstage/core-plugin-api/alpha';

const useStyles = makeStyles({
  root: {
    display: "flex",
    flexDirection: "column"
  }
});
function useColocated(entity) {
  const catalogApi = useApi(catalogApiRef);
  const currentEntityRef = stringifyEntityRef(entity);
  const location = entity.metadata.annotations?.[ANNOTATION_LOCATION];
  const origin = entity.metadata.annotations?.[ANNOTATION_ORIGIN_LOCATION];
  const { loading, error, value } = useAsync(async () => {
    if (!location && !origin) {
      return [];
    }
    const response = await catalogApi.getEntities({
      filter: [
        ...location ? [{ [`metadata.annotations.${ANNOTATION_LOCATION}`]: location }] : [],
        ...origin ? [{ [`metadata.annotations.${ANNOTATION_ORIGIN_LOCATION}`]: origin }] : []
      ]
    });
    return response.items;
  }, [location, origin]);
  return {
    loading,
    error,
    location,
    originLocation: origin,
    colocatedEntities: value?.filter(
      (colocated) => stringifyEntityRef(colocated) !== currentEntityRef
    )
  };
}
function EntityList(props) {
  return /* @__PURE__ */ jsxs(List, { dense: true, children: [
    props.header && /* @__PURE__ */ jsx(KeyValueListItem, { entry: props.header }, "header"),
    props.entities.map((entity) => /* @__PURE__ */ jsx(ListItem, { children: /* @__PURE__ */ jsx(ListItemText, { primary: /* @__PURE__ */ jsx(EntityRefLink, { entityRef: entity }) }) }, stringifyEntityRef(entity)))
  ] });
}
function Contents(props) {
  const { entity } = props;
  const { t } = useTranslationRef(catalogReactTranslationRef);
  const { loading, error, location, originLocation, colocatedEntities } = useColocated(entity);
  if (loading) {
    return /* @__PURE__ */ jsx(Progress, {});
  } else if (error) {
    return /* @__PURE__ */ jsx(ResponseErrorPanel, { error });
  }
  if (!location && !originLocation) {
    return /* @__PURE__ */ jsx(Alert, { severity: "warning", children: t("inspectEntityDialog.colocatedPage.alertNoLocation") });
  } else if (!colocatedEntities?.length) {
    return /* @__PURE__ */ jsx(Alert, { severity: "info", children: t("inspectEntityDialog.colocatedPage.alertNoEntity") });
  }
  if (location === originLocation) {
    return /* @__PURE__ */ jsx(EntityList, { entities: colocatedEntities });
  }
  const atLocation = colocatedEntities.filter(
    (e) => e.metadata.annotations?.[ANNOTATION_LOCATION] === location
  );
  const atOrigin = colocatedEntities.filter(
    (e) => e.metadata.annotations?.[ANNOTATION_ORIGIN_LOCATION] === originLocation
  );
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    atLocation.length > 0 && /* @__PURE__ */ jsx(
      EntityList,
      {
        entities: atLocation,
        header: ["At the same location", location]
      }
    ),
    atOrigin.length > 0 && /* @__PURE__ */ jsx(
      EntityList,
      {
        entities: atOrigin,
        header: ["At the same origin", originLocation]
      }
    )
  ] });
}
function ColocatedPage(props) {
  const classes = useStyles();
  const { t } = useTranslationRef(catalogReactTranslationRef);
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(DialogContentText, { variant: "h2", children: t("inspectEntityDialog.colocatedPage.title") }),
    /* @__PURE__ */ jsx(DialogContentText, { children: t("inspectEntityDialog.colocatedPage.description") }),
    /* @__PURE__ */ jsx("div", { className: classes.root, children: /* @__PURE__ */ jsx(Contents, { entity: props.entity }) })
  ] });
}

export { ColocatedPage };
//# sourceMappingURL=ColocatedPage.esm.js.map
