import { jsx, jsxs } from 'react/jsx-runtime';
import { stringifyEntityRef, parseEntityRef } from '@backstage/catalog-model';
import Box from '@material-ui/core/Box';
import Checkbox from '@material-ui/core/Checkbox';
import FormControlLabel from '@material-ui/core/FormControlLabel';
import Typography from '@material-ui/core/Typography';
import Tooltip from '@material-ui/core/Tooltip';
import { makeStyles, withStyles } from '@material-ui/core/styles';
import CheckBoxIcon from '@material-ui/icons/CheckBox';
import CheckBoxOutlineBlankIcon from '@material-ui/icons/CheckBoxOutlineBlank';
import { useState, useMemo, useEffect } from 'react';
import { useEntityList } from '../../hooks/useEntityListProvider.esm.js';
import { EntityOwnerFilter } from '../../filters.esm.js';
import { useDebouncedEffect } from '@react-hookz/web';
import PersonIcon from '@material-ui/icons/Person';
import GroupIcon from '@material-ui/icons/Group';
import { humanizeEntity, humanizeEntityRef } from '../EntityRefLink/humanize.esm.js';
import { useFetchEntities } from './useFetchEntities.esm.js';
import '../../apis/EntityPresentationApi/EntityPresentationApi.esm.js';
import 'lodash/get';
import { useEntityPresentation } from '../../apis/EntityPresentationApi/useEntityPresentation.esm.js';
import '../../apis/StarredEntitiesApi/StarredEntitiesApi.esm.js';
import 'zen-observable';
import { catalogReactTranslationRef } from '../../translation.esm.js';
import { useTranslationRef } from '@backstage/core-plugin-api/alpha';
import { CatalogAutocomplete } from '../CatalogAutocomplete/CatalogAutocomplete.esm.js';

const useStyles = makeStyles(
  {
    root: {},
    label: {},
    input: {},
    fullWidth: { width: "100%" },
    boxLabel: {
      width: "100%",
      textOverflow: "ellipsis",
      overflow: "hidden"
    }
  },
  { name: "CatalogReactEntityOwnerPicker" }
);
const FixedWidthFormControlLabel = withStyles(
  (_theme) => ({
    label: {
      width: "100%"
    },
    root: {
      width: "90%"
    }
  }),
  { name: "FixedWidthFormControlLabel" }
)(FormControlLabel);
const icon = /* @__PURE__ */ jsx(CheckBoxOutlineBlankIcon, { fontSize: "small" });
const checkedIcon = /* @__PURE__ */ jsx(CheckBoxIcon, { fontSize: "small" });
function RenderOptionLabel(props) {
  const classes = useStyles();
  const isGroup = props.entity.kind.toLocaleLowerCase("en-US") === "group";
  const { primaryTitle: title } = useEntityPresentation(props.entity);
  return /* @__PURE__ */ jsx(Box, { className: classes.fullWidth, children: /* @__PURE__ */ jsx(
    FixedWidthFormControlLabel,
    {
      className: classes.fullWidth,
      control: /* @__PURE__ */ jsx(
        Checkbox,
        {
          icon,
          checkedIcon,
          checked: props.isSelected
        }
      ),
      onClick: (event) => event.preventDefault(),
      label: /* @__PURE__ */ jsx(Tooltip, { title, children: /* @__PURE__ */ jsxs(Box, { display: "flex", alignItems: "center", children: [
        isGroup ? /* @__PURE__ */ jsx(GroupIcon, { fontSize: "small" }) : /* @__PURE__ */ jsx(PersonIcon, { fontSize: "small" }),
        "\xA0",
        /* @__PURE__ */ jsx(Box, { className: classes.boxLabel, children: /* @__PURE__ */ jsx(Typography, { noWrap: true, children: title }) })
      ] }) })
    }
  ) });
}
const EntityOwnerPicker = (props) => {
  const classes = useStyles();
  const { mode = "owners-only" } = props || {};
  const {
    updateFilters,
    filters,
    queryParameters: { owners: ownersParameter }
  } = useEntityList();
  const [text, setText] = useState("");
  const { t } = useTranslationRef(catalogReactTranslationRef);
  const queryParamOwners = useMemo(
    () => [ownersParameter].flat().filter(Boolean),
    [ownersParameter]
  );
  const [selectedOwners, setSelectedOwners] = useState(
    queryParamOwners.length ? queryParamOwners : filters.owners?.values ?? []
  );
  const [{ value, loading }, handleFetch, cache] = useFetchEntities({
    mode,
    initialSelectedOwnersRefs: selectedOwners
  });
  useDebouncedEffect(() => handleFetch({ text }), [text, handleFetch], 250);
  const availableOwners = value?.items || [];
  useEffect(() => {
    if (queryParamOwners.length) {
      const filter = new EntityOwnerFilter(queryParamOwners);
      setSelectedOwners(filter.values);
    }
  }, [queryParamOwners]);
  useEffect(() => {
    updateFilters({
      owners: selectedOwners.length ? new EntityOwnerFilter(selectedOwners) : void 0
    });
  }, [selectedOwners, updateFilters]);
  if (["user", "group"].includes(
    filters.kind?.value.toLocaleLowerCase("en-US") || ""
  )) {
    return null;
  }
  return /* @__PURE__ */ jsx(Box, { className: classes.root, pb: 1, pt: 1, children: /* @__PURE__ */ jsx(
    CatalogAutocomplete,
    {
      label: t("entityOwnerPicker.title"),
      multiple: true,
      disableCloseOnSelect: true,
      loading,
      options: availableOwners,
      value: selectedOwners,
      getOptionSelected: (o, v) => {
        if (typeof v === "string") {
          return stringifyEntityRef(o) === v;
        }
        return o === v;
      },
      getOptionLabel: (o) => {
        const entity = typeof o === "string" ? cache.getEntity(o) || parseEntityRef(o, {
          defaultKind: "group",
          defaultNamespace: "default"
        }) : o;
        return humanizeEntity(entity, humanizeEntityRef(entity));
      },
      onChange: (_, owners) => {
        setText("");
        setSelectedOwners(
          owners.map((e) => {
            const entityRef = typeof e === "string" ? e : stringifyEntityRef(e);
            if (typeof e !== "string") {
              cache.setEntity(e);
            }
            return entityRef;
          })
        );
      },
      filterOptions: (x) => x,
      renderOption: (entity, { selected }) => {
        return /* @__PURE__ */ jsx(RenderOptionLabel, { entity, isSelected: selected });
      },
      name: "owner-picker",
      onInputChange: (_e, inputValue) => {
        setText(inputValue);
      },
      ListboxProps: {
        onScroll: (e) => {
          const element = e.currentTarget;
          const hasReachedEnd = Math.abs(
            element.scrollHeight - element.clientHeight - element.scrollTop
          ) < 1;
          if (hasReachedEnd && value?.cursor) {
            handleFetch({ items: value.items, cursor: value.cursor });
          }
        },
        "data-testid": "owner-picker-listbox"
      },
      LabelProps: { className: classes.label },
      TextFieldProps: { className: classes.input }
    }
  ) });
};

export { EntityOwnerPicker };
//# sourceMappingURL=EntityOwnerPicker.esm.js.map
