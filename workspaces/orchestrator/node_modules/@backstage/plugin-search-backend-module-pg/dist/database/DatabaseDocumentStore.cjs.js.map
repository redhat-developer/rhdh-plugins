{"version":3,"file":"DatabaseDocumentStore.cjs.js","sources":["../../src/database/DatabaseDocumentStore.ts"],"sourcesContent":["/*\n * Copyright 2021 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport {\n  DatabaseService,\n  resolvePackagePath,\n} from '@backstage/backend-plugin-api';\nimport { IndexableDocument } from '@backstage/plugin-search-common';\nimport { Knex } from 'knex';\nimport {\n  DatabaseStore,\n  DocumentResultRow,\n  PgSearchQuery,\n  RawDocumentRow,\n} from './types';\nimport { queryPostgresMajorVersion } from './util';\n\nconst migrationsDir = resolvePackagePath(\n  '@backstage/plugin-search-backend-module-pg',\n  'migrations',\n);\n\n/** @public */\nexport class DatabaseDocumentStore implements DatabaseStore {\n  static async create(\n    database: DatabaseService,\n  ): Promise<DatabaseDocumentStore> {\n    const knex = await database.getClient();\n    try {\n      const majorVersion = await queryPostgresMajorVersion(knex);\n\n      if (majorVersion < 12) {\n        // We are using some features (like generated columns) that aren't\n        // available in older postgres versions.\n        throw new Error(\n          `The PgSearchEngine requires at least postgres version 12 (but is running on ${majorVersion})`,\n        );\n      }\n    } catch {\n      // Actually both mysql and sqlite have a full text search, too. We could\n      // implement them separately or add them here.\n      throw new Error(\n        'The PgSearchEngine is only supported when using a postgres database (>=12.x)',\n      );\n    }\n\n    if (!database.migrations?.skip) {\n      await knex.migrate.latest({\n        directory: migrationsDir,\n      });\n    }\n\n    return new DatabaseDocumentStore(knex);\n  }\n\n  static async supported(knex: Knex): Promise<boolean> {\n    try {\n      const majorVersion = await queryPostgresMajorVersion(knex);\n\n      return majorVersion >= 12;\n    } catch {\n      return false;\n    }\n  }\n\n  constructor(private readonly db: Knex) {}\n\n  async transaction<T>(fn: (tx: Knex.Transaction) => Promise<T>): Promise<T> {\n    return await this.db.transaction(fn);\n  }\n\n  async getTransaction(): Promise<Knex.Transaction> {\n    return this.db.transaction();\n  }\n\n  async prepareInsert(tx: Knex.Transaction): Promise<void> {\n    // We create a temporary table to collect the hashes of the documents that\n    // we expect to be in the documents table at the end. The table is deleted\n    // at the end of the transaction.\n    // The hash makes sure that we generate a new row for every change.\n    await tx.raw(\n      'CREATE TEMP TABLE documents_to_insert (' +\n        'type text NOT NULL, ' +\n        'document jsonb NOT NULL, ' +\n        // Generating the hash requires a trick, as the text to bytea\n        // conversation runs into errors in case the text contains a backslash.\n        // Therefore we have to escape them.\n        \"hash bytea NOT NULL GENERATED ALWAYS AS (sha256(replace(document::text || type, '\\\\', '\\\\\\\\')::bytea)) STORED\" +\n        ') ON COMMIT DROP',\n    );\n  }\n\n  async completeInsert(tx: Knex.Transaction, type: string): Promise<void> {\n    // Copy all new rows into the documents table\n    await tx\n      .insert(\n        tx<RawDocumentRow>('documents_to_insert').select(\n          'type',\n          'document',\n          'hash',\n        ),\n      )\n      .into(tx.raw('documents (type, document, hash)'))\n      .onConflict('hash')\n      .ignore();\n\n    // Delete all documents that we don't expect (deleted and changed)\n    const rowsToDelete = tx<RawDocumentRow>('documents')\n      .select('documents.hash')\n      .leftJoin<RawDocumentRow>('documents_to_insert', {\n        'documents.hash': 'documents_to_insert.hash',\n      })\n      .whereNull('documents_to_insert.hash');\n\n    await tx<RawDocumentRow>('documents')\n      .where({ type })\n      .whereIn('hash', rowsToDelete)\n      .delete();\n  }\n\n  async insertDocuments(\n    tx: Knex.Transaction,\n    type: string,\n    documents: IndexableDocument[],\n  ): Promise<void> {\n    // Insert all documents into the temporary table to process them later\n    await tx<DocumentResultRow>('documents_to_insert').insert(\n      documents.map(document => ({\n        type,\n        document,\n      })),\n    );\n  }\n\n  async query(\n    tx: Knex.Transaction,\n    searchQuery: PgSearchQuery,\n  ): Promise<DocumentResultRow[]> {\n    const {\n      types,\n      pgTerm,\n      fields,\n      offset,\n      limit,\n      normalization = 0,\n      options,\n    } = searchQuery;\n    // TODO(awanlin): We should make the language a parameter so that we can support more then just english\n    // Builds a query like:\n    // SELECT ts_rank_cd(body, query, 0) AS rank, type, document,\n    // ts_headline('english', document, query) AS highlight\n    // FROM documents, to_tsquery('english', 'consent') query\n    // WHERE query @@ body AND (document @> '{\"kind\": \"API\"}')\n    // ORDER BY rank DESC\n    // LIMIT 10;\n    const query = tx<DocumentResultRow>('documents');\n\n    if (pgTerm) {\n      query\n        .from(tx.raw(\"documents, to_tsquery('english', ?) query\", pgTerm))\n        .whereRaw('query @@ body');\n    } else {\n      query.from('documents');\n    }\n\n    if (types) {\n      query.whereIn('type', types);\n    }\n\n    if (fields) {\n      Object.keys(fields).forEach(key => {\n        const value = fields[key];\n        const valueArray = Array.isArray(value) ? value : [value];\n        const fieldValueCompare = valueArray\n          .map(v => ({ [key]: v }))\n          .map(v => JSON.stringify(v));\n        const arrayValueCompare = valueArray\n          .map(v => ({ [key]: [v] }))\n          .map(v => JSON.stringify(v));\n        const valueCompare = [...fieldValueCompare, ...arrayValueCompare];\n        query.whereRaw(\n          `(${valueCompare.map(() => 'document @> ?').join(' OR ')})`,\n          valueCompare,\n        );\n      });\n    }\n\n    query.select('type', 'document');\n\n    if (pgTerm && options.useHighlight) {\n      const headlineOptions = `MaxWords=${options.maxWords}, MinWords=${options.minWords}, ShortWord=${options.shortWord}, HighlightAll=${options.highlightAll}, MaxFragments=${options.maxFragments}, FragmentDelimiter=${options.fragmentDelimiter}, StartSel=${options.preTag}, StopSel=${options.postTag}`;\n      query\n        .select(tx.raw(`ts_rank_cd(body, query, ${normalization}) AS \"rank\"`))\n        .select(\n          tx.raw(\n            `ts_headline(\\'english\\', document, query, '${headlineOptions}') as \"highlight\"`,\n          ),\n        )\n        .orderBy('rank', 'desc');\n    } else if (pgTerm && !options.useHighlight) {\n      query\n        .select(tx.raw(`ts_rank_cd(body, query, ${normalization}) AS \"rank\"`))\n        .orderBy('rank', 'desc');\n    } else {\n      query.select(tx.raw('1 as rank'));\n    }\n\n    return await query.offset(offset).limit(limit);\n  }\n}\n"],"names":["resolvePackagePath","queryPostgresMajorVersion"],"mappings":";;;;;AA6BA,MAAM,aAAA,GAAgBA,mCAAA;AAAA,EACpB,4CAAA;AAAA,EACA;AACF,CAAA;AAGO,MAAM,qBAAA,CAA+C;AAAA,EA0C1D,YAA6B,EAAA,EAAU;AAAV,IAAA,IAAA,CAAA,EAAA,GAAA,EAAA;AAAA,EAAW;AAAA,EAzCxC,aAAa,OACX,QAAA,EACgC;AAChC,IAAA,MAAM,IAAA,GAAO,MAAM,QAAA,CAAS,SAAA,EAAU;AACtC,IAAA,IAAI;AACF,MAAA,MAAM,YAAA,GAAe,MAAMC,8BAAA,CAA0B,IAAI,CAAA;AAEzD,MAAA,IAAI,eAAe,EAAA,EAAI;AAGrB,QAAA,MAAM,IAAI,KAAA;AAAA,UACR,+EAA+E,YAAY,CAAA,CAAA;AAAA,SAC7F;AAAA,MACF;AAAA,IACF,CAAA,CAAA,MAAQ;AAGN,MAAA,MAAM,IAAI,KAAA;AAAA,QACR;AAAA,OACF;AAAA,IACF;AAEA,IAAA,IAAI,CAAC,QAAA,CAAS,UAAA,EAAY,IAAA,EAAM;AAC9B,MAAA,MAAM,IAAA,CAAK,QAAQ,MAAA,CAAO;AAAA,QACxB,SAAA,EAAW;AAAA,OACZ,CAAA;AAAA,IACH;AAEA,IAAA,OAAO,IAAI,sBAAsB,IAAI,CAAA;AAAA,EACvC;AAAA,EAEA,aAAa,UAAU,IAAA,EAA8B;AACnD,IAAA,IAAI;AACF,MAAA,MAAM,YAAA,GAAe,MAAMA,8BAAA,CAA0B,IAAI,CAAA;AAEzD,MAAA,OAAO,YAAA,IAAgB,EAAA;AAAA,IACzB,CAAA,CAAA,MAAQ;AACN,MAAA,OAAO,KAAA;AAAA,IACT;AAAA,EACF;AAAA,EAIA,MAAM,YAAe,EAAA,EAAsD;AACzE,IAAA,OAAO,MAAM,IAAA,CAAK,EAAA,CAAG,WAAA,CAAY,EAAE,CAAA;AAAA,EACrC;AAAA,EAEA,MAAM,cAAA,GAA4C;AAChD,IAAA,OAAO,IAAA,CAAK,GAAG,WAAA,EAAY;AAAA,EAC7B;AAAA,EAEA,MAAM,cAAc,EAAA,EAAqC;AAKvD,IAAA,MAAM,EAAA,CAAG,GAAA;AAAA,MACP;AAAA,KAQF;AAAA,EACF;AAAA,EAEA,MAAM,cAAA,CAAe,EAAA,EAAsB,IAAA,EAA6B;AAEtE,IAAA,MAAM,EAAA,CACH,MAAA;AAAA,MACC,EAAA,CAAmB,qBAAqB,CAAA,CAAE,MAAA;AAAA,QACxC,MAAA;AAAA,QACA,UAAA;AAAA,QACA;AAAA;AACF,KACF,CACC,IAAA,CAAK,EAAA,CAAG,GAAA,CAAI,kCAAkC,CAAC,CAAA,CAC/C,UAAA,CAAW,MAAM,CAAA,CACjB,MAAA,EAAO;AAGV,IAAA,MAAM,YAAA,GAAe,GAAmB,WAAW,CAAA,CAChD,OAAO,gBAAgB,CAAA,CACvB,SAAyB,qBAAA,EAAuB;AAAA,MAC/C,gBAAA,EAAkB;AAAA,KACnB,CAAA,CACA,SAAA,CAAU,0BAA0B,CAAA;AAEvC,IAAA,MAAM,EAAA,CAAmB,WAAW,CAAA,CACjC,KAAA,CAAM,EAAE,IAAA,EAAM,CAAA,CACd,OAAA,CAAQ,MAAA,EAAQ,YAAY,CAAA,CAC5B,MAAA,EAAO;AAAA,EACZ;AAAA,EAEA,MAAM,eAAA,CACJ,EAAA,EACA,IAAA,EACA,SAAA,EACe;AAEf,IAAA,MAAM,EAAA,CAAsB,qBAAqB,CAAA,CAAE,MAAA;AAAA,MACjD,SAAA,CAAU,IAAI,CAAA,QAAA,MAAa;AAAA,QACzB,IAAA;AAAA,QACA;AAAA,OACF,CAAE;AAAA,KACJ;AAAA,EACF;AAAA,EAEA,MAAM,KAAA,CACJ,EAAA,EACA,WAAA,EAC8B;AAC9B,IAAA,MAAM;AAAA,MACJ,KAAA;AAAA,MACA,MAAA;AAAA,MACA,MAAA;AAAA,MACA,MAAA;AAAA,MACA,KAAA;AAAA,MACA,aAAA,GAAgB,CAAA;AAAA,MAChB;AAAA,KACF,GAAI,WAAA;AASJ,IAAA,MAAM,KAAA,GAAQ,GAAsB,WAAW,CAAA;AAE/C,IAAA,IAAI,MAAA,EAAQ;AACV,MAAA,KAAA,CACG,IAAA,CAAK,GAAG,GAAA,CAAI,2CAAA,EAA6C,MAAM,CAAC,CAAA,CAChE,SAAS,eAAe,CAAA;AAAA,IAC7B,CAAA,MAAO;AACL,MAAA,KAAA,CAAM,KAAK,WAAW,CAAA;AAAA,IACxB;AAEA,IAAA,IAAI,KAAA,EAAO;AACT,MAAA,KAAA,CAAM,OAAA,CAAQ,QAAQ,KAAK,CAAA;AAAA,IAC7B;AAEA,IAAA,IAAI,MAAA,EAAQ;AACV,MAAA,MAAA,CAAO,IAAA,CAAK,MAAM,CAAA,CAAE,OAAA,CAAQ,CAAA,GAAA,KAAO;AACjC,QAAA,MAAM,KAAA,GAAQ,OAAO,GAAG,CAAA;AACxB,QAAA,MAAM,aAAa,KAAA,CAAM,OAAA,CAAQ,KAAK,CAAA,GAAI,KAAA,GAAQ,CAAC,KAAK,CAAA;AACxD,QAAA,MAAM,oBAAoB,UAAA,CACvB,GAAA,CAAI,CAAA,CAAA,MAAM,EAAE,CAAC,GAAG,GAAG,CAAA,EAAE,CAAE,EACvB,GAAA,CAAI,CAAA,CAAA,KAAK,IAAA,CAAK,SAAA,CAAU,CAAC,CAAC,CAAA;AAC7B,QAAA,MAAM,oBAAoB,UAAA,CACvB,GAAA,CAAI,QAAM,EAAE,CAAC,GAAG,GAAG,CAAC,CAAC,CAAA,GAAI,CAAA,CACzB,GAAA,CAAI,OAAK,IAAA,CAAK,SAAA,CAAU,CAAC,CAAC,CAAA;AAC7B,QAAA,MAAM,YAAA,GAAe,CAAC,GAAG,iBAAA,EAAmB,GAAG,iBAAiB,CAAA;AAChE,QAAA,KAAA,CAAM,QAAA;AAAA,UACJ,CAAA,CAAA,EAAI,aAAa,GAAA,CAAI,MAAM,eAAe,CAAA,CAAE,IAAA,CAAK,MAAM,CAAC,CAAA,CAAA,CAAA;AAAA,UACxD;AAAA,SACF;AAAA,MACF,CAAC,CAAA;AAAA,IACH;AAEA,IAAA,KAAA,CAAM,MAAA,CAAO,QAAQ,UAAU,CAAA;AAE/B,IAAA,IAAI,MAAA,IAAU,QAAQ,YAAA,EAAc;AAClC,MAAA,MAAM,eAAA,GAAkB,CAAA,SAAA,EAAY,OAAA,CAAQ,QAAQ,CAAA,WAAA,EAAc,QAAQ,QAAQ,CAAA,YAAA,EAAe,OAAA,CAAQ,SAAS,CAAA,eAAA,EAAkB,OAAA,CAAQ,YAAY,CAAA,eAAA,EAAkB,OAAA,CAAQ,YAAY,CAAA,oBAAA,EAAuB,OAAA,CAAQ,iBAAiB,cAAc,OAAA,CAAQ,MAAM,CAAA,UAAA,EAAa,OAAA,CAAQ,OAAO,CAAA,CAAA;AACtS,MAAA,KAAA,CACG,OAAO,EAAA,CAAG,GAAA,CAAI,2BAA2B,aAAa,CAAA,WAAA,CAAa,CAAC,CAAA,CACpE,MAAA;AAAA,QACC,EAAA,CAAG,GAAA;AAAA,UACD,4CAA8C,eAAe,CAAA,iBAAA;AAAA;AAC/D,OACF,CACC,OAAA,CAAQ,MAAA,EAAQ,MAAM,CAAA;AAAA,IAC3B,CAAA,MAAA,IAAW,MAAA,IAAU,CAAC,OAAA,CAAQ,YAAA,EAAc;AAC1C,MAAA,KAAA,CACG,MAAA,CAAO,EAAA,CAAG,GAAA,CAAI,CAAA,wBAAA,EAA2B,aAAa,aAAa,CAAC,CAAA,CACpE,OAAA,CAAQ,MAAA,EAAQ,MAAM,CAAA;AAAA,IAC3B,CAAA,MAAO;AACL,MAAA,KAAA,CAAM,MAAA,CAAO,EAAA,CAAG,GAAA,CAAI,WAAW,CAAC,CAAA;AAAA,IAClC;AAEA,IAAA,OAAO,MAAM,KAAA,CAAM,MAAA,CAAO,MAAM,CAAA,CAAE,MAAM,KAAK,CAAA;AAAA,EAC/C;AACF;;;;"}