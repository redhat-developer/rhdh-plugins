import { jsx, jsxs } from 'react/jsx-runtime';
import { Fragment, isValidElement } from 'react';
import startCase from 'lodash/startCase';
import Typography from '@material-ui/core/Typography';
import { MetadataList, MetadataTable, MetadataTableItem, MetadataListItem } from './MetadataTable.esm.js';
import { CodeSnippet } from '../CodeSnippet/CodeSnippet.esm.js';
import jsyaml from 'js-yaml';
import { createStyles, withStyles } from '@material-ui/core/styles';

const listStyle = createStyles({
  root: {
    margin: "0 0",
    listStyleType: "none"
  }
});
const nestedListStyle = (theme) => createStyles({
  root: {
    ...listStyle.root,
    paddingLeft: theme.spacing(1)
  }
});
const StyledList = withStyles(listStyle, {
  name: "BackstageStructuredMetadataTableList"
})(({ classes, children }) => /* @__PURE__ */ jsx(MetadataList, { classes, children }));
const StyledNestedList = withStyles(nestedListStyle, {
  name: "BackstageStructuredMetadataTableNestedList"
})(({ classes, children }) => /* @__PURE__ */ jsx(MetadataList, { classes, children }));
function renderList(list, options, nested) {
  const values = list.map((item, index) => /* @__PURE__ */ jsx(MetadataListItem, { children: toValue(item, options, nested) }, index));
  return nested ? /* @__PURE__ */ jsx(StyledNestedList, { children: values }) : /* @__PURE__ */ jsx(StyledList, { children: values });
}
function renderMap(map, options, nested) {
  const values = Object.keys(map).map((key) => {
    const value = toValue(map[key], options, true);
    return /* @__PURE__ */ jsxs(MetadataListItem, { children: [
      /* @__PURE__ */ jsx(Typography, { variant: "body2", component: "span", children: `${options.titleFormat(key)}: ` }),
      value
    ] }, key);
  });
  return nested ? /* @__PURE__ */ jsx(StyledNestedList, { children: values }) : /* @__PURE__ */ jsx(StyledList, { children: values });
}
function toValue(value, options, nested) {
  if (isValidElement(value)) {
    return /* @__PURE__ */ jsx(Fragment, { children: value });
  }
  if (value !== null && typeof value === "object") {
    if (options.nestedValuesAsYaml) {
      return /* @__PURE__ */ jsx(
        CodeSnippet,
        {
          language: "yaml",
          text: jsyaml.dump(value),
          customStyle: {
            background: "transparent",
            lineHeight: "1.4",
            padding: "0",
            margin: 0
          }
        }
      );
    }
    if (!Array.isArray(value)) {
      return renderMap(value, options, nested);
    }
  }
  if (Array.isArray(value)) {
    return renderList(value, options, nested);
  }
  if (typeof value === "boolean") {
    return /* @__PURE__ */ jsx(Fragment, { children: value ? "\u2705" : "\u274C" });
  }
  return /* @__PURE__ */ jsx(Typography, { variant: "body2", component: "span", children: value });
}
const ItemValue = ({ value, options }) => /* @__PURE__ */ jsx(Fragment, { children: toValue(value, options, false) });
const TableItem = ({
  title,
  value,
  options
}) => {
  return /* @__PURE__ */ jsx(MetadataTableItem, { title: options.titleFormat(title), children: /* @__PURE__ */ jsx(ItemValue, { value, options }) });
};
function mapToItems(info, options) {
  return Object.keys(info).map((key) => /* @__PURE__ */ jsx(TableItem, { title: key, value: info[key], options }, key));
}
function StructuredMetadataTable(props) {
  const { metadata, dense = true, options } = props;
  const metadataItems = mapToItems(metadata, {
    titleFormat: startCase,
    nestedValuesAsYaml: options?.nestedValuesAsYaml ?? false,
    ...options
  });
  return /* @__PURE__ */ jsx(MetadataTable, { dense, children: metadataItems });
}

export { StructuredMetadataTable };
//# sourceMappingURL=StructuredMetadataTable.esm.js.map
