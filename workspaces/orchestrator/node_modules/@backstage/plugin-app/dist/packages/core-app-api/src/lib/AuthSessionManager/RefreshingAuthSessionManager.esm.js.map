{"version":3,"file":"RefreshingAuthSessionManager.esm.js","sources":["../../../../../../../../packages/core-app-api/src/lib/AuthSessionManager/RefreshingAuthSessionManager.ts"],"sourcesContent":["/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  SessionManager,\n  SessionScopesFunc,\n  SessionShouldRefreshFunc,\n  GetSessionOptions,\n} from './types';\nimport { AuthConnector } from '../AuthConnector';\nimport { SessionScopeHelper, hasScopes } from './common';\nimport { SessionStateTracker } from './SessionStateTracker';\n\ntype Options<T> = {\n  /** The connector used for acting on the auth session */\n  connector: AuthConnector<T>;\n  /** Used to get the scope of the session */\n  sessionScopes: SessionScopesFunc<T>;\n  /** Used to check if the session needs to be refreshed */\n  sessionShouldRefresh: SessionShouldRefreshFunc<T>;\n  /** The default scopes that should always be present in a session, defaults to none. */\n  defaultScopes?: Set<string>;\n};\n\n/**\n * RefreshingAuthSessionManager manages an underlying session that has\n * and expiration time and needs to be refreshed periodically.\n */\nexport class RefreshingAuthSessionManager<T> implements SessionManager<T> {\n  private readonly connector: AuthConnector<T>;\n  private readonly helper: SessionScopeHelper<T>;\n  private readonly sessionScopesFunc: SessionScopesFunc<T>;\n  private readonly sessionShouldRefreshFunc: SessionShouldRefreshFunc<T>;\n  private readonly stateTracker = new SessionStateTracker();\n\n  private refreshPromise?: Promise<T>;\n  private currentSession: T | undefined;\n\n  constructor(options: Options<T>) {\n    const {\n      connector,\n      defaultScopes = new Set(),\n      sessionScopes,\n      sessionShouldRefresh,\n    } = options;\n\n    this.connector = connector;\n    this.sessionScopesFunc = sessionScopes;\n    this.sessionShouldRefreshFunc = sessionShouldRefresh;\n    this.helper = new SessionScopeHelper({ sessionScopes, defaultScopes });\n  }\n\n  async getSession(options: GetSessionOptions): Promise<T | undefined> {\n    let alreadyTriedToRefreshSession = false;\n    if (\n      this.helper.sessionExistsAndHasScope(this.currentSession, options.scopes)\n    ) {\n      const shouldRefresh = this.sessionShouldRefreshFunc(this.currentSession!);\n      if (!shouldRefresh) {\n        return this.currentSession!;\n      }\n\n      alreadyTriedToRefreshSession = true;\n\n      try {\n        const refreshedSession = await this.collapsedSessionRefresh(\n          options.scopes,\n        );\n        const currentScopes = this.sessionScopesFunc(this.currentSession!);\n        const refreshedScopes = this.sessionScopesFunc(refreshedSession);\n        if (hasScopes(refreshedScopes, currentScopes)) {\n          this.currentSession = refreshedSession;\n        }\n        return refreshedSession;\n      } catch (error) {\n        this.removeLocalSession();\n\n        if (options.optional) {\n          return undefined;\n        }\n        // If the refresh attempt fails we assume we don't have a session, so continue to create one\n      }\n    }\n\n    // The user may still have a valid refresh token in their cookies. Attempt to\n    // initiate a fresh session through the backend using that refresh token.\n    //\n    // We can still try to refresh even if client requested instant popup.\n    // With instant popup option, the client is responsible for providing the user login prompt modal window.\n    // If control flow executes this code and client requested instant popup, it means that\n    // must have clicked sign in on the login prompt. The browser allows asynchronous code to open a popup\n    // if it is caused by a user interaction, clicking on a sign-in button, for example.\n    if (!alreadyTriedToRefreshSession) {\n      try {\n        const newSession = await this.collapsedSessionRefresh(options.scopes);\n        this.currentSession = newSession;\n        // The session might not have the scopes requested so go back and check again\n        return this.getSession(options);\n      } catch {\n        this.removeLocalSession();\n        // If the refresh attempt fails we assume we don't have a session, so continue to create one.\n      }\n    }\n\n    // If we continue here we will show a popup, so exit if this is an optional session request.\n    if (options.optional) {\n      return undefined;\n    }\n\n    // We can call authRequester multiple times, the returned session will contain all requested scopes.\n    this.currentSession = await this.connector.createSession({\n      ...options,\n      scopes: this.helper.getExtendedScope(this.currentSession, options.scopes),\n    });\n    this.stateTracker.setIsSignedIn(true);\n    return this.currentSession;\n  }\n\n  /**\n   * Sets `undefined` to this.{@link currentSession} and tells this.{@link stateTracker}, session state tracker,\n   * that a user has signed out.\n   *\n   * Does not propagate session removal to the connector like {@link removeSession}().\n   *\n   */\n  removeLocalSession() {\n    this.currentSession = undefined;\n    this.stateTracker.setIsSignedIn(false);\n  }\n\n  async removeSession() {\n    this.currentSession = undefined;\n    await this.connector.removeSession();\n    this.stateTracker.setIsSignedIn(false);\n  }\n\n  sessionState$() {\n    return this.stateTracker.sessionState$();\n  }\n\n  private async collapsedSessionRefresh(scopes?: Set<string>): Promise<T> {\n    if (this.refreshPromise) {\n      return this.refreshPromise;\n    }\n\n    this.refreshPromise = this.connector.refreshSession({\n      scopes: this.helper.getExtendedScope(this.currentSession, scopes),\n    });\n\n    try {\n      const session = await this.refreshPromise;\n      if (!this.helper.sessionExistsAndHasScope(session, scopes)) {\n        throw new Error(\n          'Refreshed session did not receive the required scopes',\n        );\n      }\n      this.stateTracker.setIsSignedIn(true);\n      return session;\n    } finally {\n      delete this.refreshPromise;\n    }\n  }\n}\n"],"names":[],"mappings":"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"}