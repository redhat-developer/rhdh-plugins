{"version":3,"file":"FlatRoutes.esm.js","sources":["../../../../../../../packages/core-app-api/src/routing/FlatRoutes.tsx"],"sourcesContent":["/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ReactNode, useMemo } from 'react';\nimport { useRoutes } from 'react-router-dom';\nimport {\n  attachComponentData,\n  useApp,\n  useElementFilter,\n} from '@backstage/core-plugin-api';\nimport { isReactRouterBeta } from '../app/isReactRouterBeta';\n\nlet warned = false;\n\ntype RouteObject = {\n  path: string;\n  element: ReactNode;\n  children?: RouteObject[];\n};\n\n/**\n * Props for the {@link FlatRoutes} component.\n *\n * @public\n */\nexport type FlatRoutesProps = {\n  children: ReactNode;\n};\n\n/**\n * A wrapper around a set of routes.\n *\n * @remarks\n *\n * The root of the routing hierarchy in your app should use this component,\n * instead of the one from `react-router-dom`. This ensures that all of the\n * plugin route and utility API wiring happens under the hood.\n *\n * @public\n */\nexport const FlatRoutes = (props: FlatRoutesProps): JSX.Element | null => {\n  const app = useApp();\n  const { NotFoundErrorPage } = app.getComponents();\n  const isBeta = useMemo(() => isReactRouterBeta(), []);\n  const routes = useElementFilter(props.children, elements =>\n    elements\n      .getElements<{\n        path?: string;\n        element?: ReactNode;\n        children?: ReactNode;\n      }>()\n      .flatMap<RouteObject>(child => {\n        let path = child.props.path;\n\n        // TODO(Rugvip): Work around plugins registering empty paths, remove once deprecated routes are gone\n        if (path === '') {\n          return [];\n        }\n        path = path?.replace(/\\/\\*$/, '') ?? '/';\n\n        let element = isBeta ? child : child.props.element;\n        if (!isBeta && !element) {\n          element = child;\n          if (!warned && process.env.NODE_ENV !== 'test') {\n            // eslint-disable-next-line no-console\n            console.warn(\n              'DEPRECATION WARNING: All elements within <FlatRoutes> must be of type <Route> with an element prop. ' +\n                'Existing usages of <Navigate key=[path] to=[to] /> should be replaced with <Route path=[path] element={<Navigate to=[to] />} />.',\n            );\n            warned = true;\n          }\n        }\n\n        return [\n          {\n            // Each route matches any sub route, except for the explicit root path\n            path,\n            element,\n            children: child.props.children\n              ? [\n                  // These are the children of each route, which we all add in under a catch-all\n                  // subroute in order to make them available to `useOutlet`\n                  {\n                    path: path === '/' ? '/' : '*', // The root path must require an exact match\n                    element: child.props.children,\n                  },\n                ]\n              : undefined,\n          },\n        ];\n      })\n      // Routes are sorted to work around a bug where prefixes are unexpectedly matched\n      // TODO(Rugvip): This can be removed once react-router v6 beta is no longer supported\n      .sort((a, b) => b.path.localeCompare(a.path))\n      .map(obj => ({ ...obj, path: obj.path === '/' ? '/' : `${obj.path}/*` })),\n  );\n\n  // TODO(Rugvip): Possibly add a way to skip this, like a noNotFoundPage prop\n  const withNotFound = [\n    ...routes,\n    {\n      path: '*',\n      element: <NotFoundErrorPage />,\n    },\n  ];\n\n  return useRoutes(withNotFound);\n};\n\nattachComponentData(FlatRoutes, 'core.type', 'FlatRoutes');\n"],"names":[],"mappings":";;;;;;AAyBA,IAAI,MAAA,GAAS,KAAA;AA4BN,MAAM,UAAA,GAAa,CAAC,KAAA,KAA+C;AACxE,EAAA,MAAM,MAAM,MAAA,EAAO;AACnB,EAAA,MAAM,EAAE,iBAAA,EAAkB,GAAI,GAAA,CAAI,aAAA,EAAc;AAChD,EAAA,MAAM,SAAS,OAAA,CAAQ,MAAM,iBAAA,EAAkB,EAAG,EAAE,CAAA;AACpD,EAAA,MAAM,MAAA,GAAS,gBAAA;AAAA,IAAiB,KAAA,CAAM,QAAA;AAAA,IAAU,CAAA,QAAA,KAC9C,QAAA,CACG,WAAA,EAIE,CACF,QAAqB,CAAA,KAAA,KAAS;AAC7B,MAAA,IAAI,IAAA,GAAO,MAAM,KAAA,CAAM,IAAA;AAGvB,MAAA,IAAI,SAAS,EAAA,EAAI;AACf,QAAA,OAAO,EAAC;AAAA,MACV;AACA,MAAA,IAAA,GAAO,IAAA,EAAM,OAAA,CAAQ,OAAA,EAAS,EAAE,CAAA,IAAK,GAAA;AAErC,MAAA,IAAI,OAAA,GAAU,MAAA,GAAS,KAAA,GAAQ,KAAA,CAAM,KAAA,CAAM,OAAA;AAC3C,MAAA,IAAI,CAAC,MAAA,IAAU,CAAC,OAAA,EAAS;AACvB,QAAA,OAAA,GAAU,KAAA;AACV,QAAA,IAAI,CAAC,MAAA,IAAU,OAAA,CAAQ,GAAA,CAAI,aAAa,MAAA,EAAQ;AAE9C,UAAA,OAAA,CAAQ,IAAA;AAAA,YACN;AAAA,WAEF;AACA,UAAA,MAAA,GAAS,IAAA;AAAA,QACX;AAAA,MACF;AAEA,MAAA,OAAO;AAAA,QACL;AAAA;AAAA,UAEE,IAAA;AAAA,UACA,OAAA;AAAA,UACA,QAAA,EAAU,KAAA,CAAM,KAAA,CAAM,QAAA,GAClB;AAAA;AAAA;AAAA,YAGE;AAAA,cACE,IAAA,EAAM,IAAA,KAAS,GAAA,GAAM,GAAA,GAAM,GAAA;AAAA;AAAA,cAC3B,OAAA,EAAS,MAAM,KAAA,CAAM;AAAA;AACvB,WACF,GACA;AAAA;AACN,OACF;AAAA,IACF,CAAC,CAAA,CAGA,IAAA,CAAK,CAAC,CAAA,EAAG,CAAA,KAAM,CAAA,CAAE,IAAA,CAAK,aAAA,CAAc,CAAA,CAAE,IAAI,CAAC,CAAA,CAC3C,GAAA,CAAI,CAAA,GAAA,MAAQ,EAAE,GAAG,GAAA,EAAK,IAAA,EAAM,GAAA,CAAI,IAAA,KAAS,GAAA,GAAM,GAAA,GAAM,CAAA,EAAG,GAAA,CAAI,IAAI,CAAA,EAAA,CAAA,EAAK,CAAE;AAAA,GAC5E;AAGA,EAAA,MAAM,YAAA,GAAe;AAAA,IACnB,GAAG,MAAA;AAAA,IACH;AAAA,MACE,IAAA,EAAM,GAAA;AAAA,MACN,OAAA,sBAAU,iBAAA,EAAA,EAAkB;AAAA;AAC9B,GACF;AAEA,EAAA,OAAO,UAAU,YAAY,CAAA;AAC/B;AAEA,mBAAA,CAAoB,UAAA,EAAY,aAAa,YAAY,CAAA;;;;"}