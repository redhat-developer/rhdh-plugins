import { createInstance } from 'i18next';
import ObservableImpl from 'zen-observable';
import { toInternalTranslationResource } from '../../../../../core-plugin-api/src/translation/TranslationResource.esm.js';
import { toInternalTranslationRef } from '../../../../../core-plugin-api/src/translation/TranslationRef.esm.js';
import { DEFAULT_LANGUAGE } from '../AppLanguageApi/AppLanguageSelector.esm.js';
import { isValidElement, createElement, Fragment } from 'react';

function removeNulls(messages) {
  return Object.fromEntries(
    Object.entries(messages).filter(
      (e) => e[1] !== null
    )
  );
}
class ResourceLoader {
  constructor(onLoad) {
    this.onLoad = onLoad;
  }
  /** Loaded resources by loader key */
  #loaded = /* @__PURE__ */ new Set();
  /** Resource loading promises by loader key */
  #loading = /* @__PURE__ */ new Map();
  /** Loaders for each resource language */
  #loaders = /* @__PURE__ */ new Map();
  addTranslationResource(resource) {
    const internalResource = toInternalTranslationResource(resource);
    for (const entry of internalResource.resources) {
      const key = this.#getLoaderKey(entry.language, internalResource.id);
      if (!this.#loaders.has(key)) {
        this.#loaders.set(key, entry.loader);
      }
    }
  }
  #getLoaderKey(language, namespace) {
    return `${language}/${namespace}`;
  }
  needsLoading(language, namespace) {
    const key = this.#getLoaderKey(language, namespace);
    const loader = this.#loaders.get(key);
    if (!loader) {
      return false;
    }
    return !this.#loaded.has(key);
  }
  async load(language, namespace) {
    const key = this.#getLoaderKey(language, namespace);
    const loader = this.#loaders.get(key);
    if (!loader) {
      return;
    }
    if (this.#loaded.has(key)) {
      return;
    }
    const loading = this.#loading.get(key);
    if (loading) {
      await loading;
      return;
    }
    const load = loader().then(
      (result) => {
        this.onLoad({ language, namespace, messages: result.messages });
        this.#loaded.add(key);
      },
      (error) => {
        this.#loaded.add(key);
        throw error;
      }
    );
    this.#loading.set(key, load);
    await load;
  }
}
class JsxInterpolator {
  #setFormatHook;
  #marker;
  #pattern;
  static fromI18n(i18n) {
    const interpolator = i18n.services.interpolator;
    const originalFormat = interpolator.format;
    let formatHook;
    interpolator.format = (value, format, lng, formatOpts) => {
      if (format) {
        return originalFormat(value, format, lng, formatOpts);
      }
      return formatHook?.(value, format, lng, formatOpts) ?? value;
    };
    return new JsxInterpolator(
      // Using a random marker to ensure it can't be misused
      Math.random().toString(36).substring(2, 8),
      (hook) => {
        formatHook = hook;
      }
    );
  }
  constructor(marker, setFormatHook) {
    this.#setFormatHook = setFormatHook;
    this.#marker = marker;
    this.#pattern = new RegExp(`\\$${marker}\\(([^)]+)\\)`);
  }
  wrapT(originalT) {
    return (key, options) => {
      let elementsMap = void 0;
      this.#setFormatHook((value) => {
        if (isValidElement(value)) {
          if (!elementsMap) {
            elementsMap = /* @__PURE__ */ new Map();
          }
          const elementKey = elementsMap.size.toString();
          elementsMap.set(elementKey, value);
          return `$${this.#marker}(${elementKey})`;
        }
        return value;
      });
      const result = originalT(key, options);
      if (!elementsMap) {
        return result;
      }
      const split = result.split(this.#pattern);
      return createElement(
        Fragment,
        null,
        ...split.map((part, index) => {
          if (index % 2 === 0) {
            return part;
          }
          return elementsMap?.get(part);
        }).filter(Boolean)
      );
    };
  }
}
class I18nextTranslationApi {
  static create(options) {
    const { languages } = options.languageApi.getAvailableLanguages();
    const i18n = createInstance({
      fallbackLng: DEFAULT_LANGUAGE,
      supportedLngs: languages,
      interpolation: {
        escapeValue: false,
        // Used for the JsxInterpolator format hook
        alwaysFormat: true
      },
      ns: [],
      defaultNS: false,
      fallbackNS: false,
      // Disable resource loading on init, meaning i18n will be ready to use immediately
      initImmediate: false
    });
    i18n.init();
    if (!i18n.isInitialized) {
      throw new Error("i18next was unexpectedly not initialized");
    }
    const interpolator = JsxInterpolator.fromI18n(i18n);
    const { language: initialLanguage } = options.languageApi.getLanguage();
    if (initialLanguage !== DEFAULT_LANGUAGE) {
      i18n.changeLanguage(initialLanguage);
    }
    const loader = new ResourceLoader((loaded) => {
      i18n.addResourceBundle(
        loaded.language,
        loaded.namespace,
        removeNulls(loaded.messages),
        false,
        // do not merge with existing translations
        true
        // overwrite translations
      );
    });
    const resources = options?.resources || [];
    for (let i = resources.length - 1; i >= 0; i--) {
      const resource = resources[i];
      if (resource.$$type === "@backstage/TranslationResource") {
        loader.addTranslationResource(resource);
      } else if (resource.$$type === "@backstage/TranslationMessages") {
        i18n.addResourceBundle(
          DEFAULT_LANGUAGE,
          resource.id,
          removeNulls(resource.messages),
          true,
          // merge with existing translations
          false
          // do not overwrite translations
        );
      }
    }
    const instance = new I18nextTranslationApi(
      i18n,
      loader,
      options.languageApi.getLanguage().language,
      interpolator
    );
    options.languageApi.language$().subscribe(({ language }) => {
      instance.#changeLanguage(language);
    });
    return instance;
  }
  #i18n;
  #loader;
  #language;
  #jsxInterpolator;
  /** Keep track of which refs we have registered default resources for */
  #registeredRefs = /* @__PURE__ */ new Set();
  /** Notify observers when language changes */
  #languageChangeListeners = /* @__PURE__ */ new Set();
  constructor(i18n, loader, language, jsxInterpolator) {
    this.#i18n = i18n;
    this.#loader = loader;
    this.#language = language;
    this.#jsxInterpolator = jsxInterpolator;
  }
  getTranslation(translationRef) {
    const internalRef = toInternalTranslationRef(translationRef);
    this.#registerDefaults(internalRef);
    return this.#createSnapshot(internalRef);
  }
  translation$(translationRef) {
    const internalRef = toInternalTranslationRef(translationRef);
    this.#registerDefaults(internalRef);
    return new ObservableImpl((subscriber) => {
      let loadTicket = {};
      const loadResource = () => {
        loadTicket = {};
        const ticket = loadTicket;
        this.#loader.load(this.#language, internalRef.id).then(
          () => {
            if (ticket === loadTicket) {
              const snapshot = this.#createSnapshot(internalRef);
              if (snapshot.ready) {
                subscriber.next(snapshot);
              }
            }
          },
          (error) => {
            if (ticket === loadTicket) {
              subscriber.error(Array.isArray(error) ? error[0] : error);
            }
          }
        );
      };
      const onChange = () => {
        const snapshot = this.#createSnapshot(internalRef);
        if (snapshot.ready) {
          subscriber.next(snapshot);
        } else {
          loadResource();
        }
      };
      if (this.#loader.needsLoading(this.#language, internalRef.id)) {
        loadResource();
      }
      this.#languageChangeListeners.add(onChange);
      return () => {
        this.#languageChangeListeners.delete(onChange);
      };
    });
  }
  #changeLanguage(language) {
    if (this.#language !== language) {
      this.#language = language;
      this.#i18n.changeLanguage(language);
      this.#languageChangeListeners.forEach((listener) => listener());
    }
  }
  #createSnapshot(internalRef) {
    if (this.#loader.needsLoading(this.#language, internalRef.id)) {
      return { ready: false };
    }
    const unwrappedT = this.#i18n.getFixedT(null, internalRef.id);
    const t = this.#jsxInterpolator.wrapT(unwrappedT);
    return {
      ready: true,
      t
    };
  }
  #registerDefaults(internalRef) {
    if (this.#registeredRefs.has(internalRef.id)) {
      return;
    }
    this.#registeredRefs.add(internalRef.id);
    const defaultMessages = internalRef.getDefaultMessages();
    this.#i18n.addResourceBundle(
      DEFAULT_LANGUAGE,
      internalRef.id,
      defaultMessages,
      true,
      // merge with existing translations
      false
      // do not overwrite translations
    );
    const defaultResource = internalRef.getDefaultResource();
    if (defaultResource) {
      this.#loader.addTranslationResource(defaultResource);
    }
  }
}

export { I18nextTranslationApi, JsxInterpolator };
//# sourceMappingURL=I18nextTranslationApi.esm.js.map
