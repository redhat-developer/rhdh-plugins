import { SessionScopeHelper, hasScopes } from './common.esm.js';
import { SessionStateTracker } from './SessionStateTracker.esm.js';

class RefreshingAuthSessionManager {
  connector;
  helper;
  sessionScopesFunc;
  sessionShouldRefreshFunc;
  stateTracker = new SessionStateTracker();
  refreshPromise;
  currentSession;
  constructor(options) {
    const {
      connector,
      defaultScopes = /* @__PURE__ */ new Set(),
      sessionScopes,
      sessionShouldRefresh
    } = options;
    this.connector = connector;
    this.sessionScopesFunc = sessionScopes;
    this.sessionShouldRefreshFunc = sessionShouldRefresh;
    this.helper = new SessionScopeHelper({ sessionScopes, defaultScopes });
  }
  async getSession(options) {
    let alreadyTriedToRefreshSession = false;
    if (this.helper.sessionExistsAndHasScope(this.currentSession, options.scopes)) {
      const shouldRefresh = this.sessionShouldRefreshFunc(this.currentSession);
      if (!shouldRefresh) {
        return this.currentSession;
      }
      alreadyTriedToRefreshSession = true;
      try {
        const refreshedSession = await this.collapsedSessionRefresh(
          options.scopes
        );
        const currentScopes = this.sessionScopesFunc(this.currentSession);
        const refreshedScopes = this.sessionScopesFunc(refreshedSession);
        if (hasScopes(refreshedScopes, currentScopes)) {
          this.currentSession = refreshedSession;
        }
        return refreshedSession;
      } catch (error) {
        this.removeLocalSession();
        if (options.optional) {
          return void 0;
        }
      }
    }
    if (!alreadyTriedToRefreshSession) {
      try {
        const newSession = await this.collapsedSessionRefresh(options.scopes);
        this.currentSession = newSession;
        return this.getSession(options);
      } catch {
        this.removeLocalSession();
      }
    }
    if (options.optional) {
      return void 0;
    }
    this.currentSession = await this.connector.createSession({
      ...options,
      scopes: this.helper.getExtendedScope(this.currentSession, options.scopes)
    });
    this.stateTracker.setIsSignedIn(true);
    return this.currentSession;
  }
  /**
   * Sets `undefined` to this.{@link currentSession} and tells this.{@link stateTracker}, session state tracker,
   * that a user has signed out.
   *
   * Does not propagate session removal to the connector like {@link removeSession}().
   *
   */
  removeLocalSession() {
    this.currentSession = void 0;
    this.stateTracker.setIsSignedIn(false);
  }
  async removeSession() {
    this.currentSession = void 0;
    await this.connector.removeSession();
    this.stateTracker.setIsSignedIn(false);
  }
  sessionState$() {
    return this.stateTracker.sessionState$();
  }
  async collapsedSessionRefresh(scopes) {
    if (this.refreshPromise) {
      return this.refreshPromise;
    }
    this.refreshPromise = this.connector.refreshSession({
      scopes: this.helper.getExtendedScope(this.currentSession, scopes)
    });
    try {
      const session = await this.refreshPromise;
      if (!this.helper.sessionExistsAndHasScope(session, scopes)) {
        throw new Error(
          "Refreshed session did not receive the required scopes"
        );
      }
      this.stateTracker.setIsSignedIn(true);
      return session;
    } finally {
      delete this.refreshPromise;
    }
  }
}

export { RefreshingAuthSessionManager };
//# sourceMappingURL=RefreshingAuthSessionManager.esm.js.map
