'use strict';

var paths = require('./paths.cjs.js');
var pLimit = require('p-limit');
var path = require('path');
var portFinder = require('portfinder');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var pLimit__default = /*#__PURE__*/_interopDefaultCompat(pLimit);
var portFinder__default = /*#__PURE__*/_interopDefaultCompat(portFinder);

async function runner(paths$1, command, options) {
  const packages = await paths.resolvePackagePaths({ paths: paths$1 });
  const limit = pLimit__default.default(options?.concurrencyLimit ?? 5);
  let port = options?.startingPort && await portFinder__default.default.getPortPromise({
    // Prevent collisions with optic which runs 8000->8999
    port: options.startingPort,
    stopPort: options.startingPort + 1e3
  });
  const resultsList = await Promise.all(
    packages.map(
      (pkg) => limit(async () => {
        let resultText = "";
        try {
          if (port)
            port = options?.startingPort && await portFinder__default.default.getPortPromise({
              // Prevent collisions with optic which runs 8000->8999
              port: port + 1,
              stopPort: options.startingPort + 1e3
            });
          console.log(`## Processing ${pkg}`);
          await command(pkg, port ? { port } : void 0);
        } catch (err) {
          resultText = err.message;
        }
        return {
          relativeDir: path.relative(paths.paths.targetRoot, pkg),
          resultText
        };
      })
    )
  );
  return resultsList;
}
async function block() {
  return new Promise(() => {
  });
}

exports.block = block;
exports.runner = runner;
//# sourceMappingURL=runner.cjs.js.map
