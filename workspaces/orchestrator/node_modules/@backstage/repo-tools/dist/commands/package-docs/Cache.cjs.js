'use strict';

var promises = require('fs/promises');
var globby = require('globby');
var path = require('path');
var crypto = require('crypto');
var fs = require('fs-extra');
var zod = require('zod');
var constants = require('./constants.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var globby__default = /*#__PURE__*/_interopDefaultCompat(globby);
var crypto__default = /*#__PURE__*/_interopDefaultCompat(crypto);

const version = "1";
const cacheEntrySchema = zod.z.object({
  hash: zod.z.string(),
  packageName: zod.z.string(),
  restoreTo: zod.z.string(),
  version: zod.z.string()
});
class PackageDocsCache {
  constructor(lockfile, cache, baseDirectory) {
    this.lockfile = lockfile;
    this.cache = cache;
    this.baseDirectory = baseDirectory;
    this.keyCache = /* @__PURE__ */ new Map();
  }
  // A map of package directory to package hash.
  keyCache;
  static async loadAsync(baseDirectory, lockfile) {
    const cacheDir = path.join(baseDirectory, constants.CACHE_DIR);
    await fs.mkdirp(cacheDir);
    const cacheFiles = await globby__default.default(`**/${constants.CACHE_FILE}`, {
      cwd: cacheDir
    });
    const map = /* @__PURE__ */ new Map();
    for (const file of cacheFiles) {
      const pkg = path.dirname(file);
      const cache = await promises.readFile(path.join(cacheDir, file), "utf-8");
      try {
        const cacheJson = JSON.parse(cache);
        const parsed = cacheEntrySchema.parse(cacheJson);
        if (parsed.version !== version) {
          console.warn(
            `Skipping cache file ${file} due to version mismatch: ${parsed.version} !== ${version}`
          );
          continue;
        }
        map.set(pkg, parsed);
      } catch (e) {
        console.error(`Skipping unparseable cache file ${file}: ${e}`);
      }
    }
    return new PackageDocsCache(lockfile, map, baseDirectory);
  }
  async directoryToName(directory) {
    const packageJson = await promises.readFile(
      path.join(this.baseDirectory, directory, "package.json"),
      "utf-8"
    );
    return JSON.parse(packageJson).name;
  }
  async toKey(pkg) {
    if (this.keyCache.has(pkg)) {
      return this.keyCache.get(pkg);
    }
    const name = await this.directoryToName(pkg);
    const result = await globby__default.default("src/**", {
      gitignore: true,
      onlyFiles: true,
      cwd: pkg
    });
    const hash = crypto__default.default.createHash("sha1");
    hash.update(version);
    hash.update("\0");
    for (const path$1 of result.sort()) {
      const absPath = path.join(this.baseDirectory, pkg, path$1);
      const pathInPackage = path.join(absPath, path$1);
      hash.update(pathInPackage);
      hash.update("\0");
      hash.update(await promises.readFile(absPath));
      hash.update("\0");
    }
    hash.update(this.lockfile.getDependencyTreeHash(name));
    hash.update("\0");
    const hashString = hash.digest("hex");
    this.keyCache.set(pkg, hashString);
    return hashString;
  }
  async has(pkg) {
    const cache = this.cache.get(pkg);
    if (!cache) {
      return false;
    }
    const hashString = await this.toKey(pkg);
    return cache.hash === hashString;
  }
  async restore(pkg) {
    if (!this.has(pkg)) {
      throw new Error(`Cache entry for ${pkg} not found`);
    }
    const cacheEntry = this.cache.get(pkg);
    const restoreTo = cacheEntry.restoreTo;
    const cacheDir = path.join(this.baseDirectory, constants.CACHE_DIR, pkg);
    const contentsDir = path.join(cacheDir, "contents");
    const targetDir = path.join(this.baseDirectory, restoreTo);
    await fs.mkdirp(targetDir);
    await promises.cp(contentsDir, targetDir, { recursive: true });
  }
  async write(pkg, contentDirectory) {
    const cacheDir = path.join(this.baseDirectory, constants.CACHE_DIR, pkg);
    const contentsDir = path.join(cacheDir, "contents");
    if (await fs.exists(contentsDir)) {
      await fs.rm(contentsDir, { recursive: true });
    } else {
      await fs.mkdirp(contentsDir);
    }
    const hashString = await this.toKey(pkg);
    await promises.cp(contentDirectory, contentsDir, { recursive: true });
    const cacheEntry = {
      hash: hashString,
      packageName: await this.directoryToName(pkg),
      restoreTo: path.relative(this.baseDirectory, contentDirectory),
      version
    };
    await promises.writeFile(path.join(cacheDir, constants.CACHE_FILE), JSON.stringify(cacheEntry));
  }
}

exports.PackageDocsCache = PackageDocsCache;
//# sourceMappingURL=Cache.cjs.js.map
