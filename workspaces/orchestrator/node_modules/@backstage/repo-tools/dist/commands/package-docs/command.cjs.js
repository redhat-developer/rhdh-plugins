'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var child_process = require('child_process');
var util = require('util');
var paths = require('../../lib/paths.cjs.js');
var utils = require('./utils.cjs.js');
var promises = require('fs/promises');
var pLimit = require('p-limit');
var fs = require('fs-extra');
var Cache = require('./Cache.cjs.js');
var cliNode = require('@backstage/cli-node');
var glob = require('glob');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var pLimit__default = /*#__PURE__*/_interopDefaultCompat(pLimit);

const limit = pLimit__default.default(8);
const execAsync = util.promisify(child_process.exec);
const EXCLUDE = [
  "packages/app",
  "packages/app-next",
  "packages/app-next-example-plugin",
  "packages/cli",
  "packages/cli-common",
  "packages/cli-node",
  "packages/e2e-test",
  "packages/e2e-test-utils",
  "packages/opaque-internal",
  "packages/techdocs-cli",
  "packages/techdocs-cli-embedded-app",
  "packages/yarn-plugin",
  "packages/backend",
  "packages/backend-legacy"
];
const HIGHLIGHT_LANGUAGES = [
  "ts",
  "tsx",
  "yaml",
  "bash",
  "sh",
  "shell",
  "yml",
  "jsx",
  "diff",
  "js",
  "json",
  "docker"
];
function getExports(packageJson) {
  if (packageJson.exports) {
    return Object.values(packageJson.exports).filter(
      (e) => !e.endsWith("package.json")
    );
  }
  return [packageJson.main];
}
async function generateDocJson(pkg) {
  const temporaryTsConfigPath = await utils.createTemporaryTsConfig(pkg);
  const packageJson = JSON.parse(
    await promises.readFile(paths.paths.resolveTargetRoot(pkg, "package.json"), "utf-8")
  );
  const exports = getExports(packageJson);
  if (!exports.length || !exports.some((e) => e.startsWith("src") || e.startsWith("./src"))) {
    return false;
  }
  await fs.mkdirp(paths.paths.resolveTargetRoot(`dist-types`, pkg));
  const { stdout, stderr } = await execAsync(
    [
      paths.paths.resolveTargetRoot("node_modules/.bin/typedoc"),
      "--json",
      paths.paths.resolveTargetRoot(`dist-types`, pkg, "docs.json"),
      "--tsconfig",
      temporaryTsConfigPath,
      "--basePath",
      paths.paths.targetRoot,
      "--skipErrorChecking",
      ...getExports(packageJson).flatMap((e) => [
        "--entryPoints",
        e
      ])
    ].join(" "),
    {
      cwd: pkg,
      env: { ...process.env, NODE_OPTIONS: "--max-old-space-size=12288" }
    }
  );
  console.log(`### Processed ${pkg}`);
  console.log(stdout);
  console.error(stderr);
  return true;
}
async function packageDocs(paths$1 = [], opts) {
  console.warn("!!! This is an experimental command !!!");
  const existingDocsJsonPaths = glob.glob.sync(
    paths.paths.resolveTargetRoot("dist-types/**/docs.json")
  );
  if (existingDocsJsonPaths.length > 0) {
    console.warn(
      `!!! Deleting all ${existingDocsJsonPaths.length} existing docs.json files !!!`
    );
    for (const path of existingDocsJsonPaths) {
      await promises.rm(path, { force: true });
    }
  }
  console.warn("!!! Deleting existing docs output !!!");
  await promises.rm(paths.paths.resolveTargetRoot("type-docs"), {
    recursive: true,
    force: true
  });
  const selectedPackageDirs = await paths.resolvePackagePaths({
    paths: paths$1,
    include: opts.include,
    exclude: opts.exclude
  });
  const cache = await Cache.PackageDocsCache.loadAsync(
    paths.paths.resolveTargetRoot(),
    await cliNode.Lockfile.load(paths.paths.resolveTargetRoot("yarn.lock"))
  );
  console.log(`### Generating docs.`);
  await Promise.all(
    selectedPackageDirs.map(
      (pkg) => limit(async () => {
        const pkgJson = JSON.parse(
          await promises.readFile(
            paths.paths.resolveTargetRoot(pkg, "package.json"),
            "utf-8"
          )
        );
        if (EXCLUDE.includes(pkg) || pkgJson.name.startsWith("@internal/")) {
          return;
        }
        if (await cache.has(pkg)) {
          console.log(`### Skipping ${pkg} due to cache hit`);
          try {
            await cache.restore(pkg);
            return;
          } catch (e) {
            console.error("Failed to restore cache for", pkg);
            console.error(e);
          }
        }
        try {
          console.log(`### Processing ${pkg}`);
          const success = await generateDocJson(pkg);
          if (success) {
            await cache.write(
              pkg,
              paths.paths.resolveTargetRoot(`dist-types`, pkg)
            );
          }
        } catch (e) {
          console.error("Failed to generate docs for", pkg);
          console.error(e);
        }
      })
    )
  );
  const generatedPackageDirs = [];
  for (const pkg of selectedPackageDirs) {
    try {
      const docsJsonPath = paths.paths.resolveTargetRoot(
        `dist-types/${pkg}/docs.json`
      );
      const docsJson = JSON.parse(await promises.readFile(docsJsonPath, "utf-8"));
      const index = docsJson.children?.find(
        (child) => child.sources.some((e) => e.fileName.endsWith("src/index.ts"))
      );
      if (index) {
        index.name = "index";
      }
      await promises.writeFile(docsJsonPath, JSON.stringify(docsJson, null, 2));
      generatedPackageDirs.push(pkg);
    } catch (e) {
      if (e.code === "ENOENT") {
        console.log("No docs.json found for", pkg);
      } else {
        throw e;
      }
    }
  }
  const { stdout, stderr } = await execAsync(
    [
      paths.paths.resolveTargetRoot("node_modules/.bin/typedoc"),
      "--entryPointStrategy",
      "merge",
      ...generatedPackageDirs.flatMap((pkg) => [
        "--entryPoints",
        `dist-types/${pkg}/docs.json`
      ]),
      ...HIGHLIGHT_LANGUAGES.flatMap((e) => ["--highlightLanguages", e]),
      "--out",
      paths.paths.resolveTargetRoot("type-docs")
    ].join(" "),
    {
      cwd: paths.paths.targetRoot
    }
  );
  console.log(stdout);
  console.error(stderr);
}

exports.default = packageDocs;
//# sourceMappingURL=command.cjs.js.map
