'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var path = require('path');
var getPackages = require('@manypkg/get-packages');
var fs = require('fs');

const desiredLocalVersionsOfDependencies = {
  "@types/react": "^18.0.0",
  react: "^18.0.2",
  "react-dom": "^18.0.2",
  "react-router-dom": "^6.3.0"
};
const peerDependencies = {
  "@types/react": "^17.0.0 || ^18.0.0",
  react: "^17.0.0 || ^18.0.0",
  "react-dom": "^17.0.0 || ^18.0.0",
  "react-router-dom": "^6.3.0"
};
const groupsOfPeerDependencies = [["@types/react", "react", "react-dom"]];
const optionalPeerDependencies = /* @__PURE__ */ new Set(["@types/react"]);
const isOptional = (dep) => {
  return optionalPeerDependencies.has(dep);
};
const isMarkedAsOptional = (dep, packageJson) => {
  return packageJson.peerDependenciesMeta?.[dep]?.optional;
};
const isDevDependency = (dep, packageJson) => {
  return !!packageJson.devDependencies?.[dep];
};
const isProdDependency = (dep, packageJson) => {
  return !!packageJson.dependencies?.[dep];
};
const isPeerDependency = (dep, packageJson) => {
  return !!packageJson.peerDependencies?.[dep];
};
const isStandaloneApplication = (packageJson) => {
  return ["cli", "frontend", "backend"].includes(
    packageJson.backstage?.role || ""
  );
};
const matchesDependency = (dep, packageJson) => {
  return packageJson.devDependencies && packageJson.devDependencies[dep] === desiredLocalVersionsOfDependencies[dep];
};
const matchesPeerDependency = (dep, packageJson) => {
  return packageJson.peerDependencies && packageJson.peerDependencies[dep] === peerDependencies[dep];
};
var peerDeps = async ({ fix }) => {
  let failed = false;
  const attemptToApplyFix = (fn) => {
    if (fix) {
      fn();
    } else {
      failed = true;
    }
  };
  const { packages } = await getPackages.getPackages(path.resolve("."));
  const packagesWithRelevantDependencies = [];
  for (const pkg of packages) {
    if (isStandaloneApplication(pkg.packageJson)) {
      continue;
    }
    const dependencies = {
      ...pkg.packageJson.dependencies,
      ...pkg.packageJson.devDependencies,
      ...pkg.packageJson.peerDependencies
    };
    for (const dep in peerDependencies) {
      if (dependencies?.[dep]) {
        packagesWithRelevantDependencies.push(pkg);
        break;
      }
    }
  }
  for (const pkg of packagesWithRelevantDependencies) {
    const packageJson = pkg.packageJson;
    for (const dep of Object.keys(peerDependencies)) {
      if (isPeerDependency(dep, packageJson)) {
        if (isOptional(dep) && !isMarkedAsOptional(dep, packageJson)) {
          console.error(
            `Optional peer dependency ${dep} in ${pkg.packageJson.name} is not marked as optional`
          );
          attemptToApplyFix(() => {
            packageJson.peerDependenciesMeta = packageJson.peerDependenciesMeta || {};
            packageJson.peerDependenciesMeta[dep] = { optional: true };
          });
        } else if (!isOptional(dep) && isMarkedAsOptional(dep, packageJson)) {
          console.error(
            `Peer dependency ${dep} in ${pkg.packageJson.name} is marked as optional but should not be`
          );
          attemptToApplyFix(() => {
            packageJson.peerDependenciesMeta = packageJson.peerDependenciesMeta || {};
            delete packageJson.peerDependenciesMeta[dep];
          });
        }
        if (!isDevDependency(dep, packageJson)) {
          console.error(
            `Peer dependency ${dep} in ${pkg.packageJson.name} is not listed as a devDependency`
          );
          attemptToApplyFix(() => {
            delete packageJson.dependencies?.[dep];
            packageJson.devDependencies = packageJson.devDependencies || {};
            packageJson.devDependencies[dep] = desiredLocalVersionsOfDependencies[dep];
          });
        } else if (isProdDependency(dep, packageJson)) {
          console.error(
            `Peer dependency ${dep} in ${pkg.packageJson.name} is listed as a dependency`
          );
          attemptToApplyFix(() => {
            delete packageJson.dependencies?.[dep];
          });
        }
        const groups = groupsOfPeerDependencies.filter(
          (group) => group.includes(dep)
        );
        if (groups.length) {
          for (const group of groups) {
            for (const groupDep of group) {
              if (!isPeerDependency(groupDep, packageJson)) {
                console.error(
                  `Peer dependency ${groupDep} in ${pkg.packageJson.name} is missing`
                );
                attemptToApplyFix(() => {
                  packageJson.peerDependencies = packageJson.peerDependencies || {};
                  packageJson.peerDependencies[groupDep] = peerDependencies[groupDep];
                });
              }
            }
          }
        }
        if (!matchesDependency(dep, packageJson)) {
          console.error(
            `Incorrect dependency ${dep} in ${pkg.packageJson.name}`
          );
          attemptToApplyFix(() => {
            packageJson.devDependencies = packageJson.devDependencies || {};
            packageJson.devDependencies[dep] = desiredLocalVersionsOfDependencies[dep];
          });
        }
        if (!matchesPeerDependency(dep, packageJson)) {
          console.error(
            `Incorrect peer dependency ${dep} in ${pkg.packageJson.name}`
          );
          attemptToApplyFix(() => {
            packageJson.peerDependencies = packageJson.peerDependencies || {};
            packageJson.peerDependencies[dep] = peerDependencies[dep];
          });
        }
      } else {
        console.error(
          `Missing peer dependency ${dep} in ${pkg.packageJson.name}`
        );
        attemptToApplyFix(() => {
          packageJson.peerDependencies = packageJson.peerDependencies || {};
          packageJson.peerDependencies[dep] = peerDependencies[dep];
        });
      }
    }
    if (fix) {
      fs.writeFileSync(
        path.resolve(pkg.dir, "package.json"),
        `${JSON.stringify(packageJson, null, 2)}
`
      );
    }
  }
  if (failed) {
    console.error("Some packages have incorrect peer dependencies");
    process.exit(1);
  }
};

exports.default = peerDeps;
//# sourceMappingURL=peer-deps.cjs.js.map
