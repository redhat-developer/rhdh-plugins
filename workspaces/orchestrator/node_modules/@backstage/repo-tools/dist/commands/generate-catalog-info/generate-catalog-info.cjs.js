'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var YAML = require('js-yaml');
var pLimit = require('p-limit');
var path = require('path');
var yamlDiffPatch = require('yaml-diff-patch');
var chalk = require('chalk');
var cliNode = require('@backstage/cli-node');
var codeowners = require('./codeowners.cjs.js');
var utils = require('./utils.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var YAML__default = /*#__PURE__*/_interopDefaultCompat(YAML);
var pLimit__default = /*#__PURE__*/_interopDefaultCompat(pLimit);
var chalk__default = /*#__PURE__*/_interopDefaultCompat(chalk);

var generateCatalogInfo = async (opts) => {
  const { dryRun = false, ci = false } = opts;
  const packages = await cliNode.PackageGraph.listTargetPackages();
  const codeowners$1 = await codeowners.loadCodeowners();
  const limit = pLimit__default.default(10);
  const isDryRun = ci ? true : dryRun;
  const checkForChanges = ci;
  const results = await Promise.allSettled(
    packages.map(
      ({ packageJson, dir }) => limit(async () => {
        if (!utils.isBackstagePackage(packageJson)) {
          return "";
        }
        const infoYamlPath = path.resolve(dir, "catalog-info.yaml");
        let yamlString = "";
        try {
          yamlString = await utils.readFile(infoYamlPath, { encoding: "utf-8" });
        } catch (e) {
          if (e.code === "ENOENT") {
            return await createCatalogInfoYaml({
              yamlPath: infoYamlPath,
              packageJson,
              codeowners: codeowners$1,
              dryRun: isDryRun
            });
          }
          throw e;
        }
        return await fixCatalogInfoYaml({
          yamlPath: infoYamlPath,
          packageJson,
          codeowners: codeowners$1,
          yamlString,
          dryRun: isDryRun,
          ci
        });
      })
    )
  );
  const rejects = results.filter(utils.isRejected);
  if (rejects.length > 0) {
    console.error(
      chalk__default.default.red("Unable to create or fix catalog-info.yaml files\n")
    );
    rejects.forEach((reject) => console.error(`  ${reject.reason}`));
    console.error();
    process.exit(1);
  }
  if (checkForChanges) {
    const instructions = results.filter(utils.isFulfilled).map((r) => r.value).filter((r) => r !== "");
    if (instructions.length > 0) {
      console.error(
        "\ncatalog-info.yaml file(s) out of sync with CODEOWNERS and/or package.json (see instructions above)\n"
      );
      process.exit(1);
    } else {
      console.error(
        "catalog-info.yaml file(s) in sync with CODEOWNERS and package.json"
      );
    }
  }
};
async function createCatalogInfoYaml(options) {
  const { codeowners: codeowners$1, dryRun, packageJson, yamlPath } = options;
  const instruction = `Create ${path.relative(".", yamlPath)}`;
  const owner = codeowners.getOwnerFromCodeowners(codeowners$1, yamlPath);
  const entity = createOrMergeEntity(packageJson, owner);
  if (dryRun) {
    console.error(instruction);
  } else {
    await utils.writeFile(yamlPath, YAML__default.default.dump(entity));
  }
  return instruction;
}
async function fixCatalogInfoYaml(options) {
  const { ci, codeowners: codeowners$1, dryRun, packageJson, yamlPath, yamlString } = options;
  const possibleOwners = codeowners.getPossibleCodeowners(
    codeowners$1,
    path.relative(".", yamlPath)
  );
  const safeName = utils.safeEntityName(packageJson.name);
  let yamlJson;
  try {
    yamlJson = YAML__default.default.load(yamlString);
  } catch (e) {
    throw new Error(`Unable to parse ${path.relative(".", yamlPath)}: ${e}`);
  }
  const badOwner = !possibleOwners.includes(yamlJson.spec?.owner);
  const badTitle = yamlJson.metadata.title !== packageJson.name;
  const badName = yamlJson.metadata.name !== safeName;
  const badType = yamlJson.spec?.type !== `backstage-${packageJson.backstage.role}`;
  if (badOwner || badTitle || badName || badType) {
    const owner = badOwner ? codeowners.getOwnerFromCodeowners(codeowners$1, yamlPath) : yamlJson.spec?.owner;
    const newJson = createOrMergeEntity(packageJson, owner, yamlJson);
    const instructions = [`Update ${path.relative(".", yamlPath)}`];
    if (ci) {
      if (badOwner) {
        instructions.push(
          `  spec.owner cannot be "${yamlJson.spec.owner}" because it must be one of (${possibleOwners.join(
            ", "
          )}) as listed in CODEOWNERS`
        );
      }
      if (badTitle) {
        instructions.push(
          `  metadata.title cannot be "${yamlJson.metadata.title}" because it must be exactly "${packageJson.name}", the package.json name`
        );
      }
      if (badName) {
        instructions.push(
          `  metadata.name cannot be "${yamlJson.metadata.name}" because it must be exactly "${safeName}", as derived from package.json name`
        );
      }
      if (badType) {
        instructions.push(
          `  spec.type cannot be "${yamlJson.spec.type}" because it must be exactly "backstage-${packageJson.backstage.role}", as derived from package.json backstage.role`
        );
      }
    }
    if (dryRun) {
      console.error(instructions.join("\n"));
    } else {
      await utils.writeFile(yamlPath, yamlDiffPatch.yamlOverwrite(yamlString, newJson));
    }
    return instructions.join("\n");
  }
  return "";
}
function createOrMergeEntity(packageJson, owner, existingEntity = {}) {
  const entityName = utils.safeEntityName(packageJson.name);
  return {
    ...existingEntity,
    apiVersion: "backstage.io/v1alpha1",
    kind: "Component",
    metadata: {
      ...existingEntity.metadata,
      // Provide default name/title/description values.
      name: entityName,
      title: packageJson.name,
      ...packageJson.description && !existingEntity.metadata?.description ? { description: packageJson.description } : void 0
    },
    spec: {
      lifecycle: "experimental",
      ...existingEntity.spec,
      type: `backstage-${packageJson.backstage.role}`,
      owner
    }
  };
}

exports.default = generateCatalogInfo;
//# sourceMappingURL=generate-catalog-info.cjs.js.map
