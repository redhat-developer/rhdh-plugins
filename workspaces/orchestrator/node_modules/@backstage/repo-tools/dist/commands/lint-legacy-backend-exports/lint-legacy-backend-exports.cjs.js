'use strict';

var tsMorph = require('ts-morph');
var cliNode = require('@backstage/cli-node');
var fs = require('fs-extra');
var paths = require('../../lib/paths.cjs.js');
var path = require('path');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var fs__default = /*#__PURE__*/_interopDefaultCompat(fs);
var path__default = /*#__PURE__*/_interopDefaultCompat(path);

const project = new tsMorph.Project({
  tsConfigFilePath: paths.paths.resolveTargetRoot("tsconfig.json")
});
function readPackageJson(pkg) {
  return JSON.parse(fs__default.default.readFileSync(path__default.default.join(pkg, "package.json"), "utf-8"));
}
async function lint(paths) {
  const pkgs = (await cliNode.PackageGraph.listTargetPackages()).filter((pkg) => {
    return pkg.packageJson.backstage?.role === "backend-plugin" || pkg.packageJson.backstage?.role === "backend-plugin-module";
  });
  if (paths.length > 0) {
    paths.forEach((pkg) => verifyIndex(pkg));
    return;
  }
  pkgs.forEach((pkg) => verifyIndex(pkg.dir, pkg.packageJson));
}
function verifyIndex(pkg, packageJson) {
  console.log(`Verifying ${pkg}`);
  const tsPath = path__default.default.join(pkg, "src/index.ts");
  const sourceFile = project.getSourceFile(tsPath);
  if (!sourceFile) {
    console.log(`Could not find ${tsPath}`);
    process.exit(1);
  }
  const symbols = sourceFile?.getExportSymbols();
  const exportCount = symbols?.length || 0;
  if (exportCount > 1) {
    console.log(
      `   \u26A0\uFE0F Warning: ${exportCount} exports found, ${symbols.map((symbol) => symbol.getName()).join(", ")}`
    );
  }
  const createRouterExport = symbols?.find(
    (symbol) => symbol.getName() === "createRouter"
  );
  if (!sourceFile.getDefaultExportSymbol()) {
    console.log("   \u274C Missing default export");
  }
  let createRouterDeprecated = void 0;
  let routerCreateRouterDeprecated = void 0;
  if (createRouterExport) {
    createRouterDeprecated = createRouterExport.getJsDocTags().find((tag) => tag.getName() === "deprecated");
    const declarations = createRouterExport?.getDeclarations();
    const firstDeclaration = declarations?.[0];
    let resolvedSymbol = void 0;
    if (firstDeclaration) {
      resolvedSymbol = createRouterExport.getAliasedSymbol();
      if (resolvedSymbol) {
        const resolvedDeclarations = resolvedSymbol.getDeclarations();
        const resolvedDeclaration = resolvedDeclarations?.[0];
        if (resolvedDeclaration) {
          routerCreateRouterDeprecated = resolvedDeclaration.getSymbol()?.getJsDocTags().find((tag) => tag.getName() === "deprecated");
        }
      }
    }
  }
  if (createRouterExport) {
    console.log("   \u274C createRouter is exported");
    if (!createRouterDeprecated && !routerCreateRouterDeprecated)
      console.log("   \u274C createRouter is NOT deprecated");
  }
  const pkgJson = packageJson ?? readPackageJson(pkg);
  if ("@backstage/backend-common" in pkgJson.dependencies || "@backstage/backend-common" in pkgJson.devDependencies) {
    console.log("   \u274C Stop depending on @backstage/backend-common");
  }
  if ("@backstage/backend-tasks" in pkgJson.dependencies || "@backstage/backend-tasks" in pkgJson.devDependencies) {
    console.log("   \u274C Stop depending on @backstage/backend-tasks");
  }
}

exports.lint = lint;
//# sourceMappingURL=lint-legacy-backend-exports.cjs.js.map
