'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var getPackages = require('@manypkg/get-packages');
var os = require('os');
var fs = require('fs-extra');
var path = require('path');
var exec = require('../../lib/exec.cjs.js');
var errors = require('@backstage/errors');
var stream = require('stream');
var promises = require('stream/promises');
var tar = require('tar');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var os__default = /*#__PURE__*/_interopDefaultCompat(os);
var fs__default = /*#__PURE__*/_interopDefaultCompat(fs);
var tar__default = /*#__PURE__*/_interopDefaultCompat(tar);

const DEFAULT_REGISTRY_URL = "https://registry.npmjs.org";
const PATCH_GITIGNORE = [
  // Avoid generating patches for source maps
  "*.map",
  // Patching package.json has no effect, so exclude
  "package.json",
  // No point patching docs
  "/*.md",
  "/docs"
];
const GIT_ENV = {
  GIT_CONFIG_NOSYSTEM: "1",
  HOME: "",
  XDG_CONFIG_HOME: "",
  USERPROFILE: ""
};
var generatePatch = async (packageArg, opts) => {
  const sourceRepo = await getPackages.getPackages(process.cwd());
  const targetRepo = await getPackages.getPackages(opts.target);
  const registryUrl = opts.registryUrl || DEFAULT_REGISTRY_URL;
  if (targetRepo.tool !== "yarn") {
    throw new Error(
      `Unable to generate patch for target repo, tool is not supported: ${targetRepo.tool}`
    );
  }
  if (sourceRepo.root.dir === targetRepo.root.dir) {
    throw new Error(
      `Unexpected workspace roots, source and target repo are the same: ${sourceRepo.root.dir}`
    );
  }
  await verifyYarnVersion(sourceRepo.root.dir);
  await verifyYarnVersion(targetRepo.root.dir);
  const sourcePkg = sourceRepo.packages.find(
    (pkg) => pkg.packageJson.name === packageArg || path.relative(sourceRepo.root.dir, pkg.dir) === packageArg
  );
  if (!sourcePkg) {
    throw new Error(`Could not find package ${packageArg} in source repo`);
  }
  const tmpDir = await fs__default.default.mkdtemp(os__default.default.tmpdir());
  const ctx = {
    sourceRepo,
    targetRepo,
    sourcePkg,
    packageName: sourcePkg.packageJson.name,
    targetRoot: targetRepo.root.dir,
    registryUrl,
    workDir: tmpDir
  };
  try {
    const updateTargetRootPkg = await loadTrimmedRootPkg(ctx, opts.query);
    console.log(
      `Building and packaging target package ${sourcePkg.packageJson.name}`
    );
    const targetArchive = await buildTargetArchive(ctx);
    console.log(`Generating patch from ${sourcePkg.packageJson.version}`);
    const patchEntry = await generatePatch$1(
      ctx,
      targetArchive,
      opts.baseVersion || sourcePkg.packageJson.version
    );
    await updateTargetRootPkg(patchEntry);
    if (!opts.skipInstall) {
      console.log("Running 'yarn install' in target workspace");
      await exec.exec("yarn", ["install"], {
        cwd: ctx.targetRoot
      }).catch(() => {
        throw new Error(
          "Failed to run 'yarn install' in target workspace, please run it manually to troubleshoot"
        );
      });
    } else {
      console.log("Skipped running 'yarn install'");
    }
  } finally {
    fs__default.default.rmSync(tmpDir, { force: true, recursive: true, maxRetries: 3 });
  }
};
async function loadTrimmedRootPkg(ctx, query) {
  const newPkgJson = JSON.parse(
    JSON.stringify(ctx.targetRepo.root.packageJson)
  );
  const resolutionsObj = newPkgJson.resolutions || (newPkgJson.resolutions = {});
  const searchEntry = query ? `${ctx.packageName}@${query}` : ctx.packageName;
  if (query || resolutionsObj[searchEntry]) {
    const existingPatchFile = tryParsePatchResolution(
      resolutionsObj[searchEntry]
    );
    if (existingPatchFile) {
      await fs__default.default.rm(path.resolve(ctx.targetRoot, existingPatchFile), {
        force: true
      });
    }
    return async (patchEntry) => {
      resolutionsObj[searchEntry] = patchEntry;
      await fs__default.default.writeJson(
        path.resolve(ctx.targetRoot, "package.json"),
        newPkgJson,
        {
          spaces: 2
        }
      );
    };
  }
  const entriesToRemove = Object.entries(resolutionsObj).filter(
    ([key]) => key.startsWith(`${ctx.packageName}@`)
  );
  for (const [key, value] of entriesToRemove) {
    delete resolutionsObj[key];
    const existingPatchFile = tryParsePatchResolution(value);
    if (existingPatchFile) {
      await fs__default.default.rm(path.resolve(ctx.targetRoot, existingPatchFile), {
        force: true
      });
    }
  }
  return async (patchEntry) => {
    resolutionsObj[ctx.packageName] = patchEntry;
    await fs__default.default.writeJson(
      path.resolve(ctx.targetRoot, "package.json"),
      newPkgJson,
      {
        spaces: 2
      }
    );
  };
}
async function verifyYarnVersion(cwd) {
  const exists = await fs__default.default.pathExists(path.join(cwd, ".yarnrc.yml"));
  if (!exists) {
    throw new Error(
      `Missing .yarnrc.yml in ${cwd}, Yarn v1 (classic) is not support by this command`
    );
  }
}
async function generatePatch$1(ctx, targetArchive, version) {
  const baseArchive = await downloadArchive(ctx, version);
  const patch = await generatePatchForArchives(ctx, baseArchive, targetArchive);
  if (!patch) {
    console.warn(`Generated patch for ${ctx.packageName} is empty`);
    return void 0;
  }
  const cleanPackageName = ctx.packageName.replace("/", "-");
  const describeResult = await exec.exec(
    "git",
    ["describe", "--always", "--dirty", "--exclude='*'"],
    {
      cwd: ctx.sourceRepo.root.dir,
      env: { ...process.env, ...GIT_ENV }
    }
  );
  const describe = describeResult.stdout.toString("utf8").trim();
  const name = `${cleanPackageName}-${version}-${describe}.patch`;
  const patchDir = path.join(ctx.targetRepo.root.dir, ".yarn", "patches");
  await fs__default.default.ensureDir(patchDir);
  await fs__default.default.writeFile(path.join(patchDir, name), patch, "utf8");
  const locator = `${ctx.sourcePkg.packageJson.name}@npm:${version}`;
  return `patch:${locator}#${path.posix.join(".", ".yarn", "patches", name)}`;
}
function tryParsePatchResolution(value) {
  if (!value) {
    return void 0;
  }
  if (!value.startsWith("patch:")) {
    return void 0;
  }
  const patchFilePath = value.split("#")[1];
  return patchFilePath;
}
async function buildTargetArchive(ctx) {
  await exec.exec("yarn", ["build"], {
    cwd: ctx.sourcePkg.dir
  });
  const archiveName = "target.tgz";
  await exec.exec("yarn", ["pack", "--out", path.join(ctx.workDir, archiveName)], {
    cwd: ctx.sourcePkg.dir
  });
  return archiveName;
}
async function downloadArchive(ctx, version) {
  const nameWithoutScope = ctx.packageName.replace(/^@.+\//, "");
  const tarName = `${nameWithoutScope}-${version}.tgz`;
  if (await fs__default.default.pathExists(path.join(ctx.workDir, tarName))) {
    return tarName;
  }
  try {
    const url = `${ctx.registryUrl}/${ctx.packageName}/-/${tarName}`;
    const res = await fetch(url);
    if (!res.ok) {
      throw new Error(
        `Request to ${url} failed with status ${res.status} ${res.statusText}`
      );
    }
    if (!res.body) {
      throw new Error("Missing response body");
    }
    const write = fs__default.default.createWriteStream(path.join(ctx.workDir, tarName));
    await promises.finished(stream.Readable.fromWeb(res.body).pipe(write));
    return tarName;
  } catch (error) {
    throw new errors.ForwardedError(
      `Failed to fetch tarball for ${ctx.packageName}@${version}`,
      error
    );
  }
}
async function generatePatchForArchives(ctx, baseArchive, headArchive) {
  const basePath = path.join(ctx.workDir, baseArchive);
  const headPath = path.join(ctx.workDir, headArchive);
  const patchDir = await fs__default.default.mkdtemp(path.join(ctx.workDir, "patch-"));
  await tar__default.default.extract({ file: basePath, cwd: patchDir, strip: 1 });
  await fs__default.default.writeFile(
    path.join(patchDir, ".gitignore"),
    PATCH_GITIGNORE.join(os__default.default.EOL)
  );
  await exec.exec("git", ["init"], {
    cwd: patchDir,
    env: { ...process.env, ...GIT_ENV }
  });
  await exec.exec("git", ["add", "."], {
    cwd: patchDir,
    env: { ...process.env, ...GIT_ENV }
  });
  await exec.exec(
    "git",
    [
      "-c",
      'user.name="patcher"',
      "-c",
      'user.email="patcher@acme.org"',
      "commit",
      "-m",
      "base"
    ],
    {
      cwd: patchDir,
      env: { ...process.env, ...GIT_ENV }
    }
  );
  for (const path$1 of await fs__default.default.readdir(patchDir)) {
    if (path$1 !== ".git" && path$1 !== ".gitignore") {
      await fs__default.default.rm(path.join(patchDir, path$1), {
        recursive: true,
        maxRetries: 3,
        force: true
      });
    }
  }
  await tar__default.default.extract({ file: headPath, cwd: patchDir, strip: 1 });
  await exec.exec("git", ["add", "."], {
    cwd: patchDir,
    env: { ...process.env, ...GIT_ENV }
  });
  const { stdout: patch } = await exec.exec(
    "git",
    [
      "-c",
      "core.safecrlf=false",
      "diff",
      "--cached",
      "--src-prefix=a/",
      "--dst-prefix=b/",
      "--ignore-cr-at-eol",
      "--full-index",
      "--no-renames",
      "--text"
    ],
    {
      cwd: patchDir,
      env: { ...process.env, ...GIT_ENV }
    }
  );
  return patch.toString("utf8");
}

exports.default = generatePatch;
//# sourceMappingURL=generate-patch.cjs.js.map
