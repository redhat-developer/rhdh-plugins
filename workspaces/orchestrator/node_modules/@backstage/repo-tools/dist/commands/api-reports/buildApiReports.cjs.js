'use strict';

var categorizePackageDirs = require('./categorizePackageDirs.cjs.js');
var paths = require('../../lib/paths.cjs.js');
var runSqlExtraction = require('./sql-reports/runSqlExtraction.cjs.js');
var runCliExtraction = require('./cli-reports/runCliExtraction.cjs.js');
var runApiExtraction = require('./api-reports/runApiExtraction.cjs.js');
var buildDocs = require('./api-reports/buildDocs.cjs.js');
var createTemporaryTsConfig = require('./api-reports/createTemporaryTsConfig.cjs.js');
var generateTypeDeclarations = require('./api-reports/generateTypeDeclarations.cjs.js');

async function buildApiReports(paths$1 = [], opts) {
  const tmpDir = paths.paths.resolveTargetRoot(
    "./node_modules/.cache/api-extractor"
  );
  const isCiBuild = opts.ci;
  const isDocsBuild = opts.docs;
  const runTsc = opts.tsc;
  const allowWarnings = parseArrayOption(opts.allowWarnings);
  const allowAllWarnings = opts.allowAllWarnings;
  const omitMessages = parseArrayOption(opts.omitMessages);
  const isAllPackages = !paths$1?.length;
  const selectedPackageDirs = await paths.resolvePackagePaths({
    paths: paths$1,
    include: opts.include,
    exclude: opts.exclude
  });
  if (isAllPackages && !isCiBuild && !isDocsBuild) {
    console.log("");
    console.log(
      "TIP: You can generate api-reports for select packages by passing package paths:"
    );
    console.log("");
    console.log(
      "       yarn build:api-reports packages/config packages/core-plugin-api plugins/*"
    );
    console.log("");
  }
  let temporaryTsConfigPath;
  if (!isAllPackages) {
    temporaryTsConfigPath = await createTemporaryTsConfig.createTemporaryTsConfig(selectedPackageDirs);
  }
  const tsconfigFilePath = temporaryTsConfigPath ?? paths.paths.resolveTargetRoot("tsconfig.json");
  if (runTsc) {
    console.log("# Compiling TypeScript");
    await generateTypeDeclarations.generateTypeDeclarations(tsconfigFilePath);
  }
  const { tsPackageDirs, cliPackageDirs, sqlPackageDirs } = await categorizePackageDirs.categorizePackageDirs(selectedPackageDirs);
  if (tsPackageDirs.length > 0) {
    console.log("# Generating package API reports");
    await runApiExtraction.runApiExtraction({
      packageDirs: tsPackageDirs,
      outputDir: tmpDir,
      isLocalBuild: !isCiBuild,
      tsconfigFilePath,
      allowWarnings: allowAllWarnings || allowWarnings,
      omitMessages: Array.isArray(omitMessages) ? omitMessages : [],
      validateReleaseTags: opts.validateReleaseTags
    });
  }
  if (cliPackageDirs.length > 0) {
    console.log("# Generating package CLI reports");
    await runCliExtraction.runCliExtraction({
      packageDirs: cliPackageDirs,
      isLocalBuild: !isCiBuild
    });
  }
  if (sqlPackageDirs.length > 0 && opts.sqlReports) {
    console.log("# Generating package SQL reports");
    await runSqlExtraction.runSqlExtraction({
      packageDirs: sqlPackageDirs,
      isLocalBuild: !isCiBuild
    });
  }
  if (isDocsBuild) {
    console.log("# Generating package documentation");
    await buildDocs.buildDocs({
      inputDir: tmpDir,
      outputDir: paths.paths.resolveTargetRoot("docs/reference")
    });
  }
}
function parseArrayOption(value) {
  return value ? value.split(",").map((s) => s.trim()).filter(Boolean) : [];
}

exports.buildApiReports = buildApiReports;
//# sourceMappingURL=buildApiReports.cjs.js.map
