'use strict';

var apiExtractor = require('@microsoft/api-extractor');
var tsdoc = require('@microsoft/tsdoc');
var tsdocConfig = require('@microsoft/tsdoc-config');
var fs = require('fs-extra');
var lodash = require('lodash');
var minimatch = require('minimatch');
var path = require('path');
var getPackageExportDetails = require('../../../lib/getPackageExportDetails.cjs.js');
var paths = require('../../../lib/paths.cjs.js');
var logApiReportInstructions = require('../common/logApiReportInstructions.cjs.js');
var patchApiReportGeneration = require('./patchApiReportGeneration.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var fs__default = /*#__PURE__*/_interopDefaultCompat(fs);

const tmpDir = paths.paths.resolveTargetRoot(
  "./node_modules/.cache/api-extractor"
);
async function countApiReportWarnings(reportPath) {
  try {
    const content = await fs__default.default.readFile(reportPath, "utf8");
    const lines = content.split("\n");
    const lineWarnings = lines.filter(
      (line) => line.includes("// Warning:")
    ).length;
    const trailerStart = lines.findIndex(
      (line) => line === "// Warnings were encountered during analysis:"
    );
    const trailerWarnings = trailerStart === -1 ? 0 : lines.length - trailerStart - 4;
    return lineWarnings + trailerWarnings;
  } catch (error) {
    if (error.code === "ENOENT") {
      return 0;
    }
    throw error;
  }
}
async function getTsDocConfig() {
  const tsdocConfigFile = await tsdocConfig.TSDocConfigFile.loadFile(
    require.resolve("@microsoft/api-extractor/extends/tsdoc-base.json")
  );
  tsdocConfigFile.addTagDefinition({
    tagName: "@ignore",
    syntaxKind: tsdoc.TSDocTagSyntaxKind.ModifierTag
  });
  tsdocConfigFile.addTagDefinition({
    tagName: "@config",
    syntaxKind: tsdoc.TSDocTagSyntaxKind.BlockTag
  });
  tsdocConfigFile.setSupportForTag("@ignore", true);
  tsdocConfigFile.setSupportForTag("@config", true);
  return tsdocConfigFile;
}
async function findPackageEntryPoints(packageDirs) {
  return Promise.all(
    packageDirs.map(async (packageDir) => {
      const pkg = await fs__default.default.readJson(
        paths.paths.resolveTargetRoot(packageDir, "package.json")
      );
      return getPackageExportDetails.getPackageExportDetails(pkg).map((details) => {
        return { packageDir, ...details };
      });
    })
  ).then((results) => results.flat());
}
async function runApiExtraction({
  packageDirs,
  outputDir,
  isLocalBuild,
  tsconfigFilePath,
  allowWarnings = false,
  omitMessages = [],
  validateReleaseTags = false
}) {
  patchApiReportGeneration.patchApiReportGeneration();
  await fs__default.default.remove(outputDir);
  const allEntryPoints = await findPackageEntryPoints(packageDirs);
  const allDistTypesEntryPointPaths = allEntryPoints.map(
    ({ packageDir, distTypesPath }) => {
      return paths.paths.resolveTargetRoot(
        "./dist-types",
        packageDir,
        distTypesPath
      );
    }
  );
  let compilerState = void 0;
  const allowWarningPkg = Array.isArray(allowWarnings) ? allowWarnings : [];
  const messagesConf = {};
  for (const messageCode of omitMessages) {
    messagesConf[messageCode] = {
      logLevel: "none"
    };
  }
  const warnings = new Array();
  for (const [packageDir, packageEntryPoints] of Object.entries(
    lodash.groupBy(allEntryPoints, (ep) => ep.packageDir)
  )) {
    console.log(`## Processing ${packageDir}`);
    const noBail = Array.isArray(allowWarnings) ? allowWarnings.some((aw) => aw === packageDir || minimatch.minimatch(packageDir, aw)) : allowWarnings;
    const projectFolder = paths.paths.resolveTargetRoot(packageDir);
    const packageFolder = paths.paths.resolveTargetRoot(
      "./dist-types",
      packageDir
    );
    const remainingReportFiles = new Set(
      fs__default.default.readdirSync(projectFolder).filter(
        (filename) => (
          // https://regex101.com/r/QDZIV0/2
          filename !== "knip-report.md" && !filename.endsWith(".sql.md") && // this has to temporarily match all old api report formats
          filename.match(/^.*?(api-)?report(-[^.-]+)?(.*?)\.md$/)
        )
      )
    );
    for (const packageEntryPoint of packageEntryPoints) {
      const suffix = packageEntryPoint.name === "index" ? "" : `-${packageEntryPoint.name}`;
      const reportFileName = `report${suffix}`;
      const reportPath = path.resolve(projectFolder, `${reportFileName}.api.md`);
      const warningCountBefore = await countApiReportWarnings(reportPath);
      const extractorConfig = apiExtractor.ExtractorConfig.prepare({
        configObject: {
          mainEntryPointFilePath: path.resolve(
            packageFolder,
            packageEntryPoint.distTypesPath
          ),
          bundledPackages: [],
          compiler: {
            tsconfigFilePath
          },
          apiReport: {
            enabled: true,
            reportFileName,
            reportFolder: projectFolder,
            reportTempFolder: path.resolve(
              outputDir,
              `<unscopedPackageName>${suffix}`
            )
          },
          docModel: {
            // TODO(Rugvip): This skips docs for non-index entry points. We can try to work around it, but
            //               most likely it makes sense to wait for API Extractor to natively support exports.
            enabled: packageEntryPoint.name === "index",
            apiJsonFilePath: path.resolve(
              outputDir,
              `<unscopedPackageName>${suffix}.api.json`
            )
          },
          dtsRollup: {
            enabled: false
          },
          tsdocMetadata: {
            enabled: false
          },
          messages: {
            // Silence compiler warnings, as these will prevent the CI build to work
            compilerMessageReporting: {
              default: {
                logLevel: "none"
                // These contain absolute file paths, so can't be included in the report
                // addToApiReportFile: true,
              }
            },
            extractorMessageReporting: {
              default: {
                logLevel: "warning",
                addToApiReportFile: true
              },
              ...messagesConf
            },
            tsdocMessageReporting: {
              default: {
                logLevel: "warning",
                addToApiReportFile: true
              }
            }
          },
          newlineKind: "lf",
          projectFolder
        },
        configObjectFullPath: projectFolder,
        packageJsonFullPath: path.resolve(projectFolder, "package.json"),
        tsdocConfigFile: await getTsDocConfig(),
        ignoreMissingEntryPoint: true
      });
      for (const reportConfig of extractorConfig.reportConfigs) {
        remainingReportFiles.delete(reportConfig.fileName);
      }
      extractorConfig.packageFolder = packageFolder;
      if (!compilerState) {
        compilerState = apiExtractor.CompilerState.create(extractorConfig, {
          additionalEntryPoints: allDistTypesEntryPointPaths
        });
      }
      apiExtractor.Extractor._checkCompilerCompatibility = () => {
      };
      let shouldLogInstructions = false;
      let conflictingFile = void 0;
      const extractorResult = apiExtractor.Extractor.invoke(extractorConfig, {
        localBuild: isLocalBuild,
        showVerboseMessages: false,
        showDiagnostics: false,
        messageCallback(message) {
          if (message.text.includes("The API report file is missing")) {
            shouldLogInstructions = true;
          }
          if (message.text.includes(
            "You have changed the API signature for this project."
          )) {
            shouldLogInstructions = true;
            const match = message.text.match(
              /Please copy the file "(.*)" to "report\.api\.md"/
            );
            if (match) {
              conflictingFile = match[1];
            }
          }
        },
        compilerState
      });
      if (validateReleaseTags && fs__default.default.pathExistsSync(extractorConfig.reportFilePath)) {
        if (["index", "alpha", "beta"].includes(packageEntryPoint.name)) {
          const report = await fs__default.default.readFile(
            extractorConfig.reportFilePath,
            "utf8"
          );
          const lines = report.split(/\r?\n/);
          const expectedTag = packageEntryPoint.name === "index" ? "public" : packageEntryPoint.name;
          for (let i = 0; i < lines.length; i += 1) {
            const line = lines[i];
            const match = line.match(/^\/\/ @(alpha|beta|public)/);
            if (match && match[1] !== expectedTag) {
              if (expectedTag !== "public" && match[1] === "public") {
                continue;
              }
              throw new Error(
                `Unexpected release tag ${match[1]} in ${extractorConfig.reportFilePath} at line ${i + 1}`
              );
            }
          }
        }
      }
      if (!extractorResult.succeeded) {
        if (shouldLogInstructions) {
          logApiReportInstructions.logApiReportInstructions();
          if (conflictingFile) {
            console.log("");
            console.log(
              `The conflicting file is ${path.relative(
                tmpDir,
                conflictingFile
              )}, with the following content:`
            );
            console.log("");
            const content = await fs__default.default.readFile(conflictingFile, "utf8");
            console.log(content);
            logApiReportInstructions.logApiReportInstructions();
          }
        }
        throw new Error(
          `API Extractor completed with ${extractorResult.errorCount} errors and ${extractorResult.warningCount} warnings`
        );
      }
      const warningCountAfter = await countApiReportWarnings(reportPath);
      if (noBail) {
        console.log(`Skipping warnings check for ${packageDir}`);
      }
      if (warningCountAfter > 0 && !noBail) {
        throw new Error(
          `The API Report for ${packageDir} is not allowed to have warnings`
        );
      }
      if (warningCountAfter === 0 && allowWarningPkg.includes(packageDir)) {
        console.log(
          `No need to allow warnings for ${packageDir}, it does not have any`
        );
      }
      if (warningCountAfter > warningCountBefore) {
        warnings.push(
          `The API Report for ${packageDir} introduces new warnings. Please fix these warnings in order to keep the API Reports tidy.`
        );
      }
    }
    if (remainingReportFiles.size > 0) {
      if (isLocalBuild) {
        for (const f of remainingReportFiles) {
          fs__default.default.rmSync(path.resolve(projectFolder, f));
          console.log(`Deleted deprecated API report ${f}`);
        }
      } else {
        const staleList = [...remainingReportFiles].map((f) => path.join(packageDir, f)).join(", ");
        throw new Error(
          `The API Report(s) ${staleList} are no longer relevant and should be deleted`
        );
      }
    }
  }
  if (warnings.length > 0) {
    console.warn();
    for (const warning of warnings) {
      console.warn(warning);
    }
    console.warn();
  }
}

exports.countApiReportWarnings = countApiReportWarnings;
exports.getTsDocConfig = getTsDocConfig;
exports.runApiExtraction = runApiExtraction;
//# sourceMappingURL=runApiExtraction.cjs.js.map
