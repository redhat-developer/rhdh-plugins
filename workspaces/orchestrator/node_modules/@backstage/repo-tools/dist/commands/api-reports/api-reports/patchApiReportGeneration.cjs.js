'use strict';

var tryRunPrettier = require('../common/tryRunPrettier.cjs.js');

let applied = false;
function patchApiReportGeneration() {
  if (applied) {
    return;
  }
  applied = true;
  const {
    ApiReportGenerator
  } = require("@microsoft/api-extractor/lib/generators/ApiReportGenerator");
  function patchFileMessageFetcher(router, transform) {
    const {
      fetchAssociatedMessagesForReviewFile,
      fetchUnassociatedMessagesForReviewFile
    } = router;
    router.fetchAssociatedMessagesForReviewFile = function patchedFetchAssociatedMessagesForReviewFile(ast) {
      const messages = fetchAssociatedMessagesForReviewFile.call(this, ast);
      return transform(messages, ast);
    };
    router.fetchUnassociatedMessagesForReviewFile = function patchedFetchUnassociatedMessagesForReviewFile() {
      const messages = fetchUnassociatedMessagesForReviewFile.call(this);
      return transform(messages);
    };
  }
  const originalGenerateReviewFileContent = ApiReportGenerator.generateReviewFileContent;
  ApiReportGenerator.generateReviewFileContent = function decoratedGenerateReviewFileContent(collector, ...moreArgs) {
    const program = collector.program;
    patchFileMessageFetcher(
      collector.messageRouter,
      (messages) => {
        return messages.filter((message) => {
          if (message.messageId !== "ae-forgotten-export") {
            return true;
          }
          const symbolMatch = message.text.match(/The symbol "([^"]+)"/);
          if (!symbolMatch) {
            throw new Error(
              `Failed to extract symbol name from message "${message.text}"`
            );
          }
          const [, symbolName] = symbolMatch;
          const sourceFile = message.sourceFilePath && program.getSourceFile(message.sourceFilePath);
          if (!sourceFile) {
            throw new Error(
              `Failed to find source file in program at path "${message.sourceFilePath}"`
            );
          }
          let localName = sourceFile.identifiers?.get(symbolName);
          if (!localName) {
            const [, trimmedSymbolName] = symbolName.match(/(.*)_\d+/) || [];
            localName = sourceFile.identifiers?.get(
              trimmedSymbolName
            );
          }
          if (!localName) {
            throw new Error(
              `Unable to find local name of "${symbolName}" in ${sourceFile.fileName}`
            );
          }
          const local = sourceFile.locals?.get(localName);
          if (!local) {
            return true;
          }
          const type = program.getTypeChecker().getDeclaredTypeOfSymbol(local);
          if (!type) {
            throw new Error(
              `Unable to find type declaration of "${symbolName}" in ${sourceFile.fileName}`
            );
          }
          const declarations = type.aliasSymbol?.declarations;
          if (!declarations || declarations.length === 0) {
            return true;
          }
          const isIgnored = declarations.some((declaration) => {
            const tags = [declaration.jsDoc].flat().filter(Boolean).flatMap((tagNode) => tagNode.tags);
            return tags.some((tag) => tag?.tagName.text === "ignore");
          });
          return !isIgnored;
        });
      }
    );
    const content = originalGenerateReviewFileContent.call(
      this,
      collector,
      ...moreArgs
    );
    return tryRunPrettier.tryRunPrettier(content);
  };
}

exports.patchApiReportGeneration = patchApiReportGeneration;
//# sourceMappingURL=patchApiReportGeneration.cjs.js.map
