'use strict';

async function getPgSchemaInfo(knex) {
  const { rows: tableNames } = await knex.raw(`
    SELECT table_name as name
    FROM information_schema.tables
    WHERE
      table_schema = 'public'
      AND table_type = 'BASE TABLE'
      AND table_name NOT LIKE 'knex_migrations%'
  `);
  const tables = Object.fromEntries(
    await Promise.all(
      tableNames.map(async ({ name }) => {
        const columns = await knex.table(name).columnInfo();
        const { rows: indices } = await knex.raw(
          `
          SELECT
            index_class.relname as name,
            index.indisunique as unique,
            index.indisprimary as primary,
            json_agg(attribute.attname ORDER BY keys.rn) as columns
          FROM
            pg_class table_class,
            pg_class index_class,
            pg_index index,
            UNNEST(index.indkey) WITH ORDINALITY keys(id, rn)
          INNER JOIN pg_attribute attribute
            ON attribute.attnum = keys.id
          WHERE
            table_class.oid = index.indrelid
            AND table_class.relkind = 'r'
            AND table_class.relname = ?
            AND index_class.oid = index.indexrelid
            AND attribute.attrelid = table_class.oid
          GROUP BY index_class.relname, index.indexrelid
        `,
          [name]
        );
        return [
          name,
          {
            name,
            columns,
            indices: Object.fromEntries(
              indices.map((index) => [index.name, index])
            )
          }
        ];
      })
    )
  );
  const { rows: sequences } = await knex.raw(`
    SELECT sequence_name as name, data_type as type
    FROM information_schema.sequences
    WHERE
      sequence_schema = 'public'
      AND sequence_name NOT LIKE 'knex_migrations%'
  `);
  return {
    tables,
    sequences: Object.fromEntries(sequences.map((seq) => [seq.name, seq]))
  };
}

exports.getPgSchemaInfo = getPgSchemaInfo;
//# sourceMappingURL=getPgSchemaInfo.cjs.js.map
