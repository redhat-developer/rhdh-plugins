'use strict';

var fs = require('fs-extra');
var path = require('path');
var paths = require('../../../lib/paths.cjs.js');
var justDiff = require('just-diff');
var getPgSchemaInfo = require('./getPgSchemaInfo.cjs.js');
var generateSqlReport = require('./generateSqlReport.cjs.js');
var tryRunPrettier = require('../common/tryRunPrettier.cjs.js');
var logApiReportInstructions = require('../common/logApiReportInstructions.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var fs__default = /*#__PURE__*/_interopDefaultCompat(fs);

async function runSqlExtraction(options) {
  const { default: Knex } = await import('knex');
  const { default: ClientPgLite } = await import('knex-pglite');
  class WrappedClientPgLite extends ClientPgLite {
    constructor(config) {
      super({ ...config, client: "pg" });
    }
  }
  let dbIndex = 1;
  for (const packageDir of options.packageDirs) {
    const migrationDir = paths.paths.resolveTargetRoot(packageDir, "migrations");
    if (!await fs__default.default.pathExists(migrationDir)) {
      console.log(`No SQL migrations found in ${packageDir}`);
      continue;
    }
    const { name: pkgName } = await fs.readJson(
      paths.paths.resolveTargetRoot(packageDir, "package.json")
    );
    const migrationFiles = await fs__default.default.readdir(migrationDir, {
      withFileTypes: true
    });
    const migrationTargets = migrationFiles.filter((entry) => entry.isDirectory()).map((entry) => entry.name);
    if (migrationFiles.some((entry) => entry.isFile())) {
      migrationTargets.push(".");
    }
    for (const migrationTarget of migrationTargets) {
      const database = `extractor-${dbIndex++}`;
      const knex = Knex({
        client: WrappedClientPgLite,
        dialect: "postgres",
        connection: {
          database
        }
      });
      await knex.raw("CREATE DATABASE ??", [database]);
      await runSingleSqlExtraction(
        packageDir,
        migrationTarget,
        pkgName,
        knex,
        options
      );
    }
  }
}
async function runSingleSqlExtraction(targetDir, migrationTarget, pkgName, knex, options) {
  const migrationDir = paths.paths.resolveTargetRoot(
    targetDir,
    "migrations",
    migrationTarget
  );
  const reportName = migrationTarget === "." ? pkgName : `${pkgName}/${migrationTarget}`;
  console.log(`Generating SQL report for ${reportName}`);
  const migrationsListResult = await knex.migrate.list({
    directory: migrationDir
  });
  const migrations = migrationsListResult[1].map(
    (m) => m.file
  );
  const schemaInfoBeforeMigration = /* @__PURE__ */ new Map();
  for (const migration of migrations) {
    const schemaInfo2 = await getPgSchemaInfo.getPgSchemaInfo(knex);
    schemaInfoBeforeMigration.set(migration, schemaInfo2);
    await knex.migrate.up({
      directory: migrationDir,
      name: migration
    });
  }
  const schemaInfo = await getPgSchemaInfo.getPgSchemaInfo(knex);
  let failedDownMigration = void 0;
  for (const migration of migrations.toReversed()) {
    await knex.migrate.down({
      directory: migrationDir,
      name: migration
    });
    const after = await getPgSchemaInfo.getPgSchemaInfo(knex);
    const before = schemaInfoBeforeMigration.get(migration);
    if (!before) {
      throw new Error(`No previous result for migration ${migration}`);
    }
    const diff = justDiff.diff(before, after);
    if (diff.length !== 0) {
      console.log(
        `Migration ${migration} is not reversible: ${JSON.stringify(
          diff,
          null,
          2
        )}`
      );
      failedDownMigration = migration;
      break;
    }
  }
  const report = tryRunPrettier.tryRunPrettier(
    generateSqlReport.generateSqlReport({
      reportName,
      failedDownMigration,
      schemaInfo
    })
  );
  const reportPath = paths.paths.resolveTargetRoot(
    targetDir,
    `report${migrationTarget === "." ? "" : `-${migrationTarget}`}.sql.md`
  );
  const existingReport = await fs__default.default.readFile(reportPath, "utf8").catch((error) => {
    if (error.code === "ENOENT") {
      return void 0;
    }
    throw error;
  });
  if (existingReport !== report) {
    if (options.isLocalBuild) {
      console.warn(`SQL report changed for ${targetDir}`);
      await fs__default.default.writeFile(reportPath, report);
    } else {
      logApiReportInstructions.logApiReportInstructions();
      if (existingReport) {
        console.log("");
        console.log(
          `The conflicting file is ${path.relative(
            paths.paths.targetRoot,
            reportPath
          )}, expecting the following content:`
        );
        console.log("");
        console.log(report);
        logApiReportInstructions.logApiReportInstructions();
      }
      throw new Error(`Report ${reportPath} is out of date`);
    }
  }
}

exports.runSqlExtraction = runSqlExtraction;
//# sourceMappingURL=runSqlExtraction.cjs.js.map
