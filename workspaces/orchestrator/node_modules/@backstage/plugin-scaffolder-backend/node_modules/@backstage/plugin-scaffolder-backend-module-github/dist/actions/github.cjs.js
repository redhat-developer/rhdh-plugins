'use strict';

var errors = require('@backstage/errors');
var octokit = require('octokit');
var pluginScaffolderNode = require('@backstage/plugin-scaffolder-node');
var helpers = require('./helpers.cjs.js');
var util = require('../util.cjs.js');
var inputProperties = require('./inputProperties.cjs.js');
var outputProperties = require('./outputProperties.cjs.js');
var github_examples = require('./github.examples.cjs.js');

function createPublishGithubAction(options) {
  const { integrations, config, githubCredentialsProvider } = options;
  return pluginScaffolderNode.createTemplateAction({
    id: "publish:github",
    description: "Initializes a git repository of contents in workspace and publishes it to GitHub.",
    examples: github_examples.examples,
    schema: {
      input: {
        repoUrl: inputProperties.repoUrl,
        description: inputProperties.description,
        homepage: inputProperties.homepage,
        access: inputProperties.access,
        bypassPullRequestAllowances: inputProperties.bypassPullRequestAllowances,
        requiredApprovingReviewCount: inputProperties.requiredApprovingReviewCount,
        restrictions: inputProperties.restrictions,
        requireCodeOwnerReviews: inputProperties.requireCodeOwnerReviews,
        dismissStaleReviews: inputProperties.dismissStaleReviews,
        requiredStatusCheckContexts: inputProperties.requiredStatusCheckContexts,
        requireBranchesToBeUpToDate: inputProperties.requireBranchesToBeUpToDate,
        requiredConversationResolution: inputProperties.requiredConversationResolution,
        requireLastPushApproval: inputProperties.requireLastPushApproval,
        repoVisibility: inputProperties.repoVisibility,
        defaultBranch: inputProperties.defaultBranch,
        protectDefaultBranch: inputProperties.protectDefaultBranch,
        protectEnforceAdmins: inputProperties.protectEnforceAdmins,
        deleteBranchOnMerge: inputProperties.deleteBranchOnMerge,
        gitCommitMessage: inputProperties.gitCommitMessage,
        gitAuthorName: inputProperties.gitAuthorName,
        gitAuthorEmail: inputProperties.gitAuthorEmail,
        allowMergeCommit: inputProperties.allowMergeCommit,
        allowSquashMerge: inputProperties.allowSquashMerge,
        squashMergeCommitTitle: inputProperties.squashMergeCommitTitle,
        squashMergeCommitMessage: inputProperties.squashMergeCommitMessage,
        allowRebaseMerge: inputProperties.allowRebaseMerge,
        allowAutoMerge: inputProperties.allowAutoMerge,
        allowUpdateBranch: inputProperties.allowUpdateBranch,
        sourcePath: inputProperties.sourcePath,
        collaborators: inputProperties.collaborators,
        hasProjects: inputProperties.hasProjects,
        hasWiki: inputProperties.hasWiki,
        hasIssues: inputProperties.hasIssues,
        token: inputProperties.token,
        topics: inputProperties.topics,
        repoVariables: inputProperties.repoVariables,
        secrets: inputProperties.secrets,
        oidcCustomization: inputProperties.oidcCustomization,
        requiredCommitSigning: inputProperties.requiredCommitSigning,
        requiredLinearHistory: inputProperties.requiredLinearHistory,
        customProperties: inputProperties.customProperties,
        subscribe: inputProperties.subscribe
      },
      output: {
        remoteUrl: outputProperties.remoteUrl,
        repoContentsUrl: outputProperties.repoContentsUrl,
        commitHash: outputProperties.commitHash
      }
    },
    async handler(ctx) {
      const {
        repoUrl,
        description,
        homepage,
        access,
        requireCodeOwnerReviews = false,
        dismissStaleReviews = false,
        bypassPullRequestAllowances,
        requiredApprovingReviewCount = 1,
        restrictions,
        requiredStatusCheckContexts = [],
        requireBranchesToBeUpToDate = true,
        requiredConversationResolution = false,
        requireLastPushApproval = false,
        repoVisibility = "private",
        defaultBranch = "main",
        protectDefaultBranch = true,
        protectEnforceAdmins = true,
        deleteBranchOnMerge = false,
        gitCommitMessage,
        gitAuthorName,
        gitAuthorEmail,
        allowMergeCommit = true,
        allowSquashMerge = true,
        squashMergeCommitTitle = "COMMIT_OR_PR_TITLE",
        squashMergeCommitMessage = "COMMIT_MESSAGES",
        allowRebaseMerge = true,
        allowAutoMerge = false,
        allowUpdateBranch = false,
        collaborators,
        hasProjects = void 0,
        hasWiki = void 0,
        hasIssues = void 0,
        topics,
        repoVariables,
        secrets,
        oidcCustomization,
        token: providedToken,
        customProperties,
        subscribe = false,
        requiredCommitSigning = false,
        requiredLinearHistory = false
      } = ctx.input;
      const { host, owner, repo } = pluginScaffolderNode.parseRepoUrl(repoUrl, integrations);
      if (!owner) {
        throw new errors.InputError("Invalid repository owner provided in repoUrl");
      }
      const octokitOptions = await util.getOctokitOptions({
        integrations,
        credentialsProvider: githubCredentialsProvider,
        token: providedToken,
        host,
        owner,
        repo
      });
      const client = new octokit.Octokit({
        ...octokitOptions,
        log: ctx.logger
      });
      const { remoteUrl, repoContentsUrl } = await ctx.checkpoint({
        key: `create.github.repo.${owner}.${repo}`,
        fn: async () => {
          const newRepo = await helpers.createGithubRepoWithCollaboratorsAndTopics(
            client,
            repo,
            owner,
            repoVisibility,
            description,
            homepage,
            deleteBranchOnMerge,
            allowMergeCommit,
            allowSquashMerge,
            squashMergeCommitTitle,
            squashMergeCommitMessage,
            allowRebaseMerge,
            allowAutoMerge,
            allowUpdateBranch,
            access,
            collaborators,
            hasProjects,
            hasWiki,
            hasIssues,
            topics,
            repoVariables,
            secrets,
            oidcCustomization,
            customProperties,
            subscribe,
            ctx.logger
          );
          return {
            remoteUrl: newRepo.clone_url,
            repoContentsUrl: `${newRepo.html_url}/blob/${defaultBranch}`
          };
        }
      });
      const commitResult = await helpers.initRepoPushAndProtect(
        remoteUrl,
        octokitOptions.auth,
        ctx.workspacePath,
        ctx.input.sourcePath,
        defaultBranch,
        protectDefaultBranch,
        protectEnforceAdmins,
        owner,
        client,
        repo,
        requireCodeOwnerReviews,
        bypassPullRequestAllowances,
        requiredApprovingReviewCount,
        restrictions,
        requiredStatusCheckContexts,
        requireBranchesToBeUpToDate,
        requiredConversationResolution,
        requireLastPushApproval,
        config,
        ctx.logger,
        gitCommitMessage,
        gitAuthorName,
        gitAuthorEmail,
        dismissStaleReviews,
        requiredCommitSigning,
        requiredLinearHistory
      );
      ctx.output("commitHash", commitResult?.commitHash);
      ctx.output("remoteUrl", remoteUrl);
      ctx.output("repoContentsUrl", repoContentsUrl);
    }
  });
}

exports.createPublishGithubAction = createPublishGithubAction;
//# sourceMappingURL=github.cjs.js.map
