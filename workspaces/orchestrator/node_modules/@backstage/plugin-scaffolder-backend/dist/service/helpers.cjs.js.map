{"version":3,"file":"helpers.cjs.js","sources":["../../src/service/helpers.ts"],"sourcesContent":["/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  BackstageCredentials,\n  LoggerService,\n} from '@backstage/backend-plugin-api';\nimport {\n  ANNOTATION_LOCATION,\n  ANNOTATION_SOURCE_LOCATION,\n  CompoundEntityRef,\n  Entity,\n  parseLocationRef,\n  stringifyEntityRef,\n} from '@backstage/catalog-model';\nimport { Config } from '@backstage/config';\nimport { assertError, InputError, NotFoundError } from '@backstage/errors';\nimport { CatalogService } from '@backstage/plugin-catalog-node';\nimport { TemplateEntityV1beta3 } from '@backstage/plugin-scaffolder-common';\nimport fs from 'fs-extra';\nimport os from 'os';\n\nexport async function getWorkingDirectory(\n  config: Config,\n  logger: LoggerService,\n): Promise<string> {\n  if (!config.has('backend.workingDirectory')) {\n    return os.tmpdir();\n  }\n\n  const workingDirectory = config.getString('backend.workingDirectory');\n  try {\n    // Check if working directory exists and is writable\n    await fs.access(workingDirectory, fs.constants.F_OK | fs.constants.W_OK);\n    logger.info(`using working directory: ${workingDirectory}`);\n  } catch (err) {\n    assertError(err);\n    logger.error(\n      `working directory ${workingDirectory} ${\n        err.code === 'ENOENT' ? 'does not exist' : 'is not writable'\n      }`,\n    );\n    throw err;\n  }\n  return workingDirectory;\n}\n\n/**\n * Gets the base URL of the entity location that points to the source location\n * of the entity description within a repo. If there is not source location\n * or if it has an invalid type, undefined will be returned instead.\n *\n * For file locations this will return a `file://` URL.\n */\nexport function getEntityBaseUrl(entity: Entity): string | undefined {\n  let location = entity.metadata.annotations?.[ANNOTATION_SOURCE_LOCATION];\n  if (!location) {\n    location = entity.metadata.annotations?.[ANNOTATION_LOCATION];\n  }\n  if (!location) {\n    return undefined;\n  }\n\n  const { type, target } = parseLocationRef(location);\n  if (type === 'url') {\n    return target;\n  } else if (type === 'file') {\n    return `file://${target}`;\n  }\n\n  // Only url and file location are handled, as we otherwise don't know if\n  // what the url is pointing to makes sense to use as a baseUrl\n  return undefined;\n}\n\n/**\n * Will use the provided CatalogApi to go find the given template entity with an additional token.\n * Returns the matching template, or throws a NotFoundError if no such template existed.\n */\nexport async function findTemplate(options: {\n  entityRef: CompoundEntityRef;\n  catalog: CatalogService;\n  credentials: BackstageCredentials;\n}): Promise<TemplateEntityV1beta3> {\n  const { entityRef, catalog, credentials } = options;\n\n  if (entityRef.kind.toLocaleLowerCase('en-US') !== 'template') {\n    throw new InputError(`Invalid kind, only 'Template' kind is supported`);\n  }\n\n  const template = await catalog.getEntityByRef(entityRef, {\n    credentials,\n  });\n  if (!template) {\n    throw new NotFoundError(\n      `Template ${stringifyEntityRef(entityRef)} not found`,\n    );\n  }\n\n  return template as TemplateEntityV1beta3;\n}\n\n/**\n * Takes a single unknown parameter and makes sure that it's a single string or\n * an array of strings, and returns as an array.\n */\nexport function parseStringsParam(\n  param: unknown,\n  paramName: string,\n): string[] | undefined {\n  if (param === undefined) {\n    return undefined;\n  }\n\n  const array = [param].flat();\n  if (array.some(p => typeof p !== 'string')) {\n    throw new InputError(\n      `Invalid ${paramName}, not a string or array of strings`,\n    );\n  }\n\n  return array as string[];\n}\n\nexport function parseNumberParam(\n  param: unknown,\n  paramName: string,\n): number[] | undefined {\n  return parseStringsParam(param, paramName)?.map(val => {\n    const ret = Number.parseInt(val, 10);\n    if (isNaN(ret)) {\n      throw new InputError(\n        `Invalid ${paramName} parameter \"${val}\", expected a number or array of numbers`,\n      );\n    }\n    return ret;\n  });\n}\n\nexport function flattenParams<T>(...params: (undefined | T | T[])[]): T[] {\n  return [...params].flat().filter(Boolean) as T[];\n}\n"],"names":["os","fs","assertError","ANNOTATION_SOURCE_LOCATION","ANNOTATION_LOCATION","parseLocationRef","InputError","NotFoundError","stringifyEntityRef"],"mappings":"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"}