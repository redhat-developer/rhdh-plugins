'use strict';

var backendPluginApi = require('@backstage/backend-plugin-api');
var catalogModel = require('@backstage/catalog-model');
var config = require('@backstage/config');
var errors = require('@backstage/errors');
var integration = require('@backstage/integration');
var pluginPermissionNode = require('@backstage/plugin-permission-node');
var pluginScaffolderCommon = require('@backstage/plugin-scaffolder-common');
var alpha = require('@backstage/plugin-scaffolder-common/alpha');
var express = require('express');
var jsonschema = require('jsonschema');
var luxon = require('luxon');
var url = require('url');
var uuid = require('uuid');
var zod = require('zod');
require('@backstage/plugin-scaffolder-node');
require('../scaffolder/actions/builtin/catalog/register.examples.cjs.js');
require('fs-extra');
require('yaml');
require('../scaffolder/actions/builtin/catalog/write.examples.cjs.js');
require('../scaffolder/actions/builtin/catalog/fetch.examples.cjs.js');
require('path');
require('../scaffolder/actions/builtin/debug/log.examples.cjs.js');
require('fs');
require('../scaffolder/actions/builtin/debug/wait.examples.cjs.js');
require('../scaffolder/actions/builtin/fetch/plain.examples.cjs.js');
require('../scaffolder/actions/builtin/fetch/plainFile.examples.cjs.js');
require('../scaffolder/actions/builtin/fetch/template.examples.cjs.js');
require('globby');
require('isbinaryfile');
var createDefaultFilters = require('../lib/templating/filters/createDefaultFilters.cjs.js');
var templating = require('../util/templating.cjs.js');
require('isolated-vm');
require('../scaffolder/actions/builtin/fetch/templateFile.examples.cjs.js');
require('../scaffolder/actions/builtin/filesystem/delete.examples.cjs.js');
require('../scaffolder/actions/builtin/filesystem/rename.examples.cjs.js');
require('fs/promises');
require('../scaffolder/actions/builtin/filesystem/read.examples.cjs.js');
var TemplateActionRegistry = require('../scaffolder/actions/TemplateActionRegistry.cjs.js');
var DatabaseTaskStore = require('../scaffolder/tasks/DatabaseTaskStore.cjs.js');
var StorageTaskBroker = require('../scaffolder/tasks/StorageTaskBroker.cjs.js');
var TaskWorker = require('../scaffolder/tasks/TaskWorker.cjs.js');
var createDryRunner = require('../scaffolder/dryrun/createDryRunner.cjs.js');
var router = require('../schema/openapi/generated/router.cjs.js');
var checkPermissions = require('../util/checkPermissions.cjs.js');
var helpers = require('./helpers.cjs.js');
var permissions = require('./permissions.cjs.js');
var rules = require('./rules.cjs.js');
var lodash = require('lodash');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var express__default = /*#__PURE__*/_interopDefaultCompat(express);

function isSupportedTemplate(entity) {
  return entity.apiVersion === "scaffolder.backstage.io/v1beta3";
}
const readDuration = (config$1, key, defaultValue) => {
  if (config$1.has(key)) {
    return config.readDurationFromConfig(config$1, { key });
  }
  return defaultValue;
};
async function createRouter(options) {
  const router$1 = await router.createOpenApiRouter({
    middleware: [
      // Be generous in upload size to support a wide range of templates in dry-run mode.
      express__default.default.json({ limit: "10MB" })
    ]
  });
  const {
    logger: parentLogger,
    config,
    database,
    catalog,
    actions = [],
    scheduler,
    additionalTemplateFilters,
    additionalTemplateGlobals,
    additionalWorkspaceProviders,
    permissions: permissions$1,
    permissionRules,
    autocompleteHandlers = {},
    events: eventsService,
    auth,
    httpAuth,
    auditor,
    actionsRegistry
  } = options;
  const concurrentTasksLimit = options.concurrentTasksLimit ?? options.config.getOptionalNumber("scaffolder.concurrentTasksLimit");
  const logger = parentLogger.child({ plugin: "scaffolder" });
  const workingDirectory = await helpers.getWorkingDirectory(config, logger);
  const integrations = integration.ScmIntegrations.fromConfig(config);
  let taskBroker;
  if (!options.taskBroker) {
    const databaseTaskStore = await DatabaseTaskStore.DatabaseTaskStore.create({
      database,
      events: eventsService
    });
    taskBroker = new StorageTaskBroker.StorageTaskBroker(
      databaseTaskStore,
      logger,
      config,
      auth,
      additionalWorkspaceProviders,
      auditor
    );
    if (scheduler && databaseTaskStore.listStaleTasks) {
      await scheduler.scheduleTask({
        id: "close_stale_tasks",
        frequency: readDuration(
          config,
          "scaffolder.taskTimeoutJanitorFrequency",
          {
            minutes: 5
          }
        ),
        timeout: { minutes: 15 },
        fn: async () => {
          const { tasks } = await databaseTaskStore.listStaleTasks({
            timeoutS: luxon.Duration.fromObject(
              readDuration(config, "scaffolder.taskTimeout", {
                hours: 24
              })
            ).as("seconds")
          });
          for (const task of tasks) {
            await databaseTaskStore.shutdownTask(task);
            logger.info(`Successfully closed stale task ${task.taskId}`);
          }
        }
      });
    }
  } else {
    taskBroker = options.taskBroker;
  }
  const actionRegistry = new TemplateActionRegistry.TemplateActionRegistry();
  const templateExtensions = {
    additionalTemplateFilters: templating.convertFiltersToRecord(
      additionalTemplateFilters
    ),
    additionalTemplateGlobals: templating.convertGlobalsToRecord(
      additionalTemplateGlobals
    )
  };
  const workers = [];
  if (concurrentTasksLimit !== 0) {
    const gracefulShutdown = config.getOptionalBoolean(
      "scaffolder.EXPERIMENTAL_gracefulShutdown"
    );
    const worker = await TaskWorker.TaskWorker.create({
      taskBroker,
      actionRegistry,
      integrations,
      logger,
      auditor,
      config,
      workingDirectory,
      concurrentTasksLimit,
      permissions: permissions$1,
      gracefulShutdown,
      ...templateExtensions
    });
    workers.push(worker);
  }
  const { actions: distributedActions } = await actionsRegistry.list({
    credentials: await auth.getOwnServiceCredentials()
  });
  for (const action of actions) {
    actionRegistry.register(action);
  }
  for (const action of distributedActions) {
    actionRegistry.register({
      id: action.id,
      description: action.description,
      examples: [],
      supportsDryRun: action.attributes?.readOnly === true && action.attributes?.destructive === false,
      handler: async (ctx) => {
        const { output } = await actionsRegistry.invoke({
          id: action.id,
          input: ctx.input,
          credentials: await ctx.getInitiatorCredentials()
        });
        if (lodash.isPlainObject(output)) {
          for (const [key, value] of Object.entries(output)) {
            ctx.output(key, value);
          }
        }
      },
      schema: {
        input: action.schema.input,
        output: action.schema.output
      }
    });
  }
  const launchWorkers = () => workers.forEach((worker) => worker.start());
  const shutdownWorkers = async () => {
    await Promise.allSettled(workers.map((worker) => worker.stop()));
  };
  if (options.lifecycle) {
    options.lifecycle.addStartupHook(launchWorkers);
    options.lifecycle.addShutdownHook(shutdownWorkers);
  } else {
    launchWorkers();
  }
  const dryRunner = createDryRunner.createDryRunner({
    actionRegistry,
    integrations,
    logger,
    auditor,
    workingDirectory,
    permissions: permissions$1,
    ...templateExtensions
  });
  const templateRules = Object.values(
    rules.scaffolderTemplateRules
  );
  const actionRules = Object.values(
    rules.scaffolderActionRules
  );
  const taskRules = Object.values(rules.scaffolderTaskRules);
  if (permissionRules) {
    templateRules.push(
      ...permissionRules.filter(permissions.isTemplatePermissionRuleInput)
    );
    actionRules.push(...permissionRules.filter(permissions.isActionPermissionRuleInput));
    taskRules.push(...permissionRules.filter(permissions.isTaskPermissionRuleInput));
  }
  const isTemplateAuthorized = pluginPermissionNode.createConditionAuthorizer(
    Object.values(templateRules)
  );
  const isTaskAuthorized = pluginPermissionNode.createConditionAuthorizer(Object.values(taskRules));
  const taskTransformConditions = pluginPermissionNode.createConditionTransformer(Object.values(taskRules));
  const permissionIntegrationRouter = pluginPermissionNode.createPermissionIntegrationRouter({
    resources: [
      {
        resourceType: alpha.RESOURCE_TYPE_SCAFFOLDER_TEMPLATE,
        permissions: alpha.scaffolderTemplatePermissions,
        rules: templateRules
      },
      {
        resourceType: alpha.RESOURCE_TYPE_SCAFFOLDER_ACTION,
        permissions: alpha.scaffolderActionPermissions,
        rules: actionRules
      },
      {
        resourceType: alpha.RESOURCE_TYPE_SCAFFOLDER_TASK,
        permissions: alpha.scaffolderTaskPermissions,
        rules: taskRules,
        getResources: async (resourceRefs) => {
          return Promise.all(
            resourceRefs.map(async (taskId) => {
              return await taskBroker.get(taskId);
            })
          );
        }
      }
    ],
    permissions: alpha.scaffolderPermissions
  });
  router$1.use(permissionIntegrationRouter);
  router$1.get(
    "/v2/templates/:namespace/:kind/:name/parameter-schema",
    async (req, res) => {
      const requestedTemplateRef = `${req.params.kind}:${req.params.namespace}/${req.params.name}`;
      const auditorEvent = await auditor?.createEvent({
        eventId: "template-parameter-schema",
        request: req,
        meta: { templateRef: requestedTemplateRef }
      });
      try {
        const credentials = await httpAuth.credentials(req);
        const template = await authorizeTemplate(req.params, credentials);
        const parameters = [template.spec.parameters ?? []].flat();
        const presentation = template.spec.presentation;
        const templateRef = `${template.kind}:${template.metadata.namespace || "default"}/${template.metadata.name}`;
        await auditorEvent?.success({ meta: { templateRef } });
        res.json({
          title: template.metadata.title ?? template.metadata.name,
          ...presentation ? { presentation } : {},
          description: template.metadata.description,
          "ui:options": template.metadata["ui:options"],
          steps: parameters.map((schema) => ({
            title: schema.title ?? "Please enter the following information",
            description: schema.description,
            schema
          })),
          EXPERIMENTAL_formDecorators: template.spec.EXPERIMENTAL_formDecorators
        });
      } catch (err) {
        await auditorEvent?.fail({ error: err });
        throw err;
      }
    }
  ).get("/v2/actions", async (req, res) => {
    const auditorEvent = await auditor?.createEvent({
      eventId: "action-fetch",
      request: req
    });
    try {
      const actionsList = actionRegistry.list().map((action) => {
        return {
          id: action.id,
          description: action.description,
          examples: action.examples,
          schema: action.schema
        };
      });
      await auditorEvent?.success();
      res.json(actionsList);
    } catch (err) {
      await auditorEvent?.fail({ error: err });
      throw err;
    }
  }).post("/v2/tasks", async (req, res) => {
    const templateRef = req.body.templateRef;
    const { kind, namespace, name } = catalogModel.parseEntityRef(templateRef, {
      defaultKind: "template"
    });
    const auditorEvent = await auditor?.createEvent({
      eventId: "task",
      severityLevel: "medium",
      request: req,
      meta: {
        actionType: "create",
        templateRef
      }
    });
    try {
      const credentials = await httpAuth.credentials(req);
      await checkPermissions.checkPermission({
        credentials,
        permissions: [alpha.taskCreatePermission],
        permissionService: permissions$1
      });
      const userEntityRef = auth.isPrincipal(credentials, "user") ? credentials.principal.userEntityRef : void 0;
      const userEntity = userEntityRef ? await catalog.getEntityByRef(userEntityRef, { credentials }) : void 0;
      let auditLog = `Scaffolding task for ${templateRef}`;
      if (userEntityRef) {
        auditLog += ` created by ${userEntityRef}`;
      }
      logger.info(auditLog);
      const values = req.body.values;
      const template = await authorizeTemplate(
        { kind, namespace, name },
        credentials
      );
      for (const parameters of [template.spec.parameters ?? []].flat()) {
        const result2 = jsonschema.validate(values, parameters);
        if (!result2.valid) {
          await auditorEvent?.fail({
            // TODO(Rugvip): Seems like there aren't proper types for AggregateError yet
            error: AggregateError(
              result2.errors,
              "Could not create entity"
            )
          });
          res.status(400).json({ errors: result2.errors });
          return;
        }
      }
      const baseUrl = helpers.getEntityBaseUrl(template);
      const taskSpec = {
        apiVersion: template.apiVersion,
        steps: template.spec.steps.map((step, index) => ({
          ...step,
          id: step.id ?? `step-${index + 1}`,
          name: step.name ?? step.action
        })),
        EXPERIMENTAL_recovery: template.spec.EXPERIMENTAL_recovery,
        output: template.spec.output ?? {},
        parameters: values,
        user: {
          entity: userEntity,
          ref: userEntityRef
        },
        templateInfo: {
          entityRef: catalogModel.stringifyEntityRef({ kind, name, namespace }),
          baseUrl,
          entity: {
            metadata: template.metadata
          }
        }
      };
      const secrets = {
        ...req.body.secrets,
        backstageToken: credentials.token,
        __initiatorCredentials: JSON.stringify({
          ...credentials,
          // credentials.token is nonenumerable and will not be serialized, so we need to add it explicitly
          token: credentials.token
        })
      };
      const result = await taskBroker.dispatch({
        spec: taskSpec,
        createdBy: userEntityRef,
        secrets
      });
      await auditorEvent?.success({ meta: { taskId: result.taskId } });
      res.status(201).json({ id: result.taskId });
    } catch (err) {
      await auditorEvent?.fail({ error: err });
      throw err;
    }
  }).get("/v2/tasks", async (req, res) => {
    const auditorEvent = await auditor?.createEvent({
      eventId: "task",
      request: req,
      meta: {
        actionType: "list"
      }
    });
    try {
      const credentials = await httpAuth.credentials(req);
      if (!taskBroker.list) {
        throw new Error(
          "TaskBroker does not support listing tasks, please implement the list method on the TaskBroker."
        );
      }
      const createdBy = helpers.parseStringsParam(req.query.createdBy, "createdBy");
      const status = helpers.parseStringsParam(req.query.status, "status");
      const order = helpers.parseStringsParam(req.query.order, "order")?.map((item) => {
        const match = item.match(/^(asc|desc):(.+)$/);
        if (!match) {
          throw new errors.InputError(
            `Invalid order parameter "${item}", expected "<asc or desc>:<field name>"`
          );
        }
        return {
          order: match[1],
          field: match[2]
        };
      });
      const { limit, offset } = req.query;
      const taskPermissionFilters = await checkPermissions.getAuthorizeConditions({
        credentials,
        permission: alpha.taskReadPermission,
        permissionService: permissions$1,
        transformConditions: taskTransformConditions
      });
      const tasks = await taskBroker.list({
        filters: {
          createdBy,
          status: status ? status : void 0
        },
        order,
        pagination: {
          limit,
          offset
        },
        permissionFilters: taskPermissionFilters
      });
      await auditorEvent?.success();
      res.status(200).json(tasks);
    } catch (err) {
      await auditorEvent?.fail({ error: err });
      throw err;
    }
  }).get("/v2/tasks/:taskId", async (req, res) => {
    const { taskId } = req.params;
    const auditorEvent = await auditor?.createEvent({
      eventId: "task",
      request: req,
      meta: {
        actionType: "get",
        taskId
      }
    });
    try {
      const credentials = await httpAuth.credentials(req);
      const task = await taskBroker.get(taskId);
      await checkPermissions.checkTaskPermission({
        credentials,
        permissions: [alpha.taskReadPermission],
        permissionService: permissions$1,
        task,
        isTaskAuthorized
      });
      if (!task) {
        throw new errors.NotFoundError(`Task with id ${taskId} does not exist`);
      }
      await auditorEvent?.success();
      delete task.secrets;
      res.status(200).json(task);
    } catch (err) {
      await auditorEvent?.fail({ error: err });
      throw err;
    }
  }).post("/v2/tasks/:taskId/cancel", async (req, res) => {
    const { taskId } = req.params;
    const auditorEvent = await auditor?.createEvent({
      eventId: "task",
      severityLevel: "medium",
      request: req,
      meta: {
        actionType: "cancel",
        taskId
      }
    });
    try {
      const credentials = await httpAuth.credentials(req);
      const task = await taskBroker.get(taskId);
      await checkPermissions.checkTaskPermission({
        credentials,
        permissions: [alpha.taskCancelPermission, alpha.taskReadPermission],
        permissionService: permissions$1,
        task,
        isTaskAuthorized
      });
      await taskBroker.cancel?.(taskId);
      await auditorEvent?.success();
      res.status(200).json({ status: "cancelled" });
    } catch (err) {
      await auditorEvent?.fail({ error: err });
      throw err;
    }
  }).post("/v2/tasks/:taskId/retry", async (req, res) => {
    const { taskId } = req.params;
    const auditorEvent = await auditor?.createEvent({
      eventId: "task",
      severityLevel: "medium",
      request: req,
      meta: {
        actionType: "retry",
        taskId
      }
    });
    try {
      const credentials = await httpAuth.credentials(req);
      const task = await taskBroker.get(taskId);
      await checkPermissions.checkPermission({
        credentials,
        permissions: [alpha.taskCreatePermission],
        permissionService: permissions$1
      });
      await checkPermissions.checkTaskPermission({
        credentials,
        permissions: [alpha.taskReadPermission],
        permissionService: permissions$1,
        task,
        isTaskAuthorized
      });
      await auditorEvent?.success();
      const { token } = await auth.getPluginRequestToken({
        onBehalfOf: credentials,
        targetPluginId: "catalog"
      });
      const secrets = {
        ...req.body.secrets,
        backstageToken: token,
        __initiatorCredentials: JSON.stringify({
          ...credentials,
          // credentials.token is nonenumerable and will not be serialized, so we need to add it explicitly
          token: credentials.token
        })
      };
      await taskBroker.retry?.({ secrets, taskId });
      res.status(201).json({ id: taskId });
    } catch (err) {
      await auditorEvent?.fail({ error: err });
      throw err;
    }
  });
  router$1.get(
    "/v2/tasks/:taskId/eventstream",
    async (req, res) => {
      const { taskId } = req.params;
      const auditorEvent = await auditor?.createEvent({
        eventId: "task",
        request: req,
        meta: {
          actionType: "stream",
          taskId
        }
      });
      try {
        const credentials = await httpAuth.credentials(req);
        const task = await taskBroker.get(taskId);
        await checkPermissions.checkTaskPermission({
          credentials,
          permissions: [alpha.taskReadPermission],
          permissionService: permissions$1,
          task,
          isTaskAuthorized
        });
        const after = req.query.after !== void 0 ? Number(req.query.after) : void 0;
        logger.debug(`Event stream observing taskId '${taskId}' opened`);
        res.writeHead(200, {
          Connection: "keep-alive",
          "Cache-Control": "no-cache",
          "Content-Type": "text/event-stream"
        });
        const subscription = taskBroker.event$({ taskId, after }).subscribe({
          error: async (error) => {
            logger.error(
              `Received error from event stream when observing taskId '${taskId}', ${error}`
            );
            await auditorEvent?.fail({ error });
            res.end();
          },
          next: ({ events }) => {
            let shouldUnsubscribe = false;
            for (const event of events) {
              res.write(
                `event: ${event.type}
data: ${JSON.stringify(event)}

`
              );
              if (event.type === "completion" && !event.isTaskRecoverable) {
                shouldUnsubscribe = true;
              }
            }
            res.flush?.();
            if (shouldUnsubscribe) {
              subscription.unsubscribe();
              res.end();
            }
          }
        });
        req.on("close", async () => {
          subscription.unsubscribe();
          logger.debug(`Event stream observing taskId '${taskId}' closed`);
          await auditorEvent?.success();
        });
      } catch (err) {
        await auditorEvent?.fail({ error: err });
        throw err;
      }
    }
  );
  router$1.get("/v2/tasks/:taskId/events", async (req, res) => {
    const { taskId } = req.params;
    const auditorEvent = await auditor?.createEvent({
      eventId: "task",
      request: req,
      meta: {
        actionType: "events",
        taskId
      }
    });
    try {
      const credentials = await httpAuth.credentials(req);
      const task = await taskBroker.get(taskId);
      await checkPermissions.checkTaskPermission({
        credentials,
        permissions: [alpha.taskReadPermission],
        permissionService: permissions$1,
        task,
        isTaskAuthorized
      });
      const after = Number(req.query.after) || void 0;
      const timeout = setTimeout(() => {
        res.json([]);
      }, 3e4);
      const subscription = taskBroker.event$({ taskId, after }).subscribe({
        error: async (error) => {
          logger.error(
            `Received error from event stream when observing taskId '${taskId}', ${error}`
          );
          await auditorEvent?.fail({ error });
        },
        next: async ({ events }) => {
          clearTimeout(timeout);
          subscription.unsubscribe();
          await auditorEvent?.success();
          res.json(events);
        }
      });
      req.on("close", () => {
        subscription.unsubscribe();
        clearTimeout(timeout);
      });
    } catch (err) {
      await auditorEvent?.fail({ error: err });
      throw err;
    }
  }).post("/v2/dry-run", async (req, res) => {
    const auditorEvent = await auditor?.createEvent({
      eventId: "task",
      request: req,
      meta: {
        actionType: "dry-run"
      }
    });
    try {
      const credentials = await httpAuth.credentials(req);
      await checkPermissions.checkPermission({
        credentials,
        permissions: [alpha.taskCreatePermission],
        permissionService: permissions$1
      });
      const bodySchema = zod.z.object({
        template: zod.z.unknown(),
        values: zod.z.record(zod.z.unknown()),
        secrets: zod.z.record(zod.z.string()).optional(),
        directoryContents: zod.z.array(
          zod.z.object({ path: zod.z.string(), base64Content: zod.z.string() })
        )
      });
      const body = await bodySchema.parseAsync(req.body).catch((e) => {
        throw new errors.InputError(`Malformed request: ${e}`);
      });
      const template = body.template;
      if (!await pluginScaffolderCommon.templateEntityV1beta3Validator.check(template)) {
        throw new errors.InputError("Input template is not a template");
      }
      const userEntityRef = auth.isPrincipal(credentials, "user") ? credentials.principal.userEntityRef : void 0;
      const userEntity = userEntityRef ? await catalog.getEntityByRef(userEntityRef, { credentials }) : void 0;
      const templateRef = `${template.kind}:${template.metadata.namespace || "default"}/${template.metadata.name}`;
      for (const parameters of [template.spec.parameters ?? []].flat()) {
        const result2 = jsonschema.validate(body.values, parameters);
        if (!result2.valid) {
          await auditorEvent?.fail({
            // TODO(Rugvip): Seems like there aren't proper types for AggregateError yet
            error: AggregateError(
              result2.errors,
              "Could not execute dry run"
            ),
            meta: {
              templateRef,
              parameters: template.spec.parameters
            }
          });
          res.status(400).json({ errors: result2.errors });
          return;
        }
      }
      const steps = template.spec.steps.map((step, index) => ({
        ...step,
        id: step.id ?? `step-${index + 1}`,
        name: step.name ?? step.action
      }));
      const dryRunId = uuid.v4();
      const contentsPath = backendPluginApi.resolveSafeChildPath(
        workingDirectory,
        `dry-run-content-${dryRunId}`
      );
      const templateInfo = {
        entityRef: "template:default/dry-run",
        entity: {
          metadata: template.metadata
        },
        baseUrl: url.pathToFileURL(
          backendPluginApi.resolveSafeChildPath(contentsPath, "template.yaml")
        ).toString()
      };
      const result = await dryRunner({
        spec: {
          apiVersion: template.apiVersion,
          steps,
          output: template.spec.output ?? {},
          parameters: body.values,
          user: {
            entity: userEntity,
            ref: userEntityRef
          }
        },
        templateInfo,
        directoryContents: (body.directoryContents ?? []).map((file) => ({
          path: file.path,
          content: Buffer.from(file.base64Content, "base64")
        })),
        secrets: {
          ...body.secrets,
          backstageToken: credentials.token
        },
        credentials
      });
      await auditorEvent?.success({
        meta: {
          templateRef,
          parameters: template.spec.parameters
        }
      });
      res.status(200).json({
        ...result,
        steps,
        directoryContents: result.directoryContents.map((file) => ({
          path: file.path,
          executable: file.executable,
          base64Content: file.content.toString("base64")
        }))
      });
    } catch (err) {
      await auditorEvent?.fail({ error: err });
      throw err;
    }
  }).post("/v2/autocomplete/:provider/:resource", async (req, res) => {
    const { token, context } = req.body;
    const { provider, resource } = req.params;
    if (!token) throw new errors.InputError("Missing token query parameter");
    if (!autocompleteHandlers[provider]) {
      throw new errors.InputError(`Unsupported provider: ${provider}`);
    }
    const { results } = await autocompleteHandlers[provider]({
      resource,
      token,
      context
    });
    res.status(200).json({ results });
  }).get("/v2/templating-extensions", async (_req, res) => {
    res.status(200).json({
      filters: {
        ...templating.extractFilterMetadata(createDefaultFilters.createDefaultFilters({ integrations })),
        ...templating.extractFilterMetadata(additionalTemplateFilters)
      },
      globals: {
        functions: templating.extractGlobalFunctionMetadata(additionalTemplateGlobals),
        values: templating.extractGlobalValueMetadata(additionalTemplateGlobals)
      }
    });
  });
  const app = express__default.default();
  app.set("logger", logger);
  app.use("/", router$1);
  async function authorizeTemplate(entityRef, credentials) {
    const template = await helpers.findTemplate({
      catalog,
      entityRef,
      credentials
    });
    if (!isSupportedTemplate(template)) {
      throw new errors.InputError(
        `Unsupported apiVersion field in schema entity, ${template.apiVersion}`
      );
    }
    if (!permissions$1) {
      return template;
    }
    const [parameterDecision, stepDecision] = await permissions$1.authorizeConditional(
      [
        { permission: alpha.templateParameterReadPermission },
        { permission: alpha.templateStepReadPermission }
      ],
      { credentials }
    );
    if (Array.isArray(template.spec.parameters)) {
      template.spec.parameters = template.spec.parameters.filter(
        (step) => isTemplateAuthorized(parameterDecision, step)
      );
    } else if (template.spec.parameters && !isTemplateAuthorized(parameterDecision, template.spec.parameters)) {
      template.spec.parameters = void 0;
    }
    template.spec.steps = template.spec.steps.filter(
      (step) => isTemplateAuthorized(stepDecision, step)
    );
    return template;
  }
  return app;
}

exports.createRouter = createRouter;
//# sourceMappingURL=router.cjs.js.map
