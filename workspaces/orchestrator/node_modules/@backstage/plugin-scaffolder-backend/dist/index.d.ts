import * as _backstage_backend_plugin_api from '@backstage/backend-plugin-api';
import { UrlReaderService, DatabaseService, LoggerService, AuthService, BackstageCredentials, AuditorService } from '@backstage/backend-plugin-api';
import * as _backstage_plugin_scaffolder_node from '@backstage/plugin-scaffolder-node';
import { TemplateFilter, TemplateGlobal, TemplateAction, TaskSecrets, SerializedTask, TaskStatus, TaskFilters, SerializedTaskEvent, TaskContext, TaskCompletionState, TaskBroker } from '@backstage/plugin-scaffolder-node';
import { ScmIntegrations } from '@backstage/integration';
import { CatalogService } from '@backstage/plugin-catalog-node';
import { HumanDuration, JsonObject } from '@backstage/types';
import { Duration } from 'luxon';
import { Knex } from 'knex';
import * as _backstage_plugin_scaffolder_common from '@backstage/plugin-scaffolder-common';
import { TaskSpec, TaskRecovery, TemplateEntityStepV1beta3, TemplateParametersV1beta3 } from '@backstage/plugin-scaffolder-common';
import { PermissionCriteria, PermissionEvaluator, PermissionRuleParams } from '@backstage/plugin-permission-common';
import { EventsService } from '@backstage/plugin-events-node';
import { Config } from '@backstage/config';
import { WorkspaceProvider, UpdateTaskCheckpointOptions } from '@backstage/plugin-scaffolder-node/alpha';
import { PermissionRule } from '@backstage/plugin-permission-node';
import { RESOURCE_TYPE_SCAFFOLDER_TEMPLATE, RESOURCE_TYPE_SCAFFOLDER_ACTION } from '@backstage/plugin-scaffolder-common/alpha';

/**
 * Scaffolder plugin
 *
 * @public
 */
declare const scaffolderPlugin: _backstage_backend_plugin_api.BackendFeature;

/**
 * Registers entities from a catalog descriptor file in the workspace into the software catalog.
 * @public
 */
declare function createCatalogRegisterAction(options: {
    catalog: CatalogService;
    integrations: ScmIntegrations;
}): _backstage_plugin_scaffolder_node.TemplateAction<{
    catalogInfoUrl: string;
    optional?: boolean | undefined;
} | {
    catalogInfoUrl: string;
    optional?: boolean | undefined;
    catalogInfoPath?: string | undefined;
} | {
    repoContentsUrl: string;
    optional?: boolean | undefined;
} | {
    repoContentsUrl: string;
    optional?: boolean | undefined;
    catalogInfoPath?: string | undefined;
}, {
    [x: string]: any;
}, "v2">;

/**
 * Writes a catalog descriptor file containing the provided entity to a path in the workspace.
 * @public
 */
declare function createCatalogWriteAction(): _backstage_plugin_scaffolder_node.TemplateAction<{
    entity: Record<string, any>;
    filePath?: string | undefined;
}, {
    [x: string]: any;
}, "v2">;

/**
 * Returns entity or entities from the catalog by entity reference(s).
 *
 * @public
 */
declare function createFetchCatalogEntityAction(options: {
    catalog: CatalogService;
}): _backstage_plugin_scaffolder_node.TemplateAction<{
    entityRef?: string | undefined;
    entityRefs?: string[] | undefined;
    optional?: boolean | undefined;
    defaultKind?: string | undefined;
    defaultNamespace?: string | undefined;
}, {
    entity?: any;
    entities?: any[] | undefined;
}, "v2">;

/**
 * Writes a message into the log or lists all files in the workspace
 *
 * @remarks
 *
 * This task is useful for local development and testing of both the scaffolder
 * and scaffolder templates.
 *
 * @public
 */
declare function createDebugLogAction(): _backstage_plugin_scaffolder_node.TemplateAction<{
    message?: string | undefined;
    listWorkspace?: boolean | "with-contents" | "with-filenames" | undefined;
}, {
    [x: string]: any;
}, "v2">;

/**
 * Waits for a certain period of time.
 *
 * @remarks
 *
 * This task is useful to give some waiting time for manual intervention.
 * Has to be used in a combination with other actions.
 *
 * @public
 */
declare function createWaitAction(options?: {
    maxWaitTime?: Duration | HumanDuration;
}): _backstage_plugin_scaffolder_node.TemplateAction<{
    minutes?: number | undefined;
    seconds?: number | undefined;
    milliseconds?: number | undefined;
}, {
    [x: string]: any;
}, "v2">;

/**
 * Downloads content and places it in the workspace, or optionally
 * in a subdirectory specified by the 'targetPath' input option.
 * @public
 */
declare function createFetchPlainAction(options: {
    reader: UrlReaderService;
    integrations: ScmIntegrations;
}): _backstage_plugin_scaffolder_node.TemplateAction<{
    url: string;
    targetPath?: string | undefined;
    token?: string | undefined;
}, {
    [x: string]: any;
}, "v2">;

/**
 * Downloads a single file and places it in the workspace.
 * @public
 */
declare function createFetchPlainFileAction(options: {
    reader: UrlReaderService;
    integrations: ScmIntegrations;
}): _backstage_plugin_scaffolder_node.TemplateAction<{
    url: string;
    targetPath: string;
    token?: string | undefined;
}, {
    [x: string]: any;
}, "v2">;

/**
 * Downloads a skeleton, templates variables into file and directory names and content.
 * Then places the result in the workspace, or optionally in a subdirectory
 * specified by the 'targetPath' input option.
 *
 * @public
 */
declare function createFetchTemplateAction(options: {
    reader: UrlReaderService;
    integrations: ScmIntegrations;
    additionalTemplateFilters?: Record<string, TemplateFilter>;
    additionalTemplateGlobals?: Record<string, TemplateGlobal>;
}): _backstage_plugin_scaffolder_node.TemplateAction<{
    url: string;
    targetPath?: string | undefined;
    values?: Record<string, any> | undefined;
    copyWithoutRender?: string[] | undefined;
    copyWithoutTemplating?: string[] | undefined;
    cookiecutterCompat?: boolean | undefined;
    templateFileExtension?: string | boolean | undefined;
    replace?: boolean | undefined;
    trimBlocks?: boolean | undefined;
    lstripBlocks?: boolean | undefined;
    token?: string | undefined;
}, {
    [x: string]: any;
}, "v2">;

/**
 * Downloads a single file and templates variables into file.
 * Then places the result in the workspace, or optionally in a subdirectory
 * specified by the 'targetPath' input option.
 * @public
 */
declare function createFetchTemplateFileAction(options: {
    reader: UrlReaderService;
    integrations: ScmIntegrations;
    additionalTemplateFilters?: Record<string, TemplateFilter>;
    additionalTemplateGlobals?: Record<string, TemplateGlobal>;
}): _backstage_plugin_scaffolder_node.TemplateAction<{
    url: string;
    targetPath: string;
    values?: Record<string, any> | undefined;
    cookiecutterCompat?: boolean | undefined;
    replace?: boolean | undefined;
    trimBlocks?: boolean | undefined;
    lstripBlocks?: boolean | undefined;
    token?: string | undefined;
}, {
    [x: string]: any;
}, "v2">;

/**
 * Creates new action that enables deletion of files and directories in the workspace.
 * @public
 */
declare const createFilesystemDeleteAction: () => _backstage_plugin_scaffolder_node.TemplateAction<{
    files: string[];
}, {
    [x: string]: any;
}, "v2">;

/**
 * Creates a new action that allows renames of files and directories in the workspace.
 * @public
 */
declare const createFilesystemRenameAction: () => _backstage_plugin_scaffolder_node.TemplateAction<{
    files: {
        from: string;
        to: string;
        overwrite?: boolean | undefined;
    }[];
}, {
    [x: string]: any;
}, "v2">;

/**
 * Creates new action that enables reading directories in the workspace.
 * @public
 */
declare const createFilesystemReadDirAction: () => _backstage_plugin_scaffolder_node.TemplateAction<{
    paths: string[];
    recursive: boolean;
}, {
    files: {
        name: string;
        path: string;
        fullPath: string;
    }[];
    folders: {
        name: string;
        path: string;
        fullPath: string;
    }[];
}, "v2">;

/**
 * Registry of all registered template actions.
 * @public
 * @deprecated this type is deprecated, and there will be a new way to create Workers in the next major version.
 */
declare class TemplateActionRegistry {
    private readonly actions;
    register(action: TemplateAction<any, any, any>): void;
    get(actionId: string): TemplateAction<any, any, any>;
    list(): TemplateAction<any, any, any>[];
}

/**
 * TaskStoreEmitOptions
 *
 * @public
 * @deprecated this type is deprecated, and there will be a new way to create Workers in the next major version.
 */
type TaskStoreEmitOptions<TBody = JsonObject> = {
    taskId: string;
    body: TBody;
};
/**
 * TaskStoreListEventsOptions
 *
 * @public
 * @deprecated this type is deprecated, and there will be a new way to create Workers in the next major version.
 */
type TaskStoreListEventsOptions = {
    isTaskRecoverable?: boolean;
    taskId: string;
    after?: number | undefined;
};
/**
 * TaskStoreShutDownTaskOptions
 *
 * @public
 * @deprecated this type is deprecated, and there will be a new way to create Workers in the next major version.
 */
type TaskStoreShutDownTaskOptions = {
    taskId: string;
};
/**
 * The options passed to {@link TaskStore.createTask}
 * @public
 * @deprecated this type is deprecated, and there will be a new way to create Workers in the next major version.
 */
type TaskStoreCreateTaskOptions = {
    spec: TaskSpec;
    createdBy?: string;
    secrets?: TaskSecrets;
};
/**
 * The options passed to {@link TaskStore.recoverTasks}
 * @public
 * @deprecated this type is deprecated, and there will be a new way to create Workers in the next major version.
 */
type TaskStoreRecoverTaskOptions = {
    timeout: HumanDuration;
};
/**
 * The response from {@link TaskStore.createTask}
 * @public
 * @deprecated this type is deprecated, and there will be a new way to create Workers in the next major version.
 */
type TaskStoreCreateTaskResult = {
    taskId: string;
};
/**
 * TaskStore
 *
 * @public
 * @deprecated this type is deprecated, and there will be a new way to create Workers in the next major version.
 */
interface TaskStore {
    cancelTask?(options: TaskStoreEmitOptions): Promise<void>;
    createTask(options: TaskStoreCreateTaskOptions): Promise<TaskStoreCreateTaskResult>;
    retryTask?(options: {
        secrets?: TaskSecrets;
        taskId: string;
    }): Promise<void>;
    recoverTasks?(options: TaskStoreRecoverTaskOptions): Promise<{
        ids: string[];
    }>;
    getTask(taskId: string): Promise<SerializedTask>;
    claimTask(): Promise<SerializedTask | undefined>;
    completeTask(options: {
        taskId: string;
        status: TaskStatus;
        eventBody: JsonObject;
    }): Promise<void>;
    heartbeatTask(taskId: string): Promise<void>;
    listStaleTasks(options: {
        timeoutS: number;
    }): Promise<{
        tasks: {
            taskId: string;
        }[];
    }>;
    list?(options: {
        filters?: {
            createdBy?: string | string[];
            status?: TaskStatus | TaskStatus[];
        };
        pagination?: {
            limit?: number;
            offset?: number;
        };
        permissionFilters?: PermissionCriteria<TaskFilters>;
        order?: {
            order: 'asc' | 'desc';
            field: string;
        }[];
    }): Promise<{
        tasks: SerializedTask[];
        totalTasks?: number;
    }>;
    /**
     * @deprecated Make sure to pass `createdBy` and `status` in the `filters` parameter instead
     */
    list?(options: {
        createdBy?: string;
        status?: TaskStatus;
        filters?: {
            createdBy?: string | string[];
            status?: TaskStatus | TaskStatus[];
        };
        pagination?: {
            limit?: number;
            offset?: number;
        };
        order?: {
            order: 'asc' | 'desc';
            field: string;
        }[];
    }): Promise<{
        tasks: SerializedTask[];
        totalTasks?: number;
    }>;
    emitLogEvent(options: TaskStoreEmitOptions): Promise<void>;
    getTaskState?({ taskId }: {
        taskId: string;
    }): Promise<{
        state: JsonObject;
    } | undefined>;
    saveTaskState?(options: {
        taskId: string;
        state?: JsonObject;
    }): Promise<void>;
    listEvents(options: TaskStoreListEventsOptions): Promise<{
        events: SerializedTaskEvent[];
    }>;
    shutdownTask?(options: TaskStoreShutDownTaskOptions): Promise<void>;
    rehydrateWorkspace?(options: {
        taskId: string;
        targetPath: string;
    }): Promise<void>;
    cleanWorkspace?({ taskId }: {
        taskId: string;
    }): Promise<void>;
    serializeWorkspace?({ path, taskId, }: {
        path: string;
        taskId: string;
    }): Promise<void>;
}

/**
 * DatabaseTaskStore
 * @deprecated this type is deprecated, and there will be a new way to create Workers in the next major version.
 * @public
 */
type DatabaseTaskStoreOptions = {
    database: DatabaseService | Knex;
    events?: EventsService;
};
/**
 * DatabaseTaskStore
 * @deprecated this type is deprecated, and there will be a new way to create Workers in the next major version.
 * @public
 */
declare class DatabaseTaskStore implements TaskStore {
    private readonly db;
    private readonly events?;
    static create(options: DatabaseTaskStoreOptions): Promise<DatabaseTaskStore>;
    private isRecoverableTask;
    private parseSpec;
    private parseTaskSecrets;
    private static getClient;
    private static runMigrations;
    private constructor();
    private getState;
    private isTaskFilter;
    private parseFilter;
    list(options: {
        createdBy?: string;
        status?: TaskStatus;
        filters?: {
            createdBy?: string | string[];
            status?: TaskStatus | TaskStatus[];
        };
        pagination?: {
            limit?: number;
            offset?: number;
        };
        order?: {
            order: 'asc' | 'desc';
            field: string;
        }[];
        permissionFilters?: PermissionCriteria<TaskFilters>;
    }): Promise<{
        tasks: SerializedTask[];
        totalTasks?: number;
    }>;
    getTask(taskId: string): Promise<SerializedTask>;
    private parseTaskRow;
    createTask(options: TaskStoreCreateTaskOptions): Promise<TaskStoreCreateTaskResult>;
    claimTask(): Promise<SerializedTask | undefined>;
    heartbeatTask(taskId: string): Promise<void>;
    listStaleTasks(options: {
        timeoutS: number;
    }): Promise<{
        tasks: {
            taskId: string;
            recovery?: TaskRecovery;
        }[];
    }>;
    completeTask(options: {
        taskId: string;
        status: TaskStatus;
        eventBody: JsonObject;
    }): Promise<void>;
    emitLogEvent(options: TaskStoreEmitOptions<{
        message: string;
    } & JsonObject>): Promise<void>;
    getTaskState({ taskId }: {
        taskId: string;
    }): Promise<{
        state: JsonObject;
    } | undefined>;
    saveTaskState(options: {
        taskId: string;
        state?: JsonObject;
    }): Promise<void>;
    listEvents(options: TaskStoreListEventsOptions): Promise<{
        events: SerializedTaskEvent[];
    }>;
    shutdownTask(options: TaskStoreShutDownTaskOptions): Promise<void>;
    rehydrateWorkspace(options: {
        taskId: string;
        targetPath: string;
    }): Promise<void>;
    cleanWorkspace({ taskId }: {
        taskId: string;
    }): Promise<void>;
    serializeWorkspace(options: {
        path: string;
        taskId: string;
    }): Promise<void>;
    cancelTask(options: TaskStoreEmitOptions<{
        message: string;
    } & JsonObject>): Promise<void>;
    retryTask?(options: {
        secrets?: TaskSecrets;
        taskId: string;
    }): Promise<void>;
    recoverTasks(options: TaskStoreRecoverTaskOptions): Promise<{
        ids: string[];
    }>;
}

/**
 * TaskManager
 * @deprecated this type is deprecated, and there will be a new way to create Workers in the next major version.
 * @public
 */
declare class TaskManager implements TaskContext {
    private readonly task;
    private readonly storage;
    private readonly signal;
    private readonly logger;
    private readonly workspaceService;
    private readonly auth?;
    private isDone;
    private heartbeatTimeoutId?;
    static create(task: CurrentClaimedTask, storage: TaskStore, abortSignal: AbortSignal, logger: LoggerService, auth?: AuthService, config?: Config, additionalWorkspaceProviders?: Record<string, WorkspaceProvider>): TaskManager;
    private constructor();
    get taskId(): string;
    get spec(): _backstage_plugin_scaffolder_common.TaskSpecV1beta3;
    get cancelSignal(): AbortSignal;
    get secrets(): TaskSecrets | undefined;
    get createdBy(): string | undefined;
    getWorkspaceName(): Promise<string>;
    rehydrateWorkspace?(options: {
        taskId: string;
        targetPath: string;
    }): Promise<void>;
    get done(): boolean;
    emitLog(message: string, logMetadata?: JsonObject): Promise<void>;
    getTaskState?(): Promise<{
        state?: JsonObject;
    } | undefined>;
    updateCheckpoint?(options: UpdateTaskCheckpointOptions): Promise<void>;
    serializeWorkspace?(options: {
        path: string;
    }): Promise<void>;
    cleanWorkspace?(): Promise<void>;
    complete(result: TaskCompletionState, metadata?: JsonObject): Promise<void>;
    private startTimeout;
    getInitiatorCredentials(): Promise<BackstageCredentials>;
}
/**
 * Stores the state of the current claimed task passed to the TaskContext
 *
 * @public
 */
interface CurrentClaimedTask {
    /**
     * The TaskSpec of the current claimed task.
     */
    spec: TaskSpec;
    /**
     * The uuid of the current claimed task.
     */
    taskId: string;
    /**
     * The secrets that are stored with the task.
     */
    secrets?: TaskSecrets;
    /**
     * The state of checkpoints of the task.
     */
    state?: JsonObject;
    /**
     * The creator of the task.
     */
    createdBy?: string;
    /**
     * The workspace of the task.
     */
    workspace?: Promise<Buffer>;
}

/**
 * CreateWorkerOptions
 * @deprecated this type is deprecated, and there will be a new way to create Workers in the next major version.
 * @public
 */
type CreateWorkerOptions = {
    taskBroker: TaskBroker;
    actionRegistry: TemplateActionRegistry;
    integrations: ScmIntegrations;
    workingDirectory: string;
    logger: LoggerService;
    auditor?: AuditorService;
    config?: Config;
    additionalTemplateFilters?: Record<string, TemplateFilter>;
    /**
     * The number of tasks that can be executed at the same time by the worker
     * @defaultValue 10
     * @example
     * ```
     * {
     *   concurrentTasksLimit: 1,
     *   // OR
     *   concurrentTasksLimit: Infinity
     * }
     * ```
     */
    concurrentTasksLimit?: number;
    additionalTemplateGlobals?: Record<string, TemplateGlobal>;
    permissions?: PermissionEvaluator;
    gracefulShutdown?: boolean;
};
/**
 * TaskWorker
 * @deprecated this type is deprecated, and there will be a new way to create Workers in the next major version.
 * @public
 */
declare class TaskWorker {
    private readonly options;
    private taskQueue;
    private logger;
    private auditor;
    private parameterAuditTransform;
    private stopWorkers;
    private constructor();
    static create(options: CreateWorkerOptions): Promise<TaskWorker>;
    recoverTasks(): Promise<void>;
    start(): void;
    stop(): Promise<void>;
    protected onReadyToClaimTask(): Promise<void>;
    runOneTask(task: TaskContext): Promise<void>;
}

/**
 * @public
 */
type TemplatePermissionRuleInput<TParams extends PermissionRuleParams = PermissionRuleParams> = PermissionRule<TemplateEntityStepV1beta3 | TemplateParametersV1beta3, {}, typeof RESOURCE_TYPE_SCAFFOLDER_TEMPLATE, TParams>;
/**
 *
 * @public
 */
type ActionPermissionRuleInput<TParams extends PermissionRuleParams = PermissionRuleParams> = PermissionRule<TemplateEntityStepV1beta3 | TemplateParametersV1beta3, {}, typeof RESOURCE_TYPE_SCAFFOLDER_ACTION, TParams>;

export { type ActionPermissionRuleInput, type CreateWorkerOptions, type CurrentClaimedTask, DatabaseTaskStore, type DatabaseTaskStoreOptions, TaskManager, type TaskStore, type TaskStoreCreateTaskOptions, type TaskStoreCreateTaskResult, type TaskStoreEmitOptions, type TaskStoreListEventsOptions, type TaskStoreRecoverTaskOptions, type TaskStoreShutDownTaskOptions, TaskWorker, TemplateActionRegistry, type TemplatePermissionRuleInput, createCatalogRegisterAction, createCatalogWriteAction, createDebugLogAction, createFetchCatalogEntityAction, createFetchPlainAction, createFetchPlainFileAction, createFetchTemplateAction, createFetchTemplateFileAction, createFilesystemDeleteAction, createFilesystemReadDirAction, createFilesystemRenameAction, createWaitAction, scaffolderPlugin as default };
