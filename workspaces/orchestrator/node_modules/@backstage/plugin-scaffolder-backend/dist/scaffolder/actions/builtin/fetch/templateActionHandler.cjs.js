'use strict';

var backendPluginApi = require('@backstage/backend-plugin-api');
var errors = require('@backstage/errors');
var fs = require('fs-extra');
var globby = require('globby');
var isbinaryfile = require('isbinaryfile');
var createDefaultFilters = require('../../../../lib/templating/filters/createDefaultFilters.cjs.js');
var templating = require('../../../../util/templating.cjs.js');
var SecureTemplater = require('../../../../lib/templating/SecureTemplater.cjs.js');
var path = require('path');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var fs__default = /*#__PURE__*/_interopDefaultCompat(fs);
var globby__default = /*#__PURE__*/_interopDefaultCompat(globby);

async function createTemplateActionHandler(options) {
  const {
    resolveTemplate,
    integrations,
    additionalTemplateFilters,
    additionalTemplateGlobals: templateGlobals,
    ctx
  } = options;
  const templateFilters = {
    ...templating.convertFiltersToRecord(createDefaultFilters.createDefaultFilters({ integrations })),
    ...additionalTemplateFilters
  };
  const { outputDir, copyOnlyPatterns, renderFilename, extension } = resolveTemplateActionSettings(ctx);
  const templateDir = await resolveTemplate();
  if (backendPluginApi.isChildPath(templateDir, outputDir)) {
    throw new errors.InputError("targetPath must not be within template path");
  }
  ctx.logger.info("Listing files and directories in template");
  const allEntriesInTemplate = await globby__default.default(`**/*`, {
    cwd: templateDir,
    dot: true,
    onlyFiles: false,
    markDirectories: true,
    followSymbolicLinks: false
  });
  const nonTemplatedEntries = new Set(
    await globby__default.default(copyOnlyPatterns || [], {
      cwd: templateDir,
      dot: true,
      onlyFiles: false,
      markDirectories: true,
      followSymbolicLinks: false
    })
  );
  const { cookiecutterCompat, values } = ctx.input;
  const context = {
    [cookiecutterCompat ? "cookiecutter" : "values"]: values
  };
  ctx.logger.info(
    `Processing ${allEntriesInTemplate.length} template files/directories with input values`,
    ctx.input.values
  );
  const renderTemplate = await SecureTemplater.SecureTemplater.loadRenderer({
    cookiecutterCompat: ctx.input.cookiecutterCompat,
    templateFilters,
    templateGlobals,
    nunjucksConfigs: {
      trimBlocks: ctx.input.trimBlocks,
      lstripBlocks: ctx.input.lstripBlocks
    }
  });
  for (const location of allEntriesInTemplate) {
    let renderContents;
    let localOutputPath = location;
    if (extension) {
      renderContents = path.extname(localOutputPath) === extension;
      if (renderContents) {
        localOutputPath = localOutputPath.slice(0, -extension.length);
      }
      localOutputPath = renderTemplate(localOutputPath, context);
    } else {
      renderContents = !nonTemplatedEntries.has(location);
      if (renderFilename) {
        localOutputPath = renderTemplate(localOutputPath, context);
      } else {
        localOutputPath = renderContents ? renderTemplate(localOutputPath, context) : localOutputPath;
      }
    }
    if (containsSkippedContent(localOutputPath)) {
      continue;
    }
    const outputPath = backendPluginApi.resolveSafeChildPath(outputDir, localOutputPath);
    if (fs__default.default.existsSync(outputPath) && !ctx.input.replace) {
      continue;
    }
    if (!renderContents && !extension) {
      ctx.logger.info(`Copying file/directory ${location} without processing.`);
    }
    if (location.endsWith("/")) {
      ctx.logger.info(`Writing directory ${location} to template output path.`);
      await fs__default.default.ensureDir(outputPath);
    } else {
      const inputFilePath = backendPluginApi.resolveSafeChildPath(templateDir, location);
      const stats = await fs__default.default.promises.lstat(inputFilePath);
      if (stats.isSymbolicLink() || await isbinaryfile.isBinaryFile(inputFilePath)) {
        ctx.logger.info(
          `Copying file binary or symbolic link at ${location}, to template output path.`
        );
        await fs__default.default.copy(inputFilePath, outputPath);
      } else {
        const statsObj = await fs__default.default.stat(inputFilePath);
        ctx.logger.info(
          `Writing file ${location} to template output path with mode ${statsObj.mode}.`
        );
        const inputFileContents = await fs__default.default.readFile(inputFilePath, "utf-8");
        await fs__default.default.outputFile(
          outputPath,
          renderContents ? renderTemplate(inputFileContents, context) : inputFileContents,
          { mode: statsObj.mode }
        );
      }
    }
  }
  ctx.logger.info(`Template result written to ${outputDir}`);
}
function resolveTemplateActionSettings(ctx) {
  const targetPath = ctx.input.targetPath ?? "./";
  const outputDir = backendPluginApi.resolveSafeChildPath(ctx.workspacePath, targetPath);
  const copyOnlyPatterns = ctx.input.copyWithoutTemplating;
  const renderFilename = true;
  if (copyOnlyPatterns && !Array.isArray(copyOnlyPatterns)) {
    throw new errors.InputError(
      "Fetch action input copyWithoutTemplating must be an Array"
    );
  }
  if (ctx.input.templateFileExtension && (copyOnlyPatterns || ctx.input.cookiecutterCompat)) {
    throw new errors.InputError(
      "Fetch action input extension incompatible with copyWithoutTemplating and cookiecutterCompat"
    );
  }
  let extension = false;
  if (ctx.input.templateFileExtension) {
    extension = ctx.input.templateFileExtension === true ? ".njk" : ctx.input.templateFileExtension;
    if (!extension.startsWith(".")) {
      extension = `.${extension}`;
    }
  }
  return {
    outputDir,
    copyOnlyPatterns,
    renderFilename,
    extension
  };
}
function containsSkippedContent(localOutputPath) {
  return localOutputPath === "" || localOutputPath.startsWith("/") || localOutputPath.includes("//");
}

exports.createTemplateActionHandler = createTemplateActionHandler;
//# sourceMappingURL=templateActionHandler.cjs.js.map
