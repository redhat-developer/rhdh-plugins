'use strict';

var errors = require('@backstage/errors');
var catalogModel = require('@backstage/catalog-model');
var pluginScaffolderNode = require('@backstage/plugin-scaffolder-node');
var register_examples = require('./register.examples.cjs.js');

const id = "catalog:register";
function createCatalogRegisterAction(options) {
  const { catalog, integrations } = options;
  return pluginScaffolderNode.createTemplateAction({
    id,
    description: "Registers entities from a catalog descriptor file in the workspace into the software catalog.",
    examples: register_examples.examples,
    schema: {
      input: (z) => z.union([
        z.object({
          catalogInfoUrl: z.string({
            description: "An absolute URL pointing to the catalog info file location"
          }),
          optional: z.boolean({
            description: "Permit the registered location to optionally exist. Default: false"
          }).optional()
        }),
        z.object({
          repoContentsUrl: z.string({
            description: "An absolute URL pointing to the root of a repository directory tree"
          }),
          catalogInfoPath: z.string({
            description: "A relative path from the repo root pointing to the catalog info file, defaults to /catalog-info.yaml"
          }).optional(),
          optional: z.boolean({
            description: "Permit the registered location to optionally exist. Default: false"
          }).optional()
        })
      ])
    },
    async handler(ctx) {
      const { input } = ctx;
      let catalogInfoUrl;
      if ("catalogInfoUrl" in input) {
        catalogInfoUrl = input.catalogInfoUrl;
      } else {
        const { repoContentsUrl, catalogInfoPath = "/catalog-info.yaml" } = input;
        const integration = integrations.byUrl(repoContentsUrl);
        if (!integration) {
          throw new errors.InputError(
            `No integration found for host ${repoContentsUrl}`
          );
        }
        catalogInfoUrl = integration.resolveUrl({
          base: repoContentsUrl,
          url: catalogInfoPath
        });
      }
      ctx.logger.info(`Registering ${catalogInfoUrl} in the catalog`);
      try {
        await catalog.addLocation(
          {
            type: "url",
            target: catalogInfoUrl
          },
          { credentials: await ctx.getInitiatorCredentials() }
        );
      } catch (e) {
        if (!input.optional) {
          throw e;
        }
      }
      try {
        const result = await catalog.addLocation(
          {
            dryRun: true,
            type: "url",
            target: catalogInfoUrl
          },
          { credentials: await ctx.getInitiatorCredentials() }
        );
        if (result.entities.length) {
          const { entities } = result;
          let entity;
          entity = entities.find(
            (e) => !e.metadata.name.startsWith("generated-") && e.kind === "Component"
          );
          if (!entity) {
            entity = entities.find(
              (e) => !e.metadata.name.startsWith("generated-")
            );
          }
          if (!entity) {
            entity = entities[0];
          }
          ctx.output("entityRef", catalogModel.stringifyEntityRef(entity));
        }
      } catch (e) {
        if (!input.optional) {
          throw e;
        }
      }
      ctx.output("catalogInfoUrl", catalogInfoUrl);
    }
  });
}

exports.createCatalogRegisterAction = createCatalogRegisterAction;
//# sourceMappingURL=register.cjs.js.map
