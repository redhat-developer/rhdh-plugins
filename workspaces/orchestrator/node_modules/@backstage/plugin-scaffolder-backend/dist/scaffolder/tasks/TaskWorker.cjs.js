'use strict';

var errors = require('@backstage/errors');
var PQueue = require('p-queue');
var NunjucksWorkflowRunner = require('./NunjucksWorkflowRunner.cjs.js');
var promises = require('timers/promises');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var PQueue__default = /*#__PURE__*/_interopDefaultCompat(PQueue);

const DEFAULT_TASK_PARAMETER_MAX_LENGTH = 256;
class TaskWorker {
  constructor(options) {
    this.options = options;
    this.stopWorkers = false;
    this.logger = options.logger;
    this.auditor = options.auditor;
    this.taskQueue = new PQueue__default.default({
      concurrency: options.concurrentTasksLimit
    });
    this.parameterAuditTransform = options.parameterAuditTransform;
  }
  taskQueue;
  logger;
  auditor;
  parameterAuditTransform;
  stopWorkers;
  static async create(options) {
    const {
      taskBroker,
      logger,
      auditor,
      config,
      actionRegistry,
      integrations,
      workingDirectory,
      additionalTemplateFilters,
      concurrentTasksLimit = 10,
      // from 1 to Infinity
      additionalTemplateGlobals,
      permissions,
      gracefulShutdown
    } = options;
    const workflowRunner = new NunjucksWorkflowRunner.NunjucksWorkflowRunner({
      actionRegistry,
      integrations,
      logger,
      auditor,
      workingDirectory,
      additionalTemplateFilters,
      additionalTemplateGlobals,
      permissions
    });
    return new TaskWorker({
      taskBroker,
      runners: { workflowRunner },
      concurrentTasksLimit,
      permissions,
      auditor,
      config,
      gracefulShutdown,
      parameterAuditTransform: createParameterTruncator(config)
    });
  }
  async recoverTasks() {
    try {
      await this.options.taskBroker.recoverTasks?.();
    } catch (err) {
      this.logger?.error(errors.stringifyError(err));
    }
  }
  start() {
    (async () => {
      while (!this.stopWorkers) {
        await promises.setTimeout(1e4);
        await this.recoverTasks();
      }
    })();
    (async () => {
      while (!this.stopWorkers) {
        await this.onReadyToClaimTask();
        if (!this.stopWorkers) {
          const task = await this.options.taskBroker.claim();
          void this.taskQueue.add(() => this.runOneTask(task));
        }
      }
    })();
  }
  async stop() {
    this.stopWorkers = true;
    if (this.options?.gracefulShutdown) {
      while (this.taskQueue.size > 0) {
        await promises.setTimeout(1e3);
      }
    }
  }
  onReadyToClaimTask() {
    if (this.taskQueue.pending < this.options.concurrentTasksLimit) {
      return Promise.resolve();
    }
    return new Promise((resolve) => {
      this.taskQueue.once("next", () => {
        resolve();
      });
    });
  }
  async runOneTask(task) {
    const auditorEvent = await this.auditor?.createEvent({
      eventId: "task",
      severityLevel: "medium",
      meta: {
        actionType: "execution",
        createdBy: task.createdBy,
        taskId: task.taskId,
        taskParameters: this.parameterAuditTransform(task.spec.parameters),
        templateRef: task.spec.templateInfo?.entityRef
      }
    });
    try {
      if (task.spec.apiVersion !== "scaffolder.backstage.io/v1beta3") {
        throw new Error(
          `Unsupported Template apiVersion ${task.spec.apiVersion}`
        );
      }
      const { output } = await this.options.runners.workflowRunner.execute(
        task
      );
      await task.complete("completed", { output });
      await auditorEvent?.success();
    } catch (error) {
      errors.assertError(error);
      await auditorEvent?.fail({
        error
      });
      await task.complete("failed", {
        error: { name: error.name, message: error.message }
      });
    }
  }
}
function createParameterTruncator(config) {
  const maxLength = config?.getOptionalNumber("scaffolder.auditor.taskParameterMaxLength") ?? DEFAULT_TASK_PARAMETER_MAX_LENGTH;
  if (!Number.isSafeInteger(maxLength) || maxLength < -1) {
    throw new errors.InputError(
      `Invalid configuration for 'scaffolder.auditor.taskParameterMaxLength', got ${maxLength}. Must be a positive integer or -1 to disable truncation.`
    );
  }
  if (maxLength === -1) {
    return (parameters) => parameters;
  }
  return (parameters) => {
    function truncate(value) {
      if (typeof value === "string") {
        if (value.length > maxLength) {
          return value.slice(0, maxLength).concat("...<truncated>");
        }
        return value;
      }
      if (Array.isArray(value)) {
        return value.map(truncate);
      }
      if (value && typeof value === "object") {
        const result = {};
        for (const k in value) {
          if (Object.hasOwn(value, k)) {
            result[k] = truncate(value[k]);
          }
        }
        return result;
      }
      return value;
    }
    return truncate(parameters);
  };
}

exports.TaskWorker = TaskWorker;
exports.createParameterTruncator = createParameterTruncator;
//# sourceMappingURL=TaskWorker.cjs.js.map
