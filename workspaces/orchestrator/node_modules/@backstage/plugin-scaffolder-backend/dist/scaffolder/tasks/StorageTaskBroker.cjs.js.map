{"version":3,"file":"StorageTaskBroker.cjs.js","sources":["../../../src/scaffolder/tasks/StorageTaskBroker.ts"],"sourcesContent":["/*\n * Copyright 2021 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  AuditorService,\n  AuthService,\n  BackstageCredentials,\n  LoggerService,\n} from '@backstage/backend-plugin-api';\nimport { Config } from '@backstage/config';\nimport { TaskSpec } from '@backstage/plugin-scaffolder-common';\nimport {\n  SerializedTask,\n  SerializedTaskEvent,\n  TaskBroker,\n  TaskBrokerDispatchOptions,\n  TaskCompletionState,\n  TaskContext,\n  TaskFilters,\n  TaskSecrets,\n  TaskStatus,\n} from '@backstage/plugin-scaffolder-node';\nimport {\n  CheckpointState,\n  WorkspaceProvider,\n  UpdateTaskCheckpointOptions,\n} from '@backstage/plugin-scaffolder-node/alpha';\nimport { JsonObject, Observable, createDeferred } from '@backstage/types';\nimport ObservableImpl from 'zen-observable';\nimport { DefaultWorkspaceService, WorkspaceService } from './WorkspaceService';\nimport { readDuration } from './helper';\nimport { InternalTaskSecrets, TaskStore } from './types';\nimport { PermissionCriteria } from '@backstage/plugin-permission-common';\n\ntype TaskState = {\n  checkpoints: CheckpointState;\n};\n/**\n * TaskManager\n * @deprecated this type is deprecated, and there will be a new way to create Workers in the next major version.\n * @public\n */\nexport class TaskManager implements TaskContext {\n  private isDone = false;\n\n  private heartbeatTimeoutId?: ReturnType<typeof setInterval>;\n\n  static create(\n    task: CurrentClaimedTask,\n    storage: TaskStore,\n    abortSignal: AbortSignal,\n    logger: LoggerService,\n    auth?: AuthService,\n    config?: Config,\n    additionalWorkspaceProviders?: Record<string, WorkspaceProvider>,\n  ) {\n    const workspaceService = DefaultWorkspaceService.create(\n      task,\n      storage,\n      additionalWorkspaceProviders,\n      config,\n    );\n\n    const agent = new TaskManager(\n      task,\n      storage,\n      abortSignal,\n      logger,\n      workspaceService,\n      auth,\n    );\n    agent.startTimeout();\n    return agent;\n  }\n\n  // Runs heartbeat internally\n  private constructor(\n    private readonly task: CurrentClaimedTask,\n    private readonly storage: TaskStore,\n    private readonly signal: AbortSignal,\n    private readonly logger: LoggerService,\n    private readonly workspaceService: WorkspaceService,\n    private readonly auth?: AuthService,\n  ) {}\n\n  get taskId() {\n    return this.task.taskId;\n  }\n\n  get spec() {\n    return this.task.spec;\n  }\n\n  get cancelSignal() {\n    return this.signal;\n  }\n\n  get secrets() {\n    return this.task.secrets;\n  }\n\n  get createdBy() {\n    return this.task.createdBy;\n  }\n\n  async getWorkspaceName() {\n    return this.task.taskId;\n  }\n\n  async rehydrateWorkspace?(options: {\n    taskId: string;\n    targetPath: string;\n  }): Promise<void> {\n    await this.workspaceService.rehydrateWorkspace(options);\n  }\n\n  get done() {\n    return this.isDone;\n  }\n\n  async emitLog(message: string, logMetadata?: JsonObject): Promise<void> {\n    await this.storage.emitLogEvent({\n      taskId: this.task.taskId,\n      body: { message, ...logMetadata },\n    });\n  }\n\n  async getTaskState?(): Promise<\n    | {\n        state?: JsonObject;\n      }\n    | undefined\n  > {\n    return this.storage.getTaskState?.({ taskId: this.task.taskId });\n  }\n\n  async updateCheckpoint?(options: UpdateTaskCheckpointOptions): Promise<void> {\n    const { key, ...value } = options;\n\n    if (this.task.state) {\n      (this.task.state as TaskState).checkpoints[key] = value;\n    } else {\n      this.task.state = { checkpoints: { [key]: value } };\n    }\n    await this.storage.saveTaskState?.({\n      taskId: this.task.taskId,\n      state: this.task.state,\n    });\n  }\n\n  async serializeWorkspace?(options: { path: string }): Promise<void> {\n    await this.workspaceService.serializeWorkspace(options);\n  }\n\n  async cleanWorkspace?(): Promise<void> {\n    await this.workspaceService.cleanWorkspace();\n  }\n\n  async complete(\n    result: TaskCompletionState,\n    metadata?: JsonObject,\n  ): Promise<void> {\n    await this.storage.completeTask({\n      taskId: this.task.taskId,\n      status: result === 'failed' ? 'failed' : 'completed',\n      eventBody: {\n        message: `Run completed with status: ${result}`,\n        ...metadata,\n      },\n    });\n    this.isDone = true;\n    if (this.heartbeatTimeoutId) {\n      clearTimeout(this.heartbeatTimeoutId);\n    }\n  }\n\n  private startTimeout() {\n    this.heartbeatTimeoutId = setTimeout(async () => {\n      try {\n        await this.storage.heartbeatTask(this.task.taskId);\n        this.startTimeout();\n      } catch (error) {\n        this.isDone = true;\n\n        this.logger.error(\n          `Heartbeat for task ${this.task.taskId} failed`,\n          error,\n        );\n      }\n    }, 1000);\n  }\n\n  async getInitiatorCredentials(): Promise<BackstageCredentials> {\n    const secrets = this.task.secrets as InternalTaskSecrets;\n\n    if (secrets && secrets.__initiatorCredentials) {\n      return JSON.parse(secrets.__initiatorCredentials);\n    }\n    if (!this.auth) {\n      throw new Error(\n        'Failed to create none credentials in scaffolder task. The TaskManager has not been initialized with an auth service implementation',\n      );\n    }\n    return this.auth.getNoneCredentials();\n  }\n}\n\n/**\n * Stores the state of the current claimed task passed to the TaskContext\n *\n * @public\n */\nexport interface CurrentClaimedTask {\n  /**\n   * The TaskSpec of the current claimed task.\n   */\n  spec: TaskSpec;\n  /**\n   * The uuid of the current claimed task.\n   */\n  taskId: string;\n  /**\n   * The secrets that are stored with the task.\n   */\n  secrets?: TaskSecrets;\n  /**\n   * The state of checkpoints of the task.\n   */\n  state?: JsonObject;\n  /**\n   * The creator of the task.\n   */\n  createdBy?: string;\n  /**\n   * The workspace of the task.\n   */\n  workspace?: Promise<Buffer>;\n}\n\nexport class StorageTaskBroker implements TaskBroker {\n  constructor(\n    private readonly storage: TaskStore,\n    private readonly logger: LoggerService,\n    private readonly config?: Config,\n    private readonly auth?: AuthService,\n    private readonly additionalWorkspaceProviders?: Record<\n      string,\n      WorkspaceProvider\n    >,\n    private readonly auditor?: AuditorService,\n  ) {}\n\n  async list(options?: {\n    createdBy?: string;\n    status?: TaskStatus;\n    filters?: {\n      createdBy?: string | string[];\n      status?: TaskStatus | TaskStatus[];\n    };\n    pagination?: {\n      limit?: number;\n      offset?: number;\n    };\n    order?: { order: 'asc' | 'desc'; field: string }[];\n    permissionFilters?: PermissionCriteria<TaskFilters>;\n  }): Promise<{ tasks: SerializedTask[]; totalTasks?: number }> {\n    if (!this.storage.list) {\n      throw new Error(\n        'TaskStore does not implement the list method. Please implement the list method to be able to list tasks',\n      );\n    }\n    return await this.storage.list(options ?? {});\n  }\n\n  private deferredDispatch = createDeferred();\n\n  private async registerCancellable(\n    taskId: string,\n    abortController: AbortController,\n  ) {\n    let shouldUnsubscribe = false;\n    const subscription = this.event$({ taskId, after: undefined }).subscribe({\n      error: _ => {\n        subscription.unsubscribe();\n      },\n      next: ({ events }) => {\n        for (const event of events) {\n          if (event.type === 'cancelled') {\n            abortController.abort();\n            shouldUnsubscribe = true;\n          }\n\n          if (event.type === 'completion' && !event.isTaskRecoverable) {\n            shouldUnsubscribe = true;\n          }\n        }\n        if (shouldUnsubscribe) {\n          subscription.unsubscribe();\n        }\n      },\n    });\n  }\n\n  public async recoverTasks(): Promise<void> {\n    const enabled =\n      this.config?.getOptionalBoolean('scaffolder.EXPERIMENTAL_recoverTasks') ??\n      false;\n\n    if (enabled) {\n      const defaultTimeout = { seconds: 30 };\n      const timeout = readDuration(\n        this.config,\n        'scaffolder.EXPERIMENTAL_recoverTasksTimeout',\n        defaultTimeout,\n      );\n      const { ids: recoveredTaskIds } = (await this.storage.recoverTasks?.({\n        timeout,\n      })) ?? { ids: [] };\n      if (recoveredTaskIds.length > 0) {\n        this.signalDispatch();\n      }\n    }\n  }\n\n  /**\n   * {@inheritdoc TaskBroker.claim}\n   */\n  async claim(): Promise<TaskContext> {\n    for (;;) {\n      const pendingTask = await this.storage.claimTask();\n      if (pendingTask) {\n        const abortController = new AbortController();\n        await this.registerCancellable(pendingTask.id, abortController);\n        return TaskManager.create(\n          {\n            taskId: pendingTask.id,\n            spec: pendingTask.spec,\n            secrets: pendingTask.secrets,\n            createdBy: pendingTask.createdBy,\n            state: pendingTask.state,\n          },\n          this.storage,\n          abortController.signal,\n          this.logger,\n          this.auth,\n          this.config,\n          this.additionalWorkspaceProviders,\n        );\n      }\n\n      await this.waitForDispatch();\n    }\n  }\n\n  /**\n   * {@inheritdoc TaskBroker.dispatch}\n   */\n  async dispatch(\n    options: TaskBrokerDispatchOptions,\n  ): Promise<{ taskId: string }> {\n    const taskRow = await this.storage.createTask(options);\n    this.signalDispatch();\n    return {\n      taskId: taskRow.taskId,\n    };\n  }\n\n  /**\n   * {@inheritdoc TaskBroker.get}\n   */\n  async get(taskId: string): Promise<SerializedTask> {\n    return this.storage.getTask(taskId);\n  }\n\n  /**\n   * {@inheritdoc TaskBroker.event$}\n   */\n  event$(options: {\n    taskId: string;\n    after?: number;\n  }): Observable<{ events: SerializedTaskEvent[] }> {\n    return new ObservableImpl(observer => {\n      const { taskId } = options;\n\n      let after = options.after;\n      let cancelled = false;\n\n      (async () => {\n        const task = await this.storage.getTask(taskId);\n        const isTaskRecoverable =\n          task.spec.EXPERIMENTAL_recovery?.EXPERIMENTAL_strategy ===\n          'startOver';\n\n        while (!cancelled) {\n          const result = await this.storage.listEvents({\n            isTaskRecoverable,\n            taskId,\n            after,\n          });\n          const { events } = result;\n          if (events.length) {\n            after = events[events.length - 1].id;\n            observer.next(result);\n          }\n\n          await new Promise(resolve => setTimeout(resolve, 1000));\n        }\n      })();\n\n      return () => {\n        cancelled = true;\n      };\n    });\n  }\n\n  /**\n   * {@inheritdoc TaskBroker.vacuumTasks}\n   */\n  async vacuumTasks(options: { timeoutS: number }): Promise<void> {\n    const { tasks } = await this.storage.listStaleTasks(options);\n    await Promise.all(\n      tasks.map(async task => {\n        const auditorEvent = await this.auditor?.createEvent({\n          eventId: 'task',\n          severityLevel: 'medium',\n          meta: {\n            actionType: 'stale-cancel',\n            taskId: task.taskId,\n          },\n        });\n        try {\n          await this.storage.completeTask({\n            taskId: task.taskId,\n            status: 'failed',\n            eventBody: {\n              message:\n                'The task was cancelled because the task worker lost connection to the task broker',\n            },\n          });\n          await auditorEvent?.success();\n        } catch (error) {\n          this.logger.warn(`Failed to cancel task '${task.taskId}', ${error}`);\n          await auditorEvent?.fail({ error: error });\n        }\n      }),\n    );\n  }\n\n  private waitForDispatch() {\n    return this.deferredDispatch;\n  }\n\n  private signalDispatch() {\n    this.deferredDispatch.resolve();\n    this.deferredDispatch = createDeferred();\n  }\n\n  async cancel(taskId: string) {\n    const { events } = await this.storage.listEvents({ taskId });\n    const currentStepId =\n      events.length > 0\n        ? events\n            .filter(({ body }) => body?.stepId)\n            .reduce((prev, curr) => (prev.id > curr.id ? prev : curr)).body\n            .stepId\n        : 0;\n\n    await this.storage.cancelTask?.({\n      taskId,\n      body: {\n        message: `Step ${currentStepId} has been cancelled.`,\n        stepId: currentStepId,\n        status: 'cancelled',\n      },\n    });\n  }\n\n  async retry?(options: {\n    secrets?: TaskSecrets;\n    taskId: string;\n  }): Promise<void> {\n    await this.storage.retryTask?.(options);\n    this.signalDispatch();\n  }\n}\n"],"names":["DefaultWorkspaceService","createDeferred","readDuration","ObservableImpl"],"mappings":"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"}