{"version":3,"file":"readDeclarativeSignInResolver.cjs.js","sources":["../../src/sign-in/readDeclarativeSignInResolver.ts"],"sourcesContent":["/*\n * Copyright 2023 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Config } from '@backstage/config';\nimport { JsonObject } from '@backstage/types';\nimport { SignInResolver } from '../types';\nimport { SignInResolverFactory } from './createSignInResolverFactory';\n\n/** @public */\nexport interface ReadDeclarativeSignInResolverOptions<TAuthResult> {\n  config: Config;\n  signInResolverFactories: {\n    [name in string]: SignInResolverFactory<TAuthResult, unknown>;\n  };\n}\n\n/** @public */\nexport function readDeclarativeSignInResolver<TAuthResult>(\n  options: ReadDeclarativeSignInResolverOptions<TAuthResult>,\n): SignInResolver<TAuthResult> | undefined {\n  const resolvers =\n    options.config\n      .getOptionalConfigArray('signIn.resolvers')\n      ?.map(resolverConfig => {\n        const resolverName = resolverConfig.getString('resolver');\n        if (!Object.hasOwn(options.signInResolverFactories, resolverName)) {\n          throw new Error(\n            `Sign-in resolver '${resolverName}' is not available`,\n          );\n        }\n        const resolver = options.signInResolverFactories[resolverName];\n        const { resolver: _ignored, ...resolverOptions } =\n          resolverConfig.get<JsonObject>();\n\n        return resolver(\n          Object.keys(resolverOptions).length > 0 ? resolverOptions : undefined,\n        );\n      }) ?? [];\n\n  if (resolvers.length === 0) {\n    return undefined;\n  }\n\n  return async (profile, context) => {\n    for (const resolver of resolvers) {\n      try {\n        return await resolver(profile, context);\n      } catch (error) {\n        if (error?.name === 'NotFoundError') {\n          continue;\n        }\n        throw error;\n      }\n    }\n\n    throw new Error(\n      'Failed to sign-in, unable to resolve user identity. Please verify that your catalog contains the expected User entities that would match your configured sign-in resolver.',\n    );\n  };\n}\n"],"names":[],"mappings":";;AA8BO,SAAS,8BACd,OAAA,EACyC;AACzC,EAAA,MAAM,YACJ,OAAA,CAAQ,MAAA,CACL,uBAAuB,kBAAkB,CAAA,EACxC,IAAI,CAAA,cAAA,KAAkB;AACtB,IAAA,MAAM,YAAA,GAAe,cAAA,CAAe,SAAA,CAAU,UAAU,CAAA;AACxD,IAAA,IAAI,CAAC,MAAA,CAAO,MAAA,CAAO,OAAA,CAAQ,uBAAA,EAAyB,YAAY,CAAA,EAAG;AACjE,MAAA,MAAM,IAAI,KAAA;AAAA,QACR,qBAAqB,YAAY,CAAA,kBAAA;AAAA,OACnC;AAAA,IACF;AACA,IAAA,MAAM,QAAA,GAAW,OAAA,CAAQ,uBAAA,CAAwB,YAAY,CAAA;AAC7D,IAAA,MAAM,EAAE,QAAA,EAAU,QAAA,EAAU,GAAG,eAAA,EAAgB,GAC7C,eAAe,GAAA,EAAgB;AAEjC,IAAA,OAAO,QAAA;AAAA,MACL,OAAO,IAAA,CAAK,eAAe,CAAA,CAAE,MAAA,GAAS,IAAI,eAAA,GAAkB;AAAA,KAC9D;AAAA,EACF,CAAC,KAAK,EAAC;AAEX,EAAA,IAAI,SAAA,CAAU,WAAW,CAAA,EAAG;AAC1B,IAAA,OAAO,MAAA;AAAA,EACT;AAEA,EAAA,OAAO,OAAO,SAAS,OAAA,KAAY;AACjC,IAAA,KAAA,MAAW,YAAY,SAAA,EAAW;AAChC,MAAA,IAAI;AACF,QAAA,OAAO,MAAM,QAAA,CAAS,OAAA,EAAS,OAAO,CAAA;AAAA,MACxC,SAAS,KAAA,EAAO;AACd,QAAA,IAAI,KAAA,EAAO,SAAS,eAAA,EAAiB;AACnC,UAAA;AAAA,QACF;AACA,QAAA,MAAM,KAAA;AAAA,MACR;AAAA,IACF;AAEA,IAAA,MAAM,IAAI,KAAA;AAAA,MACR;AAAA,KACF;AAAA,EACF,CAAA;AACF;;;;"}