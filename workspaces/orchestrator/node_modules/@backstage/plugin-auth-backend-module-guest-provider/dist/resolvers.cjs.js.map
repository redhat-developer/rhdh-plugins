{"version":3,"file":"resolvers.cjs.js","sources":["../src/resolvers.ts"],"sourcesContent":["/*\n * Copyright 2024 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { stringifyEntityRef } from '@backstage/catalog-model';\nimport type { Config } from '@backstage/config';\nimport { SignInResolver } from '@backstage/plugin-auth-node';\nimport { NotImplementedError } from '@backstage/errors';\n\n/**\n * Provide a default implementation of the user to resolve to. By default, this\n *  is `user:development/guest`. We will attempt to get that user if they're in the\n *  catalog. If that user doesn't exist in the catalog, we will still create a\n *  token for them so they can keep viewing.\n */\nexport const signInAsGuestUser: (config: Config) => SignInResolver<{}> =\n  (config: Config) => async (_, ctx) => {\n    if (\n      process.env.NODE_ENV !== 'development' &&\n      config.getOptionalBoolean('dangerouslyAllowOutsideDevelopment') !== true\n    ) {\n      throw new NotImplementedError(\n        'The guest provider is NOT recommended for use outside of a development environment. If you want to enable this, set `auth.providers.guest.dangerouslyAllowOutsideDevelopment: true` in your app config.',\n      );\n    }\n    const userRef =\n      config.getOptionalString('userEntityRef') ??\n      stringifyEntityRef({\n        kind: 'user',\n        namespace: 'development',\n        name: 'guest',\n      });\n    const ownershipRefs = config.getOptionalStringArray(\n      'ownershipEntityRefs',\n    ) ?? [userRef];\n    try {\n      return await ctx.signInWithCatalogUser({ entityRef: userRef });\n    } catch (err) {\n      // We can't guarantee that a guest user exists in the catalog, so we issue a token directly,\n      return ctx.issueToken({\n        claims: {\n          sub: userRef,\n          ent: ownershipRefs,\n        },\n      });\n    }\n  };\n"],"names":["NotImplementedError","stringifyEntityRef"],"mappings":";;;;;AA2BO,MAAM,iBAAA,GACX,CAAC,MAAA,KAAmB,OAAO,GAAG,GAAA,KAAQ;AACpC,EAAA,IACE,OAAA,CAAQ,IAAI,QAAA,KAAa,aAAA,IACzB,OAAO,kBAAA,CAAmB,oCAAoC,MAAM,IAAA,EACpE;AACA,IAAA,MAAM,IAAIA,0BAAA;AAAA,MACR;AAAA,KACF;AAAA,EACF;AACA,EAAA,MAAM,OAAA,GACJ,MAAA,CAAO,iBAAA,CAAkB,eAAe,KACxCC,+BAAA,CAAmB;AAAA,IACjB,IAAA,EAAM,MAAA;AAAA,IACN,SAAA,EAAW,aAAA;AAAA,IACX,IAAA,EAAM;AAAA,GACP,CAAA;AACH,EAAA,MAAM,gBAAgB,MAAA,CAAO,sBAAA;AAAA,IAC3B;AAAA,GACF,IAAK,CAAC,OAAO,CAAA;AACb,EAAA,IAAI;AACF,IAAA,OAAO,MAAM,GAAA,CAAI,qBAAA,CAAsB,EAAE,SAAA,EAAW,SAAS,CAAA;AAAA,EAC/D,SAAS,GAAA,EAAK;AAEZ,IAAA,OAAO,IAAI,UAAA,CAAW;AAAA,MACpB,MAAA,EAAQ;AAAA,QACN,GAAA,EAAK,OAAA;AAAA,QACL,GAAA,EAAK;AAAA;AACP,KACD,CAAA;AAAA,EACH;AACF;;;;"}