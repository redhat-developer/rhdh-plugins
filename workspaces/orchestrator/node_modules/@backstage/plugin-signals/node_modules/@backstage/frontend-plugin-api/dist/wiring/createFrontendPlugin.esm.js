import { resolveExtensionDefinition } from './resolveExtensionDefinition.esm.js';
import { OpaqueFrontendPlugin } from '../frontend-internal/src/wiring/InternalFrontendPlugin.esm.js';
import '../frontend-internal/src/wiring/InternalSwappableComponentRef.esm.js';
import { OpaqueExtensionDefinition } from '../frontend-internal/src/wiring/InternalExtensionDefinition.esm.js';

function createFrontendPlugin(options) {
  const pluginId = options.pluginId;
  const extensions = new Array();
  const extensionDefinitionsById = /* @__PURE__ */ new Map();
  for (const def of options.extensions ?? []) {
    const internal = OpaqueExtensionDefinition.toInternal(def);
    const ext = resolveExtensionDefinition(def, { namespace: pluginId });
    extensions.push(ext);
    extensionDefinitionsById.set(ext.id, {
      ...internal,
      namespace: pluginId
    });
  }
  if (extensions.length !== extensionDefinitionsById.size) {
    const extensionIds = extensions.map((e) => e.id);
    const duplicates = Array.from(
      new Set(
        extensionIds.filter((id, index) => extensionIds.indexOf(id) !== index)
      )
    );
    throw new Error(
      `Plugin '${pluginId}' provided duplicate extensions: ${duplicates.join(
        ", "
      )}`
    );
  }
  return OpaqueFrontendPlugin.createInstance("v1", {
    id: pluginId,
    routes: options.routes ?? {},
    externalRoutes: options.externalRoutes ?? {},
    featureFlags: options.featureFlags ?? [],
    extensions,
    infoOptions: options.info,
    // This method is overridden when the plugin instance is installed in an app
    async info() {
      throw new Error(
        `Attempted to load plugin info for plugin '${pluginId}', but the plugin instance is not installed in an app`
      );
    },
    getExtension(id) {
      const ext = extensionDefinitionsById.get(id);
      if (!ext) {
        throw new Error(
          `Attempted to get non-existent extension '${id}' from plugin '${pluginId}'`
        );
      }
      return ext;
    },
    toString() {
      return `Plugin{id=${pluginId}}`;
    },
    withOverrides(overrides) {
      const overriddenExtensionIds = new Set(
        overrides.extensions.map(
          (e) => resolveExtensionDefinition(e, { namespace: pluginId }).id
        )
      );
      const nonOverriddenExtensions = (options.extensions ?? []).filter(
        (e) => !overriddenExtensionIds.has(
          resolveExtensionDefinition(e, { namespace: pluginId }).id
        )
      );
      return createFrontendPlugin({
        ...options,
        pluginId,
        extensions: [...nonOverriddenExtensions, ...overrides.extensions],
        info: {
          ...options.info,
          ...overrides.info
        }
      });
    }
  });
}

export { createFrontendPlugin };
//# sourceMappingURL=createFrontendPlugin.esm.js.map
