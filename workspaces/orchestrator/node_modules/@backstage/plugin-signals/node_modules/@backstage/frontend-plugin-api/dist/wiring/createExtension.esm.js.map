{"version":3,"file":"createExtension.esm.js","sources":["../../src/wiring/createExtension.ts"],"sourcesContent":["/*\n * Copyright 2023 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ApiHolder, AppNode } from '../apis';\nimport { Expand } from '@backstage/types';\nimport {\n  ResolvedInputValueOverrides,\n  resolveInputOverrides,\n} from './resolveInputOverrides';\nimport { createExtensionDataContainer } from '@internal/frontend';\nimport { ExtensionDataRef, ExtensionDataValue } from './createExtensionDataRef';\nimport { ExtensionInput } from './createExtensionInput';\nimport { z } from 'zod';\nimport { createSchemaFromZod } from '../schema/createSchemaFromZod';\nimport { OpaqueExtensionDefinition } from '@internal/frontend';\nimport { ExtensionDataContainer } from './types';\nimport {\n  ExtensionBlueprint,\n  ExtensionBlueprintDefineParams,\n} from './createExtensionBlueprint';\nimport { FrontendPlugin } from './createFrontendPlugin';\nimport { FrontendModule } from './createFrontendModule';\n\n/**\n * This symbol is used to pass parameter overrides from the extension override to the blueprint factory\n * @internal\n */\nexport const ctxParamsSymbol = Symbol('params');\n\n/**\n * Convert a single extension input into a matching resolved input.\n * @public\n */\nexport type ResolvedExtensionInput<\n  TExtensionInput extends ExtensionInput<any, any>,\n> = TExtensionInput['extensionData'] extends Array<ExtensionDataRef>\n  ? {\n      node: AppNode;\n    } & ExtensionDataContainer<TExtensionInput['extensionData'][number]>\n  : never;\n\n/**\n * Converts an extension input map into a matching collection of resolved inputs.\n * @public\n */\nexport type ResolvedExtensionInputs<\n  TInputs extends {\n    [name in string]: ExtensionInput<any, any>;\n  },\n> = {\n  [InputName in keyof TInputs]: false extends TInputs[InputName]['config']['singleton']\n    ? Array<Expand<ResolvedExtensionInput<TInputs[InputName]>>>\n    : false extends TInputs[InputName]['config']['optional']\n    ? Expand<ResolvedExtensionInput<TInputs[InputName]>>\n    : Expand<ResolvedExtensionInput<TInputs[InputName]> | undefined>;\n};\n\ntype ToIntersection<U> = (U extends any ? (k: U) => void : never) extends (\n  k: infer I,\n) => void\n  ? I\n  : never;\n\ntype PopUnion<U> = ToIntersection<\n  U extends any ? () => U : never\n> extends () => infer R\n  ? [rest: Exclude<U, R>, next: R]\n  : undefined;\n\n/** @ignore */\ntype JoinStringUnion<\n  U,\n  TDiv extends string = ', ',\n  TResult extends string = '',\n> = PopUnion<U> extends [infer IRest extends string, infer INext extends string]\n  ? TResult extends ''\n    ? JoinStringUnion<IRest, TDiv, INext>\n    : JoinStringUnion<IRest, TDiv, `${TResult}${TDiv}${INext}`>\n  : TResult;\n\n/** @ignore */\nexport type VerifyExtensionFactoryOutput<\n  UDeclaredOutput extends ExtensionDataRef,\n  UFactoryOutput extends ExtensionDataValue<any, any>,\n> = (\n  UDeclaredOutput extends any\n    ? UDeclaredOutput['config']['optional'] extends true\n      ? never\n      : UDeclaredOutput['id']\n    : never\n) extends infer IRequiredOutputIds\n  ? [IRequiredOutputIds] extends [UFactoryOutput['id']]\n    ? [UFactoryOutput['id']] extends [UDeclaredOutput['id']]\n      ? {}\n      : `Error: The extension factory has undeclared output(s): ${JoinStringUnion<\n          Exclude<UFactoryOutput['id'], UDeclaredOutput['id']>\n        >}`\n    : `Error: The extension factory is missing the following output(s): ${JoinStringUnion<\n        Exclude<IRequiredOutputIds, UFactoryOutput['id']>\n      >}`\n  : never;\n\n/** @public */\nexport type ExtensionAttachToSpec =\n  | { id: string; input: string }\n  | Array<{ id: string; input: string }>;\n\n/** @public */\nexport type CreateExtensionOptions<\n  TKind extends string | undefined,\n  TName extends string | undefined,\n  UOutput extends ExtensionDataRef,\n  TInputs extends {\n    [inputName in string]: ExtensionInput<\n      ExtensionDataRef,\n      { optional: boolean; singleton: boolean }\n    >;\n  },\n  TConfigSchema extends { [key: string]: (zImpl: typeof z) => z.ZodType },\n  UFactoryOutput extends ExtensionDataValue<any, any>,\n> = {\n  kind?: TKind;\n  name?: TName;\n  attachTo: ExtensionAttachToSpec;\n  disabled?: boolean;\n  inputs?: TInputs;\n  output: Array<UOutput>;\n  config?: {\n    schema: TConfigSchema;\n  };\n  factory(context: {\n    node: AppNode;\n    apis: ApiHolder;\n    config: {\n      [key in keyof TConfigSchema]: z.infer<ReturnType<TConfigSchema[key]>>;\n    };\n    inputs: Expand<ResolvedExtensionInputs<TInputs>>;\n  }): Iterable<UFactoryOutput>;\n} & VerifyExtensionFactoryOutput<UOutput, UFactoryOutput>;\n\n/** @public */\nexport type ExtensionDefinitionParameters = {\n  kind?: string;\n  name?: string;\n  configInput?: { [K in string]: any };\n  config?: { [K in string]: any };\n  output?: ExtensionDataRef;\n  inputs?: {\n    [KName in string]: ExtensionInput<\n      ExtensionDataRef,\n      { optional: boolean; singleton: boolean }\n    >;\n  };\n  params?: object | ExtensionBlueprintDefineParams;\n};\n\n/**\n * Same as the one in `createExtensionBlueprint`, but with `ParamsFactory` inlined.\n * It can't be exported because it breaks API reports.\n * @ignore\n */\ntype AnyParamsInput<TParams extends object | ExtensionBlueprintDefineParams> =\n  TParams extends ExtensionBlueprintDefineParams<infer IParams>\n    ? IParams | ((define: TParams) => ReturnType<TParams>)\n    :\n        | TParams\n        | ((\n            define: ExtensionBlueprintDefineParams<TParams, TParams>,\n          ) => ReturnType<ExtensionBlueprintDefineParams<TParams, TParams>>);\n\n/** @public */\nexport type ExtensionDefinition<\n  T extends ExtensionDefinitionParameters = ExtensionDefinitionParameters,\n> = {\n  $$type: '@backstage/ExtensionDefinition';\n  readonly T: T;\n\n  override<\n    TExtensionConfigSchema extends {\n      [key in string]: (zImpl: typeof z) => z.ZodType;\n    },\n    UFactoryOutput extends ExtensionDataValue<any, any>,\n    UNewOutput extends ExtensionDataRef,\n    TExtraInputs extends {\n      [inputName in string]: ExtensionInput<\n        ExtensionDataRef,\n        { optional: boolean; singleton: boolean }\n      >;\n    },\n    TParamsInput extends AnyParamsInput<NonNullable<T['params']>>,\n  >(\n    args: Expand<\n      {\n        attachTo?: ExtensionAttachToSpec;\n        disabled?: boolean;\n        inputs?: TExtraInputs & {\n          [KName in keyof T['inputs']]?: `Error: Input '${KName &\n            string}' is already defined in parent definition`;\n        };\n        output?: Array<UNewOutput>;\n        config?: {\n          schema: TExtensionConfigSchema & {\n            [KName in keyof T['config']]?: `Error: Config key '${KName &\n              string}' is already defined in parent schema`;\n          };\n        };\n        factory?(\n          originalFactory: <\n            TFactoryParamsReturn extends AnyParamsInput<\n              NonNullable<T['params']>\n            >,\n          >(\n            context?: Expand<\n              {\n                config?: T['config'];\n                inputs?: ResolvedInputValueOverrides<NonNullable<T['inputs']>>;\n              } & ([T['params']] extends [never]\n                ? {}\n                : {\n                    params?: TFactoryParamsReturn extends ExtensionBlueprintDefineParams\n                      ? TFactoryParamsReturn\n                      : T['params'] extends ExtensionBlueprintDefineParams\n                      ? 'Error: This blueprint uses advanced parameter types and requires you to pass parameters as using the following callback syntax: `originalFactory(defineParams => defineParams(<params>))`'\n                      : Partial<T['params']>;\n                  })\n            >,\n          ) => ExtensionDataContainer<NonNullable<T['output']>>,\n          context: {\n            node: AppNode;\n            apis: ApiHolder;\n            config: T['config'] & {\n              [key in keyof TExtensionConfigSchema]: z.infer<\n                ReturnType<TExtensionConfigSchema[key]>\n              >;\n            };\n            inputs: Expand<ResolvedExtensionInputs<T['inputs'] & TExtraInputs>>;\n          },\n        ): Iterable<UFactoryOutput>;\n      } & ([T['params']] extends [never]\n        ? {}\n        : {\n            params?: TParamsInput extends ExtensionBlueprintDefineParams\n              ? TParamsInput\n              : T['params'] extends ExtensionBlueprintDefineParams\n              ? 'Error: This blueprint uses advanced parameter types and requires you to pass parameters as using the following callback syntax: `originalFactory(defineParams => defineParams(<params>))`'\n              : Partial<T['params']>;\n          })\n    > &\n      VerifyExtensionFactoryOutput<\n        ExtensionDataRef extends UNewOutput\n          ? NonNullable<T['output']>\n          : UNewOutput,\n        UFactoryOutput\n      >,\n  ): ExtensionDefinition<{\n    kind: T['kind'];\n    name: T['name'];\n    output: ExtensionDataRef extends UNewOutput ? T['output'] : UNewOutput;\n    inputs: T['inputs'] & TExtraInputs;\n    config: T['config'] & {\n      [key in keyof TExtensionConfigSchema]: z.infer<\n        ReturnType<TExtensionConfigSchema[key]>\n      >;\n    };\n    configInput: T['configInput'] &\n      z.input<\n        z.ZodObject<{\n          [key in keyof TExtensionConfigSchema]: ReturnType<\n            TExtensionConfigSchema[key]\n          >;\n        }>\n      >;\n  }>;\n};\n\n/**\n * Creates a new extension definition for installation in a Backstage app.\n *\n * @remarks\n *\n * This is a low-level function for creation of extensions with arbitrary inputs\n * and outputs and is typically only intended to be used for advanced overrides\n * or framework-level extensions. For most extension creation needs, it is\n * recommended to use existing {@link ExtensionBlueprint}s instead. You can find\n * blueprints both in the `@backstage/frontend-plugin-api` package as well as\n * other plugin libraries. There is also a list of\n * {@link https://backstage.io/docs/frontend-system/building-plugins/common-extension-blueprints | commonly used blueprints}\n * in the frontend system documentation.\n *\n * Extension definitions that are created with this function can be installed in\n * a Backstage app via a {@link FrontendPlugin} or {@link FrontendModule}.\n *\n * For more details on how extensions work, see the\n * {@link https://backstage.io/docs/frontend-system/architecture/extensions | documentation for extensions}.\n *\n * @example\n *\n * ```ts\n * const myExtension = createExtension({\n *   name: 'example',\n *   attachTo: { id: 'app', input: 'root' },\n *   output: [coreExtensionData.reactElement],\n *   factory() {\n *     return [coreExtensionData.reactElement(<h1>Hello, world!</h1>)];\n *   },\n * });\n * ```\n *\n * @public\n */\nexport function createExtension<\n  UOutput extends ExtensionDataRef,\n  TInputs extends {\n    [inputName in string]: ExtensionInput<\n      ExtensionDataRef,\n      { optional: boolean; singleton: boolean }\n    >;\n  },\n  TConfigSchema extends { [key: string]: (zImpl: typeof z) => z.ZodType },\n  UFactoryOutput extends ExtensionDataValue<any, any>,\n  const TKind extends string | undefined = undefined,\n  const TName extends string | undefined = undefined,\n>(\n  options: CreateExtensionOptions<\n    TKind,\n    TName,\n    UOutput,\n    TInputs,\n    TConfigSchema,\n    UFactoryOutput\n  >,\n): ExtensionDefinition<{\n  config: string extends keyof TConfigSchema\n    ? {}\n    : {\n        [key in keyof TConfigSchema]: z.infer<ReturnType<TConfigSchema[key]>>;\n      };\n  configInput: string extends keyof TConfigSchema\n    ? {}\n    : z.input<\n        z.ZodObject<{\n          [key in keyof TConfigSchema]: ReturnType<TConfigSchema[key]>;\n        }>\n      >;\n  // This inference and remapping back to ExtensionDataRef eliminates any occurrences ConfigurationExtensionDataRef\n  output: UOutput extends ExtensionDataRef<\n    infer IData,\n    infer IId,\n    infer IConfig\n  >\n    ? ExtensionDataRef<IData, IId, IConfig>\n    : never;\n  inputs: TInputs;\n  params: never;\n  kind: string | undefined extends TKind ? undefined : TKind;\n  name: string | undefined extends TName ? undefined : TName;\n}> {\n  const schemaDeclaration = options.config?.schema;\n  const configSchema =\n    schemaDeclaration &&\n    createSchemaFromZod(innerZ =>\n      innerZ.object(\n        Object.fromEntries(\n          Object.entries(schemaDeclaration).map(([k, v]) => [k, v(innerZ)]),\n        ),\n      ),\n    );\n\n  return OpaqueExtensionDefinition.createInstance('v2', {\n    T: undefined as unknown as {\n      config: string extends keyof TConfigSchema\n        ? {}\n        : {\n            [key in keyof TConfigSchema]: z.infer<\n              ReturnType<TConfigSchema[key]>\n            >;\n          };\n      configInput: string extends keyof TConfigSchema\n        ? {}\n        : z.input<\n            z.ZodObject<{\n              [key in keyof TConfigSchema]: ReturnType<TConfigSchema[key]>;\n            }>\n          >;\n      output: UOutput;\n      inputs: TInputs;\n      kind: string | undefined extends TKind ? undefined : TKind;\n      name: string | undefined extends TName ? undefined : TName;\n    },\n    kind: options.kind,\n    name: options.name,\n    attachTo: options.attachTo,\n    disabled: options.disabled ?? false,\n    inputs: options.inputs ?? {},\n    output: options.output,\n    configSchema,\n    factory: options.factory,\n    toString() {\n      const parts: string[] = [];\n      if (options.kind) {\n        parts.push(`kind=${options.kind}`);\n      }\n      if (options.name) {\n        parts.push(`name=${options.name}`);\n      }\n      parts.push(\n        `attachTo=${[options.attachTo]\n          .flat()\n          .map(a => `${a.id}@${a.input}`)\n          .join('+')}`,\n      );\n      return `ExtensionDefinition{${parts.join(',')}}`;\n    },\n    override(overrideOptions) {\n      if (!Array.isArray(options.output)) {\n        throw new Error(\n          'Cannot override an extension that is not declared using the new format with outputs as an array',\n        );\n      }\n\n      // TODO(Rugvip): Making this a type check would be optimal, but it seems\n      //               like it's tricky to add that and still have the type\n      //               inference work correctly for the factory output.\n      if (overrideOptions.output && !overrideOptions.factory) {\n        throw new Error(\n          'Refused to override output without also overriding factory',\n        );\n      }\n      // TODO(Rugvip): Similar to above, would be nice to error during type checking, but don't want to complicate the types too much\n      if (overrideOptions.params && overrideOptions.factory) {\n        throw new Error(\n          'Refused to override params and factory at the same time',\n        );\n      }\n\n      return createExtension({\n        kind: options.kind,\n        name: options.name,\n        attachTo: overrideOptions.attachTo ?? options.attachTo,\n        disabled: overrideOptions.disabled ?? options.disabled,\n        inputs: { ...overrideOptions.inputs, ...options.inputs },\n        output: (overrideOptions.output ??\n          options.output) as ExtensionDataRef[],\n        config:\n          options.config || overrideOptions.config\n            ? {\n                schema: {\n                  ...options.config?.schema,\n                  ...overrideOptions.config?.schema,\n                },\n              }\n            : undefined,\n        factory: ({ node, apis, config, inputs }) => {\n          if (!overrideOptions.factory) {\n            return options.factory({\n              node,\n              apis,\n              config: config as any,\n              inputs: inputs as any,\n              [ctxParamsSymbol as any]: overrideOptions.params,\n            });\n          }\n          const parentResult = overrideOptions.factory(\n            (innerContext): ExtensionDataContainer<UOutput> => {\n              return createExtensionDataContainer<UOutput>(\n                options.factory({\n                  node,\n                  apis,\n                  config: (innerContext?.config ?? config) as any,\n                  inputs: resolveInputOverrides(\n                    options.inputs,\n                    inputs,\n                    innerContext?.inputs,\n                  ) as any,\n                  [ctxParamsSymbol as any]: innerContext?.params,\n                }) as Iterable<any>,\n                'original extension factory',\n                options.output,\n              );\n            },\n            {\n              node,\n              apis,\n              config: config as any,\n              inputs: inputs as any,\n            },\n          );\n\n          if (\n            typeof parentResult !== 'object' ||\n            !parentResult?.[Symbol.iterator]\n          ) {\n            throw new Error(\n              'extension factory override did not provide an iterable object',\n            );\n          }\n\n          const deduplicatedResult = new Map<\n            string,\n            ExtensionDataValue<any, any>\n          >();\n          for (const item of parentResult) {\n            deduplicatedResult.set(item.id, item);\n          }\n\n          return deduplicatedResult.values();\n        },\n      }) as ExtensionDefinition<any>;\n    },\n  });\n}\n"],"names":[],"mappings":"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"}