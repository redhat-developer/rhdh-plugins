import { v4 } from 'uuid';

const WS_CLOSE_NORMAL = 1e3;
const WS_CLOSE_GOING_AWAY = 1001;
class SignalClient {
  constructor(identity, discoveryApi, connectTimeout, reconnectTimeout) {
    this.identity = identity;
    this.discoveryApi = discoveryApi;
    this.connectTimeout = connectTimeout;
    this.reconnectTimeout = reconnectTimeout;
  }
  static DEFAULT_CONNECT_TIMEOUT_MS = 1e3;
  static DEFAULT_RECONNECT_TIMEOUT_MS = 5e3;
  ws = null;
  subscriptions = /* @__PURE__ */ new Map();
  messageQueue = [];
  reconnectTo;
  static create(options) {
    const {
      identity,
      discoveryApi,
      connectTimeout = SignalClient.DEFAULT_CONNECT_TIMEOUT_MS,
      reconnectTimeout = SignalClient.DEFAULT_RECONNECT_TIMEOUT_MS
    } = options;
    return new SignalClient(
      identity,
      discoveryApi,
      connectTimeout,
      reconnectTimeout
    );
  }
  subscribe(channel, onMessage) {
    const subscriptionId = v4();
    const exists = [...this.subscriptions.values()].find(
      (sub) => sub.channel === channel
    );
    this.subscriptions.set(subscriptionId, {
      channel,
      callback: onMessage
    });
    this.connect().then(() => {
      if (!exists) {
        this.send({ action: "subscribe", channel });
      }
    }).catch(() => {
      this.reconnect();
    });
    const unsubscribe = () => {
      const sub = this.subscriptions.get(subscriptionId);
      if (!sub) {
        return;
      }
      this.subscriptions.delete(subscriptionId);
      const multipleExists = [...this.subscriptions.values()].find(
        (s) => s.channel === channel
      );
      if (!multipleExists) {
        this.send({ action: "unsubscribe", channel: sub.channel });
      }
      if (this.subscriptions.size === 0) {
        this.ws?.close(WS_CLOSE_NORMAL);
        this.ws = null;
      }
    };
    return { unsubscribe };
  }
  send(data) {
    const jsonMessage = JSON.stringify(data);
    if (jsonMessage.length === 0) {
      return;
    }
    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
      if (data) {
        this.messageQueue.unshift(jsonMessage);
      }
      return;
    }
    for (const msg of this.messageQueue) {
      this.ws.send(msg);
    }
    this.messageQueue = [];
    if (data) {
      this.ws.send(jsonMessage);
    }
  }
  async connect() {
    if (this.ws && this.ws.readyState !== WebSocket.CLOSED) {
      return;
    }
    const apiUrl = await this.discoveryApi.getBaseUrl("signals");
    const { token } = await this.identity.getCredentials();
    const url = new URL(apiUrl);
    url.protocol = url.protocol === "http:" ? "ws:" : "wss:";
    this.ws = new WebSocket(url.toString(), token);
    let connectSleep = 0;
    while (this.ws && this.ws.readyState !== WebSocket.OPEN && connectSleep < this.connectTimeout) {
      await new Promise((r) => setTimeout(r, 100));
      connectSleep += 100;
    }
    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
      throw new Error("Connect timeout");
    }
    this.ws.onmessage = (data) => {
      this.handleMessage(data);
    };
    this.ws.onerror = () => {
      this.reconnect();
    };
    this.ws.onclose = (ev) => {
      if (ev.code !== WS_CLOSE_NORMAL && ev.code !== WS_CLOSE_GOING_AWAY) {
        this.reconnect();
      }
    };
  }
  handleMessage(data) {
    try {
      const json = JSON.parse(data.data);
      if (!json.channel) {
        return;
      }
      for (const sub of this.subscriptions.values()) {
        if (sub.channel === json.channel) {
          sub.callback(json.message);
        }
      }
    } catch (e) {
    }
  }
  reconnect() {
    if (this.reconnectTo) {
      clearTimeout(this.reconnectTo);
    }
    this.reconnectTo = setTimeout(() => {
      this.reconnectTo = null;
      if (this.ws) {
        this.ws.close();
      }
      this.ws = null;
      this.connect().then(() => {
        for (const sub of this.subscriptions.values()) {
          this.send({ action: "subscribe", channel: sub.channel });
        }
      }).catch(() => {
        this.reconnect();
      });
    }, this.reconnectTimeout);
  }
}

export { SignalClient };
//# sourceMappingURL=SignalClient.esm.js.map
