import { jsxs, jsx } from 'react/jsx-runtime';
import { useState, useRef, useMemo, useCallback, useEffect } from 'react';
import * as d3Zoom from 'd3-zoom';
import * as d3Selection from 'd3-selection';
import useTheme from '@material-ui/core/styles/useTheme';
import dagre from '@dagrejs/dagre';
import debounce from 'lodash/debounce';
import { DependencyGraphTypes } from './types.esm.js';
import { Node } from './Node.esm.js';
import { Edge } from './Edge.esm.js';
import { ARROW_MARKER_ID } from './constants.esm.js';

const WORKSPACE_ID = "workspace";
function DependencyGraph(props) {
  const {
    edges,
    nodes,
    renderNode,
    direction = DependencyGraphTypes.Direction.TOP_BOTTOM,
    align,
    nodeMargin = 50,
    edgeMargin = 10,
    rankMargin = 50,
    paddingX = 0,
    paddingY = 0,
    acyclicer,
    ranker = DependencyGraphTypes.Ranker.NETWORK_SIMPLEX,
    labelPosition = DependencyGraphTypes.LabelPosition.RIGHT,
    labelOffset = 10,
    edgeRanks = 1,
    edgeWeight = 1,
    renderLabel,
    defs,
    zoom = "enabled",
    curve = "curveMonotoneX",
    showArrowHeads = false,
    fit = "grow",
    ...svgProps
  } = props;
  const theme = useTheme();
  const [containerWidth, setContainerWidth] = useState(100);
  const [containerHeight, setContainerHeight] = useState(100);
  const graph = useRef(
    new dagre.graphlib.Graph()
  );
  const [graphWidth, setGraphWidth] = useState(
    graph.current.graph()?.width || 0
  );
  const [graphHeight, setGraphHeight] = useState(
    graph.current.graph()?.height || 0
  );
  const [graphNodes, setGraphNodes] = useState([]);
  const [graphEdges, setGraphEdges] = useState([]);
  const maxWidth = Math.max(graphWidth, containerWidth);
  const maxHeight = Math.max(graphHeight, containerHeight);
  const minHeight = Math.min(graphHeight, containerHeight);
  const scalableHeight = fit === "grow" ? maxHeight : minHeight;
  const containerRef = useMemo(
    () => debounce((node) => {
      if (!node) {
        return;
      }
      const container = d3Selection.select(node);
      const workspace = d3Selection.select(node.getElementById(WORKSPACE_ID));
      function enableZoom() {
        container.call(
          d3Zoom.zoom().scaleExtent([1, Infinity]).on("zoom", (event) => {
            event.transform.x = Math.min(
              0,
              Math.max(
                event.transform.x,
                maxWidth - maxWidth * event.transform.k
              )
            );
            event.transform.y = Math.min(
              0,
              Math.max(
                event.transform.y,
                maxHeight - maxHeight * event.transform.k
              )
            );
            workspace.attr("transform", event.transform);
          })
        );
      }
      if (zoom === "enabled") {
        enableZoom();
      } else if (zoom === "enable-on-click") {
        container.on("click", () => enableZoom());
      }
      const { width: newContainerWidth, height: newContainerHeight } = node.getBoundingClientRect();
      if (containerWidth !== newContainerWidth) {
        setContainerWidth(newContainerWidth);
      }
      if (containerHeight !== newContainerHeight) {
        setContainerHeight(newContainerHeight);
      }
    }, 100),
    [containerHeight, containerWidth, maxWidth, maxHeight, zoom]
  );
  const setNodesAndEdges = useCallback(() => {
    const currentGraphNodes = graph.current.nodes();
    const currentGraphEdges = graph.current.edges();
    currentGraphNodes.forEach((nodeId) => {
      const remainingNode = nodes.some((node) => node.id === nodeId);
      if (!remainingNode) {
        graph.current.removeNode(nodeId);
      }
    });
    currentGraphEdges.forEach((e) => {
      const remainingEdge = edges.some(
        (edge) => edge.from === e.v && edge.to === e.w
      );
      if (!remainingEdge) {
        graph.current.removeEdge(e.v, e.w);
      }
    });
    nodes.forEach((node) => {
      const existingNode = graph.current.nodes().find((nodeId) => node.id === nodeId);
      if (existingNode && graph.current.node(existingNode)) {
        const { width, height, x, y } = graph.current.node(existingNode);
        graph.current.setNode(existingNode, { ...node, width, height, x, y });
      } else {
        graph.current.setNode(node.id, { ...node, width: 0, height: 0 });
      }
    });
    edges.forEach((e) => {
      graph.current.setEdge(e.from, e.to, {
        ...e,
        label: e.label,
        width: 0,
        height: 0,
        labelpos: labelPosition,
        labeloffset: labelOffset,
        weight: edgeWeight,
        minlen: edgeRanks
      });
    });
  }, [edges, nodes, labelPosition, labelOffset, edgeWeight, edgeRanks]);
  const updateGraph = useMemo(
    () => debounce(
      () => {
        dagre.layout(graph.current);
        const { height, width } = graph.current.graph();
        const newHeight = Math.max(0, height || 0);
        const newWidth = Math.max(0, width || 0);
        setGraphWidth(newWidth);
        setGraphHeight(newHeight);
        setGraphNodes(graph.current.nodes());
        setGraphEdges(graph.current.edges());
      },
      250,
      { leading: true }
    ),
    []
  );
  useEffect(() => {
    graph.current.setGraph({
      rankdir: direction,
      align,
      nodesep: nodeMargin,
      edgesep: edgeMargin,
      ranksep: rankMargin,
      marginx: paddingX,
      marginy: paddingY,
      acyclicer,
      ranker
    });
    setNodesAndEdges();
    updateGraph();
    return updateGraph.cancel;
  }, [
    acyclicer,
    align,
    direction,
    edgeMargin,
    paddingX,
    paddingY,
    nodeMargin,
    rankMargin,
    ranker,
    setNodesAndEdges,
    updateGraph
  ]);
  function setNode(id, node) {
    graph.current.setNode(id, node);
    updateGraph();
    return graph.current;
  }
  function setEdge(id, edge) {
    graph.current.setEdge(id, edge);
    updateGraph();
    return graph.current;
  }
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      ref: containerRef,
      ...svgProps,
      width: "100%",
      height: scalableHeight,
      viewBox: `0 0 ${maxWidth} ${maxHeight}`,
      children: [
        /* @__PURE__ */ jsxs("defs", { children: [
          /* @__PURE__ */ jsx(
            "marker",
            {
              id: ARROW_MARKER_ID,
              viewBox: "0 0 24 24",
              markerWidth: "14",
              markerHeight: "14",
              refX: "16",
              refY: "12",
              orient: "auto",
              markerUnits: "strokeWidth",
              children: /* @__PURE__ */ jsx(
                "path",
                {
                  fill: theme.palette.textSubtle,
                  d: "M8.59 16.59L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.41z"
                }
              )
            }
          ),
          defs
        ] }),
        /* @__PURE__ */ jsx("g", { id: WORKSPACE_ID, children: /* @__PURE__ */ jsxs(
          "svg",
          {
            width: graphWidth,
            height: graphHeight,
            y: maxHeight / 2 - graphHeight / 2,
            x: maxWidth / 2 - graphWidth / 2,
            viewBox: `0 0 ${graphWidth} ${graphHeight}`,
            children: [
              graphEdges.map((e) => {
                const edge = graph.current.edge(e);
                if (!edge) return null;
                return /* @__PURE__ */ jsx(
                  Edge,
                  {
                    id: e,
                    setEdge,
                    render: renderLabel,
                    edge,
                    curve,
                    showArrowHeads
                  },
                  `${e.v}-${e.w}`
                );
              }),
              graphNodes.map((id) => {
                const node = graph.current.node(id);
                if (!node) return null;
                return /* @__PURE__ */ jsx(
                  Node,
                  {
                    setNode,
                    render: renderNode,
                    node
                  },
                  id
                );
              })
            ]
          }
        ) })
      ]
    }
  );
}

export { DependencyGraph };
//# sourceMappingURL=DependencyGraph.esm.js.map
