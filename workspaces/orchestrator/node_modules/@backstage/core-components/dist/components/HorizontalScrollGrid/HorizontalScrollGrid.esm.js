import { jsxs, jsx } from 'react/jsx-runtime';
import Box from '@material-ui/core/Box';
import Grid from '@material-ui/core/Grid';
import IconButton from '@material-ui/core/IconButton';
import { makeStyles } from '@material-ui/core/styles';
import ChevronLeftIcon from '@material-ui/icons/ChevronLeft';
import ChevronRight from '@material-ui/icons/ChevronRight';
import classNames from 'classnames';
import { useRef, useState, useLayoutEffect } from 'react';

const generateGradientStops = (themeType) => {
  const luminance = themeType === "dark" ? "16%" : "97%";
  return `
    hsl(0, 0%, ${luminance}) 0%,
    hsla(0, 0%, ${luminance}, 0.987) 8.1%,
    hsla(0, 0%, ${luminance}, 0.951) 15.5%,
    hsla(0, 0%, ${luminance}, 0.896) 22.5%,
    hsla(0, 0%, ${luminance}, 0.825) 29%,
    hsla(0, 0%, ${luminance}, 0.741) 35.3%,
    hsla(0, 0%, ${luminance}, 0.648) 41.2%,
    hsla(0, 0%, ${luminance}, 0.55) 47.1%,
    hsla(0, 0%, ${luminance}, 0.45) 52.9%,
    hsla(0, 0%, ${luminance}, 0.352) 58.8%,
    hsla(0, 0%, ${luminance}, 0.259) 64.7%,
    hsla(0, 0%, ${luminance}, 0.175) 71%,
    hsla(0, 0%, ${luminance}, 0.104) 77.5%,
    hsla(0, 0%, ${luminance}, 0.049) 84.5%,
    hsla(0, 0%, ${luminance}, 0.013) 91.9%,
    hsla(0, 0%, ${luminance}, 0) 100%
  `;
};
const fadeSize = 100;
const fadePadding = 10;
const useStyles = makeStyles(
  (theme) => ({
    root: {
      position: "relative",
      display: "flex",
      flexFlow: "row nowrap",
      alignItems: "center"
    },
    container: {
      overflow: "auto",
      scrollbarWidth: 0,
      // hide in FF
      "&::-webkit-scrollbar": {
        display: "none"
        // hide in Chrome
      }
    },
    fade: {
      position: "absolute",
      width: fadeSize,
      height: `calc(100% + ${fadePadding}px)`,
      transition: "opacity 300ms",
      pointerEvents: "none"
    },
    fadeLeft: {
      left: -fadePadding,
      background: `linear-gradient(90deg, ${generateGradientStops(
        theme.palette.type
      )})`
    },
    fadeRight: {
      right: -fadePadding,
      background: `linear-gradient(270deg, ${generateGradientStops(
        theme.palette.type
      )})`
    },
    fadeHidden: {
      opacity: 0
    },
    button: {
      position: "absolute"
    },
    buttonLeft: {
      left: -theme.spacing(2)
    },
    buttonRight: {
      right: -theme.spacing(2)
    }
  }),
  { name: "BackstageHorizontalScrollGrid" }
);
function useScrollDistance(ref) {
  const [[scrollLeft, scrollRight], setScroll] = useState([
    0,
    0
  ]);
  useLayoutEffect(() => {
    const el = ref.current;
    if (!el) {
      setScroll([0, 0]);
      return;
    }
    const handleUpdate = () => {
      const left = el.scrollLeft;
      const right = el.scrollWidth - el.offsetWidth - el.scrollLeft;
      setScroll([left, right]);
    };
    handleUpdate();
    el.addEventListener("scroll", handleUpdate);
    window.addEventListener("resize", handleUpdate);
    return () => {
      el.removeEventListener("scroll", handleUpdate);
      window.removeEventListener("resize", handleUpdate);
    };
  }, [ref]);
  return [scrollLeft, scrollRight];
}
function useSmoothScroll(ref, speed, minDistance) {
  const [scrollTarget, setScrollTarget] = useState(0);
  useLayoutEffect(() => {
    if (scrollTarget === 0) {
      return;
    }
    const startTime = window.performance.now();
    const id = requestAnimationFrame((frameTime) => {
      if (!ref.current) {
        return;
      }
      const frameDuration = frameTime - startTime;
      const scrollDistance = Math.abs(scrollTarget) * frameDuration / speed;
      const cappedScrollDistance = Math.max(minDistance, scrollDistance);
      const scrollAmount = cappedScrollDistance * Math.sign(scrollTarget);
      ref.current.scrollBy({ left: scrollAmount });
      const newScrollTarget = scrollTarget - scrollAmount;
      if (Math.sign(scrollTarget) !== Math.sign(newScrollTarget)) {
        setScrollTarget(0);
      } else {
        setScrollTarget(newScrollTarget);
      }
    });
    return () => cancelAnimationFrame(id);
  }, [ref, scrollTarget, speed, minDistance]);
  return setScrollTarget;
}
function HorizontalScrollGrid(props) {
  const {
    scrollStep = 100,
    scrollSpeed = 50,
    minScrollDistance = 5,
    children,
    ...otherProps
  } = props;
  const classes = useStyles(props);
  const ref = useRef();
  const [scrollLeft, scrollRight] = useScrollDistance(ref);
  const setScrollTarget = useSmoothScroll(ref, scrollSpeed, minScrollDistance);
  const handleScrollClick = (forwards) => {
    const el = ref.current;
    if (!el) {
      return;
    }
    setScrollTarget(forwards ? scrollStep : -scrollStep);
  };
  return /* @__PURE__ */ jsxs(Box, { ...otherProps, className: classes.root, children: [
    /* @__PURE__ */ jsx(
      Grid,
      {
        container: true,
        direction: "row",
        wrap: "nowrap",
        className: classes.container,
        ref,
        children
      }
    ),
    /* @__PURE__ */ jsx(
      Box,
      {
        className: classNames(classes.fade, classes.fadeLeft, {
          [classes.fadeHidden]: scrollLeft === 0
        })
      }
    ),
    /* @__PURE__ */ jsx(
      Box,
      {
        className: classNames(classes.fade, classes.fadeRight, {
          [classes.fadeHidden]: scrollRight === 0
        })
      }
    ),
    scrollLeft > 0 && /* @__PURE__ */ jsx(
      IconButton,
      {
        title: "Scroll Left",
        onClick: () => handleScrollClick(false),
        className: classNames(classes.button, classes.buttonLeft, {}),
        children: /* @__PURE__ */ jsx(ChevronLeftIcon, {})
      }
    ),
    scrollRight > 0 && /* @__PURE__ */ jsx(
      IconButton,
      {
        title: "Scroll Right",
        onClick: () => handleScrollClick(true),
        className: classNames(classes.button, classes.buttonRight, {}),
        children: /* @__PURE__ */ jsx(ChevronRight, {})
      }
    )
  ] });
}

export { HorizontalScrollGrid };
//# sourceMappingURL=HorizontalScrollGrid.esm.js.map
