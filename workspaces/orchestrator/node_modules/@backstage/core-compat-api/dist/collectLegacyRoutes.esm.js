import { jsx } from 'react/jsx-runtime';
import { createPlugin, getComponentData } from '@backstage/core-plugin-api';
import { PageBlueprint, createExtensionInput, coreExtensionData, createFrontendModule, createFrontendPlugin, ApiBlueprint, createExtension } from '@backstage/frontend-plugin-api';
import { Children, isValidElement } from 'react';
import { Route, Routes } from 'react-router-dom';
import { convertLegacyRouteRef, convertLegacyRouteRefs } from './convertLegacyRouteRef.esm.js';
import { compatWrapper } from './compatWrapper/compatWrapper.esm.js';
import { collectEntityPageContents } from './collectEntityPageContents.esm.js';
import { normalizeRoutePath } from './normalizeRoutePath.esm.js';

function makeRoutingShimExtension(options) {
  const { name, parentExtensionId, routePath, routeRef } = options;
  return createExtension({
    kind: "routing-shim",
    name,
    attachTo: { id: parentExtensionId, input: "childRoutingShims" },
    inputs: {
      childRoutingShims: createExtensionInput([
        coreExtensionData.routePath.optional(),
        coreExtensionData.routeRef.optional()
      ])
    },
    output: [
      coreExtensionData.routePath.optional(),
      coreExtensionData.routeRef.optional()
    ],
    *factory() {
      if (routePath !== void 0) {
        yield coreExtensionData.routePath(routePath);
      }
      if (routeRef) {
        yield coreExtensionData.routeRef(convertLegacyRouteRef(routeRef));
      }
    }
  });
}
function visitRouteChildren(options) {
  const { children, parentExtensionId, context } = options;
  const { pluginId, extensions, getUniqueName, discoverPlugin } = context;
  Children.forEach(children, (node) => {
    if (!isValidElement(node)) {
      return;
    }
    const plugin = getComponentData(node, "core.plugin");
    const routeRef = getComponentData(
      node,
      "core.mountPoint"
    );
    const routePath = node.props?.path;
    if (plugin) {
      discoverPlugin(plugin);
    }
    let nextParentExtensionId = parentExtensionId;
    if (routeRef || routePath) {
      const nextParentExtensionName = getUniqueName();
      nextParentExtensionId = `routing-shim:${pluginId}/${nextParentExtensionName}`;
      extensions.push(
        makeRoutingShimExtension({
          name: nextParentExtensionName,
          parentExtensionId,
          routePath,
          routeRef
        })
      );
    }
    visitRouteChildren({
      children: node.props.children,
      parentExtensionId: nextParentExtensionId,
      context
    });
  });
}
function collectLegacyRoutes(flatRoutesElement, entityPage) {
  const output = new Array();
  const pluginExtensions = /* @__PURE__ */ new Map();
  const getUniqueName = /* @__PURE__ */ (() => {
    let currentIndex = 1;
    return () => String(currentIndex++);
  })();
  const orphanRoutesPlugin = createPlugin({ id: "converted-orphan-routes" });
  const getPluginExtensions = (plugin) => {
    let extensions = pluginExtensions.get(plugin);
    if (!extensions) {
      extensions = [];
      pluginExtensions.set(plugin, extensions);
    }
    return extensions;
  };
  Children.forEach(flatRoutesElement.props.children, (route) => {
    if (route === null) {
      return;
    }
    if (!isValidElement(route)) {
      throw new Error(
        `Invalid element inside FlatRoutes, expected Route but found element of type ${typeof route}.`
      );
    }
    if (route.type !== Route) {
      throw new Error(
        `Invalid element inside FlatRoutes, expected Route but found ${route.type}.`
      );
    }
    const routeElement = route.props.element;
    const path = route.props.path;
    const plugin = getComponentData(routeElement, "core.plugin") ?? orphanRoutesPlugin;
    const routeRef = getComponentData(
      routeElement,
      "core.mountPoint"
    );
    if (path === void 0) {
      throw new Error(
        `Route element inside FlatRoutes had no path prop value given`
      );
    }
    const extensions = getPluginExtensions(plugin);
    const pageExtensionName = extensions.length ? getUniqueName() : void 0;
    const pageExtensionId = `page:${plugin.getId()}${pageExtensionName ? `/${pageExtensionName}` : pageExtensionName}`;
    extensions.push(
      PageBlueprint.makeWithOverrides({
        name: pageExtensionName,
        inputs: {
          childRoutingShims: createExtensionInput([
            coreExtensionData.routePath.optional(),
            coreExtensionData.routeRef.optional()
          ])
        },
        factory(originalFactory, { inputs: _inputs }) {
          return originalFactory({
            path: normalizeRoutePath(path),
            routeRef: routeRef ? convertLegacyRouteRef(routeRef) : void 0,
            loader: async () => compatWrapper(
              route.props.children ? /* @__PURE__ */ jsx(Routes, { children: /* @__PURE__ */ jsx(Route, { path: "*", element: routeElement, children: /* @__PURE__ */ jsx(Route, { path: "*", element: route.props.children }) }) }) : routeElement
            )
          });
        }
      })
    );
    visitRouteChildren({
      children: route.props.children,
      parentExtensionId: pageExtensionId,
      context: {
        pluginId: plugin.getId(),
        extensions,
        getUniqueName,
        discoverPlugin: getPluginExtensions
      }
    });
  });
  if (entityPage) {
    collectEntityPageContents(entityPage, {
      discoverExtension(extension, plugin) {
        if (!plugin || plugin.getId() === "catalog") {
          getPluginExtensions(orphanRoutesPlugin).push(extension);
        } else {
          getPluginExtensions(plugin).push(extension);
        }
      }
    });
    const extensions = new Array();
    visitRouteChildren({
      children: entityPage,
      parentExtensionId: `page:catalog/entity`,
      context: {
        pluginId: "catalog",
        extensions,
        getUniqueName,
        discoverPlugin(plugin) {
          if (plugin.getId() !== "catalog") {
            getPluginExtensions(plugin);
          }
        }
      }
    });
    output.push(
      createFrontendModule({
        pluginId: "catalog",
        extensions
      })
    );
  }
  for (const [plugin, extensions] of pluginExtensions) {
    output.push(
      createFrontendPlugin({
        pluginId: plugin.getId(),
        extensions: [
          ...extensions,
          ...Array.from(plugin.getApis()).map(
            (factory) => ApiBlueprint.make({
              name: factory.api.id,
              params: (defineParams) => defineParams(factory)
            })
          )
        ],
        routes: convertLegacyRouteRefs(plugin.routes ?? {}),
        externalRoutes: convertLegacyRouteRefs(plugin.externalRoutes ?? {})
      })
    );
  }
  return output;
}

export { collectLegacyRoutes, visitRouteChildren };
//# sourceMappingURL=collectLegacyRoutes.esm.js.map
