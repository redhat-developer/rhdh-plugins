import { jsx } from 'react/jsx-runtime';
import { useApp } from '@backstage/core-plugin-api';
import { swappableComponentsApiRef, iconsApiRef, routeResolutionApiRef, ErrorDisplay, NotFoundErrorPage, Progress } from '@backstage/frontend-plugin-api';
import { useMemo } from 'react';
import { toLegacyPlugin } from './BackwardsCompatProvider.esm.js';
import { ApiProvider } from '../core-app-api/src/apis/system/ApiProvider.esm.js';
import { useVersionedContext } from '@backstage/version-bridge';
import { convertLegacyRouteRef } from '../convertLegacyRouteRef.esm.js';

class CompatComponentsApi {
  #Progress;
  #NotFoundErrorPage;
  #ErrorBoundaryFallback;
  constructor(app) {
    const components = app.getComponents();
    const ErrorBoundaryFallback = (props) => /* @__PURE__ */ jsx(
      components.ErrorBoundaryFallback,
      {
        ...props,
        plugin: props.plugin && toLegacyPlugin(props.plugin)
      }
    );
    this.#Progress = components.Progress;
    this.#NotFoundErrorPage = components.NotFoundErrorPage;
    this.#ErrorBoundaryFallback = ErrorBoundaryFallback;
  }
  getComponent(ref) {
    switch (ref.id) {
      case Progress.ref.id:
        return this.#Progress;
      case NotFoundErrorPage.ref.id:
        return this.#NotFoundErrorPage;
      case ErrorDisplay.ref.id:
        return this.#ErrorBoundaryFallback;
      default:
        throw new Error(
          `No backwards compatible component is available for ref '${ref.id}'`
        );
    }
  }
}
class CompatIconsApi {
  #app;
  constructor(app) {
    this.#app = app;
  }
  getIcon(key) {
    return this.#app.getSystemIcon(key);
  }
  listIconKeys() {
    return Object.keys(this.#app.getSystemIcons());
  }
}
class CompatRouteResolutionApi {
  #routeResolver;
  constructor(routeResolver) {
    this.#routeResolver = routeResolver;
  }
  resolve(anyRouteRef, options) {
    const legacyRef = convertLegacyRouteRef(anyRouteRef);
    return this.#routeResolver.resolve(legacyRef, options?.sourcePath ?? "/");
  }
}
class ForwardsCompatApis {
  #componentsApi;
  #iconsApi;
  #routeResolutionApi;
  constructor(app, routeResolver) {
    this.#componentsApi = new CompatComponentsApi(app);
    this.#iconsApi = new CompatIconsApi(app);
    this.#routeResolutionApi = new CompatRouteResolutionApi(routeResolver);
  }
  get(ref) {
    if (ref.id === swappableComponentsApiRef.id) {
      return this.#componentsApi;
    } else if (ref.id === iconsApiRef.id) {
      return this.#iconsApi;
    } else if (ref.id === routeResolutionApiRef.id) {
      return this.#routeResolutionApi;
    }
    return void 0;
  }
}
function NewAppApisProvider(props) {
  const app = useApp();
  const versionedRouteResolverContext = useVersionedContext("routing-context");
  if (!versionedRouteResolverContext) {
    throw new Error("Routing context is not available");
  }
  const routeResolver = versionedRouteResolverContext.atVersion(1);
  if (!routeResolver) {
    throw new Error("RoutingContext v1 not available");
  }
  const appFallbackApis = useMemo(
    () => new ForwardsCompatApis(app, routeResolver),
    [app, routeResolver]
  );
  return /* @__PURE__ */ jsx(ApiProvider, { apis: appFallbackApis, children: props.children });
}
function ForwardsCompatProvider(props) {
  return /* @__PURE__ */ jsx(NewAppApisProvider, { children: props.children });
}

export { ForwardsCompatProvider };
//# sourceMappingURL=ForwardsCompatProvider.esm.js.map
