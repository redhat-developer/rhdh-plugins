import * as react_jsx_runtime from 'react/jsx-runtime';
import { ReactNode, JSX, ComponentType } from 'react';
import { AnalyticsApi, AnalyticsEvent, AnyApiFactory, IconComponent, BackstagePlugin, AppComponents, AppTheme, FeatureFlag, AnyRouteRefParams, RouteRef, SubRouteRef, ExternalRouteRef } from '@backstage/core-plugin-api';
import { AnalyticsApi as AnalyticsApi$1, AnalyticsEvent as AnalyticsEvent$1, FrontendPlugin, FrontendModule, ExtensionDefinition, RouteRef as RouteRef$1, SubRouteRef as SubRouteRef$1, ExternalRouteRef as ExternalRouteRef$1 } from '@backstage/frontend-plugin-api';

/**
 * Wraps a React element in a bidirectional compatibility provider, allow APIs
 * from `@backstage/core-plugin-api` to be used in an app from `@backstage/frontend-app-api`,
 * and APIs from `@backstage/frontend-plugin-api` to be used in an app from `@backstage/core-app-api`.
 *
 * @public
 */
declare function compatWrapper(element: ReactNode): react_jsx_runtime.JSX.Element;

/**
 * An implementation of the AnalyticsApi that can be used to forward analytics
 * events to multiple concrete implementations.
 *
 * @public
 *
 * @example
 *
 * ```jsx
 * createApiFactory({
 *   api: analyticsApiRef,
 *   deps: { configApi: configApiRef, identityApi: identityApiRef, storageApi: storageApiRef },
 *   factory: ({ configApi, identityApi, storageApi }) =>
 *     MultipleAnalyticsApi.fromApis([
 *       VendorAnalyticsApi.fromConfig(configApi, { identityApi }),
 *       CustomAnalyticsApi.fromConfig(configApi, { identityApi, storageApi }),
 *     ]),
 * });
 * ```
 */
declare class MultipleAnalyticsApi implements AnalyticsApi, AnalyticsApi$1 {
    private readonly actualApis;
    private constructor();
    /**
     * Create an AnalyticsApi implementation from an array of concrete
     * implementations.
     *
     * @example
     *
     * ```jsx
     * MultipleAnalyticsApi.fromApis([
     *   SomeAnalyticsApi.fromConfig(configApi),
     *   new CustomAnalyticsApi(),
     * ]);
     * ```
     */
    static fromApis(actualApis: (AnalyticsApi | AnalyticsApi$1)[]): MultipleAnalyticsApi;
    /**
     * Forward the event to all configured analytics API implementations.
     */
    captureEvent(event: AnalyticsEvent | AnalyticsEvent$1): void;
}

/**
 * Base implementation for the AnalyticsApi that does nothing.
 *
 * @public
 */
declare class NoOpAnalyticsApi implements AnalyticsApi, AnalyticsApi$1 {
    captureEvent(_event: AnalyticsEvent | AnalyticsEvent$1): void;
}

/** @public */
interface ConvertLegacyAppRootOptions {
    /**
     * By providing an entity page element here it will be split up and converted
     * into individual extensions for the catalog plugin in the new frontend
     * system.
     *
     * In order to use this option the entity page and other catalog extensions
     * must be removed from the legacy app, and the catalog plugin for the new
     * frontend system must be installed instead.
     *
     * In order for this conversion to work the entity page must be a plain React
     * element tree without any component wrapping anywhere between the root
     * element and the `EntityLayout.Route` elements.
     *
     * When enabling this conversion you are likely to encounter duplicate entity
     * page content provided both via the old structure and the new plugins. Any
     * duplicate content needs to be removed from the old structure.
     */
    entityPage?: JSX.Element;
}
/** @public */
declare function convertLegacyAppRoot(rootElement: JSX.Element, options?: ConvertLegacyAppRootOptions): (FrontendPlugin | FrontendModule)[];
/**
 * @public
 * @deprecated
 * Use `convertLegacyAppRoot` instead.
 */
declare const convertLegacyApp: typeof convertLegacyAppRoot;
/**
 * @public
 * @deprecated
 * Use `ConvertLegacyAppRootOptions` instead.
 */
type ConvertLegacyAppOptions = ConvertLegacyAppRootOptions;

/**
 * @public
 */
declare function convertLegacyAppOptions(options?: {
    apis?: Iterable<AnyApiFactory>;
    icons?: {
        [key in string]: IconComponent;
    };
    plugins?: Array<BackstagePlugin>;
    components?: Partial<AppComponents>;
    themes?: AppTheme[];
    featureFlags?: (FeatureFlag & Omit<FeatureFlag, 'pluginId'>)[];
}): FrontendModule;

/** @public */
declare function convertLegacyPlugin(legacyPlugin: BackstagePlugin, options: {
    extensions: ExtensionDefinition[];
}): FrontendPlugin;

/** @public */
declare function convertLegacyPageExtension(LegacyExtension: ComponentType<{}>, overrides?: {
    name?: string;
    path?: string;
    /**
     * @deprecated Use the `path` param instead.
     */
    defaultPath?: [Error: `Use the 'path' override instead`];
}): ExtensionDefinition;

/**
 * Converts a legacy route ref type to the new system.
 *
 * @public
 */
type ToNewRouteRef<T extends RouteRef | SubRouteRef | ExternalRouteRef> = T extends RouteRef<infer IParams> ? RouteRef$1<IParams> : T extends SubRouteRef<infer IParams> ? SubRouteRef$1<IParams> : T extends ExternalRouteRef<infer IParams> ? ExternalRouteRef$1<IParams> : never;
/**
 * Converts a collection of legacy route refs to the new system.
 * This is particularly useful when defining plugin `routes` and `externalRoutes`.
 *
 * @public
 */
declare function convertLegacyRouteRefs<TRefs extends {
    [name in string]: RouteRef | SubRouteRef | ExternalRouteRef;
}>(refs: TRefs): {
    [KName in keyof TRefs]: ToNewRouteRef<TRefs[KName]>;
};
/**
 * A temporary helper to convert a legacy route ref to the new system.
 *
 * @public
 * @remarks
 *
 * In the future the legacy createRouteRef will instead create refs compatible with both systems.
 */
declare function convertLegacyRouteRef<TParams extends AnyRouteRefParams>(ref: RouteRef<TParams>): RouteRef$1<TParams>;
/**
 * A temporary helper to convert a legacy sub route ref to the new system.
 *
 * @public
 * @remarks
 *
 * In the future the legacy createSubRouteRef will instead create refs compatible with both systems.
 */
declare function convertLegacyRouteRef<TParams extends AnyRouteRefParams>(ref: SubRouteRef<TParams>): SubRouteRef$1<TParams>;
/**
 * A temporary helper to convert a legacy external route ref to the new system.
 *
 * @public
 * @remarks
 *
 * In the future the legacy createExternalRouteRef will instead create refs compatible with both systems.
 */
declare function convertLegacyRouteRef<TParams extends AnyRouteRefParams>(ref: ExternalRouteRef<TParams>): ExternalRouteRef$1<TParams>;
/**
 * A temporary helper to convert a new route ref to the legacy system.
 *
 * @public
 * @remarks
 *
 * In the future the legacy createRouteRef will instead create refs compatible with both systems.
 */
declare function convertLegacyRouteRef<TParams extends AnyRouteRefParams>(ref: RouteRef$1<TParams>): RouteRef<TParams>;
/**
 * A temporary helper to convert a new sub route ref to the legacy system.
 *
 * @public
 * @remarks
 *
 * In the future the legacy createSubRouteRef will instead create refs compatible with both systems.
 */
declare function convertLegacyRouteRef<TParams extends AnyRouteRefParams>(ref: SubRouteRef$1<TParams>): SubRouteRef<TParams>;
/**
 * A temporary helper to convert a new external route ref to the legacy system.
 *
 * @public
 * @remarks
 *
 * In the future the legacy createExternalRouteRef will instead create refs compatible with both systems.
 */
declare function convertLegacyRouteRef<TParams extends AnyRouteRefParams>(ref: ExternalRouteRef$1<TParams>): ExternalRouteRef<TParams, true>;

export { type ConvertLegacyAppOptions, type ConvertLegacyAppRootOptions, MultipleAnalyticsApi, NoOpAnalyticsApi, type ToNewRouteRef, compatWrapper, convertLegacyApp, convertLegacyAppOptions, convertLegacyAppRoot, convertLegacyPageExtension, convertLegacyPlugin, convertLegacyRouteRef, convertLegacyRouteRefs };
