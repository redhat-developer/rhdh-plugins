import { jsxs, Fragment, jsx } from 'react/jsx-runtime';
import { stringifyEntityRef } from '@backstage/catalog-model';
import { Link } from '@backstage/core-components';
import { useApi, configApiRef, useAnalytics } from '@backstage/core-plugin-api';
import { assertError } from '@backstage/errors';
import { useTranslationRef } from '@backstage/frontend-plugin-api';
import { catalogApiRef } from '@backstage/plugin-catalog-react';
import FormHelperText from '@material-ui/core/FormHelperText';
import Grid from '@material-ui/core/Grid';
import Typography from '@material-ui/core/Typography';
import LocationOnIcon from '@material-ui/icons/LocationOn';
import { useState, useCallback } from 'react';
import { BackButton, NextButton } from '../Buttons/index.esm.js';
import { EntityListComponent } from '../EntityListComponent/EntityListComponent.esm.js';
import { catalogImportTranslationRef } from '../../translation.esm.js';

const StepReviewLocation = ({
  prepareResult,
  onReview,
  onGoBack
}) => {
  const { t } = useTranslationRef(catalogImportTranslationRef);
  const catalogApi = useApi(catalogApiRef);
  const configApi = useApi(configApiRef);
  const analytics = useAnalytics();
  const appTitle = configApi.getOptionalString("app.title") || "Backstage";
  const [submitted, setSubmitted] = useState(false);
  const [error, setError] = useState();
  const exists = prepareResult.type === "locations" && prepareResult.locations.some((l) => l.exists) ? true : false;
  const handleClick = useCallback(async () => {
    setSubmitted(true);
    analytics.captureEvent("click", "import entity");
    try {
      let refreshed = new Array();
      if (prepareResult.type === "locations") {
        refreshed = await Promise.all(
          prepareResult.locations.filter((l) => l.exists).map(async (l) => {
            const ref = stringifyEntityRef(l.entities[0] ?? l);
            await catalogApi.refreshEntity(ref);
            return { target: l.target };
          })
        );
      }
      const locations = await Promise.all(
        prepareResult.locations.filter((l) => !l.exists).map(async (l) => {
          const result = await catalogApi.addLocation({
            type: "url",
            target: l.target
          });
          return {
            target: result.location.target,
            entities: result.entities
          };
        })
      );
      onReview({
        ...prepareResult,
        ...{ refreshed },
        locations
      });
    } catch (e) {
      assertError(e);
      if (prepareResult.type === "repository" && e.message.startsWith(
        "Location was added but has no entities specified yet"
      )) {
        onReview({
          ...prepareResult,
          locations: prepareResult.locations.map((l) => ({
            target: l.target,
            entities: []
          }))
        });
      } else {
        setError(e.message);
        setSubmitted(false);
      }
    }
  }, [prepareResult, onReview, catalogApi, analytics]);
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    prepareResult.type === "repository" && /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsxs(Typography, { paragraph: true, children: [
        t("stepReviewLocation.prepareResult.title"),
        /* @__PURE__ */ jsx(
          Link,
          {
            to: prepareResult.pullRequest.url,
            target: "_blank",
            rel: "noopener noreferrer",
            children: prepareResult.pullRequest.url
          }
        )
      ] }),
      /* @__PURE__ */ jsx(Typography, { paragraph: true, children: t("stepReviewLocation.prepareResult.description", { appTitle }) })
    ] }),
    /* @__PURE__ */ jsx(Typography, { children: exists ? t("stepReviewLocation.catalog.exists") : t("stepReviewLocation.catalog.new") }),
    /* @__PURE__ */ jsx(
      EntityListComponent,
      {
        locations: prepareResult.locations,
        locationListItemIcon: () => /* @__PURE__ */ jsx(LocationOnIcon, {})
      }
    ),
    error && /* @__PURE__ */ jsx(FormHelperText, { error: true, children: error }),
    /* @__PURE__ */ jsxs(Grid, { container: true, spacing: 0, children: [
      onGoBack && /* @__PURE__ */ jsx(BackButton, { onClick: onGoBack, disabled: submitted }),
      /* @__PURE__ */ jsx(
        NextButton,
        {
          disabled: submitted,
          loading: submitted,
          onClick: () => handleClick(),
          children: exists ? t("stepReviewLocation.refresh") : t("stepReviewLocation.import")
        }
      )
    ] })
  ] });
};

export { StepReviewLocation };
//# sourceMappingURL=StepReviewLocation.esm.js.map
