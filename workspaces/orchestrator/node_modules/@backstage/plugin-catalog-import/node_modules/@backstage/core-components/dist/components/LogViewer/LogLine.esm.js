import { jsx } from 'react/jsx-runtime';
import { useRef, useMemo, useEffect } from 'react';
import startCase from 'lodash/startCase';
import classNames from 'classnames';
import Linkify from 'linkify-react';
import { Link } from '../Link/Link.esm.js';

function getModifierClasses(classes, modifiers) {
  const classNames = new Array();
  if (modifiers.bold) {
    classNames.push(classes.modifierBold);
  }
  if (modifiers.italic) {
    classNames.push(classes.modifierItalic);
  }
  if (modifiers.underline) {
    classNames.push(classes.modifierUnderline);
  }
  if (modifiers.foreground) {
    const key = `modifierForeground${startCase(
      modifiers.foreground
    )}`;
    classNames.push(classes[key]);
  }
  if (modifiers.background) {
    const key = `modifierBackground${startCase(
      modifiers.background
    )}`;
    classNames.push(classes[key]);
  }
  return classNames.length > 0 ? classNames.join(" ") : void 0;
}
function findSearchResults(text, searchText) {
  if (!searchText || !text.includes(searchText)) {
    return void 0;
  }
  const searchResults = new Array();
  let offset = 0;
  for (; ; ) {
    const start = text.indexOf(searchText, offset);
    if (start === -1) {
      break;
    }
    const end = start + searchText.length;
    searchResults.push({ start, end });
    offset = end;
  }
  return searchResults;
}
function calculateHighlightedChunks(line, searchText) {
  const results = findSearchResults(line.text, searchText);
  if (!results) {
    return line.chunks;
  }
  const chunks = new Array();
  let lineOffset = 0;
  let resultIndex = 0;
  let result = results[resultIndex];
  for (const chunk of line.chunks) {
    const { text, modifiers } = chunk;
    if (!result || lineOffset + text.length < result.start) {
      chunks.push(chunk);
      lineOffset += text.length;
      continue;
    }
    let localOffset = 0;
    while (result) {
      const localStart = Math.max(result.start - lineOffset, 0);
      if (localStart > text.length) {
        break;
      }
      const localEnd = Math.min(result.end - lineOffset, text.length);
      const hasTextBeforeResult = localStart > localOffset;
      if (hasTextBeforeResult) {
        chunks.push({ text: text.slice(localOffset, localStart), modifiers });
      }
      const hasResultText = localEnd > localStart;
      if (hasResultText) {
        chunks.push({
          modifiers,
          highlight: resultIndex,
          text: text.slice(localStart, localEnd)
        });
      }
      localOffset = localEnd;
      const foundCompleteResult = result.end - lineOffset === localEnd;
      if (foundCompleteResult) {
        resultIndex += 1;
        result = results[resultIndex];
      } else {
        break;
      }
    }
    const hasTextAfterResult = localOffset < text.length;
    if (hasTextAfterResult) {
      chunks.push({ text: text.slice(localOffset), modifiers });
    }
    lineOffset += text.length;
  }
  return chunks;
}
const renderLink = ({
  attributes,
  content
}) => {
  const { href, ...props } = attributes;
  return /* @__PURE__ */ jsx(Link, { to: href, ...props, children: content });
};
function LogLine({
  line,
  classes,
  searchText,
  highlightResultIndex,
  setRowHeight
}) {
  const lineRef = useRef(null);
  const chunks = useMemo(
    () => calculateHighlightedChunks(line, searchText),
    [line, searchText]
  );
  useEffect(() => {
    if (lineRef.current && setRowHeight) {
      setRowHeight(line.lineNumber, lineRef.current.offsetHeight);
    }
  }, [line.lineNumber, setRowHeight]);
  const elements = useMemo(
    () => chunks.map(({ text, modifiers, highlight }, index) => (
      // eslint-disable-next-line react/forbid-elements
      /* @__PURE__ */ jsx(
        "span",
        {
          className: classNames(
            getModifierClasses(classes, modifiers),
            highlight !== void 0 && (highlight === highlightResultIndex ? classes.textSelectedHighlight : classes.textHighlight),
            { [classes.textWrap]: !!setRowHeight }
          ),
          children: /* @__PURE__ */ jsx(Linkify, { options: { render: renderLink }, children: text })
        },
        index
      )
    )),
    [chunks, highlightResultIndex, classes, setRowHeight]
  );
  return /* @__PURE__ */ jsx("span", { ref: lineRef, children: elements });
}

export { LogLine, calculateHighlightedChunks, findSearchResults, getModifierClasses };
//# sourceMappingURL=LogLine.esm.js.map
