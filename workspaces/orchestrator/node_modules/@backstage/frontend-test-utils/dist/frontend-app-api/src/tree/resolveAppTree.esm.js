import { toInternalExtension } from '../../../frontend-plugin-api/src/wiring/resolveExtensionDefinition.esm.js';

function indent(str) {
  return str.replace(/^/gm, "  ");
}
class SerializableAppNode {
  spec;
  edges = {
    attachedTo: void 0,
    attachments: /* @__PURE__ */ new Map()
  };
  instance;
  constructor(spec) {
    this.spec = spec;
  }
  setParent(parent, input) {
    this.edges.attachedTo = { node: parent, input };
    const parentInputEdges = parent.edges.attachments.get(input);
    if (parentInputEdges) {
      parentInputEdges.push(this);
    } else {
      parent.edges.attachments.set(input, [this]);
    }
  }
  toJSON() {
    const dataRefs = this.instance && [...this.instance.getDataRefs()];
    return {
      id: this.spec.id,
      output: dataRefs && dataRefs.length > 0 ? dataRefs.map((ref) => ref.id) : void 0,
      attachments: this.edges.attachments.size > 0 ? Object.fromEntries(this.edges.attachments) : void 0
    };
  }
  toString() {
    const dataRefs = this.instance && [...this.instance.getDataRefs()];
    const out = dataRefs && dataRefs.length > 0 ? ` out=[${[...dataRefs].map((r) => r.id).join(", ")}]` : "";
    if (this.edges.attachments.size === 0) {
      return `<${this.spec.id}${out} />`;
    }
    return [
      `<${this.spec.id}${out}>`,
      ...[...this.edges.attachments.entries()].map(
        ([k, v]) => indent([`${k} [`, ...v.map((e) => indent(e.toString())), `]`].join("\n"))
      ),
      `</${this.spec.id}>`
    ].join("\n");
  }
}
function makeRedirectKey(attachTo) {
  return `${attachTo.id}%${attachTo.input}`;
}
const isValidAttachmentPoint = (attachTo, nodes) => {
  if (!nodes.has(attachTo.id)) {
    return false;
  }
  return attachTo.input in toInternalExtension(nodes.get(attachTo.id).spec.extension).inputs;
};
function resolveAppTree(rootNodeId, specs, errorCollector) {
  const nodes = /* @__PURE__ */ new Map();
  const redirectTargetsByKey = /* @__PURE__ */ new Map();
  for (const spec of specs) {
    if (nodes.has(spec.id)) {
      continue;
    }
    const node = new SerializableAppNode(spec);
    nodes.set(spec.id, node);
    const internal = toInternalExtension(spec.extension);
    for (const [inputName, input] of Object.entries(internal.inputs)) {
      if (input.replaces) {
        for (const replace of input.replaces) {
          const key = makeRedirectKey(replace);
          if (redirectTargetsByKey.has(key)) {
            errorCollector.report({
              code: "EXTENSION_INPUT_REDIRECT_CONFLICT",
              message: `Duplicate redirect target for input '${inputName}' in extension '${spec.id}'`,
              context: {
                node,
                inputName
              }
            });
            continue;
          }
          redirectTargetsByKey.set(key, { id: spec.id, input: inputName });
        }
      }
    }
  }
  const orphans = new Array();
  const clones = /* @__PURE__ */ new Map();
  let rootNode = void 0;
  for (const node of nodes.values()) {
    const spec = node.spec;
    if (spec.id === rootNodeId) {
      rootNode = node;
    } else if (Array.isArray(spec.attachTo)) {
      let foundFirstParent = false;
      for (const origAttachTo of spec.attachTo) {
        let attachTo = origAttachTo;
        if (!isValidAttachmentPoint(attachTo, nodes)) {
          attachTo = redirectTargetsByKey.get(makeRedirectKey(attachTo)) ?? attachTo;
        }
        const parent = nodes.get(attachTo.id);
        if (parent) {
          const cloneParents = clones.get(attachTo.id) ?? [];
          if (!foundFirstParent) {
            foundFirstParent = true;
            node.setParent(parent, attachTo.input);
          } else {
            cloneParents.unshift(parent);
          }
          for (const extraParent of cloneParents) {
            const clonedNode = new SerializableAppNode(spec);
            clonedNode.setParent(extraParent, attachTo.input);
            clones.set(
              spec.id,
              clones.get(spec.id)?.concat(clonedNode) ?? [clonedNode]
            );
          }
        }
      }
      if (!foundFirstParent) {
        orphans.push(node);
      }
    } else {
      let attachTo = spec.attachTo;
      if (!isValidAttachmentPoint(attachTo, nodes)) {
        attachTo = redirectTargetsByKey.get(makeRedirectKey(attachTo)) ?? attachTo;
      }
      const parent = nodes.get(attachTo.id);
      if (parent) {
        node.setParent(parent, attachTo.input);
      } else {
        orphans.push(node);
      }
    }
  }
  if (!rootNode) {
    throw new Error(`No root node with id '${rootNodeId}' found in app tree`);
  }
  return {
    root: rootNode,
    nodes,
    orphans
  };
}

export { resolveAppTree };
//# sourceMappingURL=resolveAppTree.esm.js.map
