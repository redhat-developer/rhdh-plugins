'use strict';

var catalogModel = require('@backstage/catalog-model');
var lodash = require('lodash');
var yaml = require('yaml');
var processingResult = require('../api/processingResult.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var lodash__default = /*#__PURE__*/_interopDefaultCompat(lodash);
var yaml__default = /*#__PURE__*/_interopDefaultCompat(yaml);

function* parseEntityYaml(data, location) {
  let documents;
  try {
    documents = yaml__default.default.parseAllDocuments(
      typeof data === "string" ? data : data.toString("utf8")
    ).filter((d) => d);
  } catch (e) {
    const loc = catalogModel.stringifyLocationRef(location);
    const message = `Failed to parse YAML at ${loc}, ${e}`;
    yield processingResult.processingResult.generalError(location, message);
    return;
  }
  for (const document of documents) {
    if (document.errors?.length) {
      const loc = catalogModel.stringifyLocationRef(location);
      const message = `YAML error at ${loc}, ${document.errors[0]}`;
      yield processingResult.processingResult.generalError(location, message);
    } else {
      const json = document.toJSON();
      if (lodash__default.default.isPlainObject(json)) {
        yield processingResult.processingResult.entity(location, json);
      } else if (json === null) ; else {
        const message = `Expected object at root, got ${typeof json}`;
        yield processingResult.processingResult.generalError(location, message);
      }
    }
  }
}

exports.parseEntityYaml = parseEntityYaml;
//# sourceMappingURL=parse.cjs.js.map
