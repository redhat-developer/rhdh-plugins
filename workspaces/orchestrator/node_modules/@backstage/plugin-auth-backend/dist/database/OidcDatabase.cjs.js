'use strict';

function toDate(value) {
  if (!value) {
    return void 0;
  }
  return typeof value === "string" || typeof value === "number" ? new Date(value) : value;
}
class OidcDatabase {
  constructor(db) {
    this.db = db;
  }
  static async create(options) {
    const client = await options.database.get();
    return new OidcDatabase(client);
  }
  async createClient(client) {
    await this.db("oidc_clients").insert({
      client_id: client.clientId,
      client_secret: client.clientSecret,
      client_name: client.clientName,
      response_types: JSON.stringify(client.responseTypes),
      grant_types: JSON.stringify(client.grantTypes),
      redirect_uris: JSON.stringify(client.redirectUris),
      scope: client.scope,
      metadata: JSON.stringify(client.metadata)
    });
    return client;
  }
  async getClient({ clientId }) {
    const client = await this.db("oidc_clients").where("client_id", clientId).first();
    if (!client) {
      return null;
    }
    return this.rowToClient(client);
  }
  async createAuthorizationSession(session) {
    await this.db(
      "oauth_authorization_sessions"
    ).insert({
      id: session.id,
      client_id: session.clientId,
      user_entity_ref: session.userEntityRef,
      redirect_uri: session.redirectUri,
      scope: session.scope,
      state: session.state,
      response_type: session.responseType,
      code_challenge: session.codeChallenge,
      code_challenge_method: session.codeChallengeMethod,
      nonce: session.nonce,
      status: "pending",
      expires_at: session.expiresAt
    });
    return {
      ...session,
      status: "pending"
    };
  }
  async updateAuthorizationSession(session) {
    const row = this.authorizationSessionToRow(session);
    const updatedFields = Object.fromEntries(
      Object.entries(row).filter(([_, value]) => value !== void 0)
    );
    if (this.db.client.config.client.includes("sqlite3") || this.db.client.config.client.includes("mysql")) {
      return await this.db.transaction(async (trx) => {
        await trx("oauth_authorization_sessions").where("id", session.id).update(updatedFields);
        const updated = await trx(
          "oauth_authorization_sessions"
        ).where("id", session.id).first();
        if (!updated) {
          throw new Error(
            `Failed to retrieve updated authorization session with id ${session.id}`
          );
        }
        return this.rowToAuthorizationSession(updated);
      });
    }
    const returnedRows = await this.db(
      "oauth_authorization_sessions"
    ).where("id", session.id).update(updatedFields).returning("*");
    if (returnedRows.length !== 1) {
      throw new Error(
        `Failed to retrieve updated authorization session with id ${session.id}`
      );
    }
    const [returnedSession] = returnedRows;
    return this.rowToAuthorizationSession(
      returnedSession
    );
  }
  async getAuthorizationSession({ id }) {
    const session = await this.db(
      "oauth_authorization_sessions"
    ).where("id", id).first();
    if (!session) {
      return null;
    }
    return this.rowToAuthorizationSession(session);
  }
  async createAuthorizationCode(authorizationCode) {
    await this.db("oidc_authorization_codes").insert({
      code: authorizationCode.code,
      session_id: authorizationCode.sessionId,
      expires_at: authorizationCode.expiresAt,
      used: false
    });
    return {
      ...authorizationCode,
      used: false
    };
  }
  async getAuthorizationCode({ code }) {
    const authCode = await this.db(
      "oidc_authorization_codes"
    ).where("code", code).first();
    if (!authCode) {
      return null;
    }
    return this.rowToAuthorizationCode(authCode);
  }
  async updateAuthorizationCode(authorizationCode) {
    const row = this.authorizationCodeToRow(authorizationCode);
    const updatedFields = Object.fromEntries(
      Object.entries(row).filter(([_, value]) => value !== void 0)
    );
    if (this.db.client.config.client.includes("sqlite3") || this.db.client.config.client.includes("mysql")) {
      return await this.db.transaction(async (trx) => {
        await trx("oidc_authorization_codes").where("code", authorizationCode.code).update(updatedFields);
        const updated = await trx(
          "oidc_authorization_codes"
        ).where("code", authorizationCode.code).first();
        if (!updated) {
          throw new Error(
            `Failed to retrieve updated authorization code with code ${authorizationCode.code}`
          );
        }
        return this.rowToAuthorizationCode(updated);
      });
    }
    const returnedRows = await this.db(
      "oidc_authorization_codes"
    ).where("code", authorizationCode.code).update(updatedFields).returning("*");
    if (returnedRows.length !== 1) {
      throw new Error(
        `Failed to retrieve updated authorization code with code ${authorizationCode.code}`
      );
    }
    const [returnedCode] = returnedRows;
    return this.rowToAuthorizationCode(returnedCode);
  }
  rowToClient(row) {
    return {
      clientId: row.client_id,
      clientName: row.client_name,
      clientSecret: row.client_secret,
      redirectUris: row.redirect_uris ? JSON.parse(row.redirect_uris) : void 0,
      responseTypes: row.response_types ? JSON.parse(row.response_types) : void 0,
      grantTypes: row.grant_types ? JSON.parse(row.grant_types) : void 0,
      scope: row.scope ?? void 0,
      metadata: row.metadata ? JSON.parse(row.metadata) : void 0
    };
  }
  authorizationSessionToRow(session) {
    return {
      id: session.id,
      client_id: session.clientId,
      user_entity_ref: session.userEntityRef,
      redirect_uri: session.redirectUri,
      scope: session.scope,
      state: session.state,
      response_type: session.responseType,
      code_challenge: session.codeChallenge,
      code_challenge_method: session.codeChallengeMethod,
      nonce: session.nonce,
      status: session.status,
      expires_at: toDate(session.expiresAt)
    };
  }
  rowToAuthorizationSession(row) {
    return {
      id: row.id,
      clientId: row.client_id,
      userEntityRef: row.user_entity_ref ?? void 0,
      redirectUri: row.redirect_uri,
      scope: row.scope ?? void 0,
      state: row.state ?? void 0,
      responseType: row.response_type,
      codeChallenge: row.code_challenge ?? void 0,
      codeChallengeMethod: row.code_challenge_method ?? void 0,
      nonce: row.nonce ?? void 0,
      status: row.status,
      expiresAt: toDate(row.expires_at)
    };
  }
  authorizationCodeToRow(authorizationCode) {
    return {
      code: authorizationCode.code,
      session_id: authorizationCode.sessionId,
      expires_at: toDate(authorizationCode.expiresAt),
      used: authorizationCode.used
    };
  }
  rowToAuthorizationCode(row) {
    return {
      code: row.code,
      sessionId: row.session_id,
      expiresAt: toDate(row.expires_at),
      used: Boolean(row.used)
    };
  }
}

exports.OidcDatabase = OidcDatabase;
//# sourceMappingURL=OidcDatabase.cjs.js.map
