'use strict';

var errors = require('@backstage/errors');
var jose = require('jose');
var crypto = require('crypto');
var luxon = require('luxon');
var matcher = require('matcher');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var crypto__default = /*#__PURE__*/_interopDefaultCompat(crypto);
var matcher__default = /*#__PURE__*/_interopDefaultCompat(matcher);

class OidcService {
  constructor(auth, tokenIssuer, baseUrl, userInfo, oidc, config) {
    this.auth = auth;
    this.tokenIssuer = tokenIssuer;
    this.baseUrl = baseUrl;
    this.userInfo = userInfo;
    this.oidc = oidc;
    this.config = config;
  }
  static create(options) {
    return new OidcService(
      options.auth,
      options.tokenIssuer,
      options.baseUrl,
      options.userInfo,
      options.oidc,
      options.config
    );
  }
  getConfiguration() {
    return {
      issuer: this.baseUrl,
      token_endpoint: `${this.baseUrl}/v1/token`,
      userinfo_endpoint: `${this.baseUrl}/v1/userinfo`,
      jwks_uri: `${this.baseUrl}/.well-known/jwks.json`,
      response_types_supported: ["code", "id_token"],
      subject_types_supported: ["public"],
      id_token_signing_alg_values_supported: [
        "RS256",
        "RS384",
        "RS512",
        "ES256",
        "ES384",
        "ES512",
        "PS256",
        "PS384",
        "PS512",
        "EdDSA"
      ],
      scopes_supported: ["openid"],
      token_endpoint_auth_methods_supported: [
        "client_secret_basic",
        "client_secret_post"
      ],
      claims_supported: ["sub", "ent"],
      grant_types_supported: ["authorization_code"],
      authorization_endpoint: `${this.baseUrl}/v1/authorize`,
      registration_endpoint: `${this.baseUrl}/v1/register`,
      code_challenge_methods_supported: ["S256", "plain"]
    };
  }
  async listPublicKeys() {
    return await this.tokenIssuer.listPublicKeys();
  }
  async getUserInfo({ token }) {
    const credentials = await this.auth.authenticate(token, {
      allowLimitedAccess: true
    });
    if (!this.auth.isPrincipal(credentials, "user")) {
      throw new errors.InputError(
        "Userinfo endpoint must be called with a token that represents a user principal"
      );
    }
    const { sub: userEntityRef } = jose.decodeJwt(token);
    if (typeof userEntityRef !== "string") {
      throw new Error("Invalid user token, user entity ref must be a string");
    }
    return await this.userInfo.getUserInfo(userEntityRef);
  }
  async registerClient(opts) {
    const generatedClientId = crypto__default.default.randomUUID();
    const generatedClientSecret = crypto__default.default.randomUUID();
    const allowedRedirectUriPatterns = this.config.getOptionalStringArray(
      "auth.experimentalDynamicClientRegistration.allowedRedirectUriPatterns"
    ) ?? ["*"];
    for (const redirectUri of opts.redirectUris ?? []) {
      if (!allowedRedirectUriPatterns.some(
        (pattern) => matcher__default.default.isMatch(redirectUri, pattern)
      )) {
        throw new errors.InputError("Invalid redirect_uri");
      }
    }
    return await this.oidc.createClient({
      clientId: generatedClientId,
      clientName: opts.clientName,
      clientSecret: generatedClientSecret,
      redirectUris: opts.redirectUris ?? [],
      responseTypes: opts.responseTypes ?? ["code"],
      grantTypes: opts.grantTypes ?? ["authorization_code"],
      scope: opts.scope
    });
  }
  async createAuthorizationSession(opts) {
    const {
      clientId,
      redirectUri,
      responseType,
      scope,
      state,
      nonce,
      codeChallenge,
      codeChallengeMethod
    } = opts;
    if (responseType !== "code") {
      throw new errors.InputError("Only authorization code flow is supported");
    }
    const client = await this.oidc.getClient({ clientId });
    if (!client) {
      throw new errors.InputError("Invalid client_id");
    }
    if (!client.redirectUris.includes(redirectUri)) {
      throw new errors.InputError("Invalid redirect_uri");
    }
    if (codeChallenge) {
      if (!codeChallengeMethod || !["S256", "plain"].includes(codeChallengeMethod)) {
        throw new errors.InputError("Invalid code_challenge_method");
      }
    }
    const sessionId = crypto__default.default.randomUUID();
    const sessionExpiresAt = luxon.DateTime.now().plus({ hours: 1 }).toJSDate();
    await this.oidc.createAuthorizationSession({
      id: sessionId,
      clientId,
      redirectUri,
      responseType,
      scope,
      state,
      codeChallenge,
      codeChallengeMethod,
      nonce,
      expiresAt: sessionExpiresAt
    });
    return {
      id: sessionId,
      clientName: client.clientName,
      scope,
      redirectUri
    };
  }
  async approveAuthorizationSession(opts) {
    const { sessionId, userEntityRef } = opts;
    const session = await this.oidc.getAuthorizationSession({
      id: sessionId
    });
    if (!session) {
      throw new errors.NotFoundError("Invalid authorization session");
    }
    if (luxon.DateTime.fromJSDate(session.expiresAt) < luxon.DateTime.now()) {
      throw new errors.InputError("Authorization session expired");
    }
    if (session.status !== "pending") {
      throw new errors.NotFoundError("Authorization session not found or expired");
    }
    await this.oidc.updateAuthorizationSession({
      id: session.id,
      userEntityRef,
      status: "approved"
    });
    const authorizationCode = crypto__default.default.randomBytes(32).toString("base64url");
    const codeExpiresAt = luxon.DateTime.now().plus({ minutes: 10 }).toJSDate();
    await this.oidc.createAuthorizationCode({
      code: authorizationCode,
      sessionId: session.id,
      expiresAt: codeExpiresAt
    });
    const redirectUrl = new URL(session.redirectUri);
    redirectUrl.searchParams.append("code", authorizationCode);
    if (session.state) {
      redirectUrl.searchParams.append("state", session.state);
    }
    return {
      redirectUrl: redirectUrl.toString()
    };
  }
  async getAuthorizationSession(opts) {
    const session = await this.oidc.getAuthorizationSession({
      id: opts.sessionId
    });
    if (!session) {
      throw new errors.NotFoundError("Invalid authorization session");
    }
    if (luxon.DateTime.fromJSDate(session.expiresAt) < luxon.DateTime.now()) {
      throw new errors.InputError("Authorization session expired");
    }
    if (session.status !== "pending") {
      throw new errors.NotFoundError("Authorization session not found or expired");
    }
    const client = await this.oidc.getClient({ clientId: session.clientId });
    if (!client) {
      throw new errors.InputError("Invalid client_id");
    }
    return {
      id: session.id,
      clientId: session.clientId,
      clientName: client.clientName,
      redirectUri: session.redirectUri,
      scope: session.scope,
      state: session.state,
      responseType: session.responseType,
      codeChallenge: session.codeChallenge,
      codeChallengeMethod: session.codeChallengeMethod,
      nonce: session.nonce,
      expiresAt: session.expiresAt,
      status: session.status
    };
  }
  async rejectAuthorizationSession(opts) {
    const { sessionId, userEntityRef } = opts;
    const session = await this.oidc.getAuthorizationSession({
      id: sessionId
    });
    if (!session) {
      throw new errors.NotFoundError("Invalid authorization session");
    }
    if (luxon.DateTime.fromJSDate(session.expiresAt) < luxon.DateTime.now()) {
      throw new errors.InputError("Authorization session expired");
    }
    if (session.status !== "pending") {
      throw new errors.NotFoundError("Authorization session not found or expired");
    }
    await this.oidc.updateAuthorizationSession({
      id: session.id,
      status: "rejected",
      userEntityRef
    });
  }
  async exchangeCodeForToken(params) {
    const { code, redirectUri, codeVerifier, grantType } = params;
    if (grantType !== "authorization_code") {
      throw new errors.InputError("Unsupported grant type");
    }
    const authCode = await this.oidc.getAuthorizationCode({ code });
    if (!authCode) {
      throw new errors.AuthenticationError("Invalid authorization code");
    }
    if (luxon.DateTime.fromJSDate(authCode.expiresAt) < luxon.DateTime.now()) {
      throw new errors.AuthenticationError("Authorization code expired");
    }
    if (authCode.used) {
      throw new errors.AuthenticationError("Authorization code already used");
    }
    const session = await this.oidc.getAuthorizationSession({
      id: authCode.sessionId
    });
    if (!session) {
      throw new errors.NotFoundError("Invalid authorization session");
    }
    if (session.redirectUri !== redirectUri) {
      throw new errors.AuthenticationError("Redirect URI mismatch");
    }
    if (session.status !== "approved") {
      throw new errors.AuthenticationError("Authorization not approved");
    }
    if (!session.userEntityRef) {
      throw new errors.AuthenticationError("No user associated with authorization");
    }
    if (session.codeChallenge) {
      if (!codeVerifier) {
        throw new errors.AuthenticationError("Code verifier required for PKCE");
      }
      if (!this.verifyPkce(
        session.codeChallenge,
        codeVerifier,
        session.codeChallengeMethod
      )) {
        throw new errors.AuthenticationError("Invalid code verifier");
      }
    }
    await this.oidc.updateAuthorizationCode({
      code,
      used: true
    });
    const { token } = await this.tokenIssuer.issueToken({
      claims: {
        sub: session.userEntityRef
      }
    });
    return {
      accessToken: token,
      tokenType: "Bearer",
      expiresIn: 3600,
      idToken: token,
      scope: session.scope || "openid"
    };
  }
  verifyPkce(codeChallenge, codeVerifier, method) {
    if (!method || method === "plain") {
      return codeChallenge === codeVerifier;
    }
    if (method === "S256") {
      const hash = crypto__default.default.createHash("sha256").update(codeVerifier).digest();
      const base64urlHash = hash.toString("base64url");
      return codeChallenge === base64urlHash;
    }
    return false;
  }
}

exports.OidcService = OidcService;
//# sourceMappingURL=OidcService.cjs.js.map
