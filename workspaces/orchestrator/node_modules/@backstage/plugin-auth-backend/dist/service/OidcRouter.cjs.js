'use strict';

var Router = require('express-promise-router');
var OidcService = require('./OidcService.cjs.js');
var errors = require('@backstage/errors');
var express = require('express');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var Router__default = /*#__PURE__*/_interopDefaultCompat(Router);

class OidcRouter {
  constructor(oidc, logger, auth, appUrl, httpAuth, config) {
    this.oidc = oidc;
    this.logger = logger;
    this.auth = auth;
    this.appUrl = appUrl;
    this.httpAuth = httpAuth;
    this.config = config;
  }
  static create(options) {
    return new OidcRouter(
      OidcService.OidcService.create(options),
      options.logger,
      options.auth,
      options.appUrl,
      options.httpAuth,
      options.config
    );
  }
  getRouter() {
    const router = Router__default.default();
    router.use(express.json());
    router.get("/.well-known/openid-configuration", (_req, res) => {
      res.json(this.oidc.getConfiguration());
    });
    router.get("/.well-known/jwks.json", async (_req, res) => {
      const { keys } = await this.oidc.listPublicKeys();
      res.json({ keys });
    });
    router.get("/v1/userinfo", async (req, res) => {
      const matches = req.headers.authorization?.match(/^Bearer[ ]+(\S+)$/i);
      const token = matches?.[1];
      if (!token) {
        throw new errors.AuthenticationError("No token provided");
      }
      const userInfo = await this.oidc.getUserInfo({ token });
      if (!userInfo) {
        res.status(404).send("User info not found");
        return;
      }
      res.json(userInfo);
    });
    if (this.config.getOptionalBoolean(
      "auth.experimentalDynamicClientRegistration.enabled"
    )) {
      router.get("/v1/authorize", async (req, res) => {
        const {
          client_id: clientId,
          redirect_uri: redirectUri,
          response_type: responseType,
          scope,
          state,
          nonce,
          code_challenge: codeChallenge,
          code_challenge_method: codeChallengeMethod
        } = req.query;
        if (!clientId || !redirectUri || !responseType) {
          this.logger.error(`Failed to authorize: Missing required parameters`);
          return res.status(400).json({
            error: "invalid_request",
            error_description: "Missing required parameters: client_id, redirect_uri, response_type"
          });
        }
        try {
          const result = await this.oidc.createAuthorizationSession({
            clientId,
            redirectUri,
            responseType,
            scope,
            state,
            nonce,
            codeChallenge,
            codeChallengeMethod
          });
          const authSessionRedirectUrl = new URL(
            `./oauth2/authorize/${result.id}`,
            ensureTrailingSlash(this.appUrl)
          );
          return res.redirect(authSessionRedirectUrl.toString());
        } catch (error) {
          const errorParams = new URLSearchParams();
          errorParams.append(
            "error",
            errors.isError(error) ? error.name : "server_error"
          );
          errorParams.append(
            "error_description",
            errors.isError(error) ? error.message : "Unknown error"
          );
          if (state) {
            errorParams.append("state", state);
          }
          const redirectUrl = new URL(redirectUri);
          redirectUrl.search = errorParams.toString();
          return res.redirect(redirectUrl.toString());
        }
      });
      router.get("/v1/sessions/:sessionId", async (req, res) => {
        const { sessionId } = req.params;
        if (!sessionId) {
          return res.status(400).json({
            error: "invalid_request",
            error_description: "Missing Authorization Session ID"
          });
        }
        try {
          const session = await this.oidc.getAuthorizationSession({
            sessionId
          });
          return res.json({
            id: session.id,
            clientName: session.clientName,
            scope: session.scope,
            redirectUri: session.redirectUri
          });
        } catch (error) {
          const description = errors.isError(error) ? error.message : "Unknown error";
          this.logger.error(
            `Failed to get authorization session: ${description}`,
            error
          );
          return res.status(404).json({
            error: "not_found",
            error_description: description
          });
        }
      });
      router.post("/v1/sessions/:sessionId/approve", async (req, res) => {
        const { sessionId } = req.params;
        if (!sessionId) {
          return res.status(400).json({
            error: "invalid_request",
            error_description: "Missing authorization session ID"
          });
        }
        try {
          const httpCredentials = await this.httpAuth.credentials(req);
          if (!this.auth.isPrincipal(httpCredentials, "user")) {
            return res.status(401).json({
              error: "unauthorized",
              error_description: "Authentication required"
            });
          }
          const { userEntityRef } = httpCredentials.principal;
          const result = await this.oidc.approveAuthorizationSession({
            sessionId,
            userEntityRef
          });
          return res.json({
            redirectUrl: result.redirectUrl
          });
        } catch (error) {
          const description = errors.isError(error) ? error.message : "Unknown error";
          this.logger.error(
            `Failed to approve authorization session: ${description}`,
            error
          );
          return res.status(400).json({
            error: "invalid_request",
            error_description: description
          });
        }
      });
      router.post("/v1/sessions/:sessionId/reject", async (req, res) => {
        const { sessionId } = req.params;
        if (!sessionId) {
          return res.status(400).json({
            error: "invalid_request",
            error_description: "Missing authorization session ID"
          });
        }
        const httpCredentials = await this.httpAuth.credentials(req);
        if (!this.auth.isPrincipal(httpCredentials, "user")) {
          return res.status(401).json({
            error: "unauthorized",
            error_description: "Authentication required"
          });
        }
        const { userEntityRef } = httpCredentials.principal;
        try {
          const session = await this.oidc.getAuthorizationSession({
            sessionId
          });
          await this.oidc.rejectAuthorizationSession({
            sessionId,
            userEntityRef
          });
          const errorParams = new URLSearchParams();
          errorParams.append("error", "access_denied");
          errorParams.append("error_description", "User denied the request");
          if (session.state) {
            errorParams.append("state", session.state);
          }
          const redirectUrl = new URL(session.redirectUri);
          redirectUrl.search = errorParams.toString();
          return res.json({
            redirectUrl: redirectUrl.toString()
          });
        } catch (error) {
          const description = errors.isError(error) ? error.message : "Unknown error";
          this.logger.error(
            `Failed to reject authorization session: ${description}`,
            error
          );
          return res.status(400).json({
            error: "invalid_request",
            error_description: description
          });
        }
      });
      router.post("/v1/token", async (req, res) => {
        const {
          grant_type: grantType,
          code,
          redirect_uri: redirectUri,
          code_verifier: codeVerifier
        } = req.body;
        if (!grantType || !code || !redirectUri) {
          this.logger.error(
            `Failed to exchange code for token: Missing required parameters`
          );
          return res.status(400).json({
            error: "invalid_request",
            error_description: "Missing required parameters"
          });
        }
        try {
          const result = await this.oidc.exchangeCodeForToken({
            code,
            redirectUri,
            codeVerifier,
            grantType
          });
          return res.json({
            access_token: result.accessToken,
            token_type: result.tokenType,
            expires_in: result.expiresIn,
            id_token: result.idToken,
            scope: result.scope
          });
        } catch (error) {
          const description = errors.isError(error) ? error.message : "Unknown error";
          this.logger.error(
            `Failed to exchange code for token: ${description}`,
            error
          );
          if (errors.isError(error)) {
            if (error.name === "AuthenticationError") {
              return res.status(401).json({
                error: "invalid_client",
                error_description: error.message
              });
            }
            if (error.name === "InputError") {
              return res.status(400).json({
                error: "invalid_request",
                error_description: error.message
              });
            }
          }
          return res.status(500).json({
            error: "server_error",
            error_description: description
          });
        }
      });
      router.post("/v1/register", async (req, res) => {
        const {
          client_name: clientName,
          redirect_uris: redirectUris,
          response_types: responseTypes,
          grant_types: grantTypes,
          scope
        } = req.body;
        if (!redirectUris?.length) {
          res.status(400).json({
            error: "invalid_request",
            error_description: "redirect_uris is required"
          });
          return;
        }
        try {
          const client = await this.oidc.registerClient({
            clientName,
            redirectUris,
            responseTypes,
            grantTypes,
            scope
          });
          res.status(201).json({
            client_id: client.clientId,
            redirect_uris: client.redirectUris,
            client_secret: client.clientSecret
          });
        } catch (e) {
          const description = errors.isError(e) ? e.message : "Unknown error";
          this.logger.error(`Failed to register client: ${description}`, e);
          res.status(500).json({
            error: "server_error",
            error_description: `Failed to register client: ${description}`
          });
        }
      });
    }
    return router;
  }
}
function ensureTrailingSlash(appUrl) {
  if (appUrl.endsWith("/")) {
    return appUrl;
  }
  return `${appUrl}/`;
}

exports.OidcRouter = OidcRouter;
//# sourceMappingURL=OidcRouter.cjs.js.map
