'use strict';

var catalogModel = require('@backstage/catalog-model');
var errors = require('@backstage/errors');
var CatalogIdentityClient = require('../catalog/CatalogIdentityClient.cjs.js');

function getDefaultOwnershipEntityRefs(entity) {
  const membershipRefs = entity.relations?.filter(
    (r) => r.type === catalogModel.RELATION_MEMBER_OF && r.targetRef.startsWith("group:")
  ).map((r) => r.targetRef) ?? [];
  return Array.from(/* @__PURE__ */ new Set([catalogModel.stringifyEntityRef(entity), ...membershipRefs]));
}
class CatalogAuthResolverContext {
  constructor(logger, tokenIssuer, catalogIdentityClient, catalog, auth, userInfo, ownershipResolver) {
    this.logger = logger;
    this.tokenIssuer = tokenIssuer;
    this.catalogIdentityClient = catalogIdentityClient;
    this.catalog = catalog;
    this.auth = auth;
    this.userInfo = userInfo;
    this.ownershipResolver = ownershipResolver;
  }
  static create(options) {
    const catalogIdentityClient = new CatalogIdentityClient.CatalogIdentityClient({
      catalog: options.catalog,
      auth: options.auth
    });
    return new CatalogAuthResolverContext(
      options.logger,
      options.tokenIssuer,
      catalogIdentityClient,
      options.catalog,
      options.auth,
      options.userInfo,
      options.ownershipResolver
    );
  }
  async issueToken(params) {
    const { sub, ent = [sub], ...additionalClaims } = params.claims;
    const claims = {
      sub,
      ent,
      ...additionalClaims
    };
    const issuedToken = await this.tokenIssuer.issueToken({
      claims
    });
    await this.userInfo.addUserInfo({
      claims
    });
    return issuedToken;
  }
  async findCatalogUser(query) {
    let result = void 0;
    if ("entityRef" in query) {
      const entityRef = catalogModel.parseEntityRef(query.entityRef, {
        defaultKind: "User",
        defaultNamespace: catalogModel.DEFAULT_NAMESPACE
      });
      result = await this.catalog.getEntityByRef(entityRef, {
        credentials: await this.auth.getOwnServiceCredentials()
      });
    } else if ("annotations" in query) {
      const filter = {
        kind: "user"
      };
      for (const [key, value] of Object.entries(query.annotations)) {
        filter[`metadata.annotations.${key}`] = value;
      }
      const res = await this.catalog.getEntities(
        { filter },
        { credentials: await this.auth.getOwnServiceCredentials() }
      );
      result = res.items;
    } else if ("filter" in query) {
      const filter = [query.filter].flat().map((value) => {
        if (!Object.keys(value).some(
          (key) => key.toLocaleLowerCase("en-US") === "kind"
        )) {
          return {
            ...value,
            kind: "user"
          };
        }
        return value;
      });
      const res = await this.catalog.getEntities(
        { filter },
        { credentials: await this.auth.getOwnServiceCredentials() }
      );
      result = res.items;
    } else {
      throw new errors.InputError("Invalid user lookup query");
    }
    if (Array.isArray(result)) {
      if (result.length > 1) {
        throw new errors.ConflictError("User lookup resulted in multiple matches");
      }
      result = result[0];
    }
    if (!result) {
      throw new errors.NotFoundError("User not found");
    }
    return { entity: result };
  }
  async signInWithCatalogUser(query, options) {
    try {
      const { entity } = await this.findCatalogUser(query);
      const { ownershipEntityRefs } = await this.resolveOwnershipEntityRefs(
        entity
      );
      return await this.issueToken({
        claims: {
          sub: catalogModel.stringifyEntityRef(entity),
          ent: ownershipEntityRefs
        }
      });
    } catch (error) {
      if (error?.name !== "NotFoundError" || !options?.dangerousEntityRefFallback) {
        throw error;
      }
      const userEntityRef = catalogModel.stringifyEntityRef(
        catalogModel.parseEntityRef(options.dangerousEntityRefFallback.entityRef, {
          defaultKind: "User",
          defaultNamespace: catalogModel.DEFAULT_NAMESPACE
        })
      );
      return await this.issueToken({
        claims: {
          sub: userEntityRef,
          ent: [userEntityRef]
        }
      });
    }
  }
  async resolveOwnershipEntityRefs(entity) {
    if (this.ownershipResolver) {
      return this.ownershipResolver.resolveOwnershipEntityRefs(entity);
    }
    return { ownershipEntityRefs: getDefaultOwnershipEntityRefs(entity) };
  }
}

exports.CatalogAuthResolverContext = CatalogAuthResolverContext;
//# sourceMappingURL=CatalogAuthResolverContext.cjs.js.map
