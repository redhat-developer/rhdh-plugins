{"version":3,"file":"CatalogIdentityClient.cjs.js","sources":["../../../src/lib/catalog/CatalogIdentityClient.ts"],"sourcesContent":["/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { AuthService, LoggerService } from '@backstage/backend-plugin-api';\nimport { ConflictError, NotFoundError } from '@backstage/errors';\nimport { CatalogService } from '@backstage/plugin-catalog-node';\nimport {\n  CompoundEntityRef,\n  parseEntityRef,\n  RELATION_MEMBER_OF,\n  stringifyEntityRef,\n  UserEntity,\n} from '@backstage/catalog-model';\n\n/**\n * A catalog client tailored for reading out identity data from the catalog.\n */\nexport class CatalogIdentityClient {\n  private readonly catalog: CatalogService;\n  private readonly auth: AuthService;\n\n  constructor(options: { catalog: CatalogService; auth: AuthService }) {\n    this.catalog = options.catalog;\n    this.auth = options.auth;\n  }\n\n  /**\n   * Looks up a single user using a query.\n   *\n   * Throws a NotFoundError or ConflictError if 0 or multiple users are found.\n   */\n  async findUser(query: {\n    annotations: Record<string, string>;\n  }): Promise<UserEntity> {\n    const filter: Record<string, string> = {\n      kind: 'user',\n    };\n    for (const [key, value] of Object.entries(query.annotations)) {\n      filter[`metadata.annotations.${key}`] = value;\n    }\n\n    const { items } = await this.catalog.getEntities(\n      { filter },\n      { credentials: await this.auth.getOwnServiceCredentials() },\n    );\n\n    if (items.length !== 1) {\n      if (items.length > 1) {\n        throw new ConflictError('User lookup resulted in multiple matches');\n      } else {\n        throw new NotFoundError('User not found');\n      }\n    }\n\n    return items[0] as UserEntity;\n  }\n\n  /**\n   * Resolve additional entity claims from the catalog, using the passed-in entity names. Designed\n   * to be used within a `signInResolver` where additional entity claims might be provided, but\n   * group membership and transient group membership lean on imported catalog relations.\n   *\n   * Returns a superset of the entity names that can be passed directly to `issueToken` as `ent`.\n   */\n  async resolveCatalogMembership(query: {\n    entityRefs: string[];\n    logger?: LoggerService;\n  }): Promise<string[]> {\n    const { entityRefs, logger } = query;\n    const resolvedEntityRefs = entityRefs\n      .map((ref: string) => {\n        try {\n          const parsedRef = parseEntityRef(ref.toLocaleLowerCase('en-US'), {\n            defaultKind: 'user',\n            defaultNamespace: 'default',\n          });\n          return parsedRef;\n        } catch {\n          logger?.warn(`Failed to parse entityRef from ${ref}, ignoring`);\n          return null;\n        }\n      })\n      .filter((ref): ref is CompoundEntityRef => ref !== null);\n\n    const filter = resolvedEntityRefs.map(ref => ({\n      kind: ref.kind,\n      'metadata.namespace': ref.namespace,\n      'metadata.name': ref.name,\n    }));\n\n    const entities = await this.catalog\n      .getEntities(\n        { filter },\n        { credentials: await this.auth.getOwnServiceCredentials() },\n      )\n      .then(r => r.items);\n\n    if (entityRefs.length !== entities.length) {\n      const foundEntityNames = entities.map(stringifyEntityRef);\n      const missingEntityNames = resolvedEntityRefs\n        .map(stringifyEntityRef)\n        .filter(s => !foundEntityNames.includes(s));\n      logger?.debug(`Entities not found for refs ${missingEntityNames.join()}`);\n    }\n\n    const memberOf = entities.flatMap(\n      e =>\n        e!.relations\n          ?.filter(r => r.type === RELATION_MEMBER_OF)\n          .map(r => r.targetRef) ?? [],\n    );\n\n    const newEntityRefs = [\n      ...new Set(resolvedEntityRefs.map(stringifyEntityRef).concat(memberOf)),\n    ];\n\n    logger?.debug(`Found catalog membership: ${newEntityRefs.join()}`);\n    return newEntityRefs;\n  }\n}\n"],"names":["ConflictError","NotFoundError","parseEntityRef","stringifyEntityRef","RELATION_MEMBER_OF"],"mappings":";;;;;AA8BO,MAAM,qBAAA,CAAsB;AAAA,EAChB,OAAA;AAAA,EACA,IAAA;AAAA,EAEjB,YAAY,OAAA,EAAyD;AACnE,IAAA,IAAA,CAAK,UAAU,OAAA,CAAQ,OAAA;AACvB,IAAA,IAAA,CAAK,OAAO,OAAA,CAAQ,IAAA;AAAA,EACtB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,SAAS,KAAA,EAES;AACtB,IAAA,MAAM,MAAA,GAAiC;AAAA,MACrC,IAAA,EAAM;AAAA,KACR;AACA,IAAA,KAAA,MAAW,CAAC,KAAK,KAAK,CAAA,IAAK,OAAO,OAAA,CAAQ,KAAA,CAAM,WAAW,CAAA,EAAG;AAC5D,MAAA,MAAA,CAAO,CAAA,qBAAA,EAAwB,GAAG,CAAA,CAAE,CAAA,GAAI,KAAA;AAAA,IAC1C;AAEA,IAAA,MAAM,EAAE,KAAA,EAAM,GAAI,MAAM,KAAK,OAAA,CAAQ,WAAA;AAAA,MACnC,EAAE,MAAA,EAAO;AAAA,MACT,EAAE,WAAA,EAAa,MAAM,IAAA,CAAK,IAAA,CAAK,0BAAyB;AAAE,KAC5D;AAEA,IAAA,IAAI,KAAA,CAAM,WAAW,CAAA,EAAG;AACtB,MAAA,IAAI,KAAA,CAAM,SAAS,CAAA,EAAG;AACpB,QAAA,MAAM,IAAIA,qBAAc,0CAA0C,CAAA;AAAA,MACpE,CAAA,MAAO;AACL,QAAA,MAAM,IAAIC,qBAAc,gBAAgB,CAAA;AAAA,MAC1C;AAAA,IACF;AAEA,IAAA,OAAO,MAAM,CAAC,CAAA;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,yBAAyB,KAAA,EAGT;AACpB,IAAA,MAAM,EAAE,UAAA,EAAY,MAAA,EAAO,GAAI,KAAA;AAC/B,IAAA,MAAM,kBAAA,GAAqB,UAAA,CACxB,GAAA,CAAI,CAAC,GAAA,KAAgB;AACpB,MAAA,IAAI;AACF,QAAA,MAAM,SAAA,GAAYC,2BAAA,CAAe,GAAA,CAAI,iBAAA,CAAkB,OAAO,CAAA,EAAG;AAAA,UAC/D,WAAA,EAAa,MAAA;AAAA,UACb,gBAAA,EAAkB;AAAA,SACnB,CAAA;AACD,QAAA,OAAO,SAAA;AAAA,MACT,CAAA,CAAA,MAAQ;AACN,QAAA,MAAA,EAAQ,IAAA,CAAK,CAAA,+BAAA,EAAkC,GAAG,CAAA,UAAA,CAAY,CAAA;AAC9D,QAAA,OAAO,IAAA;AAAA,MACT;AAAA,IACF,CAAC,CAAA,CACA,MAAA,CAAO,CAAC,GAAA,KAAkC,QAAQ,IAAI,CAAA;AAEzD,IAAA,MAAM,MAAA,GAAS,kBAAA,CAAmB,GAAA,CAAI,CAAA,GAAA,MAAQ;AAAA,MAC5C,MAAM,GAAA,CAAI,IAAA;AAAA,MACV,sBAAsB,GAAA,CAAI,SAAA;AAAA,MAC1B,iBAAiB,GAAA,CAAI;AAAA,KACvB,CAAE,CAAA;AAEF,IAAA,MAAM,QAAA,GAAW,MAAM,IAAA,CAAK,OAAA,CACzB,WAAA;AAAA,MACC,EAAE,MAAA,EAAO;AAAA,MACT,EAAE,WAAA,EAAa,MAAM,IAAA,CAAK,IAAA,CAAK,0BAAyB;AAAE,KAC5D,CACC,IAAA,CAAK,CAAA,CAAA,KAAK,CAAA,CAAE,KAAK,CAAA;AAEpB,IAAA,IAAI,UAAA,CAAW,MAAA,KAAW,QAAA,CAAS,MAAA,EAAQ;AACzC,MAAA,MAAM,gBAAA,GAAmB,QAAA,CAAS,GAAA,CAAIC,+BAAkB,CAAA;AACxD,MAAA,MAAM,kBAAA,GAAqB,kBAAA,CACxB,GAAA,CAAIA,+BAAkB,CAAA,CACtB,MAAA,CAAO,CAAA,CAAA,KAAK,CAAC,gBAAA,CAAiB,QAAA,CAAS,CAAC,CAAC,CAAA;AAC5C,MAAA,MAAA,EAAQ,KAAA,CAAM,CAAA,4BAAA,EAA+B,kBAAA,CAAmB,IAAA,EAAM,CAAA,CAAE,CAAA;AAAA,IAC1E;AAEA,IAAA,MAAM,WAAW,QAAA,CAAS,OAAA;AAAA,MACxB,CAAA,CAAA,KACE,CAAA,CAAG,SAAA,EACC,MAAA,CAAO,OAAK,CAAA,CAAE,IAAA,KAASC,+BAAkB,CAAA,CAC1C,GAAA,CAAI,CAAA,CAAA,KAAK,CAAA,CAAE,SAAS,KAAK;AAAC,KACjC;AAEA,IAAA,MAAM,aAAA,GAAgB;AAAA,MACpB,GAAG,IAAI,GAAA,CAAI,kBAAA,CAAmB,IAAID,+BAAkB,CAAA,CAAE,MAAA,CAAO,QAAQ,CAAC;AAAA,KACxE;AAEA,IAAA,MAAA,EAAQ,KAAA,CAAM,CAAA,0BAAA,EAA6B,aAAA,CAAc,IAAA,EAAM,CAAA,CAAE,CAAA;AACjE,IAAA,OAAO,aAAA;AAAA,EACT;AACF;;;;"}