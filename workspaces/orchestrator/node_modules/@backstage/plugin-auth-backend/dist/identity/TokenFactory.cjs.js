'use strict';

var jose = require('jose');
var luxon = require('luxon');
var uuid = require('uuid');
var issueUserToken = require('./issueUserToken.cjs.js');

class TokenFactory {
  issuer;
  logger;
  keyStore;
  keyDurationSeconds;
  algorithm;
  omitClaimsFromToken;
  keyExpiry;
  privateKeyPromise;
  constructor(options) {
    this.issuer = options.issuer;
    this.logger = options.logger;
    this.keyStore = options.keyStore;
    this.keyDurationSeconds = options.keyDurationSeconds;
    this.algorithm = options.algorithm ?? "ES256";
    this.omitClaimsFromToken = options.omitClaimsFromToken;
  }
  async issueToken(params) {
    const key = await this.getKey();
    return issueUserToken.issueUserToken({
      issuer: this.issuer,
      key,
      keyDurationSeconds: this.keyDurationSeconds,
      logger: this.logger,
      omitClaimsFromToken: this.omitClaimsFromToken,
      params
    });
  }
  // This will be called by other services that want to verify ID tokens.
  // It is important that it returns a list of all public keys that could
  // have been used to sign tokens that have not yet expired.
  async listPublicKeys() {
    const { items: keys } = await this.keyStore.listKeys();
    const validKeys = [];
    const expiredKeys = [];
    for (const key of keys) {
      const expireAt = luxon.DateTime.fromJSDate(key.createdAt).plus({
        seconds: 3 * this.keyDurationSeconds
      });
      if (expireAt < luxon.DateTime.local()) {
        expiredKeys.push(key);
      } else {
        validKeys.push(key);
      }
    }
    if (expiredKeys.length > 0) {
      const kids = expiredKeys.map(({ key }) => key.kid);
      this.logger.info(`Removing expired signing keys, '${kids.join("', '")}'`);
      this.keyStore.removeKeys(kids).catch((error) => {
        this.logger.error(`Failed to remove expired keys, ${error}`);
      });
    }
    return { keys: validKeys.map(({ key }) => key) };
  }
  async getKey() {
    if (this.privateKeyPromise) {
      if (this.keyExpiry && luxon.DateTime.fromJSDate(this.keyExpiry) > luxon.DateTime.local()) {
        return this.privateKeyPromise;
      }
      this.logger.info(`Signing key has expired, generating new key`);
      delete this.privateKeyPromise;
    }
    this.keyExpiry = luxon.DateTime.utc().plus({
      seconds: this.keyDurationSeconds
    }).toJSDate();
    const promise = (async () => {
      const key = await jose.generateKeyPair(this.algorithm);
      const publicKey = await jose.exportJWK(key.publicKey);
      const privateKey = await jose.exportJWK(key.privateKey);
      publicKey.kid = privateKey.kid = uuid.v4();
      publicKey.alg = privateKey.alg = this.algorithm;
      this.logger.info(`Created new signing key ${publicKey.kid}`);
      await this.keyStore.addKey(publicKey);
      return privateKey;
    })();
    this.privateKeyPromise = promise;
    try {
      await promise;
    } catch (error) {
      this.logger.error(`Failed to generate new signing key, ${error}`);
      delete this.keyExpiry;
      delete this.privateKeyPromise;
    }
    return promise;
  }
}

exports.TokenFactory = TokenFactory;
//# sourceMappingURL=TokenFactory.cjs.js.map
