'use strict';

var catalogModel = require('@backstage/catalog-model');
var errors = require('@backstage/errors');
var pluginAuthNode = require('@backstage/plugin-auth-node');
var lodash = require('lodash');
var jose = require('jose');

const MS_IN_S = 1e3;
const MAX_TOKEN_LENGTH = 32768;
async function issueUserToken({
  issuer,
  key,
  keyDurationSeconds,
  logger,
  omitClaimsFromToken,
  params
}) {
  const { sub, ent, ...additionalClaims } = params.claims;
  const aud = pluginAuthNode.tokenTypes.user.audClaim;
  const iat = Math.floor(Date.now() / MS_IN_S);
  const exp = iat + keyDurationSeconds;
  try {
    catalogModel.parseEntityRef(sub);
  } catch (error) {
    throw new Error(
      '"sub" claim provided by the auth resolver is not a valid EntityRef.'
    );
  }
  if (!key.alg) {
    throw new errors.AuthenticationError("No algorithm was provided in the key");
  }
  logger.info(`Issuing token for ${sub}, with entities ${ent}`);
  const signingKey = await jose.importJWK(key);
  const uip = await createUserIdentityClaim({
    header: {
      typ: pluginAuthNode.tokenTypes.limitedUser.typParam,
      alg: key.alg,
      kid: key.kid
    },
    payload: { sub, iat, exp },
    key: signingKey
  });
  const claims = {
    ...additionalClaims,
    iss: issuer,
    sub,
    ent,
    aud,
    iat,
    exp,
    uip
  };
  const tokenClaims = omitClaimsFromToken ? lodash.omit(claims, omitClaimsFromToken) : claims;
  const token = await new jose.SignJWT(tokenClaims).setProtectedHeader({
    typ: pluginAuthNode.tokenTypes.user.typParam,
    alg: key.alg,
    kid: key.kid
  }).sign(signingKey);
  if (token.length > MAX_TOKEN_LENGTH) {
    throw new Error(
      `Failed to issue a new user token. The resulting token is excessively large, with either too many ownership claims or too large custom claims. You likely have a bug either in the sign-in resolver or catalog data. The following claims were requested: '${JSON.stringify(
        tokenClaims
      )}'`
    );
  }
  return {
    token,
    identity: {
      type: "user",
      userEntityRef: sub,
      ownershipEntityRefs: ent
    }
  };
}
async function createUserIdentityClaim(options) {
  const header = {
    typ: options.header.typ,
    alg: options.header.alg,
    ...options.header.kid ? { kid: options.header.kid } : {}
  };
  const payload = {
    sub: options.payload.sub,
    iat: options.payload.iat,
    exp: options.payload.exp
  };
  const jws = await new jose.GeneralSign(
    new TextEncoder().encode(JSON.stringify(payload))
  ).addSignature(options.key).setProtectedHeader(header).done().sign();
  return jws.signatures[0].signature;
}

exports.issueUserToken = issueUserToken;
//# sourceMappingURL=issueUserToken.cjs.js.map
