{"version":3,"file":"issueUserToken.cjs.js","sources":["../../src/identity/issueUserToken.ts"],"sourcesContent":["/*\n * Copyright 2025 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { parseEntityRef } from '@backstage/catalog-model';\nimport { AuthenticationError } from '@backstage/errors';\nimport {\n  BackstageSignInResult,\n  TokenParams,\n  tokenTypes,\n} from '@backstage/plugin-auth-node';\nimport { omit } from 'lodash';\nimport { LoggerService } from '@backstage/backend-plugin-api';\nimport { GeneralSign, importJWK, JWK, KeyLike, SignJWT } from 'jose';\nimport { BackstageTokenPayload } from './TokenFactory';\n\nconst MS_IN_S = 1000;\nconst MAX_TOKEN_LENGTH = 32768; // At 64 bytes per entity ref this still leaves room for about 500 entities\n\nexport async function issueUserToken({\n  issuer,\n  key,\n  keyDurationSeconds,\n  logger,\n  omitClaimsFromToken,\n  params,\n}: {\n  issuer: string;\n  key: JWK;\n  keyDurationSeconds: number;\n  logger: LoggerService;\n  omitClaimsFromToken?: string[];\n  params: TokenParams & { claims: { ent: string[] } };\n}): Promise<BackstageSignInResult> {\n  const { sub, ent, ...additionalClaims } = params.claims;\n  const aud = tokenTypes.user.audClaim;\n  const iat = Math.floor(Date.now() / MS_IN_S);\n  const exp = iat + keyDurationSeconds;\n\n  try {\n    // The subject must be a valid entity ref\n    parseEntityRef(sub);\n  } catch (error) {\n    throw new Error(\n      '\"sub\" claim provided by the auth resolver is not a valid EntityRef.',\n    );\n  }\n\n  if (!key.alg) {\n    throw new AuthenticationError('No algorithm was provided in the key');\n  }\n\n  logger.info(`Issuing token for ${sub}, with entities ${ent}`);\n\n  const signingKey = await importJWK(key);\n\n  const uip = await createUserIdentityClaim({\n    header: {\n      typ: tokenTypes.limitedUser.typParam,\n      alg: key.alg,\n      kid: key.kid,\n    },\n    payload: { sub, iat, exp },\n    key: signingKey,\n  });\n\n  const claims: BackstageTokenPayload = {\n    ...additionalClaims,\n    iss: issuer,\n    sub,\n    ent,\n    aud,\n    iat,\n    exp,\n    uip,\n  };\n\n  const tokenClaims = omitClaimsFromToken\n    ? omit(claims, omitClaimsFromToken)\n    : claims;\n  const token = await new SignJWT(tokenClaims)\n    .setProtectedHeader({\n      typ: tokenTypes.user.typParam,\n      alg: key.alg,\n      kid: key.kid,\n    })\n    .sign(signingKey);\n\n  if (token.length > MAX_TOKEN_LENGTH) {\n    throw new Error(\n      `Failed to issue a new user token. The resulting token is excessively large, with either too many ownership claims or too large custom claims. You likely have a bug either in the sign-in resolver or catalog data. The following claims were requested: '${JSON.stringify(\n        tokenClaims,\n      )}'`,\n    );\n  }\n\n  return {\n    token,\n    identity: {\n      type: 'user',\n      userEntityRef: sub,\n      ownershipEntityRefs: ent,\n    },\n  };\n}\n\n/**\n * The payload contents of a valid Backstage user identity claim token\n *\n * @internal\n */\ninterface BackstageUserIdentityProofPayload {\n  /**\n   * The entity ref of the user\n   */\n  sub: string;\n\n  /**\n   * Standard expiry in epoch seconds\n   */\n  exp: number;\n\n  /**\n   * Standard issue time in epoch seconds\n   */\n  iat: number;\n}\n\n/**\n * Creates a string claim that can be used as part of reconstructing a limited\n * user token. The output of this function is only the signature part of a JWS.\n */\nasync function createUserIdentityClaim(options: {\n  header: {\n    typ: string;\n    alg: string;\n    kid?: string;\n  };\n  payload: BackstageUserIdentityProofPayload;\n  key: KeyLike | Uint8Array;\n}): Promise<string> {\n  // NOTE: We reconstruct the header and payload structures carefully to\n  // perfectly guarantee ordering. The reason for this is that we store only\n  // the signature part of these to reduce duplication within the Backstage\n  // token. Anyone who wants to make an actual JWT based on all this must be\n  // able to do the EXACT reconstruction of the header and payload parts, to\n  // then append the signature.\n\n  const header = {\n    typ: options.header.typ,\n    alg: options.header.alg,\n    ...(options.header.kid ? { kid: options.header.kid } : {}),\n  };\n\n  const payload = {\n    sub: options.payload.sub,\n    iat: options.payload.iat,\n    exp: options.payload.exp,\n  };\n\n  const jws = await new GeneralSign(\n    new TextEncoder().encode(JSON.stringify(payload)),\n  )\n    .addSignature(options.key)\n    .setProtectedHeader(header)\n    .done()\n    .sign();\n\n  return jws.signatures[0].signature;\n}\n"],"names":["tokenTypes","parseEntityRef","AuthenticationError","importJWK","omit","SignJWT","GeneralSign"],"mappings":"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"}