'use strict';

var crypto = require('crypto');
var errors = require('@backstage/errors');
var pluginScaffolderNode = require('@backstage/plugin-scaffolder-node');
var gerritReview_examples = require('./gerritReview.examples.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var crypto__default = /*#__PURE__*/_interopDefaultCompat(crypto);

const generateGerritChangeId = () => {
  const changeId = crypto__default.default.randomBytes(20).toString("hex");
  return `I${changeId}`;
};
function createPublishGerritReviewAction(options) {
  const { integrations, config } = options;
  return pluginScaffolderNode.createTemplateAction({
    id: "publish:gerrit:review",
    description: "Creates a new Gerrit review.",
    examples: gerritReview_examples.examples,
    schema: {
      input: {
        repoUrl: (z) => z.string({
          description: "Repository Location"
        }),
        branch: (z) => z.string({
          description: "Branch of the repository the review will be created on"
        }).optional(),
        sourcePath: (z) => z.string({
          description: "Subdirectory of working directory containing the repository"
        }).optional(),
        gitCommitMessage: (z) => z.string({
          description: `Sets the commit message on the repository.`
        }).optional(),
        gitAuthorName: (z) => z.string({
          description: `Sets the default author name for the commit. The default value is 'Scaffolder'`
        }).optional(),
        gitAuthorEmail: (z) => z.string({
          description: `Sets the default author email for the commit.`
        }).optional(),
        signCommit: (z) => z.boolean({
          description: "Sign commit with configured PGP private key"
        }).optional()
      },
      output: {
        reviewUrl: (z) => z.string({
          description: "A URL to the review"
        }).optional(),
        repoContentsUrl: (z) => z.string({
          description: "A URL to the root of the repository"
        }).optional()
      }
    },
    async handler(ctx) {
      const {
        repoUrl,
        branch = "master",
        sourcePath,
        gitAuthorName,
        gitAuthorEmail,
        gitCommitMessage,
        signCommit
      } = ctx.input;
      const { host, repo } = pluginScaffolderNode.parseRepoUrl(repoUrl, integrations);
      if (!gitCommitMessage) {
        throw new errors.InputError(`Missing gitCommitMessage input`);
      }
      const integrationConfig = integrations.gerrit.byHost(host);
      if (!integrationConfig) {
        throw new errors.InputError(
          `No matching integration configuration for host ${host}, please check your integrations config`
        );
      }
      const auth = {
        username: integrationConfig.config.username,
        password: integrationConfig.config.password
      };
      const gitAuthorInfo = {
        name: gitAuthorName ? gitAuthorName : config.getOptionalString("scaffolder.defaultAuthor.name"),
        email: gitAuthorEmail ? gitAuthorEmail : config.getOptionalString("scaffolder.defaultAuthor.email")
      };
      const signingKey = integrationConfig.config.commitSigningKey ?? config.getOptionalString("scaffolder.defaultCommitSigningKey");
      if (signCommit && !signingKey) {
        throw new Error(
          "Signing commits is enabled but no signing key is provided in the configuration"
        );
      }
      const changeId = generateGerritChangeId();
      const commitMessage = `${gitCommitMessage}

Change-Id: ${changeId}`;
      await pluginScaffolderNode.commitAndPushRepo({
        dir: pluginScaffolderNode.getRepoSourceDirectory(ctx.workspacePath, sourcePath),
        auth,
        logger: ctx.logger,
        commitMessage,
        gitAuthorInfo,
        branch,
        remoteRef: `refs/for/${branch}`,
        signingKey: signCommit ? signingKey : void 0
      });
      const repoContentsUrl = `${integrationConfig.config.gitilesBaseUrl}/${repo}/+/refs/heads/${branch}`;
      const reviewUrl = `${integrationConfig.config.baseUrl}/#/q/${changeId}`;
      ctx.logger?.info(`Review available on ${reviewUrl}`);
      ctx.output("repoContentsUrl", repoContentsUrl);
      ctx.output("reviewUrl", reviewUrl);
    }
  });
}

exports.createPublishGerritReviewAction = createPublishGerritReviewAction;
//# sourceMappingURL=gerritReview.cjs.js.map
