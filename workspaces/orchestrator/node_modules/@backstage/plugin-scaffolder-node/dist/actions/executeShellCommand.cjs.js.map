{"version":3,"file":"executeShellCommand.cjs.js","sources":["../../src/actions/executeShellCommand.ts"],"sourcesContent":["/*\n * Copyright 2021 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { LoggerService } from '@backstage/backend-plugin-api';\nimport { spawn, SpawnOptionsWithoutStdio } from 'child_process';\nimport { PassThrough, Writable } from 'stream';\n\n/**\n * Options for {@link executeShellCommand}.\n *\n * @public\n */\nexport type ExecuteShellCommandOptions = {\n  /** command to run */\n  command: string;\n  /** arguments to pass the command */\n  args: string[];\n  /** options to pass to spawn */\n  options?: SpawnOptionsWithoutStdio;\n  /** logger to capture stdout and stderr output */\n  logger?: LoggerService;\n  /**\n   * stream to capture stdout and stderr output\n   * @deprecated  please provide a logger instead.\n   */\n  logStream?: Writable;\n};\n\n/**\n * Run a command in a sub-process, normally a shell command.\n *\n * @public\n */\nexport async function executeShellCommand(\n  options: ExecuteShellCommandOptions,\n): Promise<void> {\n  const {\n    command,\n    args,\n    options: spawnOptions,\n    logger,\n    logStream = new PassThrough(),\n  } = options;\n\n  await new Promise<void>((resolve, reject) => {\n    const process = spawn(command, args, spawnOptions);\n\n    process.stdout.on('data', chunk => {\n      logStream?.write(chunk);\n      logger?.info(\n        Buffer.isBuffer(chunk) ? chunk.toString('utf8').trim() : chunk.trim(),\n      );\n    });\n    process.stderr.on('data', chunk => {\n      logStream?.write(chunk);\n      logger?.error(\n        Buffer.isBuffer(chunk) ? chunk.toString('utf8').trim() : chunk.trim(),\n      );\n    });\n    process.on('error', error => {\n      return reject(error);\n    });\n\n    process.on('close', code => {\n      if (code !== 0) {\n        return reject(\n          new Error(`Command ${command} failed, exit code: ${code}`),\n        );\n      }\n      return resolve();\n    });\n  });\n}\n"],"names":["PassThrough","spawn"],"mappings":";;;;;AA8CA,eAAsB,oBACpB,OAAA,EACe;AACf,EAAA,MAAM;AAAA,IACJ,OAAA;AAAA,IACA,IAAA;AAAA,IACA,OAAA,EAAS,YAAA;AAAA,IACT,MAAA;AAAA,IACA,SAAA,GAAY,IAAIA,kBAAA;AAAY,GAC9B,GAAI,OAAA;AAEJ,EAAA,MAAM,IAAI,OAAA,CAAc,CAAC,OAAA,EAAS,MAAA,KAAW;AAC3C,IAAA,MAAM,OAAA,GAAUC,mBAAA,CAAM,OAAA,EAAS,IAAA,EAAM,YAAY,CAAA;AAEjD,IAAA,OAAA,CAAQ,MAAA,CAAO,EAAA,CAAG,MAAA,EAAQ,CAAA,KAAA,KAAS;AACjC,MAAA,SAAA,EAAW,MAAM,KAAK,CAAA;AACtB,MAAA,MAAA,EAAQ,IAAA;AAAA,QACN,MAAA,CAAO,QAAA,CAAS,KAAK,CAAA,GAAI,KAAA,CAAM,QAAA,CAAS,MAAM,CAAA,CAAE,IAAA,EAAK,GAAI,KAAA,CAAM,IAAA;AAAK,OACtE;AAAA,IACF,CAAC,CAAA;AACD,IAAA,OAAA,CAAQ,MAAA,CAAO,EAAA,CAAG,MAAA,EAAQ,CAAA,KAAA,KAAS;AACjC,MAAA,SAAA,EAAW,MAAM,KAAK,CAAA;AACtB,MAAA,MAAA,EAAQ,KAAA;AAAA,QACN,MAAA,CAAO,QAAA,CAAS,KAAK,CAAA,GAAI,KAAA,CAAM,QAAA,CAAS,MAAM,CAAA,CAAE,IAAA,EAAK,GAAI,KAAA,CAAM,IAAA;AAAK,OACtE;AAAA,IACF,CAAC,CAAA;AACD,IAAA,OAAA,CAAQ,EAAA,CAAG,SAAS,CAAA,KAAA,KAAS;AAC3B,MAAA,OAAO,OAAO,KAAK,CAAA;AAAA,IACrB,CAAC,CAAA;AAED,IAAA,OAAA,CAAQ,EAAA,CAAG,SAAS,CAAA,IAAA,KAAQ;AAC1B,MAAA,IAAI,SAAS,CAAA,EAAG;AACd,QAAA,OAAO,MAAA;AAAA,UACL,IAAI,KAAA,CAAM,CAAA,QAAA,EAAW,OAAO,CAAA,oBAAA,EAAuB,IAAI,CAAA,CAAE;AAAA,SAC3D;AAAA,MACF;AACA,MAAA,OAAO,OAAA,EAAQ;AAAA,IACjB,CAAC,CAAA;AAAA,EACH,CAAC,CAAA;AACH;;;;"}