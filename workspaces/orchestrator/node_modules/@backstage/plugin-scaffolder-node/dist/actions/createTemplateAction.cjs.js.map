{"version":3,"file":"createTemplateAction.cjs.js","sources":["../../src/actions/createTemplateAction.ts"],"sourcesContent":["/*\n * Copyright 2021 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ActionContext, TemplateAction } from './types';\nimport { z } from 'zod';\nimport { Expand, JsonObject } from '@backstage/types';\nimport { parseSchemas } from './util';\n\n/** @public */\nexport type TemplateExample = {\n  description: string;\n  example: string;\n};\n\n/** @public */\nexport type TemplateActionOptions<\n  TActionInput extends JsonObject = {},\n  TActionOutput extends JsonObject = {},\n  TInputSchema extends\n    | { [key in string]: (zImpl: typeof z) => z.ZodType }\n    | ((zImpl: typeof z) => z.ZodType) = {\n    [key in string]: (zImpl: typeof z) => z.ZodType;\n  },\n  TOutputSchema extends\n    | {\n        [key in string]: (zImpl: typeof z) => z.ZodType;\n      }\n    | ((zImpl: typeof z) => z.ZodType) = {\n    [key in string]: (zImpl: typeof z) => z.ZodType;\n  },\n  TSchemaType extends 'v2' = 'v2',\n> = {\n  id: string;\n  description?: string;\n  examples?: TemplateExample[];\n  supportsDryRun?: boolean;\n  schema?: {\n    input?: TInputSchema;\n    output?: TOutputSchema;\n  };\n  handler: (\n    ctx: ActionContext<TActionInput, TActionOutput, TSchemaType>,\n  ) => Promise<void>;\n};\n\n/**\n * @ignore\n */\ntype FlattenOptionalProperties<T extends { [key in string]: unknown }> = Expand<\n  {\n    [K in keyof T as undefined extends T[K] ? never : K]: T[K];\n  } & {\n    [K in keyof T as undefined extends T[K] ? K : never]?: T[K];\n  }\n>;\n/**\n * This function is used to create new template actions to get type safety.\n * Will convert zod schemas to json schemas for use throughout the system.\n * @public\n */\nexport function createTemplateAction<\n  TInputSchema extends\n    | { [key in string]: (zImpl: typeof z) => z.ZodType }\n    | ((zImpl: typeof z) => z.ZodType),\n  TOutputSchema extends\n    | { [key in string]: (zImpl: typeof z) => z.ZodType }\n    | ((zImpl: typeof z) => z.ZodType),\n>(\n  action: TemplateActionOptions<\n    TInputSchema extends { [key in string]: (zImpl: typeof z) => z.ZodType }\n      ? {\n          [key in keyof TInputSchema]: z.infer<ReturnType<TInputSchema[key]>>;\n        }\n      : TInputSchema extends (zImpl: typeof z) => z.ZodType\n      ? z.infer<ReturnType<TInputSchema>>\n      : never,\n    TOutputSchema extends { [key in string]: (zImpl: typeof z) => z.ZodType }\n      ? {\n          [key in keyof TOutputSchema]: z.infer<ReturnType<TOutputSchema[key]>>;\n        }\n      : TOutputSchema extends (zImpl: typeof z) => z.ZodType\n      ? z.infer<ReturnType<TOutputSchema>>\n      : never,\n    TInputSchema,\n    TOutputSchema,\n    'v2'\n  >,\n): TemplateAction<\n  FlattenOptionalProperties<\n    TInputSchema extends { [key in string]: (zImpl: typeof z) => z.ZodType }\n      ? {\n          [key in keyof TInputSchema]: z.output<ReturnType<TInputSchema[key]>>;\n        }\n      : TInputSchema extends (zImpl: typeof z) => z.ZodType\n      ? z.output<ReturnType<TInputSchema>>\n      : never\n  >,\n  FlattenOptionalProperties<\n    TOutputSchema extends { [key in string]: (zImpl: typeof z) => z.ZodType }\n      ? {\n          [key in keyof TOutputSchema]: z.output<\n            ReturnType<TOutputSchema[key]>\n          >;\n        }\n      : TOutputSchema extends (zImpl: typeof z) => z.ZodType\n      ? z.output<ReturnType<TOutputSchema>>\n      : never\n  >,\n  'v2'\n>;\nexport function createTemplateAction<\n  TInputSchema extends { [key in string]: (zImpl: typeof z) => z.ZodType } = {\n    [key in string]: (zImpl: typeof z) => z.ZodType;\n  },\n  TOutputSchema extends { [key in string]: (zImpl: typeof z) => z.ZodType } = {\n    [key in string]: (zImpl: typeof z) => z.ZodType;\n  },\n  TActionInput extends JsonObject = TInputSchema extends {\n    [key in string]: (zImpl: typeof z) => z.ZodType;\n  }\n    ? Expand<{\n        [key in keyof TInputSchema]: z.infer<ReturnType<TInputSchema[key]>>;\n      }>\n    : never,\n  TActionOutput extends JsonObject = TOutputSchema extends {\n    [key in string]: (zImpl: typeof z) => z.ZodType;\n  }\n    ? Expand<{\n        [key in keyof TOutputSchema]: z.infer<ReturnType<TOutputSchema[key]>>;\n      }>\n    : never,\n>(\n  action: TemplateActionOptions<\n    TActionInput,\n    TActionOutput,\n    TInputSchema,\n    TOutputSchema\n  >,\n): TemplateAction<TActionInput, TActionOutput, 'v2'> {\n  const { inputSchema, outputSchema } = parseSchemas(\n    action as TemplateActionOptions<any, any, any>,\n  );\n\n  return {\n    ...action,\n    schema: {\n      ...action.schema,\n      input: inputSchema,\n      output: outputSchema,\n    },\n  };\n}\n"],"names":["parseSchemas"],"mappings":";;;;AA2HO,SAAS,qBAsBd,MAAA,EAMmD;AACnD,EAAA,MAAM,EAAE,WAAA,EAAa,YAAA,EAAa,GAAIA,iBAAA;AAAA,IACpC;AAAA,GACF;AAEA,EAAA,OAAO;AAAA,IACL,GAAG,MAAA;AAAA,IACH,MAAA,EAAQ;AAAA,MACN,GAAG,MAAA,CAAO,MAAA;AAAA,MACV,KAAA,EAAO,WAAA;AAAA,MACP,MAAA,EAAQ;AAAA;AACV,GACF;AACF;;;;"}