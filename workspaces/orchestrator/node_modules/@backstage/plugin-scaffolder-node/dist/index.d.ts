import { JsonObject, Observable, JsonValue, Expand } from '@backstage/types';
import { BackstageCredentials, LoggerService, UrlReaderService } from '@backstage/backend-plugin-api';
import { PermissionCriteria } from '@backstage/plugin-permission-common';
import { TaskSpec, TemplateInfo } from '@backstage/plugin-scaffolder-common';
import { UpdateTaskCheckpointOptions, CheckpointContext } from '@backstage/plugin-scaffolder-node/alpha';
import { UserEntity } from '@backstage/catalog-model';
import { Schema } from 'jsonschema';
import { z } from 'zod';
import { SpawnOptionsWithoutStdio } from 'child_process';
import { Writable } from 'stream';
import { ScmIntegrations, ScmIntegrationRegistry } from '@backstage/integration';
export { T as TemplateFilter, a as TemplateGlobal } from './types/types.d-C0fXdKnD.js';

/**
 * TaskSecrets
 *
 * @public
 */
type TaskSecrets = Record<string, string> & {
    backstageToken?: string;
};
/**
 * The status of each step of the Task
 *
 * @public
 */
type TaskStatus = 'cancelled' | 'completed' | 'failed' | 'open' | 'processing' | 'skipped';
/**
 * The state of a completed task.
 *
 * @public
 */
type TaskCompletionState = 'failed' | 'completed';
/**
 * SerializedTask
 *
 * @public
 */
type SerializedTask = {
    id: string;
    spec: TaskSpec;
    status: TaskStatus;
    createdAt: string;
    lastHeartbeatAt?: string;
    createdBy?: string;
    secrets?: TaskSecrets;
    state?: JsonObject;
};
/**
 * TaskEventType
 *
 * @public
 */
type TaskEventType = 'completion' | 'log' | 'cancelled' | 'recovered';
/**
 * SerializedTaskEvent
 *
 * @public
 */
type SerializedTaskEvent = {
    id: number;
    isTaskRecoverable?: boolean;
    taskId: string;
    body: {
        message: string;
        stepId?: string;
        status?: TaskStatus;
    } & JsonObject;
    type: TaskEventType;
    createdAt: string;
};
/**
 * The result of {@link TaskBroker.dispatch}
 *
 * @public
 */
type TaskBrokerDispatchResult = {
    taskId: string;
};
/**
 * The options passed to {@link TaskBroker.dispatch}
 * Currently a spec and optional secrets
 *
 * @public
 */
type TaskBrokerDispatchOptions = {
    spec: TaskSpec;
    secrets?: TaskSecrets;
    createdBy?: string;
};
/**
 * TaskFilter
 * @public
 */
type TaskFilter = {
    key: string;
    values?: string[];
};
/**
 * TaskFilters
 * @public
 */
type TaskFilters = {
    anyOf: TaskFilter[];
} | {
    allOf: TaskFilter[];
} | {
    not: TaskFilter;
} | TaskFilter;
/**
 * Task
 *
 * @public
 */
interface TaskContext {
    taskId?: string;
    cancelSignal: AbortSignal;
    spec: TaskSpec;
    secrets?: TaskSecrets;
    createdBy?: string;
    done: boolean;
    isDryRun?: boolean;
    complete(result: TaskCompletionState, metadata?: JsonObject): Promise<void>;
    emitLog(message: string, logMetadata?: JsonObject): Promise<void>;
    getTaskState?(): Promise<{
        state?: JsonObject;
    } | undefined>;
    updateCheckpoint?(options: UpdateTaskCheckpointOptions): Promise<void>;
    serializeWorkspace?(options: {
        path: string;
    }): Promise<void>;
    cleanWorkspace?(): Promise<void>;
    rehydrateWorkspace?(options: {
        taskId: string;
        targetPath: string;
    }): Promise<void>;
    getWorkspaceName(): Promise<string>;
    getInitiatorCredentials(): Promise<BackstageCredentials>;
}
/**
 * TaskBroker
 *
 * @public
 */
interface TaskBroker {
    cancel?(taskId: string): Promise<void>;
    retry?(options: {
        secrets?: TaskSecrets;
        taskId: string;
    }): Promise<void>;
    claim(): Promise<TaskContext>;
    recoverTasks?(): Promise<void>;
    dispatch(options: TaskBrokerDispatchOptions): Promise<TaskBrokerDispatchResult>;
    vacuumTasks(options: {
        timeoutS: number;
    }): Promise<void>;
    event$(options: {
        taskId: string;
        after: number | undefined;
    }): Observable<{
        events: SerializedTaskEvent[];
    }>;
    get(taskId: string): Promise<SerializedTask>;
    list?(options?: {
        filters?: {
            createdBy?: string | string[];
            status?: TaskStatus | TaskStatus[];
        };
        pagination?: {
            limit?: number;
            offset?: number;
        };
        order?: {
            order: 'asc' | 'desc';
            field: string;
        }[];
        permissionFilters?: PermissionCriteria<TaskFilters>;
    }): Promise<{
        tasks: SerializedTask[];
        totalTasks?: number;
    }>;
    /**
     * @deprecated Make sure to pass `createdBy` and `status` in the `filters` parameter instead
     */
    list?(options: {
        createdBy?: string;
        status?: TaskStatus;
    }): Promise<{
        tasks: SerializedTask[];
        totalTasks?: number;
    }>;
}

/**
 * ActionContext is passed into scaffolder actions.
 * @public
 */
type ActionContext<TActionInput extends JsonObject, TActionOutput extends JsonObject = JsonObject, _TSchemaType extends 'v2' = 'v2'> = {
    logger: LoggerService;
    secrets?: TaskSecrets;
    workspacePath: string;
    input: TActionInput;
    checkpoint<T extends JsonValue | void>(opts: CheckpointContext<T>): Promise<T>;
    output(name: keyof TActionOutput, value: TActionOutput[keyof TActionOutput]): void;
    /**
     * Creates a temporary directory for use by the action, which is then cleaned up automatically.
     */
    createTemporaryDirectory(): Promise<string>;
    /**
     * Get the credentials for the current request
     */
    getInitiatorCredentials(): Promise<BackstageCredentials>;
    /**
     * Task information
     */
    task: {
        id: string;
    };
    templateInfo?: TemplateInfo;
    /**
     * Whether this action invocation is a dry-run or not.
     * This will only ever be true if the actions as marked as supporting dry-runs.
     */
    isDryRun?: boolean;
    /**
     * The user which triggered the action.
     */
    user?: {
        /**
         * The decorated entity from the Catalog
         */
        entity?: UserEntity;
        /**
         * An entity ref for the author of the task
         */
        ref?: string;
    };
    /**
     * Implement the signal to make your custom step abortable https://developer.mozilla.org/en-US/docs/Web/API/AbortController/signal
     */
    signal?: AbortSignal;
    /**
     * Optional value of each invocation
     */
    each?: JsonObject;
    /**
     * Step information
     */
    step?: {
        /**
         * The id of step which triggered the action
         */
        id?: string;
        /**
         * The name of the step which triggered the action
         */
        name?: string;
    };
};
/** @public */
type TemplateAction<TActionInput extends JsonObject = JsonObject, TActionOutput extends JsonObject = JsonObject, TSchemaType extends 'v2' = 'v2'> = {
    id: string;
    description?: string;
    examples?: {
        description: string;
        example: string;
    }[];
    supportsDryRun?: boolean;
    schema?: {
        input?: Schema;
        output?: Schema;
    };
    handler: (ctx: ActionContext<TActionInput, TActionOutput, TSchemaType>) => Promise<void>;
};

/** @public */
type TemplateExample = {
    description: string;
    example: string;
};
/** @public */
type TemplateActionOptions<TActionInput extends JsonObject = {}, TActionOutput extends JsonObject = {}, TInputSchema extends {
    [key in string]: (zImpl: typeof z) => z.ZodType;
} | ((zImpl: typeof z) => z.ZodType) = {
    [key in string]: (zImpl: typeof z) => z.ZodType;
}, TOutputSchema extends {
    [key in string]: (zImpl: typeof z) => z.ZodType;
} | ((zImpl: typeof z) => z.ZodType) = {
    [key in string]: (zImpl: typeof z) => z.ZodType;
}, TSchemaType extends 'v2' = 'v2'> = {
    id: string;
    description?: string;
    examples?: TemplateExample[];
    supportsDryRun?: boolean;
    schema?: {
        input?: TInputSchema;
        output?: TOutputSchema;
    };
    handler: (ctx: ActionContext<TActionInput, TActionOutput, TSchemaType>) => Promise<void>;
};
/**
 * @ignore
 */
type FlattenOptionalProperties<T extends {
    [key in string]: unknown;
}> = Expand<{
    [K in keyof T as undefined extends T[K] ? never : K]: T[K];
} & {
    [K in keyof T as undefined extends T[K] ? K : never]?: T[K];
}>;
/**
 * This function is used to create new template actions to get type safety.
 * Will convert zod schemas to json schemas for use throughout the system.
 * @public
 */
declare function createTemplateAction<TInputSchema extends {
    [key in string]: (zImpl: typeof z) => z.ZodType;
} | ((zImpl: typeof z) => z.ZodType), TOutputSchema extends {
    [key in string]: (zImpl: typeof z) => z.ZodType;
} | ((zImpl: typeof z) => z.ZodType)>(action: TemplateActionOptions<TInputSchema extends {
    [key in string]: (zImpl: typeof z) => z.ZodType;
} ? {
    [key in keyof TInputSchema]: z.infer<ReturnType<TInputSchema[key]>>;
} : TInputSchema extends (zImpl: typeof z) => z.ZodType ? z.infer<ReturnType<TInputSchema>> : never, TOutputSchema extends {
    [key in string]: (zImpl: typeof z) => z.ZodType;
} ? {
    [key in keyof TOutputSchema]: z.infer<ReturnType<TOutputSchema[key]>>;
} : TOutputSchema extends (zImpl: typeof z) => z.ZodType ? z.infer<ReturnType<TOutputSchema>> : never, TInputSchema, TOutputSchema, 'v2'>): TemplateAction<FlattenOptionalProperties<TInputSchema extends {
    [key in string]: (zImpl: typeof z) => z.ZodType;
} ? {
    [key in keyof TInputSchema]: z.output<ReturnType<TInputSchema[key]>>;
} : TInputSchema extends (zImpl: typeof z) => z.ZodType ? z.output<ReturnType<TInputSchema>> : never>, FlattenOptionalProperties<TOutputSchema extends {
    [key in string]: (zImpl: typeof z) => z.ZodType;
} ? {
    [key in keyof TOutputSchema]: z.output<ReturnType<TOutputSchema[key]>>;
} : TOutputSchema extends (zImpl: typeof z) => z.ZodType ? z.output<ReturnType<TOutputSchema>> : never>, 'v2'>;

/**
 * Options for {@link executeShellCommand}.
 *
 * @public
 */
type ExecuteShellCommandOptions = {
    /** command to run */
    command: string;
    /** arguments to pass the command */
    args: string[];
    /** options to pass to spawn */
    options?: SpawnOptionsWithoutStdio;
    /** logger to capture stdout and stderr output */
    logger?: LoggerService;
    /**
     * stream to capture stdout and stderr output
     * @deprecated  please provide a logger instead.
     */
    logStream?: Writable;
};
/**
 * Run a command in a sub-process, normally a shell command.
 *
 * @public
 */
declare function executeShellCommand(options: ExecuteShellCommandOptions): Promise<void>;

/**
 * A helper function that reads the contents of a directory from the given URL.
 * Can be used in your own actions, and also used behind fetch:template and fetch:plain
 *
 * @public
 */
declare function fetchContents(options: {
    reader: UrlReaderService;
    integrations: ScmIntegrations;
    baseUrl?: string;
    fetchUrl?: string;
    outputPath: string;
    token?: string;
}): Promise<void>;
/**
 * A helper function that reads the content of a single file from the given URL.
 * Can be used in your own actions, and also used behind `fetch:plain:file`
 *
 * @public
 */
declare function fetchFile(options: {
    reader: UrlReaderService;
    integrations: ScmIntegrations;
    baseUrl?: string;
    fetchUrl?: string;
    outputPath: string;
    token?: string;
}): Promise<void>;

/**
 * @public
 */
declare function initRepoAndPush(input: {
    dir: string;
    remoteUrl: string;
    auth: {
        username: string;
        password: string;
    } | {
        token: string;
    };
    logger: LoggerService;
    defaultBranch?: string;
    commitMessage?: string;
    gitAuthorInfo?: {
        name?: string;
        email?: string;
    };
    signingKey?: string;
}): Promise<{
    commitHash: string;
}>;
/**
 * @public
 */
declare function commitAndPushRepo(input: {
    dir: string;
    auth: {
        username: string;
        password: string;
    } | {
        token: string;
    };
    logger: LoggerService;
    commitMessage: string;
    gitAuthorInfo?: {
        name?: string;
        email?: string;
    };
    branch?: string;
    remoteRef?: string;
    signingKey?: string;
}): Promise<{
    commitHash: string;
}>;
/**
 * @public
 */
declare function cloneRepo(options: {
    url: string;
    dir: string;
    auth: {
        username: string;
        password: string;
    } | {
        token: string;
    };
    logger?: LoggerService | undefined;
    ref?: string | undefined;
    depth?: number | undefined;
    noCheckout?: boolean | undefined;
}): Promise<void>;
/**
 * @public
 */
declare function createBranch(options: {
    dir: string;
    ref: string;
    auth: {
        username: string;
        password: string;
    } | {
        token: string;
    };
    logger?: LoggerService | undefined;
}): Promise<void>;
/**
 * @public
 */
declare function addFiles(options: {
    dir: string;
    filepath: string;
    auth: {
        username: string;
        password: string;
    } | {
        token: string;
    };
    logger?: LoggerService | undefined;
}): Promise<void>;
/**
 * @public
 */
declare function commitAndPushBranch(options: {
    dir: string;
    auth: {
        username: string;
        password: string;
    } | {
        token: string;
    };
    logger?: LoggerService | undefined;
    commitMessage: string;
    gitAuthorInfo?: {
        name?: string;
        email?: string;
    };
    branch?: string;
    remoteRef?: string;
    remote?: string;
    signingKey?: string;
}): Promise<{
    commitHash: string;
}>;

/**
 * @public
 */
declare const getRepoSourceDirectory: (workspacePath: string, sourcePath: string | undefined) => string;
/**
 * @public
 */
declare const parseRepoUrl: (repoUrl: string, integrations: ScmIntegrationRegistry) => {
    repo: string;
    host: string;
    owner?: string;
    organization?: string;
    workspace?: string;
    project?: string;
};
/**
 * Filter function to exclude the .git directory and its contents
 * while keeping other files like .gitignore
 * @public
 */
declare function isNotGitDirectoryOrContents(path: string): boolean;

/**
 * @public
 */
interface SerializedFile {
    path: string;
    content: Buffer;
    executable?: boolean;
    symlink?: boolean;
}

/**
 * @public
 */
declare function serializeDirectoryContents(sourcePath: string, options?: {
    gitignore?: boolean;
    globPatterns?: string[];
}): Promise<SerializedFile[]>;

/**
 * Deserializes a list of serialized files into the target directory.
 *
 * This method uses `resolveSafeChildPath` to make sure that files are
 * not written outside of the target directory.
 *
 * @public
 */
declare function deserializeDirectoryContents(targetPath: string, files: SerializedFile[]): Promise<void>;

export { type ActionContext, type ExecuteShellCommandOptions, type SerializedFile, type SerializedTask, type SerializedTaskEvent, type TaskBroker, type TaskBrokerDispatchOptions, type TaskBrokerDispatchResult, type TaskCompletionState, type TaskContext, type TaskEventType, type TaskFilter, type TaskFilters, type TaskSecrets, type TaskStatus, type TemplateAction, type TemplateActionOptions, type TemplateExample, addFiles, cloneRepo, commitAndPushBranch, commitAndPushRepo, createBranch, createTemplateAction, deserializeDirectoryContents, executeShellCommand, fetchContents, fetchFile, getRepoSourceDirectory, initRepoAndPush, isNotGitDirectoryOrContents, parseRepoUrl, serializeDirectoryContents };
