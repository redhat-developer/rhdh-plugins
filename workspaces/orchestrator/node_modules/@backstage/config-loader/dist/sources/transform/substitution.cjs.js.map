{"version":3,"file":"substitution.cjs.js","sources":["../../../src/sources/transform/substitution.ts"],"sourcesContent":["/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { JsonValue } from '@backstage/types';\nimport { TransformFunc } from './types';\nimport { SubstitutionFunc } from '../types';\n\n/**\n * A environment variable substitution transform that transforms e.g. 'token ${MY_TOKEN}'\n * to 'token abc' if MY_TOKEN is 'abc'. If any of the substituted variables are undefined,\n * the entire expression ends up undefined. Additionally, supports parameter substitution\n * syntax to provide a default or fallback value for a given environment variable if it is\n * unset; e.g. 'token ${MY_TOKEN:-xyz}' transforms to 'token xyz' if MY_TOKEN is unset.\n */\nexport function createSubstitutionTransform(\n  env: SubstitutionFunc,\n): TransformFunc {\n  return async (input: JsonValue) => {\n    if (typeof input !== 'string') {\n      return { applied: false };\n    }\n\n    const parts: (string | undefined)[] = input.split(/(\\$?\\$\\{[^{}]*\\})/);\n    for (let i = 1; i < parts.length; i += 2) {\n      const part = parts[i]!;\n      if (part.startsWith('$$')) {\n        parts[i] = part.slice(1);\n      } else {\n        const indexOfFallbackSeparator = part.indexOf(':-');\n\n        if (indexOfFallbackSeparator > -1) {\n          const envVarValue = await env(\n            part.slice(2, indexOfFallbackSeparator).trim(),\n          );\n          const fallbackValue = part\n            .slice(indexOfFallbackSeparator + ':-'.length, -1)\n            .trim();\n\n          parts[i] = envVarValue || fallbackValue || undefined;\n        } else {\n          parts[i] = await env(part.slice(2, -1).trim());\n        }\n      }\n    }\n\n    if (parts.some(part => part === undefined)) {\n      return { applied: true, value: undefined };\n    }\n    return { applied: true, value: parts.join('') };\n  };\n}\n"],"names":[],"mappings":";;AA2BO,SAAS,4BACd,GAAA,EACe;AACf,EAAA,OAAO,OAAO,KAAA,KAAqB;AACjC,IAAA,IAAI,OAAO,UAAU,QAAA,EAAU;AAC7B,MAAA,OAAO,EAAE,SAAS,KAAA,EAAM;AAAA,IAC1B;AAEA,IAAA,MAAM,KAAA,GAAgC,KAAA,CAAM,KAAA,CAAM,mBAAmB,CAAA;AACrE,IAAA,KAAA,IAAS,IAAI,CAAA,EAAG,CAAA,GAAI,KAAA,CAAM,MAAA,EAAQ,KAAK,CAAA,EAAG;AACxC,MAAA,MAAM,IAAA,GAAO,MAAM,CAAC,CAAA;AACpB,MAAA,IAAI,IAAA,CAAK,UAAA,CAAW,IAAI,CAAA,EAAG;AACzB,QAAA,KAAA,CAAM,CAAC,CAAA,GAAI,IAAA,CAAK,KAAA,CAAM,CAAC,CAAA;AAAA,MACzB,CAAA,MAAO;AACL,QAAA,MAAM,wBAAA,GAA2B,IAAA,CAAK,OAAA,CAAQ,IAAI,CAAA;AAElD,QAAA,IAAI,2BAA2B,EAAA,EAAI;AACjC,UAAA,MAAM,cAAc,MAAM,GAAA;AAAA,YACxB,IAAA,CAAK,KAAA,CAAM,CAAA,EAAG,wBAAwB,EAAE,IAAA;AAAK,WAC/C;AACA,UAAA,MAAM,aAAA,GAAgB,KACnB,KAAA,CAAM,wBAAA,GAA2B,KAAK,MAAA,EAAQ,EAAE,EAChD,IAAA,EAAK;AAER,UAAA,KAAA,CAAM,CAAC,CAAA,GAAI,WAAA,IAAe,aAAA,IAAiB,MAAA;AAAA,QAC7C,CAAA,MAAO;AACL,UAAA,KAAA,CAAM,CAAC,CAAA,GAAI,MAAM,GAAA,CAAI,IAAA,CAAK,MAAM,CAAA,EAAG,EAAE,CAAA,CAAE,IAAA,EAAM,CAAA;AAAA,QAC/C;AAAA,MACF;AAAA,IACF;AAEA,IAAA,IAAI,KAAA,CAAM,IAAA,CAAK,CAAA,IAAA,KAAQ,IAAA,KAAS,MAAS,CAAA,EAAG;AAC1C,MAAA,OAAO,EAAE,OAAA,EAAS,IAAA,EAAM,KAAA,EAAO,MAAA,EAAU;AAAA,IAC3C;AACA,IAAA,OAAO,EAAE,OAAA,EAAS,IAAA,EAAM,OAAO,KAAA,CAAM,IAAA,CAAK,EAAE,CAAA,EAAE;AAAA,EAChD,CAAA;AACF;;;;"}