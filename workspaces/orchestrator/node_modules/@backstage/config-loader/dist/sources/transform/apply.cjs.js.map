{"version":3,"file":"apply.cjs.js","sources":["../../../src/sources/transform/apply.ts"],"sourcesContent":["/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { JsonObject, JsonValue } from '@backstage/types';\nimport { assertError } from '@backstage/errors';\nimport { TransformContext, TransformFunc } from './types';\nimport { isObject } from './utils';\nimport { createSubstitutionTransform } from './substitution';\nimport { createIncludeTransform } from './include';\nimport { SubstitutionFunc } from '../types';\n\n/**\n * Applies a set of transforms to raw configuration data.\n */\nexport async function applyConfigTransforms(\n  input: JsonValue,\n  context: { dir?: string },\n  transforms: TransformFunc[],\n): Promise<JsonObject> {\n  async function transform(\n    inputObj: JsonValue,\n    path: string,\n    baseDir?: string,\n  ): Promise<JsonValue | undefined> {\n    let obj = inputObj;\n    let dir = baseDir;\n\n    for (const tf of transforms) {\n      try {\n        const result = await tf(inputObj, { dir });\n        if (result.applied) {\n          if (result.value === undefined) {\n            return undefined;\n          }\n          obj = result.value;\n          dir = result?.newDir ?? dir;\n          break;\n        }\n      } catch (error) {\n        assertError(error);\n        throw new Error(`error at ${path}, ${error.message}`);\n      }\n    }\n\n    if (typeof obj !== 'object') {\n      return obj;\n    } else if (obj === null) {\n      return null;\n    } else if (Array.isArray(obj)) {\n      const arr = new Array<JsonValue>();\n\n      for (const [index, value] of obj.entries()) {\n        const out = await transform(value, `${path}[${index}]`, dir);\n        if (out !== undefined) {\n          arr.push(out);\n        }\n      }\n\n      return arr;\n    }\n\n    const out: JsonObject = {};\n\n    for (const [key, value] of Object.entries(obj)) {\n      // undefined covers optional fields\n      if (value !== undefined) {\n        const result = await transform(value, `${path}.${key}`, dir);\n        if (result !== undefined) {\n          out[key] = result;\n        }\n      }\n    }\n\n    return out;\n  }\n\n  const finalData = await transform(input, '', context?.dir);\n  if (!isObject(finalData)) {\n    throw new TypeError('expected object at config root');\n  }\n  return finalData;\n}\n\n/** @internal */\nexport type ConfigTransformer = (\n  input: JsonObject,\n  context?: TransformContext,\n) => Promise<JsonObject>;\n\n/** @internal */\nexport function createConfigTransformer(options: {\n  substitutionFunc?: SubstitutionFunc;\n  readFile?(path: string): Promise<string>;\n}): ConfigTransformer {\n  const {\n    substitutionFunc = async name => process.env[name]?.trim(),\n    readFile,\n  } = options;\n  const substitutionTransform = createSubstitutionTransform(substitutionFunc);\n  const transforms = [substitutionTransform];\n  if (readFile) {\n    const includeTransform = createIncludeTransform(\n      substitutionFunc,\n      readFile,\n      substitutionTransform,\n    );\n    transforms.push(includeTransform);\n  }\n\n  return async (input, ctx) =>\n    applyConfigTransforms(input, ctx ?? {}, transforms);\n}\n"],"names":["assertError","out","isObject","createSubstitutionTransform","createIncludeTransform"],"mappings":"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"}