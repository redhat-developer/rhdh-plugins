{"version":3,"file":"FileConfigSource.cjs.js","sources":["../../src/sources/FileConfigSource.ts"],"sourcesContent":["/*\n * Copyright 2023 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport chokidar, { FSWatcher } from 'chokidar';\nimport fs from 'fs-extra';\nimport { basename, dirname, isAbsolute, resolve as resolvePath } from 'path';\nimport {\n  AsyncConfigSourceGenerator,\n  ConfigSource,\n  ConfigSourceData,\n  SubstitutionFunc,\n  Parser,\n  ReadConfigDataOptions,\n} from './types';\nimport { createConfigTransformer } from './transform';\nimport { NotFoundError } from '@backstage/errors';\nimport { parseYamlContent } from './utils';\n\n/**\n * Options for {@link FileConfigSource.create}.\n *\n * @public\n */\nexport interface FileConfigSourceOptions {\n  /**\n   * The path to the config file that should be loaded.\n   */\n  path: string;\n\n  /**\n   * Set to `false` to disable file watching, defaults to `true`.\n   */\n  watch?: boolean;\n\n  /**\n   * A substitution function to use instead of the default environment substitution.\n   */\n  substitutionFunc?: SubstitutionFunc;\n\n  /**\n   * A content parsing function to transform string content to configuration values.\n   */\n  parser?: Parser;\n}\n\nasync function readFile(path: string): Promise<string | undefined> {\n  try {\n    const content = await fs.readFile(path, 'utf8');\n    // During watching we may sometimes read files too early before the file content has been written.\n    // We never expect the writing to take a long time, but if we encounter an empty file then check\n    // again after a short delay for safety.\n    if (content === '') {\n      await new Promise(resolve => setTimeout(resolve, 10));\n      return await fs.readFile(path, 'utf8');\n    }\n    return content;\n  } catch (error) {\n    if (error.code === 'ENOENT') {\n      return undefined;\n    }\n    throw error;\n  }\n}\n\n/**\n * A config source that loads configuration from a local file.\n *\n * @public\n */\nexport class FileConfigSource implements ConfigSource {\n  /**\n   * Creates a new config source that loads configuration from the given path.\n   *\n   * @remarks\n   *\n   * The source will watch the file for changes, as well as any referenced files.\n   *\n   * @param options - Options for the config source.\n   * @returns A new config source that loads from the given path.\n   */\n  static create(options: FileConfigSourceOptions): ConfigSource {\n    if (!isAbsolute(options.path)) {\n      throw new Error(`Config load path is not absolute: \"${options.path}\"`);\n    }\n    return new FileConfigSource(options);\n  }\n\n  readonly #path: string;\n  readonly #substitutionFunc?: SubstitutionFunc;\n  readonly #watch?: boolean;\n  readonly #parser: Parser;\n\n  private constructor(options: FileConfigSourceOptions) {\n    this.#path = options.path;\n    this.#substitutionFunc = options.substitutionFunc;\n    this.#watch = options.watch ?? true;\n    this.#parser = options.parser ?? parseYamlContent;\n  }\n\n  // Work is duplicated across each read, in practice that should not\n  // have any impact since there won't be multiple consumers. If that\n  // changes it might be worth refactoring this to avoid duplicate work.\n  async *readConfigData(\n    options?: ReadConfigDataOptions,\n  ): AsyncConfigSourceGenerator {\n    const signal = options?.signal;\n    const configFileName = basename(this.#path);\n\n    let watchedPaths: Array<string> | null = null;\n    let watcher: FSWatcher | null = null;\n\n    if (this.#watch) {\n      // Keep track of watched paths, since this is simpler than resetting the watcher\n      watchedPaths = new Array<string>();\n      watcher = chokidar.watch(this.#path, {\n        usePolling: process.env.NODE_ENV === 'test',\n      });\n    }\n\n    const dir = dirname(this.#path);\n    const transformer = createConfigTransformer({\n      substitutionFunc: this.#substitutionFunc,\n      readFile: async path => {\n        const fullPath = resolvePath(dir, path);\n        if (watcher && watchedPaths) {\n          // Any files discovered while reading this config should be watched too\n          watcher.add(fullPath);\n          watchedPaths.push(fullPath);\n        }\n\n        const data = await readFile(fullPath);\n        if (data === undefined) {\n          throw new NotFoundError(\n            `failed to include \"${fullPath}\", file does not exist`,\n          );\n        }\n        return data;\n      },\n    });\n\n    // This is the entry point for reading the file, called initially and on change\n    const readConfigFile = async (): Promise<ConfigSourceData[]> => {\n      if (watcher && watchedPaths) {\n        // We clear the watched files every time we initiate a new read\n        watcher.unwatch(watchedPaths);\n        watchedPaths.length = 0;\n\n        watcher.add(this.#path);\n        watchedPaths.push(this.#path);\n      }\n\n      const contents = await readFile(this.#path);\n      if (contents === undefined) {\n        throw new NotFoundError(`Config file \"${this.#path}\" does not exist`);\n      }\n      const { result: parsed } = await this.#parser({ contents });\n      if (parsed === undefined) {\n        return [];\n      }\n      try {\n        const data = await transformer(parsed, { dir });\n        return [{ data, context: configFileName, path: this.#path }];\n      } catch (error) {\n        throw new Error(\n          `Failed to read config file at \"${this.#path}\", ${error.message}`,\n        );\n      }\n    };\n\n    const onAbort = () => {\n      signal?.removeEventListener('abort', onAbort);\n      if (watcher) watcher.close();\n    };\n    signal?.addEventListener('abort', onAbort);\n\n    yield { configs: await readConfigFile() };\n\n    if (watcher) {\n      for (;;) {\n        const event = await this.#waitForEvent(watcher, signal);\n        if (event === 'abort') {\n          return;\n        }\n        yield { configs: await readConfigFile() };\n      }\n    }\n  }\n\n  toString() {\n    return `FileConfigSource{path=\"${this.#path}\"}`;\n  }\n\n  #waitForEvent(\n    watcher: FSWatcher,\n    signal?: AbortSignal,\n  ): Promise<'change' | 'abort'> {\n    return new Promise(resolve => {\n      function onChange() {\n        resolve('change');\n        onDone();\n      }\n      function onAbort() {\n        resolve('abort');\n        onDone();\n      }\n      function onDone() {\n        watcher.removeListener('change', onChange);\n        signal?.removeEventListener('abort', onAbort);\n      }\n      watcher.addListener('change', onChange);\n      signal?.addEventListener('abort', onAbort);\n    });\n  }\n}\n"],"names":["fs","isAbsolute","parseYamlContent","basename","chokidar","dirname","createConfigTransformer","path","resolvePath","NotFoundError"],"mappings":"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"}