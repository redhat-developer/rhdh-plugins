{"version":3,"file":"collect.cjs.js","sources":["../../src/schema/collect.ts"],"sourcesContent":["/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport fs from 'fs-extra';\nimport { EOL } from 'os';\nimport {\n  resolve as resolvePath,\n  relative as relativePath,\n  dirname,\n  sep,\n} from 'path';\nimport { ConfigSchemaPackageEntry } from './types';\nimport { JsonObject } from '@backstage/types';\nimport { assertError } from '@backstage/errors';\n\ntype Item = {\n  name?: string;\n  parentPath?: string;\n  packagePath?: string;\n};\n\nconst req =\n  typeof __non_webpack_require__ === 'undefined'\n    ? require\n    : __non_webpack_require__;\n\n/**\n * This collects all known config schemas across all dependencies of the app.\n */\nexport async function collectConfigSchemas(\n  packageNames: string[],\n  packagePaths: string[],\n): Promise<ConfigSchemaPackageEntry[]> {\n  const schemas = new Array<ConfigSchemaPackageEntry>();\n  const tsSchemaPaths = new Array<{ packageName: string; path: string }>();\n  const visitedPackageVersions = new Map<string, Set<string>>(); // pkgName: [versions...]\n\n  const currentDir = await fs.realpath(process.cwd());\n\n  async function processItem(item: Item) {\n    let pkgPath = item.packagePath;\n\n    if (pkgPath) {\n      const pkgExists = await fs.pathExists(pkgPath);\n      if (!pkgExists) {\n        return;\n      }\n    } else if (item.name) {\n      const { name, parentPath } = item;\n\n      try {\n        pkgPath = req.resolve(\n          `${name}/package.json`,\n          parentPath && {\n            paths: [parentPath],\n          },\n        );\n      } catch {\n        // We can somewhat safely ignore packages that don't export package.json,\n        // as they are likely not part of the Backstage ecosystem anyway.\n      }\n    }\n    if (!pkgPath) {\n      return;\n    }\n\n    const pkg = await fs.readJson(pkgPath);\n\n    // Ensures that we only process the same version of each package once.\n    let versions = visitedPackageVersions.get(pkg.name);\n    if (versions?.has(pkg.version)) {\n      return;\n    }\n    if (!versions) {\n      versions = new Set();\n      visitedPackageVersions.set(pkg.name, versions);\n    }\n    versions.add(pkg.version);\n\n    const depNames = [\n      ...Object.keys(pkg.dependencies ?? {}),\n      ...Object.keys(pkg.devDependencies ?? {}),\n      ...Object.keys(pkg.optionalDependencies ?? {}),\n      ...Object.keys(pkg.peerDependencies ?? {}),\n    ];\n\n    // TODO(Rugvip): Trying this out to avoid having to traverse the full dependency graph,\n    //               since that's pretty slow. We probably need a better way to determine when\n    //               we've left the Backstage ecosystem, but this will do for now.\n    const hasSchema = 'configSchema' in pkg;\n    const hasBackstageDep = depNames.some(_ => _.startsWith('@backstage/'));\n    if (!hasSchema && !hasBackstageDep) {\n      return;\n    }\n    if (hasSchema) {\n      if (typeof pkg.configSchema === 'string') {\n        const isJson = pkg.configSchema.endsWith('.json');\n        const isDts = pkg.configSchema.endsWith('.d.ts');\n        if (!isJson && !isDts) {\n          throw new Error(\n            `Config schema files must be .json or .d.ts, got ${pkg.configSchema}`,\n          );\n        }\n        if (isDts) {\n          tsSchemaPaths.push({\n            path: relativePath(\n              currentDir,\n              resolvePath(dirname(pkgPath), pkg.configSchema),\n            ),\n            packageName: pkg.name,\n          });\n        } else {\n          const path = resolvePath(dirname(pkgPath), pkg.configSchema);\n          const value = await fs.readJson(path);\n          schemas.push({\n            packageName: pkg.name,\n            value,\n            path: relativePath(currentDir, path),\n          });\n        }\n      } else {\n        schemas.push({\n          packageName: pkg.name,\n          value: pkg.configSchema,\n          path: relativePath(currentDir, pkgPath),\n        });\n      }\n    }\n\n    await Promise.all(\n      depNames.map(depName =>\n        processItem({ name: depName, parentPath: pkgPath }),\n      ),\n    );\n  }\n\n  await Promise.all([\n    ...packageNames.map(name => processItem({ name, parentPath: currentDir })),\n    ...packagePaths.map(path => processItem({ name: path, packagePath: path })),\n  ]);\n\n  const tsSchemas = await compileTsSchemas(tsSchemaPaths);\n  const allSchemas = schemas.concat(tsSchemas);\n\n  const hasBackendDefaults = allSchemas.some(\n    ({ packageName }) => packageName === '@backstage/backend-defaults',\n  );\n\n  if (hasBackendDefaults) {\n    // We filter out backend-common schemas here to avoid issues with\n    // schema merging over different versions of the same schema.\n    // led to issues such as https://github.com/backstage/backstage/issues/28170\n    return allSchemas.filter(\n      ({ packageName }) => packageName !== '@backstage/backend-common',\n    );\n  }\n\n  return allSchemas;\n}\n\n// This handles the support of TypeScript .d.ts config schema declarations.\n// We collect all typescript schema definition and compile them all in one go.\n// This is much faster than compiling them separately.\nasync function compileTsSchemas(\n  entries: { path: string; packageName: string }[],\n) {\n  if (entries.length === 0) {\n    return [];\n  }\n\n  // Lazy loaded, because this brings up all of TypeScript and we don't\n  // want that eagerly loaded in tests\n  const { getProgramFromFiles, buildGenerator } =\n    require('typescript-json-schema') as typeof import('typescript-json-schema');\n\n  const program = getProgramFromFiles(\n    entries.map(({ path }) => path),\n    {\n      incremental: false,\n      isolatedModules: true,\n      lib: ['ES5'], // Skipping most libs speeds processing up a lot, we just need the primitive types anyway\n      noEmit: true,\n      noResolve: true,\n      skipLibCheck: true, // Skipping lib checks speeds things up\n      skipDefaultLibCheck: true,\n      strict: true,\n      typeRoots: [], // Do not include any additional types\n      types: [],\n    },\n  );\n\n  const tsSchemas = entries.map(({ path, packageName }) => {\n    let value;\n    try {\n      const generator = buildGenerator(\n        program,\n        // This enables the use of these tags in TSDoc comments\n        {\n          required: true,\n          validationKeywords: ['visibility', 'deepVisibility', 'deprecated'],\n        },\n        [path.split(sep).join('/')], // Unix paths are expected for all OSes here\n      );\n\n      // All schemas should export a `Config` symbol\n      value = generator?.getSchemaForSymbol('Config') as JsonObject | null;\n\n      // This makes sure that no additional symbols are defined in the schema. We don't allow\n      // this because they share a global namespace and will be merged together, leading to\n      // unpredictable behavior.\n      const userSymbols = new Set(generator?.getUserSymbols());\n      userSymbols.delete('Config');\n      if (userSymbols.size !== 0) {\n        const names = Array.from(userSymbols).join(\"', '\");\n        throw new Error(\n          `Invalid configuration schema in ${path}, additional symbol definitions are not allowed, found '${names}'`,\n        );\n      }\n\n      // This makes sure that no unsupported types are used in the schema, for example `Record<,>`.\n      // The generator will extract these as a schema reference, which will in turn be broken for our usage.\n      const reffedDefs = Object.keys(generator?.ReffedDefinitions ?? {});\n      if (reffedDefs.length !== 0) {\n        const lines = reffedDefs.join(`${EOL}  `);\n        throw new Error(\n          `Invalid configuration schema in ${path}, the following definitions are not supported:${EOL}${EOL}  ${lines}`,\n        );\n      }\n    } catch (error) {\n      assertError(error);\n      if (error.message !== 'type Config not found') {\n        throw error;\n      }\n    }\n\n    if (!value) {\n      throw new Error(`Invalid schema in ${path}, missing Config export`);\n    }\n    return { path, value, packageName };\n  });\n\n  return tsSchemas;\n}\n"],"names":["fs","relativePath","resolvePath","dirname","path","sep","EOL","assertError"],"mappings":";;;;;;;;;;;AAkCA,MAAM,GAAA,GACJ,OAAO,uBAAA,KAA4B,WAAA,GAC/B,OAAA,GACA,uBAAA;AAKN,eAAsB,oBAAA,CACpB,cACA,YAAA,EACqC;AACrC,EAAA,MAAM,OAAA,GAAU,IAAI,KAAA,EAAgC;AACpD,EAAA,MAAM,aAAA,GAAgB,IAAI,KAAA,EAA6C;AACvE,EAAA,MAAM,sBAAA,uBAA6B,GAAA,EAAyB;AAE5D,EAAA,MAAM,aAAa,MAAMA,mBAAA,CAAG,QAAA,CAAS,OAAA,CAAQ,KAAK,CAAA;AAElD,EAAA,eAAe,YAAY,IAAA,EAAY;AACrC,IAAA,IAAI,UAAU,IAAA,CAAK,WAAA;AAEnB,IAAA,IAAI,OAAA,EAAS;AACX,MAAA,MAAM,SAAA,GAAY,MAAMA,mBAAA,CAAG,UAAA,CAAW,OAAO,CAAA;AAC7C,MAAA,IAAI,CAAC,SAAA,EAAW;AACd,QAAA;AAAA,MACF;AAAA,IACF,CAAA,MAAA,IAAW,KAAK,IAAA,EAAM;AACpB,MAAA,MAAM,EAAE,IAAA,EAAM,UAAA,EAAW,GAAI,IAAA;AAE7B,MAAA,IAAI;AACF,QAAA,OAAA,GAAU,GAAA,CAAI,OAAA;AAAA,UACZ,GAAG,IAAI,CAAA,aAAA,CAAA;AAAA,UACP,UAAA,IAAc;AAAA,YACZ,KAAA,EAAO,CAAC,UAAU;AAAA;AACpB,SACF;AAAA,MACF,CAAA,CAAA,MAAQ;AAAA,MAGR;AAAA,IACF;AACA,IAAA,IAAI,CAAC,OAAA,EAAS;AACZ,MAAA;AAAA,IACF;AAEA,IAAA,MAAM,GAAA,GAAM,MAAMA,mBAAA,CAAG,QAAA,CAAS,OAAO,CAAA;AAGrC,IAAA,IAAI,QAAA,GAAW,sBAAA,CAAuB,GAAA,CAAI,GAAA,CAAI,IAAI,CAAA;AAClD,IAAA,IAAI,QAAA,EAAU,GAAA,CAAI,GAAA,CAAI,OAAO,CAAA,EAAG;AAC9B,MAAA;AAAA,IACF;AACA,IAAA,IAAI,CAAC,QAAA,EAAU;AACb,MAAA,QAAA,uBAAe,GAAA,EAAI;AACnB,MAAA,sBAAA,CAAuB,GAAA,CAAI,GAAA,CAAI,IAAA,EAAM,QAAQ,CAAA;AAAA,IAC/C;AACA,IAAA,QAAA,CAAS,GAAA,CAAI,IAAI,OAAO,CAAA;AAExB,IAAA,MAAM,QAAA,GAAW;AAAA,MACf,GAAG,MAAA,CAAO,IAAA,CAAK,GAAA,CAAI,YAAA,IAAgB,EAAE,CAAA;AAAA,MACrC,GAAG,MAAA,CAAO,IAAA,CAAK,GAAA,CAAI,eAAA,IAAmB,EAAE,CAAA;AAAA,MACxC,GAAG,MAAA,CAAO,IAAA,CAAK,GAAA,CAAI,oBAAA,IAAwB,EAAE,CAAA;AAAA,MAC7C,GAAG,MAAA,CAAO,IAAA,CAAK,GAAA,CAAI,gBAAA,IAAoB,EAAE;AAAA,KAC3C;AAKA,IAAA,MAAM,YAAY,cAAA,IAAkB,GAAA;AACpC,IAAA,MAAM,kBAAkB,QAAA,CAAS,IAAA,CAAK,OAAK,CAAA,CAAE,UAAA,CAAW,aAAa,CAAC,CAAA;AACtE,IAAA,IAAI,CAAC,SAAA,IAAa,CAAC,eAAA,EAAiB;AAClC,MAAA;AAAA,IACF;AACA,IAAA,IAAI,SAAA,EAAW;AACb,MAAA,IAAI,OAAO,GAAA,CAAI,YAAA,KAAiB,QAAA,EAAU;AACxC,QAAA,MAAM,MAAA,GAAS,GAAA,CAAI,YAAA,CAAa,QAAA,CAAS,OAAO,CAAA;AAChD,QAAA,MAAM,KAAA,GAAQ,GAAA,CAAI,YAAA,CAAa,QAAA,CAAS,OAAO,CAAA;AAC/C,QAAA,IAAI,CAAC,MAAA,IAAU,CAAC,KAAA,EAAO;AACrB,UAAA,MAAM,IAAI,KAAA;AAAA,YACR,CAAA,gDAAA,EAAmD,IAAI,YAAY,CAAA;AAAA,WACrE;AAAA,QACF;AACA,QAAA,IAAI,KAAA,EAAO;AACT,UAAA,aAAA,CAAc,IAAA,CAAK;AAAA,YACjB,IAAA,EAAMC,aAAA;AAAA,cACJ,UAAA;AAAA,cACAC,YAAA,CAAYC,YAAA,CAAQ,OAAO,CAAA,EAAG,IAAI,YAAY;AAAA,aAChD;AAAA,YACA,aAAa,GAAA,CAAI;AAAA,WAClB,CAAA;AAAA,QACH,CAAA,MAAO;AACL,UAAA,MAAMC,SAAOF,YAAA,CAAYC,YAAA,CAAQ,OAAO,CAAA,EAAG,IAAI,YAAY,CAAA;AAC3D,UAAA,MAAM,KAAA,GAAQ,MAAMH,mBAAA,CAAG,QAAA,CAASI,MAAI,CAAA;AACpC,UAAA,OAAA,CAAQ,IAAA,CAAK;AAAA,YACX,aAAa,GAAA,CAAI,IAAA;AAAA,YACjB,KAAA;AAAA,YACA,IAAA,EAAMH,aAAA,CAAa,UAAA,EAAYG,MAAI;AAAA,WACpC,CAAA;AAAA,QACH;AAAA,MACF,CAAA,MAAO;AACL,QAAA,OAAA,CAAQ,IAAA,CAAK;AAAA,UACX,aAAa,GAAA,CAAI,IAAA;AAAA,UACjB,OAAO,GAAA,CAAI,YAAA;AAAA,UACX,IAAA,EAAMH,aAAA,CAAa,UAAA,EAAY,OAAO;AAAA,SACvC,CAAA;AAAA,MACH;AAAA,IACF;AAEA,IAAA,MAAM,OAAA,CAAQ,GAAA;AAAA,MACZ,QAAA,CAAS,GAAA;AAAA,QAAI,aACX,WAAA,CAAY,EAAE,MAAM,OAAA,EAAS,UAAA,EAAY,SAAS;AAAA;AACpD,KACF;AAAA,EACF;AAEA,EAAA,MAAM,QAAQ,GAAA,CAAI;AAAA,IAChB,GAAG,YAAA,CAAa,GAAA,CAAI,CAAA,IAAA,KAAQ,WAAA,CAAY,EAAE,IAAA,EAAM,UAAA,EAAY,UAAA,EAAY,CAAC,CAAA;AAAA,IACzE,GAAG,YAAA,CAAa,GAAA,CAAI,CAAA,IAAA,KAAQ,WAAA,CAAY,EAAE,IAAA,EAAM,IAAA,EAAM,WAAA,EAAa,IAAA,EAAM,CAAC;AAAA,GAC3E,CAAA;AAED,EAAA,MAAM,SAAA,GAAY,MAAM,gBAAA,CAAiB,aAAa,CAAA;AACtD,EAAA,MAAM,UAAA,GAAa,OAAA,CAAQ,MAAA,CAAO,SAAS,CAAA;AAE3C,EAAA,MAAM,qBAAqB,UAAA,CAAW,IAAA;AAAA,IACpC,CAAC,EAAE,WAAA,EAAY,KAAM,WAAA,KAAgB;AAAA,GACvC;AAEA,EAAA,IAAI,kBAAA,EAAoB;AAItB,IAAA,OAAO,UAAA,CAAW,MAAA;AAAA,MAChB,CAAC,EAAE,WAAA,EAAY,KAAM,WAAA,KAAgB;AAAA,KACvC;AAAA,EACF;AAEA,EAAA,OAAO,UAAA;AACT;AAKA,eAAe,iBACb,OAAA,EACA;AACA,EAAA,IAAI,OAAA,CAAQ,WAAW,CAAA,EAAG;AACxB,IAAA,OAAO,EAAC;AAAA,EACV;AAIA,EAAA,MAAM,EAAE,mBAAA,EAAqB,cAAA,EAAe,GAC1C,QAAQ,wBAAwB,CAAA;AAElC,EAAA,MAAM,OAAA,GAAU,mBAAA;AAAA,IACd,QAAQ,GAAA,CAAI,CAAC,EAAE,IAAA,OAAW,IAAI,CAAA;AAAA,IAC9B;AAAA,MACE,WAAA,EAAa,KAAA;AAAA,MACb,eAAA,EAAiB,IAAA;AAAA,MACjB,GAAA,EAAK,CAAC,KAAK,CAAA;AAAA;AAAA,MACX,MAAA,EAAQ,IAAA;AAAA,MACR,SAAA,EAAW,IAAA;AAAA,MACX,YAAA,EAAc,IAAA;AAAA;AAAA,MACd,mBAAA,EAAqB,IAAA;AAAA,MACrB,MAAA,EAAQ,IAAA;AAAA,MACR,WAAW,EAAC;AAAA;AAAA,MACZ,OAAO;AAAC;AACV,GACF;AAEA,EAAA,MAAM,YAAY,OAAA,CAAQ,GAAA,CAAI,CAAC,QAAEG,MAAA,EAAM,aAAY,KAAM;AACvD,IAAA,IAAI,KAAA;AACJ,IAAA,IAAI;AACF,MAAA,MAAM,SAAA,GAAY,cAAA;AAAA,QAChB,OAAA;AAAA;AAAA,QAEA;AAAA,UACE,QAAA,EAAU,IAAA;AAAA,UACV,kBAAA,EAAoB,CAAC,YAAA,EAAc,gBAAA,EAAkB,YAAY;AAAA,SACnE;AAAA,QACA,CAACA,MAAA,CAAK,KAAA,CAAMC,QAAG,CAAA,CAAE,IAAA,CAAK,GAAG,CAAC;AAAA;AAAA,OAC5B;AAGA,MAAA,KAAA,GAAQ,SAAA,EAAW,mBAAmB,QAAQ,CAAA;AAK9C,MAAA,MAAM,WAAA,GAAc,IAAI,GAAA,CAAI,SAAA,EAAW,gBAAgB,CAAA;AACvD,MAAA,WAAA,CAAY,OAAO,QAAQ,CAAA;AAC3B,MAAA,IAAI,WAAA,CAAY,SAAS,CAAA,EAAG;AAC1B,QAAA,MAAM,QAAQ,KAAA,CAAM,IAAA,CAAK,WAAW,CAAA,CAAE,KAAK,MAAM,CAAA;AACjD,QAAA,MAAM,IAAI,KAAA;AAAA,UACR,CAAA,gCAAA,EAAmCD,MAAI,CAAA,wDAAA,EAA2D,KAAK,CAAA,CAAA;AAAA,SACzG;AAAA,MACF;AAIA,MAAA,MAAM,aAAa,MAAA,CAAO,IAAA,CAAK,SAAA,EAAW,iBAAA,IAAqB,EAAE,CAAA;AACjE,MAAA,IAAI,UAAA,CAAW,WAAW,CAAA,EAAG;AAC3B,QAAA,MAAM,KAAA,GAAQ,UAAA,CAAW,IAAA,CAAK,CAAA,EAAGE,MAAG,CAAA,EAAA,CAAI,CAAA;AACxC,QAAA,MAAM,IAAI,KAAA;AAAA,UACR,mCAAmCF,MAAI,CAAA,8CAAA,EAAiDE,MAAG,CAAA,EAAGA,MAAG,KAAK,KAAK,CAAA;AAAA,SAC7G;AAAA,MACF;AAAA,IACF,SAAS,KAAA,EAAO;AACd,MAAAC,kBAAA,CAAY,KAAK,CAAA;AACjB,MAAA,IAAI,KAAA,CAAM,YAAY,uBAAA,EAAyB;AAC7C,QAAA,MAAM,KAAA;AAAA,MACR;AAAA,IACF;AAEA,IAAA,IAAI,CAAC,KAAA,EAAO;AACV,MAAA,MAAM,IAAI,KAAA,CAAM,CAAA,kBAAA,EAAqBH,MAAI,CAAA,uBAAA,CAAyB,CAAA;AAAA,IACpE;AACA,IAAA,OAAO,QAAEA,MAAA,EAAM,KAAA,EAAO,WAAA,EAAY;AAAA,EACpC,CAAC,CAAA;AAED,EAAA,OAAO,SAAA;AACT;;;;"}