{"version":3,"file":"createPermissionIntegrationRouter.cjs.js","sources":["../../src/integration/createPermissionIntegrationRouter.ts"],"sourcesContent":["/*\n * Copyright 2021 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport express, { Response } from 'express';\nimport Router from 'express-promise-router';\nimport { z } from 'zod';\nimport zodToJsonSchema from 'zod-to-json-schema';\nimport { InputError } from '@backstage/errors';\nimport {\n  AuthorizeResult,\n  DefinitivePolicyDecision,\n  IdentifiedPermissionMessage,\n  MetadataResponse as CommonMetadataResponse,\n  MetadataResponseSerializedRule as CommonMetadataResponseSerializedRule,\n  Permission,\n  PermissionCondition,\n  PermissionCriteria,\n  PolicyDecision,\n} from '@backstage/plugin-permission-common';\nimport { NoInfer, PermissionRule, PermissionRuleset } from '../types';\nimport {\n  createGetRule,\n  isAndCriteria,\n  isNotCriteria,\n  isOrCriteria,\n} from './util';\nimport { NotImplementedError } from '@backstage/errors';\nimport { PermissionResourceRef } from './createPermissionResourceRef';\n\nconst permissionCriteriaSchema: z.ZodSchema<\n  PermissionCriteria<PermissionCondition>\n> = z.lazy(() =>\n  z.union([\n    z.object({ anyOf: z.array(permissionCriteriaSchema).nonempty() }),\n    z.object({ allOf: z.array(permissionCriteriaSchema).nonempty() }),\n    z.object({ not: permissionCriteriaSchema }),\n    z.object({\n      rule: z.string(),\n      resourceType: z.string(),\n      params: z.record(z.any()).optional(),\n    }),\n  ]),\n);\n\nconst applyConditionsRequestSchema = z.object({\n  items: z.array(\n    z.object({\n      id: z.string(),\n      resourceRef: z.union([z.string(), z.array(z.string()).nonempty()]),\n      resourceType: z.string(),\n      conditions: permissionCriteriaSchema,\n    }),\n  ),\n});\n\n/**\n * A request to load the referenced resource and apply conditions in order to\n * finalize a conditional authorization response.\n *\n * @public\n */\nexport type ApplyConditionsRequestEntry = IdentifiedPermissionMessage<{\n  resourceRef: string | string[];\n  resourceType: string;\n  conditions: PermissionCriteria<PermissionCondition>;\n}>;\n\n/**\n * A batch of {@link ApplyConditionsRequestEntry} objects.\n *\n * @public\n */\nexport type ApplyConditionsRequest = {\n  items: ApplyConditionsRequestEntry[];\n};\n\n/**\n * The result of applying the conditions, expressed as a definitive authorize\n * result of ALLOW or DENY.\n *\n * @public\n */\nexport type ApplyConditionsResponseEntry = IdentifiedPermissionMessage<\n  | DefinitivePolicyDecision\n  | {\n      result: Array<AuthorizeResult.ALLOW | AuthorizeResult.DENY>;\n    }\n>;\n\n/**\n * A batch of {@link ApplyConditionsResponseEntry} objects.\n *\n * @public\n */\nexport type ApplyConditionsResponse = {\n  items: ApplyConditionsResponseEntry[];\n};\n\n/**\n * Serialized permission rules, with the paramsSchema\n * converted from a ZodSchema to a JsonSchema.\n *\n * @public\n * @deprecated Please import from `@backstage/plugin-permission-common` instead.\n */\nexport type MetadataResponseSerializedRule =\n  CommonMetadataResponseSerializedRule;\n\n/**\n * Response type for the .metadata endpoint.\n *\n * @public\n * @deprecated Please import from `@backstage/plugin-permission-common` instead.\n */\nexport type MetadataResponse = CommonMetadataResponse;\n\nconst applyConditions = <TResourceType extends string, TResource>(\n  criteria: PermissionCriteria<PermissionCondition<TResourceType>>,\n  resource: TResource | undefined,\n  getRule: (name: string) => PermissionRule<TResource, unknown, TResourceType>,\n): boolean => {\n  // If resource was not found, deny. This avoids leaking information from the\n  // apply-conditions API which would allow a user to differentiate between\n  // non-existent resources and resources to which they do not have access.\n  if (resource === undefined) {\n    return false;\n  }\n\n  if (isAndCriteria(criteria)) {\n    return criteria.allOf.every(child =>\n      applyConditions(child, resource, getRule),\n    );\n  } else if (isOrCriteria(criteria)) {\n    return criteria.anyOf.some(child =>\n      applyConditions(child, resource, getRule),\n    );\n  } else if (isNotCriteria(criteria)) {\n    return !applyConditions(criteria.not, resource, getRule);\n  }\n\n  const rule = getRule(criteria.rule);\n  const result = rule.paramsSchema?.safeParse(criteria.params);\n\n  if (result && !result.success) {\n    throw new InputError(`Parameters to rule are invalid`, result.error);\n  }\n\n  return rule.apply(resource, criteria.params ?? {});\n};\n\nfunction authorizeResult<TResourceType extends string, TResource>(\n  criteria: PermissionCriteria<PermissionCondition<TResourceType>>,\n  resource: TResource | undefined,\n  getRule: (name: string) => PermissionRule<TResource, unknown, TResourceType>,\n) {\n  return applyConditions(criteria, resource, getRule)\n    ? AuthorizeResult.ALLOW\n    : AuthorizeResult.DENY;\n}\n\n/**\n * Takes some permission conditions and returns a definitive authorization result\n * on the resource to which they apply.\n *\n * @public\n */\nexport function createConditionAuthorizer<TResource>(\n  permissionRuleset: PermissionRuleset<TResource>,\n): (decision: PolicyDecision, resource: TResource | undefined) => boolean;\n/**\n * @public\n * @deprecated Use the version of `createConditionAuthorizer` that accepts a `PermissionRuleset` instead.\n */\nexport function createConditionAuthorizer<TResource, TQuery>(\n  rules: PermissionRule<TResource, TQuery, string>[],\n): (decision: PolicyDecision, resource: TResource | undefined) => boolean;\nexport function createConditionAuthorizer<TResource, TQuery>(\n  rules:\n    | PermissionRule<TResource, TQuery, string>[]\n    | PermissionRuleset<TResource>,\n): (decision: PolicyDecision, resource: TResource | undefined) => boolean {\n  const getRule =\n    'getRuleByName' in rules\n      ? (n: string) => rules.getRuleByName(n)\n      : createGetRule(rules);\n\n  return (\n    decision: PolicyDecision,\n    resource: TResource | undefined,\n  ): boolean => {\n    if (decision.result === AuthorizeResult.CONDITIONAL) {\n      return applyConditions(decision.conditions, resource, getRule);\n    }\n\n    return decision.result === AuthorizeResult.ALLOW;\n  };\n}\n\n/**\n * Options for creating a permission integration router specific\n * for a particular resource type.\n *\n * @public\n * @deprecated {@link createPermissionIntegrationRouter} is deprecated\n */\nexport type CreatePermissionIntegrationRouterResourceOptions<\n  TResourceType extends string,\n  TResource,\n> = {\n  resourceType: TResourceType;\n  permissions?: Array<Permission>;\n  // Do not infer value of TResourceType from supplied rules.\n  // instead only consider the resourceType parameter, and\n  // consider any rules whose resource type does not match\n  // to be an error.\n  rules: PermissionRule<TResource, any, NoInfer<TResourceType>>[];\n  getResources?: (\n    resourceRefs: string[],\n  ) => Promise<Array<TResource | undefined>>;\n};\n\n/**\n * Options for creating a permission integration router exposing\n * permissions and rules from multiple resource types.\n *\n * @public\n * @deprecated {@link createPermissionIntegrationRouter} is deprecated\n */\nexport type PermissionIntegrationRouterOptions<\n  TResourceType1 extends string = string,\n  TResource1 = any,\n  TResourceType2 extends string = string,\n  TResource2 = any,\n  TResourceType3 extends string = string,\n  TResource3 = any,\n> = {\n  resources: Readonly<\n    | [\n        CreatePermissionIntegrationRouterResourceOptions<\n          TResourceType1,\n          TResource1\n        >,\n      ]\n    | [\n        CreatePermissionIntegrationRouterResourceOptions<\n          TResourceType1,\n          TResource1\n        >,\n        CreatePermissionIntegrationRouterResourceOptions<\n          TResourceType2,\n          TResource2\n        >,\n      ]\n    | [\n        CreatePermissionIntegrationRouterResourceOptions<\n          TResourceType1,\n          TResource1\n        >,\n        CreatePermissionIntegrationRouterResourceOptions<\n          TResourceType2,\n          TResource2\n        >,\n        CreatePermissionIntegrationRouterResourceOptions<\n          TResourceType3,\n          TResource3\n        >,\n      ]\n  >;\n};\n\nclass PermissionIntegrationMetadataStore {\n  readonly #rulesByTypeByName = new Map<\n    string,\n    Map<string, PermissionRule<unknown, unknown, string>>\n  >();\n  readonly #permissionsByName = new Map<string, Permission>();\n  readonly #resourcesByType = new Map<\n    string,\n    CreatePermissionIntegrationRouterResourceOptions<string, unknown>\n  >();\n  readonly #serializedRules = new Array<MetadataResponseSerializedRule>();\n\n  getSerializedMetadata(): MetadataResponse {\n    return {\n      permissions: Array.from(this.#permissionsByName.values()),\n      rules: this.#serializedRules,\n    };\n  }\n\n  hasResourceType(type: string): boolean {\n    return this.#resourcesByType.has(type);\n  }\n\n  async getResources(\n    resourceType: string,\n    refs: string[],\n  ): Promise<Record<string, unknown>> {\n    const resource = this.#resourcesByType.get(resourceType);\n    if (!resource?.getResources) {\n      throw new NotImplementedError(\n        `This plugin does not expose any permission rule or can't evaluate the conditions request for ${resourceType}`,\n      );\n    }\n\n    const uniqueRefs = Array.from(new Set(refs));\n    const resources = await resource.getResources(uniqueRefs);\n    return Object.fromEntries(\n      uniqueRefs.map((ref, index) => [ref, resources[index]]),\n    );\n  }\n\n  getRuleMapper(resourceType: string) {\n    return (name: string): PermissionRule<unknown, unknown, string> => {\n      const rule = this.#rulesByTypeByName.get(resourceType)?.get(name);\n      if (!rule) {\n        throw new Error(\n          `Permission rule '${name}' does not exist for resource type '${resourceType}'`,\n        );\n      }\n      return rule;\n    };\n  }\n\n  addPermissions(permissions: Permission[]) {\n    for (const permission of permissions) {\n      // Permission naming conflicts are silently ignored\n      this.#permissionsByName.set(permission.name, permission);\n    }\n  }\n\n  addPermissionRules(rules: PermissionRule<unknown, unknown, string>[]) {\n    for (const rule of rules) {\n      const rulesByName =\n        this.#rulesByTypeByName.get(rule.resourceType) ?? new Map();\n      this.#rulesByTypeByName.set(rule.resourceType, rulesByName);\n\n      if (rulesByName.has(rule.name)) {\n        throw new Error(\n          `Refused to add permission rule for type '${rule.resourceType}' with name '${rule.name}' because it already exists`,\n        );\n      }\n      rulesByName.set(rule.name, rule);\n\n      this.#serializedRules.push({\n        name: rule.name,\n        description: rule.description,\n        resourceType: rule.resourceType,\n        paramsSchema: zodToJsonSchema(rule.paramsSchema ?? z.object({})),\n      });\n    }\n  }\n\n  addResourceType(\n    resource: CreatePermissionIntegrationRouterResourceOptions<string, unknown>,\n  ) {\n    const { resourceType } = resource;\n\n    if (this.#resourcesByType.has(resourceType)) {\n      throw new Error(\n        `Refused to add permission resource with type '${resourceType}' because it already exists`,\n      );\n    }\n    this.#resourcesByType.set(resourceType, resource);\n\n    if (resource.rules) {\n      this.addPermissionRules(resource.rules);\n    }\n\n    if (resource.permissions) {\n      this.addPermissions(resource.permissions);\n    }\n  }\n}\n\n/**\n * Create an express Router which provides an authorization route to allow\n * integration between the permission backend and other Backstage backend\n * plugins. Plugin owners that wish to support conditional authorization for\n * their resources should add the router created by this function to their\n * express app inside their `createRouter` implementation.\n *\n * In case the `permissions` option is provided, the router also\n * provides a route that exposes permissions and routes of a plugin.\n *\n * In case resources is provided, the routes can handle permissions\n * for multiple resource types.\n *\n * @remarks\n *\n * To make this concrete, we can use the Backstage software catalog as an\n * example. The catalog has conditional rules around access to specific\n * _entities_ in the catalog. The _type_ of resource is captured here as\n * `resourceType`, a string identifier (`catalog-entity` in this example) that\n * can be provided with permission definitions. This is merely a _type_ to\n * verify that conditions in an authorization policy are constructed correctly,\n * not a reference to a specific resource.\n *\n * The `rules` parameter is an array of {@link PermissionRule}s that introduce\n * conditional filtering logic for resources; for the catalog, these are things\n * like `isEntityOwner` or `hasAnnotation`. Rules describe how to filter a list\n * of resources, and the `conditions` returned allow these rules to be applied\n * with specific parameters (such as 'group:default/team-a', or\n * 'backstage.io/edit-url').\n *\n * The `getResources` argument should load resources based on a reference\n * identifier. For the catalog, this is an\n * {@link @backstage/catalog-model#EntityRef}. For other plugins, this can be\n * any serialized format. This is used to construct the\n * `createPermissionIntegrationRouter`, a function to add an authorization route\n * to your backend plugin. This function will be called by the\n * `permission-backend` when authorization conditions relating to this plugin\n * need to be evaluated.\n *\n * @public\n * @deprecated use `PermissionRegistryService` instead, see {@link https://backstage.io/docs/backend-system/core-services/permissions-registry#migrating-from-createpermissionintegrationrouter | the migration section in the service docs} for more details.\n */\nexport function createPermissionIntegrationRouter<\n  TResourceType1 extends string,\n  TResource1,\n  TResourceType2 extends string,\n  TResource2,\n  TResourceType3 extends string,\n  TResource3,\n>(\n  options?:\n    | { permissions: Array<Permission> }\n    | CreatePermissionIntegrationRouterResourceOptions<\n        TResourceType1,\n        TResource1\n      >\n    | PermissionIntegrationRouterOptions<\n        TResourceType1,\n        TResource1,\n        TResourceType2,\n        TResource2,\n        TResourceType3,\n        TResource3\n      >,\n): express.Router & {\n  addPermissions(permissions: Permission[]): void;\n  addPermissionRules(rules: PermissionRule<unknown, unknown, string>[]): void;\n  addResourceType<const TResourceType extends string, TResource>(\n    resource: CreatePermissionIntegrationRouterResourceOptions<\n      TResourceType,\n      TResource\n    >,\n  ): void;\n  getPermissionRuleset<TResource, TQuery, TResourceType extends string>(\n    resourceRef: PermissionResourceRef<TResource, TQuery, TResourceType>,\n  ): PermissionRuleset<TResource, TQuery, TResourceType>;\n} {\n  const store = new PermissionIntegrationMetadataStore();\n\n  if (options) {\n    if ('resources' in options) {\n      // Not technically allowed by types, but it's historically been covered by tests\n      if ('permissions' in options) {\n        store.addPermissions(options.permissions as Permission[]);\n      }\n\n      for (const resource of options.resources) {\n        store.addResourceType(resource);\n      }\n    } else if ('resourceType' in options) {\n      store.addResourceType(options);\n    } else {\n      store.addPermissions(options.permissions);\n    }\n  }\n\n  const router = Router();\n\n  router.use('/.well-known/backstage/permissions/', express.json());\n\n  router.get('/.well-known/backstage/permissions/metadata', (_, res) => {\n    res.json(store.getSerializedMetadata());\n  });\n\n  router.post(\n    '/.well-known/backstage/permissions/apply-conditions',\n    async (req, res: Response<ApplyConditionsResponse>) => {\n      const parseResult = applyConditionsRequestSchema.safeParse(req.body);\n      if (!parseResult.success) {\n        throw new InputError(parseResult.error.toString());\n      }\n\n      const { items: requests } = parseResult.data;\n\n      const invalidResourceTypes = requests.filter(\n        i => !store.hasResourceType(i.resourceType),\n      );\n      if (invalidResourceTypes.length) {\n        throw new InputError(\n          `Unexpected resource types: ${invalidResourceTypes\n            .map(i => i.resourceType)\n            .join(', ')}.`,\n        );\n      }\n\n      const resourcesByType: Record<string, Record<string, any>> = {};\n      for (const requestedType of new Set(requests.map(i => i.resourceType))) {\n        resourcesByType[requestedType] = await store.getResources(\n          requestedType,\n          requests\n            .filter(r => r.resourceType === requestedType)\n            .map(i => i.resourceRef)\n            .flat(),\n        );\n      }\n\n      res.json({\n        items: requests.map(request => ({\n          id: request.id,\n          result: Array.isArray(request.resourceRef)\n            ? request.resourceRef.map(resourceRef =>\n                authorizeResult(\n                  request.conditions,\n                  resourcesByType[request.resourceType][resourceRef],\n                  store.getRuleMapper(request.resourceType),\n                ),\n              )\n            : authorizeResult(\n                request.conditions,\n                resourcesByType[request.resourceType][request.resourceRef],\n                store.getRuleMapper(request.resourceType),\n              ),\n        })),\n      });\n    },\n  );\n\n  return Object.assign(router, {\n    addPermissions(permissions: Permission[]) {\n      store.addPermissions(permissions);\n    },\n    addPermissionRules(rules: PermissionRule<unknown, unknown, string>[]) {\n      store.addPermissionRules(rules);\n    },\n    addResourceType<const TResourceType extends string, TResource>(\n      resource: CreatePermissionIntegrationRouterResourceOptions<\n        TResourceType,\n        TResource\n      >,\n    ) {\n      store.addResourceType(resource);\n    },\n    getPermissionRuleset<TResource, TQuery, TResourceType extends string>(\n      resourceRef: PermissionResourceRef<TResource, TQuery, TResourceType>,\n    ): PermissionRuleset<TResource, TQuery, TResourceType> {\n      return {\n        getRuleByName: store.getRuleMapper(resourceRef.resourceType),\n      } as PermissionRuleset<TResource, TQuery, TResourceType>;\n    },\n  });\n}\n"],"names":["z","isAndCriteria","isOrCriteria","isNotCriteria","InputError","AuthorizeResult","createGetRule","NotImplementedError","zodToJsonSchema","Router","express"],"mappings":"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"}