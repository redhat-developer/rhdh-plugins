{"version":3,"file":"SubRouteRef.esm.js","sources":["../../src/routing/SubRouteRef.ts"],"sourcesContent":["/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  AnyParams,\n  OptionalParams,\n  ParamKeys,\n  RouteRef,\n  routeRefType,\n  SubRouteRef,\n} from './types';\n\n// Should match the pattern in react-router\nconst PARAM_PATTERN = /^\\w+$/;\n\n/**\n * @internal\n */\nexport class SubRouteRefImpl<Params extends AnyParams>\n  implements SubRouteRef<Params>\n{\n  // The marker is used for type checking while the symbol is used at runtime.\n  declare $$routeRefType: 'sub';\n  readonly [routeRefType] = 'sub';\n\n  constructor(\n    private readonly id: string,\n    readonly path: string,\n    readonly parent: RouteRef,\n    readonly params: ParamKeys<Params>,\n  ) {}\n\n  toString() {\n    return `routeRef{type=sub,id=${this.id}}`;\n  }\n}\n\n/**\n * Used in {@link PathParams} type declaration.\n * @public\n * @deprecated this type is deprecated and will be removed in the future\n */\nexport type ParamPart<S extends string> = S extends `:${infer Param}`\n  ? Param\n  : never;\n\n/**\n * Used in {@link PathParams} type declaration.\n * @public\n * @deprecated this type is deprecated and will be removed in the future\n */\nexport type ParamNames<S extends string> =\n  S extends `${infer Part}/${infer Rest}`\n    ? ParamPart<Part> | ParamNames<Rest>\n    : ParamPart<S>;\n/**\n * This utility type helps us infer a Param object type from a string path\n * For example, `/foo/:bar/:baz` inferred to `{ bar: string, baz: string }`\n * @public\n * @deprecated this type is deprecated and will be removed in the future\n */\nexport type PathParams<S extends string> = { [name in ParamNames<S>]: string };\n\n/**\n * Merges a param object type with an optional params type into a params object.\n * @public\n * @deprecated this type is deprecated and will be removed in the future\n */\nexport type MergeParams<\n  P1 extends { [param in string]: string },\n  P2 extends AnyParams,\n> = (P1[keyof P1] extends never ? {} : P1) & (P2 extends undefined ? {} : P2);\n\n/**\n * Creates a SubRouteRef type given the desired parameters and parent route parameters.\n * The parameters types are merged together while ensuring that there is no overlap between the two.\n *\n * @public\n * @deprecated this type is deprecated and will be removed in the future\n */\nexport type MakeSubRouteRef<\n  Params extends { [param in string]: string },\n  ParentParams extends AnyParams,\n> = keyof Params & keyof ParentParams extends never\n  ? SubRouteRef<OptionalParams<MergeParams<Params, ParentParams>>>\n  : never;\n\n/**\n * Create a {@link SubRouteRef} from a route descriptor.\n *\n * @param config - Description of the route reference to be created.\n * @public\n */\nexport function createSubRouteRef<\n  Path extends string,\n  ParentParams extends AnyParams = never,\n>(config: {\n  id: string;\n  path: Path;\n  parent: RouteRef<ParentParams>;\n}): MakeSubRouteRef<PathParams<Path>, ParentParams> {\n  const { id, path, parent } = config;\n  type Params = PathParams<Path>;\n\n  // Collect runtime parameters from the path, e.g. ['bar', 'baz'] from '/foo/:bar/:baz'\n  const pathParams = path\n    .split('/')\n    .filter(p => p.startsWith(':'))\n    .map(p => p.substring(1));\n  const params = [...parent.params, ...pathParams];\n\n  if (parent.params.some(p => pathParams.includes(p as string))) {\n    throw new Error(\n      'SubRouteRef may not have params that overlap with its parent',\n    );\n  }\n  if (!path.startsWith('/')) {\n    throw new Error(`SubRouteRef path must start with '/', got '${path}'`);\n  }\n  if (path.endsWith('/')) {\n    throw new Error(`SubRouteRef path must not end with '/', got '${path}'`);\n  }\n  for (const param of pathParams) {\n    if (!PARAM_PATTERN.test(param)) {\n      throw new Error(`SubRouteRef path has invalid param, got '${param}'`);\n    }\n  }\n\n  // We ensure that the type of the return type is sane here\n  const subRouteRef = new SubRouteRefImpl(\n    id,\n    path,\n    parent,\n    params as ParamKeys<MergeParams<Params, ParentParams>>,\n  ) as SubRouteRef<OptionalParams<MergeParams<Params, ParentParams>>>;\n\n  // But skip type checking of the return value itself, because the conditional\n  // type checking of the parent parameter overlap is tricky to express.\n  return subRouteRef as any;\n}\n"],"names":[],"mappings":";;AA0BA,MAAM,aAAA,GAAgB,OAAA;AAKf,MAAM,eAAA,CAEb;AAAA,EAKE,WAAA,CACmB,EAAA,EACR,IAAA,EACA,MAAA,EACA,MAAA,EACT;AAJiB,IAAA,IAAA,CAAA,EAAA,GAAA,EAAA;AACR,IAAA,IAAA,CAAA,IAAA,GAAA,IAAA;AACA,IAAA,IAAA,CAAA,MAAA,GAAA,MAAA;AACA,IAAA,IAAA,CAAA,MAAA,GAAA,MAAA;AAAA,EACR;AAAA,EAPH,CAAU,YAAY,IAAI,KAAA;AAAA,EAS1B,QAAA,GAAW;AACT,IAAA,OAAO,CAAA,qBAAA,EAAwB,KAAK,EAAE,CAAA,CAAA,CAAA;AAAA,EACxC;AACF;AA0DO,SAAS,kBAGd,MAAA,EAIkD;AAClD,EAAA,MAAM,EAAE,EAAA,EAAI,IAAA,EAAM,MAAA,EAAO,GAAI,MAAA;AAI7B,EAAA,MAAM,aAAa,IAAA,CAChB,KAAA,CAAM,GAAG,CAAA,CACT,OAAO,CAAA,CAAA,KAAK,CAAA,CAAE,UAAA,CAAW,GAAG,CAAC,CAAA,CAC7B,GAAA,CAAI,OAAK,CAAA,CAAE,SAAA,CAAU,CAAC,CAAC,CAAA;AAC1B,EAAA,MAAM,SAAS,CAAC,GAAG,MAAA,CAAO,MAAA,EAAQ,GAAG,UAAU,CAAA;AAE/C,EAAA,IAAI,MAAA,CAAO,OAAO,IAAA,CAAK,CAAA,CAAA,KAAK,WAAW,QAAA,CAAS,CAAW,CAAC,CAAA,EAAG;AAC7D,IAAA,MAAM,IAAI,KAAA;AAAA,MACR;AAAA,KACF;AAAA,EACF;AACA,EAAA,IAAI,CAAC,IAAA,CAAK,UAAA,CAAW,GAAG,CAAA,EAAG;AACzB,IAAA,MAAM,IAAI,KAAA,CAAM,CAAA,2CAAA,EAA8C,IAAI,CAAA,CAAA,CAAG,CAAA;AAAA,EACvE;AACA,EAAA,IAAI,IAAA,CAAK,QAAA,CAAS,GAAG,CAAA,EAAG;AACtB,IAAA,MAAM,IAAI,KAAA,CAAM,CAAA,6CAAA,EAAgD,IAAI,CAAA,CAAA,CAAG,CAAA;AAAA,EACzE;AACA,EAAA,KAAA,MAAW,SAAS,UAAA,EAAY;AAC9B,IAAA,IAAI,CAAC,aAAA,CAAc,IAAA,CAAK,KAAK,CAAA,EAAG;AAC9B,MAAA,MAAM,IAAI,KAAA,CAAM,CAAA,yCAAA,EAA4C,KAAK,CAAA,CAAA,CAAG,CAAA;AAAA,IACtE;AAAA,EACF;AAGA,EAAA,MAAM,cAAc,IAAI,eAAA;AAAA,IACtB,EAAA;AAAA,IACA,IAAA;AAAA,IACA,MAAA;AAAA,IACA;AAAA,GACF;AAIA,EAAA,OAAO,WAAA;AACT;;;;"}