'use strict';

var errors = require('@backstage/errors');
var pluginScaffolderNode = require('@backstage/plugin-scaffolder-node');
var bitbucket_examples = require('./bitbucket.examples.cjs.js');

const createBitbucketCloudRepository = async (opts) => {
  const {
    workspace,
    project,
    repo,
    description,
    repoVisibility,
    mainBranch,
    authorization,
    apiBaseUrl
  } = opts;
  const options = {
    method: "POST",
    body: JSON.stringify({
      scm: "git",
      description,
      is_private: repoVisibility === "private",
      project: { key: project }
    }),
    headers: {
      Authorization: authorization,
      "Content-Type": "application/json"
    }
  };
  let response;
  try {
    response = await fetch(
      `${apiBaseUrl}/repositories/${workspace}/${repo}`,
      options
    );
  } catch (e) {
    throw new Error(`Unable to create repository, ${e}`);
  }
  if (response.status !== 200) {
    throw new Error(
      `Unable to create repository, ${response.status} ${response.statusText}, ${await response.text()}`
    );
  }
  const r = await response.json();
  let remoteUrl = "";
  for (const link of r.links.clone) {
    if (link.name === "https") {
      remoteUrl = link.href;
    }
  }
  const repoContentsUrl = `${r.links.html.href}/src/${mainBranch}`;
  return { remoteUrl, repoContentsUrl };
};
const createBitbucketServerRepository = async (opts) => {
  const {
    project,
    repo,
    description,
    authorization,
    repoVisibility,
    apiBaseUrl
  } = opts;
  let response;
  const options = {
    method: "POST",
    body: JSON.stringify({
      name: repo,
      description,
      public: repoVisibility === "public"
    }),
    headers: {
      Authorization: authorization,
      "Content-Type": "application/json"
    }
  };
  try {
    response = await fetch(`${apiBaseUrl}/projects/${project}/repos`, options);
  } catch (e) {
    throw new Error(`Unable to create repository, ${e}`);
  }
  if (response.status !== 201) {
    throw new Error(
      `Unable to create repository, ${response.status} ${response.statusText}, ${await response.text()}`
    );
  }
  const r = await response.json();
  let remoteUrl = "";
  for (const link of r.links.clone) {
    if (link.name === "http") {
      remoteUrl = link.href;
    }
  }
  const repoContentsUrl = `${r.links.self[0].href}`;
  return { remoteUrl, repoContentsUrl };
};
const getAuthorizationHeader = (config) => {
  if (config.username && config.appPassword) {
    const buffer = Buffer.from(
      `${config.username}:${config.appPassword}`,
      "utf8"
    );
    return `Basic ${buffer.toString("base64")}`;
  }
  if (config.token) {
    return `Bearer ${config.token}`;
  }
  throw new Error(
    `Authorization has not been provided for Bitbucket. Please add either username + appPassword or token to the Integrations config`
  );
};
const performEnableLFS = async (opts) => {
  const { authorization, host, project, repo } = opts;
  const options = {
    method: "PUT",
    headers: {
      Authorization: authorization
    }
  };
  const { ok, status, statusText } = await fetch(
    `https://${host}/rest/git-lfs/admin/projects/${project}/repos/${repo}/enabled`,
    options
  );
  if (!ok)
    throw new Error(
      `Failed to enable LFS in the repository, ${status}: ${statusText}`
    );
};
function createPublishBitbucketAction(options) {
  const { integrations, config } = options;
  return pluginScaffolderNode.createTemplateAction({
    id: "publish:bitbucket",
    description: "Initializes a git repository of the content in the workspace, and publishes it to Bitbucket.",
    examples: bitbucket_examples.examples,
    schema: {
      input: {
        repoUrl: (z) => z.string({
          description: "Repository Location"
        }),
        description: (z) => z.string({
          description: "Repository Description"
        }).optional(),
        repoVisibility: (z) => z.enum(["private", "public"], {
          description: "Repository Visibility"
        }).optional(),
        defaultBranch: (z) => z.string({
          description: `Sets the default branch on the repository. The default value is 'master'`
        }).optional(),
        sourcePath: (z) => z.string({
          description: "Path within the workspace that will be used as the repository root. If omitted, the entire workspace will be published as the repository."
        }).optional(),
        enableLFS: (z) => z.boolean({
          description: "Enable LFS for the repository. Only available for hosted Bitbucket."
        }).optional(),
        token: (z) => z.string({
          description: "The token to use for authorization to BitBucket"
        }).optional(),
        gitCommitMessage: (z) => z.string({
          description: `Sets the commit message on the repository. The default value is 'initial commit'`
        }).optional(),
        gitAuthorName: (z) => z.string({
          description: `Sets the default author name for the commit. The default value is 'Scaffolder'`
        }).optional(),
        gitAuthorEmail: (z) => z.string({
          description: `Sets the default author email for the commit.`
        }).optional(),
        signCommit: (z) => z.boolean({
          description: "Sign commit with configured PGP private key"
        }).optional()
      },
      output: {
        remoteUrl: (z) => z.string({
          description: "A URL to the repository with the provider"
        }).optional(),
        repoContentsUrl: (z) => z.string({
          description: "A URL to the root of the repository"
        }).optional(),
        commitHash: (z) => z.string({
          description: "The git commit hash of the initial commit"
        }).optional()
      }
    },
    async handler(ctx) {
      ctx.logger.warn(
        `[Deprecated] Please migrate the use of action "publish:bitbucket" to "publish:bitbucketCloud" or "publish:bitbucketServer".`
      );
      const {
        repoUrl,
        description,
        defaultBranch = "master",
        repoVisibility = "private",
        enableLFS = false,
        gitCommitMessage = "initial commit",
        gitAuthorName,
        gitAuthorEmail,
        signCommit
      } = ctx.input;
      const { workspace, project, repo, host } = pluginScaffolderNode.parseRepoUrl(
        repoUrl,
        integrations
      );
      if (host === "bitbucket.org") {
        if (!workspace) {
          throw new errors.InputError(
            `Invalid URL provider was included in the repo URL to create ${ctx.input.repoUrl}, missing workspace`
          );
        }
      }
      if (!project) {
        throw new errors.InputError(
          `Invalid URL provider was included in the repo URL to create ${ctx.input.repoUrl}, missing project`
        );
      }
      const integrationConfig = integrations.bitbucket.byHost(host);
      if (!integrationConfig) {
        throw new errors.InputError(
          `No matching integration configuration for host ${host}, please check your integrations config`
        );
      }
      const authorization = getAuthorizationHeader(
        ctx.input.token ? {
          host: integrationConfig.config.host,
          apiBaseUrl: integrationConfig.config.apiBaseUrl,
          token: ctx.input.token
        } : integrationConfig.config
      );
      const apiBaseUrl = integrationConfig.config.apiBaseUrl;
      const createMethod = host === "bitbucket.org" ? createBitbucketCloudRepository : createBitbucketServerRepository;
      const { remoteUrl, repoContentsUrl } = await ctx.checkpoint({
        key: `create.repo.${host}.${repo}`,
        fn: async () => createMethod({
          authorization,
          workspace: workspace || "",
          project,
          repo,
          repoVisibility,
          mainBranch: defaultBranch,
          description,
          apiBaseUrl
        })
      });
      const gitAuthorInfo = {
        name: gitAuthorName ? gitAuthorName : config.getOptionalString("scaffolder.defaultAuthor.name"),
        email: gitAuthorEmail ? gitAuthorEmail : config.getOptionalString("scaffolder.defaultAuthor.email")
      };
      const signingKey = integrationConfig.config.commitSigningKey ?? config.getOptionalString("scaffolder.defaultCommitSigningKey");
      if (signCommit && !signingKey) {
        throw new Error(
          "Signing commits is enabled but no signing key is provided in the configuration"
        );
      }
      let auth;
      if (ctx.input.token) {
        auth = {
          username: "x-token-auth",
          password: ctx.input.token
        };
      } else {
        auth = {
          username: integrationConfig.config.username ? integrationConfig.config.username : "x-token-auth",
          password: integrationConfig.config.appPassword ? integrationConfig.config.appPassword : integrationConfig.config.token ?? ""
        };
      }
      const commitHash = await ctx.checkpoint({
        key: `init.repo.and.push${host}.${repo}`,
        fn: async () => {
          const commitResult = await pluginScaffolderNode.initRepoAndPush({
            dir: pluginScaffolderNode.getRepoSourceDirectory(
              ctx.workspacePath,
              ctx.input.sourcePath
            ),
            remoteUrl,
            auth,
            defaultBranch,
            logger: ctx.logger,
            commitMessage: gitCommitMessage ? gitCommitMessage : config.getOptionalString("scaffolder.defaultCommitMessage"),
            gitAuthorInfo,
            signingKey: signCommit ? signingKey : void 0
          });
          return commitResult?.commitHash;
        }
      });
      if (enableLFS && host !== "bitbucket.org") {
        await performEnableLFS({ authorization, host, project, repo });
      }
      ctx.output("commitHash", commitHash);
      ctx.output("remoteUrl", remoteUrl);
      ctx.output("repoContentsUrl", repoContentsUrl);
    }
  });
}

exports.createPublishBitbucketAction = createPublishBitbucketAction;
//# sourceMappingURL=bitbucket.cjs.js.map
