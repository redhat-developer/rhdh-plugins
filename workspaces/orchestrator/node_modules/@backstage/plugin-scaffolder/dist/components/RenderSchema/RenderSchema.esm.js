import { jsx, jsxs, Fragment } from 'react/jsx-runtime';
import { MarkdownContent } from '@backstage/core-components';
import { useTranslationRef } from '@backstage/core-plugin-api/alpha';
import Box from '@material-ui/core/Box';
import Chip from '@material-ui/core/Chip';
import Collapse from '@material-ui/core/Collapse';
import IconButton from '@material-ui/core/IconButton';
import List from '@material-ui/core/List';
import ListItem from '@material-ui/core/ListItem';
import Paper from '@material-ui/core/Paper';
import Table from '@material-ui/core/Table';
import TableBody from '@material-ui/core/TableBody';
import TableCell from '@material-ui/core/TableCell';
import TableContainer from '@material-ui/core/TableContainer';
import TableHead from '@material-ui/core/TableHead';
import TableRow from '@material-ui/core/TableRow';
import Tooltip from '@material-ui/core/Tooltip';
import Typography from '@material-ui/core/Typography';
import { makeStyles } from '@material-ui/core/styles';
import ExpandLessIcon from '@material-ui/icons/ExpandLess';
import ExpandMoreIcon from '@material-ui/icons/ExpandMore';
import WrapText from '@material-ui/icons/WrapText';
import classNames from 'classnames';
import { cloneElement, Fragment as Fragment$1 } from 'react';
import { scaffolderTranslationRef } from '../../translation.esm.js';

const compositeSchemaProperties = ["allOf", "anyOf", "not", "oneOf"];
const getTypes = (schema) => {
  if (!schema.type) {
    if (Object.getOwnPropertyNames(schema).some(
      (p) => compositeSchemaProperties.includes(p)
    )) {
      return void 0;
    }
    return ["unknown"];
  }
  if (schema.type !== "array") {
    return [schema.type].flat();
  }
  return [
    `${schema.type}(${schema.items?.type ?? "unknown"})`
  ];
};
const getSubschemas = (schema) => {
  if (typeof schema === "boolean") {
    return {};
  }
  const base = {};
  const subschemas = {};
  for (const [key, value] of Object.entries(schema)) {
    if (compositeSchemaProperties.includes(key)) {
      let v;
      if (Array.isArray(value)) {
        if (!value.length) {
          continue;
        }
        v = value;
      } else if (value) {
        v = [value];
      } else {
        continue;
      }
      subschemas[key] = v;
    } else {
      base[key] = value;
    }
  }
  if (!(base?.type === "object" || "properties" in base)) {
    return subschemas;
  }
  return Object.fromEntries(
    Object.entries(subschemas).map(([key, sub]) => {
      const mergedSubschema = sub.map((alt) => {
        if (typeof alt !== "boolean" && alt.required) {
          const properties = {};
          if (schema.properties) {
            for (const k of alt.required) {
              if (k in schema.properties) {
                properties[k] = schema.properties[k];
              }
            }
          }
          Object.assign(properties, alt.properties);
          return {
            ...base,
            ...alt,
            properties
          };
        }
        return alt;
      });
      return [key, mergedSubschema];
    })
  );
};
const useColumnStyles = makeStyles({
  description: {
    width: "40%",
    whiteSpace: "normal",
    wordWrap: "break-word",
    "&.MuiTableCell-root": {
      whiteSpace: "normal"
    }
  },
  standard: {
    whiteSpace: "normal"
  }
});
const generateId = (element, context) => {
  return element.key ? `${context.parentId}.${element.key}` : context.parentId;
};
const nameColumn = {
  key: "name",
  title: (t) => t("renderSchema.tableCell.name"),
  render: (element, context) => {
    return /* @__PURE__ */ jsx(
      "div",
      {
        className: classNames(context.classes.code, {
          [context.classes.codeRequired]: element.required
        }),
        children: element.key
      }
    );
  }
};
const titleColumn = {
  key: "title",
  title: (t) => t("renderSchema.tableCell.title"),
  render: (element) => /* @__PURE__ */ jsx(MarkdownContent, { content: element.schema.title ?? "" })
};
const descriptionColumn = {
  key: "description",
  title: (t) => t("renderSchema.tableCell.description"),
  render: (element) => /* @__PURE__ */ jsx(
    MarkdownContent,
    {
      content: element.schema.description ?? ""
    }
  ),
  className: "description"
};
const enumFrom = (schema) => {
  if (schema.type === "array") {
    if (schema.items && typeof schema.items !== "boolean") {
      if (Array.isArray(schema.items)) {
        const itemsWithEnum = schema.items.filter((e) => typeof e === "object" && "enum" in e).map((e) => e);
        if (itemsWithEnum.length) {
          return itemsWithEnum[0].enum;
        }
      } else {
        return schema.items?.enum;
      }
    }
    return void 0;
  }
  return schema.enum;
};
const inspectSchema = (schema) => {
  if (typeof schema === "boolean") {
    return { canSubschema: false, hasEnum: false };
  }
  return {
    canSubschema: Object.getOwnPropertyNames(schema).some(
      (p) => compositeSchemaProperties.includes(p)
    ) || getTypes(schema).some((t) => t.includes("object")),
    hasEnum: !!enumFrom(schema)
  };
};
const typeColumn = {
  key: "type",
  title: (t) => t("renderSchema.tableCell.type"),
  render: (element, context) => {
    if (typeof element.schema === "boolean") {
      return /* @__PURE__ */ jsx(Typography, { children: element.schema ? "any" : "none" });
    }
    const types = getTypes(element.schema);
    const [isExpanded, setIsExpanded] = context.expanded;
    const id = generateId(element, context);
    const info = inspectSchema(element.schema);
    return /* @__PURE__ */ jsx(Fragment, { children: types?.map(
      (type, index) => info.canSubschema || info.hasEnum && index === 0 ? /* @__PURE__ */ jsx(
        Chip,
        {
          "data-testid": `expand_${id}`,
          label: type,
          icon: isExpanded[id] ? /* @__PURE__ */ jsx(ExpandLessIcon, {}) : /* @__PURE__ */ jsx(ExpandMoreIcon, {}),
          variant: "outlined",
          onClick: () => setIsExpanded((prevState) => {
            return {
              ...prevState,
              [id]: !!!prevState[id]
            };
          })
        },
        type
      ) : /* @__PURE__ */ jsx(Chip, { label: type, variant: "outlined" }, type)
    ) });
  }
};
const RenderEnum = ({
  e,
  classes,
  ...props
}) => {
  return /* @__PURE__ */ jsx(List, { ...props, children: e.map((v, i) => {
    let inner = /* @__PURE__ */ jsx(
      Typography,
      {
        "data-testid": `enum_el${i}`,
        className: classNames(classes.code),
        children: JSON.stringify(v)
      }
    );
    if (v !== null && ["object", "array"].includes(typeof v)) {
      inner = /* @__PURE__ */ jsxs(Fragment, { children: [
        inner,
        /* @__PURE__ */ jsx(
          Tooltip,
          {
            title: /* @__PURE__ */ jsx(
              Typography,
              {
                "data-testid": `pretty_${i}`,
                className: classNames(classes.code),
                style: { whiteSpace: "pre-wrap" },
                children: JSON.stringify(v, void 0, 2)
              }
            ),
            children: /* @__PURE__ */ jsx(IconButton, { "data-testid": `wrap-text_${i}`, children: /* @__PURE__ */ jsx(WrapText, {}) })
          }
        )
      ] });
    }
    return /* @__PURE__ */ jsx(ListItem, { children: inner }, i);
  }) });
};
const useTableStyles = makeStyles({
  schema: {
    width: "100%",
    overflowX: "hidden",
    "& table": {
      width: "100%",
      tableLayout: "fixed"
    }
  }
});
const RenderSchema = ({
  strategy,
  context,
  schema
}) => {
  const { t } = useTranslationRef(scaffolderTranslationRef);
  const tableStyles = useTableStyles();
  const columnStyles = useColumnStyles();
  const result = (() => {
    if (typeof schema === "object") {
      const subschemas = getSubschemas(schema);
      let columns;
      let elements;
      if (strategy === "root") {
        if ("type" in schema || !Object.keys(subschemas).length) {
          elements = [{ schema }];
          columns = [typeColumn];
          if (schema.description) {
            columns.unshift(descriptionColumn);
          }
          if (schema.title) {
            columns.unshift(titleColumn);
          }
        }
      } else if (schema.properties) {
        columns = [nameColumn, titleColumn, descriptionColumn, typeColumn];
        elements = Object.entries(schema.properties).map(([key, v]) => ({
          schema: v,
          key,
          required: schema.required?.includes(key)
        }));
      } else if (!Object.keys(subschemas).length) {
        return void 0;
      }
      const [isExpanded] = context.expanded;
      return /* @__PURE__ */ jsxs(Fragment, { children: [
        columns && elements && /* @__PURE__ */ jsx(TableContainer, { component: Paper, className: tableStyles.schema, children: /* @__PURE__ */ jsxs(
          Table,
          {
            "data-testid": `${strategy}_${context.parentId}`,
            size: "small",
            children: [
              /* @__PURE__ */ jsx(TableHead, { children: /* @__PURE__ */ jsx(TableRow, { children: columns.map((col, index) => /* @__PURE__ */ jsx(
                TableCell,
                {
                  className: columnStyles[col.className ?? "standard"],
                  children: col.title(t)
                },
                index
              )) }) }),
              /* @__PURE__ */ jsx(TableBody, { children: elements.map((el) => {
                const id = generateId(el, context);
                const info = inspectSchema(el.schema);
                const rows = [
                  /* @__PURE__ */ jsx(TableRow, { "data-testid": `${strategy}-row_${id}`, children: columns.map((col) => /* @__PURE__ */ jsx(
                    TableCell,
                    {
                      className: columnStyles[col.className ?? "standard"],
                      children: col.render(el, context)
                    },
                    col.key
                  )) })
                ];
                if (typeof el.schema !== "boolean" && (info.canSubschema || info.hasEnum)) {
                  let details = /* @__PURE__ */ jsxs(Box, { "data-testid": `expansion_${id}`, sx: { margin: 1 }, children: [
                    info.canSubschema && /* @__PURE__ */ jsx(
                      RenderSchema,
                      {
                        strategy: "properties",
                        context: {
                          ...context,
                          parentId: id,
                          parent: context
                        },
                        schema: el.schema.type === "array" ? el.schema.items : el.schema
                      }
                    ),
                    info.hasEnum && /* @__PURE__ */ jsxs(Fragment, { children: [
                      cloneElement(
                        context.headings[0],
                        {},
                        "Valid values:"
                      ),
                      /* @__PURE__ */ jsx(
                        RenderEnum,
                        {
                          "data-testid": `enum_${id}`,
                          e: enumFrom(el.schema),
                          classes: context.classes
                        }
                      )
                    ] })
                  ] });
                  if (getTypes(el.schema)) {
                    details = /* @__PURE__ */ jsx(
                      Collapse,
                      {
                        in: isExpanded[id],
                        timeout: "auto",
                        unmountOnExit: true,
                        children: details
                      }
                    );
                  }
                  rows.push(
                    /* @__PURE__ */ jsx(TableRow, { children: /* @__PURE__ */ jsx(
                      TableCell,
                      {
                        style: { paddingBottom: 0, paddingTop: 0 },
                        colSpan: columns.length,
                        children: details
                      }
                    ) })
                  );
                }
                return /* @__PURE__ */ jsx(Fragment$1, { children: rows }, id);
              }) })
            ]
          }
        ) }),
        Object.keys(subschemas).map((sk) => /* @__PURE__ */ jsxs(Fragment$1, { children: [
          cloneElement(context.headings[0], {}, sk),
          subschemas[sk].map((sub, index) => /* @__PURE__ */ jsx(
            RenderSchema,
            {
              strategy: typeof sub !== "boolean" && "properties" in sub ? strategy : "root",
              ...{
                context: {
                  ...context,
                  parentId: `${context.parentId}_${sk}${index}`
                },
                schema: sub
              }
            },
            index
          ))
        ] }, sk))
      ] });
    }
    return void 0;
  })();
  return result ?? /* @__PURE__ */ jsx(Typography, { children: "No schema defined" });
};

export { RenderEnum, RenderSchema };
//# sourceMappingURL=RenderSchema.esm.js.map
