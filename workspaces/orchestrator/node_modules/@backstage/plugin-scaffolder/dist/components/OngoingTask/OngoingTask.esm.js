import { jsx, jsxs, Fragment } from 'react/jsx-runtime';
import { useMemo, useState, useEffect, useCallback } from 'react';
import { Page, Header, Content, ErrorPanel } from '@backstage/core-components';
import { useParams, useNavigate } from 'react-router-dom';
import Box from '@material-ui/core/Box';
import Button from '@material-ui/core/Button';
import Paper from '@material-ui/core/Paper';
import { makeStyles } from '@material-ui/core/styles';
import { useTaskEventStream, scaffolderApiRef } from '@backstage/plugin-scaffolder-react';
import { selectedTemplateRouteRef } from '../../routes.esm.js';
import { AnalyticsContext, useRouteRef, useAnalytics, useApi } from '@backstage/core-plugin-api';
import qs from 'qs';
import { ContextMenu } from './ContextMenu.esm.js';
import { DefaultTemplateOutputs, TaskSteps, TaskLogStream } from '@backstage/plugin-scaffolder-react/alpha';
import { useAsync as useAsync$1 } from '@react-hookz/web';
import { usePermission } from '@backstage/plugin-permission-react';
import { taskCancelPermission, taskReadPermission, taskCreatePermission } from '@backstage/plugin-scaffolder-common/alpha';
import { useTranslationRef } from '@backstage/core-plugin-api/alpha';
import { scaffolderTranslationRef } from '../../translation.esm.js';
import { entityPresentationApiRef } from '@backstage/plugin-catalog-react';
import useAsync from 'react-use/esm/useAsync';
import { stringifyEntityRef } from '@backstage/catalog-model';

const useStyles = makeStyles((theme) => ({
  contentWrapper: {
    display: "flex",
    flexDirection: "column"
  },
  buttonBar: {
    display: "flex",
    flexDirection: "row",
    justifyContent: "right"
  },
  cancelButton: {
    marginRight: theme.spacing(1)
  },
  retryButton: {
    marginRight: theme.spacing(1)
  },
  logsVisibilityButton: {
    marginRight: theme.spacing(1)
  }
}));
const OngoingTask = (props) => {
  const { taskId } = useParams();
  const taskStream = useTaskEventStream(taskId);
  const { namespace, name } = taskStream.task?.spec.templateInfo?.entity?.metadata ?? {};
  return /* @__PURE__ */ jsx(
    AnalyticsContext,
    {
      attributes: {
        entityRef: name && stringifyEntityRef({
          kind: "template",
          namespace,
          name
        }),
        taskId
      },
      children: /* @__PURE__ */ jsx(Page, { themeId: "website", children: /* @__PURE__ */ jsx(OngoingTaskContent, { ...props }) })
    }
  );
};
function OngoingTaskContent(props) {
  const { taskId } = useParams();
  const templateRouteRef = useRouteRef(selectedTemplateRouteRef);
  const navigate = useNavigate();
  const analytics = useAnalytics();
  const scaffolderApi = useApi(scaffolderApiRef);
  const entityPresentationApi = useApi(entityPresentationApiRef);
  const taskStream = useTaskEventStream(taskId);
  const classes = useStyles();
  const steps = useMemo(
    () => taskStream.task?.spec.steps.map((step) => ({
      ...step,
      ...taskStream?.steps?.[step.id]
    })) ?? [],
    [taskStream]
  );
  const { t } = useTranslationRef(scaffolderTranslationRef);
  const [logsVisible, setLogVisibleState] = useState(false);
  const [buttonBarVisible, setButtonBarVisibleState] = useState(true);
  const { allowed: canCancelTask } = usePermission({
    permission: taskCancelPermission,
    resourceRef: taskId
  });
  const { allowed: canReadTask } = usePermission({
    permission: taskReadPermission,
    resourceRef: taskId
  });
  const { allowed: canCreateTask } = usePermission({
    permission: taskCreatePermission
  });
  const canStartOver = canReadTask && canCreateTask;
  useEffect(() => {
    if (taskStream.error) {
      setLogVisibleState(true);
    }
  }, [taskStream.error]);
  useEffect(() => {
    if (taskStream.completed && !taskStream.error) {
      setLogVisibleState(true);
      setButtonBarVisibleState(false);
    }
  }, [taskStream.error, taskStream.completed]);
  const { value: presentation } = useAsync(async () => {
    const templateEntityRef = taskStream.task?.spec.templateInfo?.entityRef;
    if (!templateEntityRef) {
      return void 0;
    }
    return entityPresentationApi.forEntity(templateEntityRef).promise;
  }, [entityPresentationApi, taskStream.task?.spec.templateInfo?.entityRef]);
  const activeStep = useMemo(() => {
    for (let i = steps.length - 1; i >= 0; i--) {
      if (steps[i].status !== "open") {
        return i;
      }
    }
    return 0;
  }, [steps]);
  const isRetryableTask = taskStream.task?.spec.EXPERIMENTAL_recovery?.EXPERIMENTAL_strategy === "startOver";
  const canRetry = canReadTask && canCreateTask && isRetryableTask;
  const startOver = useCallback(() => {
    const { namespace, name } = taskStream.task?.spec.templateInfo?.entity?.metadata ?? {};
    const formData = taskStream.task?.spec.parameters ?? {};
    if (!namespace || !name) {
      return;
    }
    analytics.captureEvent("click", `Task has been started over`);
    navigate({
      pathname: templateRouteRef({
        namespace,
        templateName: name
      }),
      search: `?${qs.stringify({ formData: JSON.stringify(formData) })}`
    });
  }, [
    analytics,
    navigate,
    taskStream.task?.spec.parameters,
    taskStream.task?.spec.templateInfo?.entity?.metadata,
    templateRouteRef
  ]);
  const [, { execute: triggerRetry }] = useAsync$1(async () => {
    if (taskId) {
      analytics.captureEvent("retried", "Template has been retried");
      await scaffolderApi.retry?.(taskId);
    }
  });
  const [{ status: cancelStatus }, { execute: triggerCancel }] = useAsync$1(
    async () => {
      if (taskId) {
        analytics.captureEvent("cancelled", "Template has been cancelled");
        await scaffolderApi.cancelTask(taskId);
      }
    }
  );
  const Outputs = props.TemplateOutputsComponent ?? DefaultTemplateOutputs;
  const cancelEnabled = !(taskStream.cancelled || taskStream.completed);
  const isCancelButtonDisabled = !cancelEnabled || cancelStatus !== "not-executed" || !canCancelTask;
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(
      Header,
      {
        pageTitleOverride: presentation ? t("ongoingTask.pageTitle.hasTemplateName", {
          templateName: presentation.primaryTitle
        }) : t("ongoingTask.pageTitle.noTemplateName"),
        title: /* @__PURE__ */ jsxs("div", { children: [
          t("ongoingTask.title"),
          " ",
          /* @__PURE__ */ jsx("code", { children: presentation ? presentation.primaryTitle : "" })
        ] }),
        subtitle: t("ongoingTask.subtitle", { taskId }),
        children: /* @__PURE__ */ jsx(
          ContextMenu,
          {
            cancelEnabled,
            canRetry,
            isRetryableTask,
            logsVisible,
            buttonBarVisible,
            onStartOver: startOver,
            onRetry: triggerRetry,
            onToggleLogs: setLogVisibleState,
            onToggleButtonBar: setButtonBarVisibleState,
            taskId,
            onCancel: triggerCancel,
            isCancelButtonDisabled
          }
        )
      }
    ),
    /* @__PURE__ */ jsxs(Content, { className: classes.contentWrapper, children: [
      taskStream.error ? /* @__PURE__ */ jsx(Box, { paddingBottom: 2, children: /* @__PURE__ */ jsx(
        ErrorPanel,
        {
          error: taskStream.error,
          titleFormat: "markdown",
          title: taskStream.error.message
        }
      ) }) : null,
      /* @__PURE__ */ jsx(Box, { paddingBottom: 2, children: /* @__PURE__ */ jsx(
        TaskSteps,
        {
          steps,
          activeStep,
          isComplete: taskStream.completed,
          isError: Boolean(taskStream.error)
        }
      ) }),
      /* @__PURE__ */ jsx(Outputs, { output: taskStream.output }),
      buttonBarVisible ? /* @__PURE__ */ jsx(Box, { paddingBottom: 2, children: /* @__PURE__ */ jsx(Paper, { children: /* @__PURE__ */ jsx(Box, { padding: 2, children: /* @__PURE__ */ jsxs("div", { className: classes.buttonBar, children: [
        /* @__PURE__ */ jsx(
          Button,
          {
            className: classes.cancelButton,
            disabled: !cancelEnabled || cancelStatus !== "not-executed" && !isRetryableTask || !canCancelTask,
            onClick: triggerCancel,
            "data-testid": "cancel-button",
            children: t("ongoingTask.cancelButtonTitle")
          }
        ),
        isRetryableTask && /* @__PURE__ */ jsx(
          Button,
          {
            className: classes.retryButton,
            disabled: cancelEnabled || !canRetry,
            onClick: triggerRetry,
            "data-testid": "retry-button",
            children: t("ongoingTask.retryButtonTitle")
          }
        ),
        /* @__PURE__ */ jsx(
          Button,
          {
            className: classes.logsVisibilityButton,
            color: "primary",
            variant: "outlined",
            onClick: () => setLogVisibleState(!logsVisible),
            children: logsVisible ? t("ongoingTask.hideLogsButtonTitle") : t("ongoingTask.showLogsButtonTitle")
          }
        ),
        /* @__PURE__ */ jsx(
          Button,
          {
            variant: "contained",
            color: "primary",
            disabled: cancelEnabled || !canStartOver,
            onClick: startOver,
            "data-testid": "start-over-button",
            children: t("ongoingTask.startOverButtonTitle")
          }
        )
      ] }) }) }) }) : null,
      logsVisible ? /* @__PURE__ */ jsx(Paper, { style: { height: "100%" }, children: /* @__PURE__ */ jsx(Box, { padding: 2, height: "100%", children: /* @__PURE__ */ jsx(TaskLogStream, { logs: taskStream.stepLogs }) }) }) : null
    ] })
  ] });
}

export { OngoingTask };
//# sourceMappingURL=OngoingTask.esm.js.map
