import { jsx } from 'react/jsx-runtime';
import { useState } from 'react';
import useAsync from 'react-use/esm/useAsync';
import useEffectOnce from 'react-use/esm/useEffectOnce';
import { makeValidator } from '@backstage/catalog-model';
import { useApi } from '@backstage/core-plugin-api';
import { catalogApiRef } from '@backstage/plugin-catalog-react';
import TextField from '@material-ui/core/TextField';
import Autocomplete from '@material-ui/lab/Autocomplete';
import { useTranslationRef } from '@backstage/core-plugin-api/alpha';
import { scaffolderTranslationRef } from '../../../translation.esm.js';
import { ScaffolderField } from '@backstage/plugin-scaffolder-react/alpha';
export { EntityTagsPickerSchema } from './schema.esm.js';

const EntityTagsPicker = (props) => {
  const { t } = useTranslationRef(scaffolderTranslationRef);
  const {
    formData,
    onChange,
    schema: {
      title = t("fields.entityTagsPicker.title"),
      description = t("fields.entityTagsPicker.description")
    },
    uiSchema,
    rawErrors,
    required,
    errors
  } = props;
  const catalogApi = useApi(catalogApiRef);
  const [tagOptions, setTagOptions] = useState([]);
  const [inputValue, setInputValue] = useState("");
  const [inputError, setInputError] = useState(false);
  const tagValidator = makeValidator().isValidTag;
  const kinds = uiSchema["ui:options"]?.kinds;
  const showCounts = uiSchema["ui:options"]?.showCounts;
  const helperText = uiSchema["ui:options"]?.helperText;
  const isDisabled = uiSchema?.["ui:disabled"] ?? false;
  const { loading, value: existingTags } = useAsync(async () => {
    const facet = "metadata.tags";
    const tagsRequest = { facets: [facet] };
    if (kinds) {
      tagsRequest.filter = { kind: kinds };
    }
    const { facets } = await catalogApi.getEntityFacets(tagsRequest);
    const tagFacets = Object.fromEntries(
      facets[facet].map(({ value, count }) => [value, count])
    );
    setTagOptions(
      Object.keys(tagFacets).sort(
        (a, b) => showCounts ? tagFacets[b] - tagFacets[a] : a.localeCompare(b)
      )
    );
    return tagFacets;
  });
  const setTags = (_, values) => {
    let hasError = false;
    let addDuplicate = false;
    const currentTags = formData || [];
    if (values?.length && currentTags.length < values.length) {
      const newTag = values[values.length - 1] = values[values.length - 1].toLocaleLowerCase("en-US").trim();
      hasError = !tagValidator(newTag);
      addDuplicate = currentTags.indexOf(newTag) !== -1;
    }
    setInputError(hasError);
    setInputValue(!hasError ? "" : inputValue);
    if (!hasError && !addDuplicate) {
      onChange(values || []);
    }
  };
  useEffectOnce(() => onChange(formData || []));
  return /* @__PURE__ */ jsx(
    ScaffolderField,
    {
      rawErrors,
      rawDescription: helperText ?? uiSchema["ui:description"] ?? description,
      required,
      disabled: isDisabled,
      errors,
      children: /* @__PURE__ */ jsx(
        Autocomplete,
        {
          multiple: true,
          freeSolo: true,
          filterSelectedOptions: true,
          onChange: setTags,
          disabled: isDisabled,
          value: formData || [],
          inputValue,
          loading,
          options: tagOptions,
          ChipProps: { size: "small" },
          renderOption: (option) => showCounts ? `${option} (${existingTags?.[option]})` : option,
          renderInput: (params) => /* @__PURE__ */ jsx(
            TextField,
            {
              ...params,
              label: title,
              disabled: isDisabled,
              onChange: (e) => setInputValue(e.target.value),
              error: inputError,
              FormHelperTextProps: { margin: "dense", style: { marginLeft: 0 } }
            }
          )
        }
      )
    }
  );
};

export { EntityTagsPicker };
//# sourceMappingURL=EntityTagsPicker.esm.js.map
