import { jsx } from 'react/jsx-runtime';
import { CATALOG_FILTER_EXISTS } from '@backstage/catalog-client';
import { parseEntityRef, stringifyEntityRef } from '@backstage/catalog-model';
import { useApi } from '@backstage/core-plugin-api';
import { catalogApiRef, entityPresentationApiRef, EntityDisplayName } from '@backstage/plugin-catalog-react';
import TextField from '@material-ui/core/TextField';
import Autocomplete, { createFilterOptions } from '@material-ui/lab/Autocomplete';
import { useState, useCallback, useEffect } from 'react';
import useAsync from 'react-use/esm/useAsync';
import { VirtualizedListbox } from '../VirtualizedListbox.esm.js';
import { ScaffolderField } from '@backstage/plugin-scaffolder-react/alpha';
import { useTranslationRef } from '@backstage/frontend-plugin-api';
import { scaffolderTranslationRef } from '../../../translation.esm.js';
export { MultiEntityPickerSchema } from './schema.esm.js';

const FREE_SOLO_EVENTS = [
  "blur",
  "create-option"
];
const MultiEntityPicker = (props) => {
  const { t } = useTranslationRef(scaffolderTranslationRef);
  const {
    onChange,
    schema: {
      title = t("fields.multiEntityPicker.title"),
      description = t("fields.multiEntityPicker.description")
    },
    required,
    uiSchema,
    rawErrors,
    formData,
    idSchema,
    errors
  } = props;
  const catalogFilter = buildCatalogFilter(uiSchema);
  const defaultKind = uiSchema["ui:options"]?.defaultKind;
  const defaultNamespace = uiSchema["ui:options"]?.defaultNamespace || void 0;
  const isDisabled = uiSchema?.["ui:disabled"] ?? false;
  const [noOfItemsSelected, setNoOfItemsSelected] = useState(0);
  const catalogApi = useApi(catalogApiRef);
  const entityPresentationApi = useApi(entityPresentationApiRef);
  const { value: entities, loading } = useAsync(async () => {
    const { items } = await catalogApi.getEntities(
      catalogFilter ? { filter: catalogFilter } : void 0
    );
    const entityRefToPresentation = new Map(
      await Promise.all(
        items.map(async (item) => {
          const presentation = await entityPresentationApi.forEntity(item).promise;
          return [stringifyEntityRef(item), presentation];
        })
      )
    );
    return { entities: items, entityRefToPresentation };
  });
  const allowArbitraryValues = uiSchema["ui:options"]?.allowArbitraryValues ?? true;
  const maxItems = props.schema.maxItems;
  const onSelect = useCallback(
    (_, refs, reason) => {
      const values = refs.map((ref) => {
        if (typeof ref !== "string") {
          return ref ? stringifyEntityRef(ref) : void 0;
        }
        let entityRef = ref;
        try {
          entityRef = stringifyEntityRef(
            parseEntityRef(ref, {
              defaultKind,
              defaultNamespace
            })
          );
        } catch (err) {
        }
        if (
          // If value already matches what exists in form data, allow it
          formData?.includes(ref) || // If arbitrary values are allowed and the reason is a free solo event, allow it
          allowArbitraryValues && FREE_SOLO_EVENTS.includes(reason)
        ) {
          return entityRef;
        }
        return void 0;
      }).filter((ref) => ref !== void 0);
      setNoOfItemsSelected(values.length);
      onChange(values);
    },
    [onChange, formData, defaultKind, defaultNamespace, allowArbitraryValues]
  );
  useEffect(() => {
    if (required && !allowArbitraryValues && entities?.entities?.length === 1) {
      onChange([stringifyEntityRef(entities?.entities[0])]);
    }
  }, [entities, onChange, required, allowArbitraryValues]);
  return /* @__PURE__ */ jsx(
    ScaffolderField,
    {
      rawErrors,
      rawDescription: uiSchema["ui:description"] ?? description,
      required,
      disabled: isDisabled,
      errors,
      children: /* @__PURE__ */ jsx(
        Autocomplete,
        {
          multiple: true,
          filterSelectedOptions: true,
          disabled: isDisabled || required && !allowArbitraryValues && entities?.entities?.length === 1,
          id: idSchema?.$id,
          defaultValue: formData,
          loading,
          onChange: onSelect,
          options: entities?.entities || [],
          renderOption: (option) => /* @__PURE__ */ jsx(EntityDisplayName, { entityRef: option }),
          getOptionLabel: (option) => (
            // option can be a string due to freeSolo.
            typeof option === "string" ? option : entities?.entityRefToPresentation.get(stringifyEntityRef(option))?.entityRef
          ),
          getOptionDisabled: (_options) => maxItems ? noOfItemsSelected >= maxItems : false,
          autoSelect: true,
          freeSolo: allowArbitraryValues,
          renderInput: (params) => /* @__PURE__ */ jsx(
            TextField,
            {
              ...params,
              label: title,
              disabled: isDisabled,
              margin: "dense",
              FormHelperTextProps: {
                margin: "dense",
                style: { marginLeft: 0 }
              },
              variant: "outlined",
              required,
              InputProps: {
                ...params.InputProps,
                required: formData?.length === 0 && required
              }
            }
          ),
          filterOptions: createFilterOptions({
            stringify: (option) => entities?.entityRefToPresentation.get(stringifyEntityRef(option))?.primaryTitle
          }),
          ListboxComponent: VirtualizedListbox
        }
      )
    }
  );
};
const validateMultiEntityPickerValidation = (values, validation) => {
  values.forEach((value) => {
    try {
      parseEntityRef(value);
    } catch {
      validation.addError(`${value} is not a valid entity ref`);
    }
  });
};
function convertOpsValues(value) {
  if (typeof value === "object" && value.exists) {
    return CATALOG_FILTER_EXISTS;
  }
  return value?.toString();
}
function convertSchemaFiltersToQuery(schemaFilters) {
  const query = {};
  for (const [key, value] of Object.entries(schemaFilters)) {
    if (Array.isArray(value)) {
      query[key] = value;
    } else {
      query[key] = convertOpsValues(value);
    }
  }
  return query;
}
function buildCatalogFilter(uiSchema) {
  const catalogFilter = uiSchema["ui:options"]?.catalogFilter;
  if (!catalogFilter) {
    return void 0;
  }
  if (Array.isArray(catalogFilter)) {
    return catalogFilter.map(convertSchemaFiltersToQuery);
  }
  return convertSchemaFiltersToQuery(catalogFilter);
}

export { MultiEntityPicker, validateMultiEntityPickerValidation };
//# sourceMappingURL=MultiEntityPicker.esm.js.map
