import { jsxs, Fragment, jsx } from 'react/jsx-runtime';
import { useApi } from '@backstage/core-plugin-api';
import { scmIntegrationsApiRef, scmAuthApiRef } from '@backstage/integration-react';
import { useTemplateSecrets } from '@backstage/plugin-scaffolder-react';
import Box from '@material-ui/core/Box';
import Divider from '@material-ui/core/Divider';
import Typography from '@material-ui/core/Typography';
import { useState, useMemo, useEffect, useCallback } from 'react';
import useDebounce from 'react-use/esm/useDebounce';
import { AzureRepoPicker } from './AzureRepoPicker.esm.js';
import { BitbucketRepoPicker } from './BitbucketRepoPicker.esm.js';
import { GerritRepoPicker } from './GerritRepoPicker.esm.js';
import { GiteaRepoPicker } from './GiteaRepoPicker.esm.js';
import { GithubRepoPicker } from './GithubRepoPicker.esm.js';
import { GitlabRepoPicker } from './GitlabRepoPicker.esm.js';
import { RepoUrlPickerHost } from './RepoUrlPickerHost.esm.js';
import { RepoUrlPickerRepoName } from './RepoUrlPickerRepoName.esm.js';
import { parseRepoPickerUrl, serializeRepoPickerUrl } from './utils.esm.js';
import { MarkdownContent } from '@backstage/core-components';
export { RepoUrlPickerSchema } from './schema.esm.js';

const RepoUrlPicker = (props) => {
  const { uiSchema, onChange, rawErrors, formData, schema } = props;
  const [state, setState] = useState(
    parseRepoPickerUrl(formData)
  );
  const [credentialsHost, setCredentialsHost] = useState(
    void 0
  );
  const integrationApi = useApi(scmIntegrationsApiRef);
  const scmAuthApi = useApi(scmAuthApiRef);
  const { secrets, setSecrets } = useTemplateSecrets();
  const allowedHosts = useMemo(
    () => uiSchema?.["ui:options"]?.allowedHosts ?? [],
    [uiSchema]
  );
  const allowedOrganizations = useMemo(
    () => uiSchema?.["ui:options"]?.allowedOrganizations ?? [],
    [uiSchema]
  );
  const allowedOwners = useMemo(
    () => uiSchema?.["ui:options"]?.allowedOwners ?? [],
    [uiSchema]
  );
  const allowedProjects = useMemo(
    () => uiSchema?.["ui:options"]?.allowedProjects ?? [],
    [uiSchema]
  );
  const allowedRepos = useMemo(
    () => uiSchema?.["ui:options"]?.allowedRepos ?? [],
    [uiSchema]
  );
  const isDisabled = useMemo(
    () => uiSchema?.["ui:disabled"] ?? false,
    [uiSchema]
  );
  const { owner, organization, project, repoName } = state;
  useEffect(() => {
    onChange(serializeRepoPickerUrl(state));
  }, [state, onChange]);
  useEffect(() => {
    if (allowedOrganizations.length > 0 && !organization) {
      setState((prevState) => ({
        ...prevState,
        organization: allowedOrganizations[0]
      }));
    }
  }, [setState, allowedOrganizations, organization]);
  useEffect(() => {
    if (allowedOwners.length > 0 && !owner) {
      setState((prevState) => ({
        ...prevState,
        owner: allowedOwners[0]
      }));
    }
  }, [setState, allowedOwners, owner]);
  useEffect(() => {
    if (allowedProjects.length > 0 && !project) {
      setState((prevState) => ({
        ...prevState,
        project: allowedProjects[0]
      }));
    }
  }, [setState, allowedProjects, project]);
  useEffect(() => {
    if (allowedRepos.length > 0 && !repoName) {
      setState((prevState) => ({ ...prevState, repoName: allowedRepos[0] }));
    }
  }, [setState, allowedRepos, repoName]);
  const updateLocalState = useCallback(
    (newState) => {
      setState((prevState) => ({ ...prevState, ...newState }));
    },
    [setState]
  );
  useDebounce(
    async () => {
      const { requestUserCredentials } = uiSchema?.["ui:options"] ?? {};
      if (!requestUserCredentials || !state.host) {
        return;
      }
      if (secrets[requestUserCredentials.secretsKey] && credentialsHost === state.host) {
        return;
      }
      const { token } = await scmAuthApi.getCredentials({
        url: `https://${state.host}`,
        additionalScope: {
          repoWrite: true,
          customScopes: requestUserCredentials.additionalScopes
        }
      });
      setSecrets({ [requestUserCredentials.secretsKey]: token });
      setCredentialsHost(state.host);
    },
    500,
    [state, uiSchema]
  );
  const hostType = (state.host && integrationApi.byHost(state.host)?.type) ?? null;
  const description = uiSchema["ui:description"] ?? schema.description;
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    schema.title && /* @__PURE__ */ jsxs(Box, { my: 1, children: [
      /* @__PURE__ */ jsx(Typography, { variant: "h5", children: schema.title }),
      /* @__PURE__ */ jsx(Divider, {})
    ] }),
    description && /* @__PURE__ */ jsx(Typography, { variant: "body1", children: /* @__PURE__ */ jsx(MarkdownContent, { content: description }) }),
    /* @__PURE__ */ jsx(
      RepoUrlPickerHost,
      {
        host: state.host,
        hosts: allowedHosts,
        onChange: (host) => setState((prevState) => ({ ...prevState, host })),
        rawErrors,
        isDisabled
      }
    ),
    hostType === "github" && /* @__PURE__ */ jsx(
      GithubRepoPicker,
      {
        allowedOwners,
        onChange: updateLocalState,
        rawErrors,
        state,
        isDisabled,
        accessToken: uiSchema?.["ui:options"]?.requestUserCredentials?.secretsKey && secrets[uiSchema["ui:options"].requestUserCredentials.secretsKey]
      }
    ),
    hostType === "gitea" && /* @__PURE__ */ jsx(
      GiteaRepoPicker,
      {
        allowedOwners,
        allowedRepos,
        rawErrors,
        state,
        isDisabled,
        onChange: updateLocalState
      }
    ),
    hostType === "gitlab" && /* @__PURE__ */ jsx(
      GitlabRepoPicker,
      {
        allowedOwners,
        rawErrors,
        state,
        onChange: updateLocalState,
        isDisabled,
        accessToken: uiSchema?.["ui:options"]?.requestUserCredentials?.secretsKey && secrets[uiSchema["ui:options"].requestUserCredentials.secretsKey]
      }
    ),
    hostType === "bitbucket" && /* @__PURE__ */ jsx(
      BitbucketRepoPicker,
      {
        allowedOwners,
        allowedProjects,
        rawErrors,
        state,
        onChange: updateLocalState,
        isDisabled,
        accessToken: uiSchema?.["ui:options"]?.requestUserCredentials?.secretsKey && secrets[uiSchema["ui:options"].requestUserCredentials.secretsKey]
      }
    ),
    hostType === "azure" && /* @__PURE__ */ jsx(
      AzureRepoPicker,
      {
        allowedOrganizations,
        allowedProject: allowedProjects,
        rawErrors,
        state,
        isDisabled,
        onChange: updateLocalState
      }
    ),
    hostType === "gerrit" && /* @__PURE__ */ jsx(
      GerritRepoPicker,
      {
        rawErrors,
        state,
        onChange: updateLocalState,
        isDisabled
      }
    ),
    /* @__PURE__ */ jsx(
      RepoUrlPickerRepoName,
      {
        repoName: state.repoName,
        allowedRepos,
        onChange: (repo) => setState((prevState) => ({
          ...prevState,
          repoName: repo.id || repo.name
        })),
        isDisabled,
        rawErrors,
        availableRepos: state.availableRepos
      }
    )
  ] });
};

export { RepoUrlPicker };
//# sourceMappingURL=RepoUrlPicker.esm.js.map
