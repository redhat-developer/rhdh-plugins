import { jsx } from 'react/jsx-runtime';
import yaml from 'yaml';
import { useApi } from '@backstage/core-plugin-api';
import { useState, useRef, useCallback, useMemo, createContext, useContext } from 'react';
import { scaffolderApiRef, useTemplateSecrets } from '@backstage/plugin-scaffolder-react';
import { useFormDecorators } from '../../hooks/useFormDecorators.esm.js';

const MAX_CONTENT_SIZE = 64 * 1024;
const CHUNK_SIZE = 32 * 1024;
const DryRunContext = createContext(void 0);
function base64EncodeContent(content) {
  if (content.length > MAX_CONTENT_SIZE) {
    return window.btoa("<file too large>");
  }
  try {
    return window.btoa(content);
  } catch {
    const decoder = new TextEncoder();
    const buffer = decoder.encode(content);
    const chunks = new Array();
    for (let offset = 0; offset < buffer.length; offset += CHUNK_SIZE) {
      chunks.push(
        String.fromCharCode(...buffer.slice(offset, offset + CHUNK_SIZE))
      );
    }
    return window.btoa(chunks.join(""));
  }
}
function DryRunProvider(props) {
  const decorators = useFormDecorators();
  const scaffolderApi = useApi(scaffolderApiRef);
  const { secrets: contextSecrets } = useTemplateSecrets();
  const [state, setState] = useState({
    results: [],
    selectedResult: void 0
  });
  const idRef = useRef(1);
  const selectResult = useCallback((id) => {
    setState((prevState) => {
      const result = prevState.results.find((r) => r.id === id);
      if (result === prevState.selectedResult) {
        return prevState;
      }
      return {
        results: prevState.results,
        selectedResult: result
      };
    });
  }, []);
  const deleteResult = useCallback((id) => {
    setState((prevState) => {
      const index = prevState.results.findIndex((r) => r.id === id);
      if (index === -1) {
        return prevState;
      }
      const newResults = prevState.results.slice();
      const [deleted] = newResults.splice(index, 1);
      return {
        results: newResults,
        selectedResult: prevState.selectedResult?.id === deleted.id ? newResults[0] : prevState.selectedResult
      };
    });
  }, []);
  const execute = useCallback(
    async (options) => {
      if (!scaffolderApi.dryRun) {
        throw new Error("Scaffolder API does not support dry-run");
      }
      const parsed = yaml.parse(options.templateContent);
      const { formState: values, secrets } = await decorators.run({
        formState: options.values,
        secrets: contextSecrets,
        manifest: parsed?.spec
      });
      const response = await scaffolderApi.dryRun({
        template: parsed,
        values,
        secrets,
        directoryContents: options.files.map((file) => ({
          path: file.path,
          base64Content: base64EncodeContent(file.content)
        }))
      });
      const result = {
        ...response,
        id: idRef.current++
      };
      setState((prevState) => ({
        results: [...prevState.results, result],
        selectedResult: prevState.selectedResult ?? result
      }));
    },
    [scaffolderApi, decorators, contextSecrets]
  );
  const dryRun = useMemo(
    () => ({
      ...state,
      selectResult,
      deleteResult,
      execute
    }),
    [state, selectResult, deleteResult, execute]
  );
  return /* @__PURE__ */ jsx(DryRunContext.Provider, { value: dryRun, children: props.children });
}
function useDryRun() {
  const value = useContext(DryRunContext);
  if (!value) {
    throw new Error("must be used within a DryRunProvider");
  }
  return value;
}

export { DryRunProvider, base64EncodeContent, useDryRun };
//# sourceMappingURL=DryRunContext.esm.js.map
