import { jsx, jsxs } from 'react/jsx-runtime';
import { useState, useCallback } from 'react';
import { useNavigate, Navigate } from 'react-router-dom';
import useAsync from 'react-use/esm/useAsync';
import { stringifyEntityRef, ANNOTATION_EDIT_URL } from '@backstage/catalog-model';
import { useRouteRef, useApi, useRouteRefParams, AnalyticsContext } from '@backstage/core-plugin-api';
import { useTemplateSecrets, scaffolderApiRef } from '@backstage/plugin-scaffolder-react';
import { catalogApiRef } from '@backstage/plugin-catalog-react';
import { useTemplateParameterSchema, Workflow } from '@backstage/plugin-scaffolder-react/alpha';
import { Page, Header, Progress } from '@backstage/core-components';
import { rootRouteRef, scaffolderTaskRouteRef, selectedTemplateRouteRef } from '../../../routes.esm.js';
import { useTranslationRef } from '@backstage/core-plugin-api/alpha';
import { scaffolderTranslationRef } from '../../../translation.esm.js';
import { TemplateWizardPageContextMenu } from './TemplateWizardPageContextMenu.esm.js';
import { useFormDecorators } from '../../hooks/useFormDecorators.esm.js';

const TemplateWizardPage = (props) => {
  const rootRef = useRouteRef(rootRouteRef);
  const taskRoute = useRouteRef(scaffolderTaskRouteRef);
  const { secrets: contextSecrets } = useTemplateSecrets();
  const scaffolderApi = useApi(scaffolderApiRef);
  const catalogApi = useApi(catalogApiRef);
  const [isCreating, setIsCreating] = useState(false);
  const navigate = useNavigate();
  const { templateName, namespace } = useRouteRefParams(
    selectedTemplateRouteRef
  );
  const { t } = useTranslationRef(scaffolderTranslationRef);
  const templateRef = stringifyEntityRef({
    kind: "Template",
    namespace,
    name: templateName
  });
  const { manifest } = useTemplateParameterSchema(templateRef);
  const decorators = useFormDecorators();
  const { value: editUrl } = useAsync(async () => {
    const data = await catalogApi.getEntityByRef(templateRef);
    return data?.metadata.annotations?.[ANNOTATION_EDIT_URL];
  }, [templateRef, catalogApi]);
  const onCreate = useCallback(
    async (initialValues) => {
      if (isCreating) {
        return;
      }
      setIsCreating(true);
      const { formState: values, secrets } = await decorators.run({
        formState: initialValues,
        secrets: contextSecrets,
        manifest
      });
      const { taskId } = await scaffolderApi.scaffold({
        templateRef,
        values,
        secrets
      });
      navigate(taskRoute({ taskId }));
    },
    [
      contextSecrets,
      decorators,
      isCreating,
      manifest,
      navigate,
      scaffolderApi,
      taskRoute,
      templateRef
    ]
  );
  const onError = useCallback(() => /* @__PURE__ */ jsx(Navigate, { to: rootRef() }), [rootRef]);
  return /* @__PURE__ */ jsx(AnalyticsContext, { attributes: { entityRef: templateRef }, children: /* @__PURE__ */ jsxs(Page, { themeId: "website", children: [
    /* @__PURE__ */ jsx(
      Header,
      {
        pageTitleOverride: t("templateWizardPage.pageTitle"),
        title: t("templateWizardPage.title"),
        subtitle: t("templateWizardPage.subtitle"),
        ...props.headerOptions,
        children: /* @__PURE__ */ jsx(TemplateWizardPageContextMenu, { editUrl })
      }
    ),
    isCreating && /* @__PURE__ */ jsx(Progress, {}),
    /* @__PURE__ */ jsx(
      Workflow,
      {
        namespace,
        templateName,
        onCreate,
        components: props.components,
        onError,
        extensions: props.customFieldExtensions,
        formProps: props.formProps,
        layouts: props.layouts
      }
    )
  ] }) });
};

export { TemplateWizardPage };
//# sourceMappingURL=TemplateWizardPage.esm.js.map
