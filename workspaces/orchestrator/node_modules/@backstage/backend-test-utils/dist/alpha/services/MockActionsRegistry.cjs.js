'use strict';

var errors = require('@backstage/errors');
var zod = require('zod');
var zodToJsonSchema = require('zod-to-json-schema');
require('../../services/mockServices.cjs.js');
var mockCredentials = require('../../services/mockCredentials.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var zodToJsonSchema__default = /*#__PURE__*/_interopDefaultCompat(zodToJsonSchema);

class MockActionsRegistry {
  constructor(logger) {
    this.logger = logger;
  }
  static create(opts) {
    return new MockActionsRegistry(opts.logger);
  }
  actions = /* @__PURE__ */ new Map();
  async list() {
    return {
      actions: Array.from(this.actions.entries()).map(([id, action]) => ({
        id,
        name: action.name,
        title: action.title,
        description: action.description,
        attributes: {
          destructive: action.attributes?.destructive ?? true,
          idempotent: action.attributes?.idempotent ?? false,
          readOnly: action.attributes?.readOnly ?? false
        },
        schema: {
          input: action.schema?.input ? zodToJsonSchema__default.default(action.schema.input(zod.z)) : zodToJsonSchema__default.default(zod.z.object({})),
          output: action.schema?.output ? zodToJsonSchema__default.default(action.schema.output(zod.z)) : zodToJsonSchema__default.default(zod.z.object({}))
        }
      }))
    };
  }
  async invoke(opts) {
    const action = this.actions.get(opts.id);
    if (!action) {
      const availableActionIds = Array.from(this.actions.keys()).join(", ");
      throw new errors.NotFoundError(
        `Action "${opts.id}" not found, available actions: ${availableActionIds ? `"${availableActionIds}"` : "none"}`
      );
    }
    const input = action.schema?.input ? action.schema.input(zod.z).safeParse(opts.input) : { success: true, data: void 0 };
    if (!input.success) {
      throw new errors.InputError(`Invalid input to action "${opts.id}"`, input.error);
    }
    try {
      const result = await action.action({
        input: input.data,
        credentials: opts.credentials ?? mockCredentials.mockCredentials.none(),
        logger: this.logger
      });
      const output = action.schema?.output ? action.schema.output(zod.z).safeParse(result?.output) : { success: true, data: result?.output };
      if (!output.success) {
        throw new errors.InputError(
          `Invalid output from action "${opts.id}"`,
          output.error
        );
      }
      return { output: output.data };
    } catch (error) {
      throw new errors.ForwardedError(
        `Failed execution of action "${opts.id}"`,
        error
      );
    }
  }
  register(options) {
    const id = `test:${options.name}`;
    if (this.actions.has(id)) {
      throw new Error(`Action with id "${id}" is already registered`);
    }
    this.actions.set(id, options);
  }
}

exports.MockActionsRegistry = MockActionsRegistry;
//# sourceMappingURL=MockActionsRegistry.cjs.js.map
