'use strict';

var errors = require('@backstage/errors');
var crypto = require('crypto');
var knexFactory = require('knex');
var pgConnectionString = require('pg-connection-string');
var uuid = require('uuid');
var types = require('./types.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var knexFactory__default = /*#__PURE__*/_interopDefaultCompat(knexFactory);

async function waitForPostgresReady(connection) {
  const startTime = Date.now();
  let lastError;
  let attempts = 0;
  for (; ; ) {
    attempts += 1;
    let knex;
    try {
      knex = knexFactory__default.default({
        client: "pg",
        connection: {
          // make a copy because the driver mutates this
          ...connection
        }
      });
      const result = await knex.select(knex.raw("version()"));
      if (Array.isArray(result) && result[0]?.version) {
        return;
      }
    } catch (e) {
      lastError = e;
    } finally {
      await knex?.destroy();
    }
    if (Date.now() - startTime > 3e4) {
      throw new Error(
        `Timed out waiting for the database to be ready for connections, ${attempts} attempts, ${lastError ? `last error was ${errors.stringifyError(lastError)}` : "(no errors thrown)"}`
      );
    }
    await new Promise((resolve) => setTimeout(resolve, 100));
  }
}
async function startPostgresContainer(image) {
  const user = "postgres";
  const password = uuid.v4();
  const { GenericContainer } = require("testcontainers");
  const container = await new GenericContainer(image).withExposedPorts(5432).withEnvironment({ POSTGRES_PASSWORD: password }).withTmpFs({ "/var/lib/postgresql/data": "rw" }).start();
  const host = container.getHost();
  const port = container.getMappedPort(5432);
  const connection = { host, port, user, password };
  const stopContainer = async () => {
    await container.stop({ timeout: 1e4 });
  };
  await waitForPostgresReady(connection);
  return { connection, stopContainer };
}
class PostgresEngine {
  static async create(properties) {
    const { connectionStringEnvironmentVariableName, dockerImageName } = properties;
    if (connectionStringEnvironmentVariableName) {
      const connectionString = process.env[connectionStringEnvironmentVariableName];
      if (connectionString) {
        const connection = pgConnectionString.parse(connectionString);
        return new PostgresEngine(
          properties,
          connection
        );
      }
    }
    if (dockerImageName) {
      const { connection, stopContainer } = await startPostgresContainer(
        dockerImageName
      );
      return new PostgresEngine(properties, connection, stopContainer);
    }
    throw new Error(`Test databasee for ${properties.name} not configured`);
  }
  #properties;
  #connection;
  #knexInstances;
  #databaseNames;
  #stopContainer;
  constructor(properties, connection, stopContainer) {
    this.#properties = properties;
    this.#connection = connection;
    this.#knexInstances = [];
    this.#databaseNames = [];
    this.#stopContainer = stopContainer;
  }
  async createDatabaseInstance() {
    const adminConnection = this.#connectAdmin();
    try {
      const databaseName = `db${crypto.randomBytes(16).toString("hex")}`;
      await adminConnection.raw("CREATE DATABASE ??", [databaseName]);
      this.#databaseNames.push(databaseName);
      const knexInstance = knexFactory__default.default({
        client: this.#properties.driver,
        connection: {
          ...this.#connection,
          database: databaseName
        },
        ...types.LARGER_POOL_CONFIG
      });
      this.#knexInstances.push(knexInstance);
      return knexInstance;
    } finally {
      await adminConnection.destroy();
    }
  }
  async shutdown() {
    for (const instance of this.#knexInstances) {
      await instance.destroy();
    }
    const adminConnection = this.#connectAdmin();
    try {
      for (const databaseName of this.#databaseNames) {
        await adminConnection.raw("DROP DATABASE ??", [databaseName]);
      }
    } finally {
      await adminConnection.destroy();
    }
    await this.#stopContainer?.();
  }
  #connectAdmin() {
    return knexFactory__default.default({
      client: this.#properties.driver,
      connection: {
        ...this.#connection,
        database: "postgres"
      },
      pool: {
        acquireTimeoutMillis: 1e4
      }
    });
  }
}

exports.PostgresEngine = PostgresEngine;
exports.startPostgresContainer = startPostgresContainer;
//# sourceMappingURL=postgres.cjs.js.map
