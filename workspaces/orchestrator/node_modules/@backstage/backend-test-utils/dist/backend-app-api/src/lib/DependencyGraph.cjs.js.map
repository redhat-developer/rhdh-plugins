{"version":3,"file":"DependencyGraph.cjs.js","sources":["../../../../../backend-app-api/src/lib/DependencyGraph.ts"],"sourcesContent":["/*\n * Copyright 2023 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ninterface NodeInput<T> {\n  value: T;\n  consumes?: Iterable<string>;\n  provides?: Iterable<string>;\n}\n\n/** @internal */\nclass Node<T> {\n  static from<T>(input: NodeInput<T>) {\n    return new Node<T>(\n      input.value,\n      input.consumes ? new Set(input.consumes) : new Set(),\n      input.provides ? new Set(input.provides) : new Set(),\n    );\n  }\n\n  private constructor(\n    readonly value: T,\n    readonly consumes: Set<string>,\n    readonly provides: Set<string>,\n  ) {}\n}\n\n/** @internal */\nclass CycleKeySet<T> {\n  static from<T>(nodes: Array<Node<T>>) {\n    return new CycleKeySet<T>(nodes);\n  }\n\n  #nodeIds: Map<T, number>;\n  #cycleKeys: Set<string>;\n\n  private constructor(nodes: Array<Node<T>>) {\n    this.#nodeIds = new Map(nodes.map((n, i) => [n.value, i]));\n    this.#cycleKeys = new Set<string>();\n  }\n\n  tryAdd(path: T[]): boolean {\n    const cycleKey = this.#getCycleKey(path);\n    if (this.#cycleKeys.has(cycleKey)) {\n      return false;\n    }\n    this.#cycleKeys.add(cycleKey);\n    return true;\n  }\n\n  #getCycleKey(path: T[]): string {\n    return path\n      .map(n => this.#nodeIds.get(n)!)\n      .sort()\n      .join(',');\n  }\n}\n\n/**\n * Internal helper to help validate and traverse a dependency graph.\n * @internal\n */\nexport class DependencyGraph<T> {\n  static fromMap(\n    nodes: Record<string, Omit<NodeInput<unknown>, 'value'>>,\n  ): DependencyGraph<string> {\n    return this.fromIterable(\n      Object.entries(nodes).map(([key, node]) => ({\n        value: String(key),\n        ...node,\n      })),\n    );\n  }\n\n  static fromIterable<T>(\n    nodeInputs: Iterable<NodeInput<T>>,\n  ): DependencyGraph<T> {\n    const nodes = new Array<Node<T>>();\n    for (const nodeInput of nodeInputs) {\n      nodes.push(Node.from(nodeInput));\n    }\n\n    return new DependencyGraph(nodes);\n  }\n\n  #nodes: Array<Node<T>>;\n  #allProvided: Set<string>;\n\n  private constructor(nodes: Array<Node<T>>) {\n    this.#nodes = nodes;\n    this.#allProvided = new Set();\n\n    for (const node of this.#nodes.values()) {\n      for (const produced of node.provides) {\n        this.#allProvided.add(produced);\n      }\n    }\n  }\n\n  /**\n   * Find all nodes that consume dependencies that are not provided by any other node.\n   */\n  findUnsatisfiedDeps(): Array<{ value: T; unsatisfied: string[] }> {\n    const unsatisfiedDependencies = [];\n    for (const node of this.#nodes.values()) {\n      const unsatisfied = Array.from(node.consumes).filter(\n        id => !this.#allProvided.has(id),\n      );\n      if (unsatisfied.length > 0) {\n        unsatisfiedDependencies.push({ value: node.value, unsatisfied });\n      }\n    }\n    return unsatisfiedDependencies;\n  }\n\n  /**\n   * Detect the first circular dependency within the graph, returning the path of nodes that\n   * form a cycle, with the same node as the first and last element of the array.\n   */\n  detectCircularDependency(): T[] | undefined {\n    return this.detectCircularDependencies().next().value;\n  }\n\n  /**\n   * Detect circular dependencies within the graph, returning the path of nodes that\n   * form a cycle, with the same node as the first and last element of the array.\n   */\n  *detectCircularDependencies(): Generator<T[], undefined> {\n    const cycleKeys = CycleKeySet.from(this.#nodes);\n\n    for (const startNode of this.#nodes) {\n      const visited = new Set<Node<T>>();\n      const stack = new Array<[node: Node<T>, path: T[]]>([\n        startNode,\n        [startNode.value],\n      ]);\n\n      while (stack.length > 0) {\n        const [node, path] = stack.pop()!;\n        if (visited.has(node)) {\n          continue;\n        }\n        visited.add(node);\n        for (const consumed of node.consumes) {\n          const providerNodes = this.#nodes.filter(other =>\n            other.provides.has(consumed),\n          );\n          for (const provider of providerNodes) {\n            if (provider === startNode) {\n              if (cycleKeys.tryAdd(path)) {\n                yield [...path, startNode.value];\n              }\n\n              break;\n            }\n            if (!visited.has(provider)) {\n              stack.push([provider, [...path, provider.value]]);\n            }\n          }\n        }\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * Traverses the dependency graph in topological order, calling the provided\n   * function for each node and waiting for it to resolve.\n   *\n   * The nodes are traversed in parallel, but in such a way that no node is\n   * visited before all of its dependencies.\n   *\n   * Dependencies of nodes that are not produced by any other nodes will be ignored.\n   */\n  async parallelTopologicalTraversal<TResult>(\n    fn: (value: T) => Promise<TResult>,\n  ): Promise<TResult[]> {\n    const allProvided = this.#allProvided;\n    const waiting = new Set(this.#nodes.values());\n    const visited = new Set<Node<T>>();\n    const results = new Array<TResult>();\n    let inFlight = 0; // Keep track of how many callbacks are in flight, so that we know if we got stuck\n\n    // This keeps track of a counter of how many providers there are still left\n    // to be visited for each dependency. This needs to be a counter instead of\n    // a flag for the special case where there are several providers of a given\n    // value, even though there may be only one consumer of it.\n    const producedRemaining = new Map<string, number>();\n    for (const node of this.#nodes) {\n      for (const provided of node.provides) {\n        producedRemaining.set(\n          provided,\n          (producedRemaining.get(provided) ?? 0) + 1,\n        );\n      }\n    }\n\n    // Find all nodes that have no dependencies that have not already been produced by visited nodes\n    async function processMoreNodes() {\n      if (waiting.size === 0) {\n        return;\n      }\n      const nodesToProcess = [];\n      for (const node of waiting) {\n        let ready = true;\n        for (const consumed of node.consumes) {\n          if (\n            allProvided.has(consumed) &&\n            producedRemaining.get(consumed) !== 0\n          ) {\n            ready = false;\n            continue;\n          }\n        }\n        if (ready) {\n          nodesToProcess.push(node);\n        }\n      }\n\n      for (const node of nodesToProcess) {\n        waiting.delete(node);\n      }\n\n      if (nodesToProcess.length === 0 && inFlight === 0) {\n        // We expect the caller to check for circular dependencies before\n        // traversal, so this error should never happen\n        throw new Error('Circular dependency detected');\n      }\n\n      await Promise.all(nodesToProcess.map(processNode));\n    }\n\n    // Process an individual node, and then add its produced dependencies to the set of available products\n    async function processNode(node: Node<T>) {\n      visited.add(node);\n      inFlight += 1;\n\n      const result = await fn(node.value);\n      results.push(result);\n\n      node.provides.forEach(produced => {\n        const remaining = producedRemaining.get(produced);\n        if (!remaining) {\n          // This should be impossible, if the code that generates the map is correct\n          throw new Error(\n            `Internal error: Node provided superfluous dependency '${produced}'`,\n          );\n        }\n        producedRemaining.set(produced, remaining - 1);\n      });\n\n      inFlight -= 1;\n      await processMoreNodes();\n    }\n\n    await processMoreNodes();\n\n    return results;\n  }\n}\n"],"names":[],"mappings":"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"}