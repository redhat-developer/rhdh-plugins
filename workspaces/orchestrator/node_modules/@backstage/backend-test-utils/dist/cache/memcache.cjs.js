'use strict';

var Keyv = require('keyv');
var KeyvMemcache = require('@keyv/memcache');
var uuid = require('uuid');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var Keyv__default = /*#__PURE__*/_interopDefaultCompat(Keyv);
var KeyvMemcache__default = /*#__PURE__*/_interopDefaultCompat(KeyvMemcache);

async function attemptMemcachedConnection(connection) {
  const startTime = Date.now();
  for (; ; ) {
    try {
      const store = new KeyvMemcache__default.default(connection);
      const keyv = new Keyv__default.default({ store });
      const value = uuid.v4();
      await keyv.set("test", value);
      if (await keyv.get("test") === value) {
        return keyv;
      }
    } catch (e) {
      if (Date.now() - startTime > 3e4) {
        throw new Error(
          `Timed out waiting for memcached to be ready for connections, ${e}`
        );
      }
    }
    await new Promise((resolve) => setTimeout(resolve, 100));
  }
}
async function connectToExternalMemcache(connection) {
  const keyv = await attemptMemcachedConnection(connection);
  return {
    store: "memcache",
    connection,
    keyv,
    stop: async () => await keyv.disconnect()
  };
}
async function startMemcachedContainer(image) {
  const { GenericContainer } = require("testcontainers");
  const container = await new GenericContainer(image).withExposedPorts(11211).start();
  const host = container.getHost();
  const port = container.getMappedPort(11211);
  const connection = `${host}:${port}`;
  const keyv = await attemptMemcachedConnection(connection);
  return {
    store: "memcache",
    connection,
    keyv,
    stop: async () => {
      await keyv.disconnect();
      await container.stop({ timeout: 1e4 });
    }
  };
}

exports.connectToExternalMemcache = connectToExternalMemcache;
exports.startMemcachedContainer = startMemcachedContainer;
//# sourceMappingURL=memcache.cjs.js.map
