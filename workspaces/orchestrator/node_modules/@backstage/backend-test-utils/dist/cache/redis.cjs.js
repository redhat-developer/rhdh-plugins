'use strict';

var Keyv = require('keyv');
var KeyvRedis = require('@keyv/redis');
var uuid = require('uuid');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var Keyv__default = /*#__PURE__*/_interopDefaultCompat(Keyv);
var KeyvRedis__default = /*#__PURE__*/_interopDefaultCompat(KeyvRedis);

async function attemptRedisConnection(connection) {
  const startTime = Date.now();
  for (; ; ) {
    try {
      const store = new KeyvRedis__default.default(connection);
      const keyv = new Keyv__default.default({ store });
      const value = uuid.v4();
      await keyv.set("test", value);
      if (await keyv.get("test") === value) {
        return keyv;
      }
    } catch (e) {
      if (Date.now() - startTime > 3e4) {
        throw new Error(
          `Timed out waiting for redis to be ready for connections, ${e}`
        );
      }
    }
    await new Promise((resolve) => setTimeout(resolve, 100));
  }
}
async function connectToExternalRedis(connection) {
  const keyv = await attemptRedisConnection(connection);
  return {
    store: "redis",
    connection,
    keyv,
    stop: async () => await keyv.disconnect()
  };
}
async function startRedisContainer(image) {
  const { GenericContainer } = require("testcontainers");
  const container = await new GenericContainer(image).withExposedPorts(6379).start();
  const host = container.getHost();
  const port = container.getMappedPort(6379);
  const connection = `redis://${host}:${port}`;
  const keyv = await attemptRedisConnection(connection);
  return {
    store: "redis",
    connection,
    keyv,
    stop: async () => {
      await keyv.disconnect();
      await container.stop({ timeout: 1e4 });
    }
  };
}

exports.connectToExternalRedis = connectToExternalRedis;
exports.startRedisContainer = startRedisContainer;
//# sourceMappingURL=redis.cjs.js.map
