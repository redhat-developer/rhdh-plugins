'use strict';

var Keyv = require('keyv');
var KeyvValkey = require('@keyv/valkey');
var uuid = require('uuid');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var Keyv__default = /*#__PURE__*/_interopDefaultCompat(Keyv);
var KeyvValkey__default = /*#__PURE__*/_interopDefaultCompat(KeyvValkey);

async function attemptValkeyConnection(connection) {
  const startTime = Date.now();
  for (; ; ) {
    try {
      const store = new KeyvValkey__default.default(connection);
      const keyv = new Keyv__default.default({ store });
      const value = uuid.v4();
      await keyv.set("test", value);
      if (await keyv.get("test") === value) {
        return keyv;
      }
    } catch (e) {
      if (Date.now() - startTime > 3e4) {
        throw new Error(
          `Timed out waiting for valkey to be ready for connections, ${e}`
        );
      }
    }
    await new Promise((resolve) => setTimeout(resolve, 100));
  }
}
async function connectToExternalValkey(connection) {
  const keyv = await attemptValkeyConnection(connection);
  return {
    store: "valkey",
    connection,
    keyv,
    stop: async () => await keyv.disconnect()
  };
}
async function startValkeyContainer(image) {
  const { GenericContainer } = require("testcontainers");
  const container = await new GenericContainer(image).withExposedPorts(6379).start();
  const host = container.getHost();
  const port = container.getMappedPort(6379);
  const connection = `redis://${host}:${port}`;
  const keyv = await attemptValkeyConnection(connection);
  return {
    store: "valkey",
    connection,
    keyv,
    stop: async () => {
      await keyv.disconnect();
      await container.stop({ timeout: 1e4 });
    }
  };
}

exports.connectToExternalValkey = connectToExternalValkey;
exports.startValkeyContainer = startValkeyContainer;
//# sourceMappingURL=valkey.cjs.js.map
