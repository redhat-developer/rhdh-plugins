'use strict';

var errors = require('@backstage/errors');
var mockCredentials = require('./mockCredentials.cjs.js');

class MockAuthService {
  pluginId;
  disableDefaultAuthPolicy;
  constructor(options) {
    this.pluginId = options.pluginId;
    this.disableDefaultAuthPolicy = options.disableDefaultAuthPolicy;
  }
  async authenticate(token, options) {
    switch (token) {
      case mockCredentials.MOCK_USER_TOKEN:
        return mockCredentials.mockCredentials.user();
      case mockCredentials.MOCK_SERVICE_TOKEN:
        return mockCredentials.mockCredentials.service();
      case mockCredentials.MOCK_INVALID_USER_TOKEN:
        throw new errors.AuthenticationError("User token is invalid");
      case mockCredentials.MOCK_INVALID_USER_LIMITED_TOKEN:
        throw new errors.AuthenticationError("Limited user token is invalid");
      case mockCredentials.MOCK_INVALID_SERVICE_TOKEN:
        throw new errors.AuthenticationError("Service token is invalid");
      case "":
        throw new errors.AuthenticationError("Token is empty");
    }
    if (token.startsWith(mockCredentials.MOCK_USER_TOKEN_PREFIX)) {
      const { sub: userEntityRef, actor } = JSON.parse(
        token.slice(mockCredentials.MOCK_USER_TOKEN_PREFIX.length)
      );
      return mockCredentials.mockCredentials.user(userEntityRef, { actor });
    }
    if (token.startsWith(mockCredentials.MOCK_USER_LIMITED_TOKEN_PREFIX)) {
      if (!options?.allowLimitedAccess) {
        throw new errors.AuthenticationError("Limited user token is not allowed");
      }
      const { sub: userEntityRef } = JSON.parse(
        token.slice(mockCredentials.MOCK_USER_LIMITED_TOKEN_PREFIX.length)
      );
      return mockCredentials.mockCredentials.user(userEntityRef);
    }
    if (token.startsWith(mockCredentials.MOCK_SERVICE_TOKEN_PREFIX)) {
      const { sub, target, obo } = JSON.parse(
        token.slice(mockCredentials.MOCK_SERVICE_TOKEN_PREFIX.length)
      );
      if (target && target !== this.pluginId) {
        throw new errors.AuthenticationError(
          `Invalid mock token target plugin ID, got '${target}' but expected '${this.pluginId}'`
        );
      }
      if (obo) {
        return mockCredentials.mockCredentials.user(obo);
      }
      return mockCredentials.mockCredentials.service(sub);
    }
    throw new errors.AuthenticationError(`Unknown mock token '${token}'`);
  }
  async getNoneCredentials() {
    return mockCredentials.mockCredentials.none();
  }
  async getOwnServiceCredentials() {
    return mockCredentials.mockCredentials.service(`plugin:${this.pluginId}`);
  }
  isPrincipal(credentials, type) {
    const principal = credentials.principal;
    if (type === "unknown") {
      return true;
    }
    if (principal.type !== type) {
      return false;
    }
    return true;
  }
  async getPluginRequestToken(options) {
    const principal = options.onBehalfOf.principal;
    if (principal.type === "none" && this.disableDefaultAuthPolicy) {
      return { token: "" };
    }
    if (principal.type !== "user" && principal.type !== "service") {
      throw new errors.AuthenticationError(
        `Refused to issue service token for credential type '${principal.type}'`
      );
    }
    return {
      token: mockCredentials.mockCredentials.service.token({
        onBehalfOf: options.onBehalfOf,
        targetPluginId: options.targetPluginId
      })
    };
  }
  async getLimitedUserToken(credentials) {
    if (credentials.principal.type !== "user") {
      throw new errors.AuthenticationError(
        `Refused to issue limited user token for credential type '${credentials.principal.type}'`
      );
    }
    return {
      token: mockCredentials.mockCredentials.limitedUser.token(
        credentials.principal.userEntityRef
      ),
      expiresAt: new Date(Date.now() + 36e5)
    };
  }
  listPublicServiceKeys() {
    throw new Error("Not implemented");
  }
}

exports.MockAuthService = MockAuthService;
//# sourceMappingURL=MockAuthService.cjs.js.map
