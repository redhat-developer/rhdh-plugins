{"version":3,"file":"createExtensionBlueprint.esm.js","sources":["../../src/wiring/createExtensionBlueprint.ts"],"sourcesContent":["/*\n * Copyright 2024 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ApiHolder, AppNode } from '../apis';\nimport { Expand } from '@backstage/types';\nimport { OpaqueType } from '@internal/opaque';\nimport {\n  ExtensionAttachToSpec,\n  ExtensionDefinition,\n  ResolvedExtensionInputs,\n  VerifyExtensionFactoryOutput,\n  createExtension,\n  ctxParamsSymbol,\n} from './createExtension';\nimport { z } from 'zod';\nimport { ExtensionInput } from './createExtensionInput';\nimport { ExtensionDataRef, ExtensionDataValue } from './createExtensionDataRef';\nimport { createExtensionDataContainer } from '@internal/frontend';\nimport {\n  ResolvedInputValueOverrides,\n  resolveInputOverrides,\n} from './resolveInputOverrides';\nimport { ExtensionDataContainer } from './types';\nimport { PageBlueprint } from '../blueprints/PageBlueprint';\n\n/**\n * A function used to define a parameter mapping function in order to facilitate\n * advanced parameter typing for extension blueprints.\n *\n * @remarks\n *\n * This function is primarily intended to enable the use of inferred type\n * parameters for blueprint params, but it can also be used to transoform the\n * params before they are handed ot the blueprint.\n *\n * The function must return an object created with\n * {@link createExtensionBlueprintParams}.\n *\n * @public\n */\nexport type ExtensionBlueprintDefineParams<\n  TParams extends object = object,\n  TInput = any,\n> = (params: TInput) => ExtensionBlueprintParams<TParams>;\n\n/**\n * An opaque type that represents a set of parameters to be passed to a blueprint.\n *\n * @remarks\n *\n * Created with {@link createExtensionBlueprintParams}.\n *\n * @public\n */\nexport type ExtensionBlueprintParams<T extends object = object> = {\n  $$type: '@backstage/BlueprintParams';\n  T: T;\n};\n\nconst OpaqueBlueprintParams = OpaqueType.create<{\n  public: ExtensionBlueprintParams;\n  versions: {\n    version: 'v1';\n    params: object;\n  };\n}>({\n  type: '@backstage/BlueprintParams',\n  versions: ['v1'],\n});\n\n/**\n * Wraps a plain blueprint parameter object in an opaque {@link ExtensionBlueprintParams} object.\n *\n * This is used in the definition of the `defineParams` option of {@link ExtensionBlueprint}.\n *\n * @public\n * @param params - The plain blueprint parameter object to wrap.\n * @returns The wrapped blueprint parameter object.\n */\nexport function createExtensionBlueprintParams<T extends object = object>(\n  params: T,\n): ExtensionBlueprintParams<T> {\n  return OpaqueBlueprintParams.createInstance('v1', { T: null as any, params });\n}\n\n/**\n * @public\n */\nexport type CreateExtensionBlueprintOptions<\n  TKind extends string,\n  TParams extends object | ExtensionBlueprintDefineParams,\n  UOutput extends ExtensionDataRef,\n  TInputs extends {\n    [inputName in string]: ExtensionInput<\n      ExtensionDataRef,\n      { optional: boolean; singleton: boolean }\n    >;\n  },\n  TConfigSchema extends { [key in string]: (zImpl: typeof z) => z.ZodType },\n  UFactoryOutput extends ExtensionDataValue<any, any>,\n  TDataRefs extends { [name in string]: ExtensionDataRef },\n> = {\n  kind: TKind;\n  attachTo: ExtensionAttachToSpec;\n  disabled?: boolean;\n  inputs?: TInputs;\n  output: Array<UOutput>;\n  config?: {\n    schema: TConfigSchema;\n  };\n  /**\n   * This option is used to further refine the blueprint params. When this\n   * option is used, the blueprint will require params to be passed in callback\n   * form. This function can both transform the params before they are handed to\n   * the blueprint factory, but importantly it also allows you to define\n   * inferred type parameters for your blueprint params.\n   *\n   * @example\n   * Blueprint definition with inferred type parameters:\n   * ```ts\n   * const ExampleBlueprint = createExtensionBlueprint({\n   *   kind: 'example',\n   *   attachTo: { id: 'example', input: 'example' },\n   *   output: [exampleComponentDataRef, exampleFetcherDataRef],\n   *   defineParams<T>(params: {\n   *     component(props: ExampleProps<T>): JSX.Element | null\n   *     fetcher(options: FetchOptions): Promise<FetchResult<T>>\n   *   }) {\n   *     return createExtensionBlueprintParams(params);\n   *   },\n   *   *factory(params) {\n   *     yield exampleComponentDataRef(params.component)\n   *     yield exampleFetcherDataRef(params.fetcher)\n   *   },\n   * });\n   * ```\n   *\n   * @example\n   * Usage of the above example blueprint:\n   * ```ts\n   * const example = ExampleBlueprint.make({\n   *   params: defineParams => defineParams({\n   *     component: ...,\n   *     fetcher: ...,\n   *   }),\n   * });\n   * ```\n   */\n  defineParams?: TParams extends ExtensionBlueprintDefineParams\n    ? TParams\n    : 'The defineParams option must be a function if provided, see the docs for details';\n  factory(\n    params: TParams extends ExtensionBlueprintDefineParams\n      ? ReturnType<TParams>['T']\n      : TParams,\n    context: {\n      node: AppNode;\n      apis: ApiHolder;\n      config: {\n        [key in keyof TConfigSchema]: z.infer<ReturnType<TConfigSchema[key]>>;\n      };\n      inputs: Expand<ResolvedExtensionInputs<TInputs>>;\n    },\n  ): Iterable<UFactoryOutput>;\n\n  dataRefs?: TDataRefs;\n} & VerifyExtensionFactoryOutput<UOutput, UFactoryOutput>;\n\n/** @public */\nexport type ExtensionBlueprintParameters = {\n  kind: string;\n  params?: object | ExtensionBlueprintDefineParams;\n  configInput?: { [K in string]: any };\n  config?: { [K in string]: any };\n  output?: ExtensionDataRef;\n  inputs?: {\n    [KName in string]: ExtensionInput<\n      ExtensionDataRef,\n      { optional: boolean; singleton: boolean }\n    >;\n  };\n  dataRefs?: { [name in string]: ExtensionDataRef };\n};\n\n/** @ignore */\ntype ParamsFactory<TDefiner extends ExtensionBlueprintDefineParams> = (\n  defineParams: TDefiner,\n) => ReturnType<TDefiner>;\n\n/**\n * Represents any form of params input that can be passed to a blueprint.\n * This also includes the invalid form of passing a plain params object to a blueprint that uses a definition callback.\n *\n * @ignore\n */\ntype AnyParamsInput<TParams extends object | ExtensionBlueprintDefineParams> =\n  TParams extends ExtensionBlueprintDefineParams<infer IParams>\n    ? IParams | ParamsFactory<TParams>\n    : TParams | ParamsFactory<ExtensionBlueprintDefineParams<TParams, TParams>>;\n\n/**\n * @public\n */\nexport interface ExtensionBlueprint<\n  T extends ExtensionBlueprintParameters = ExtensionBlueprintParameters,\n> {\n  dataRefs: T['dataRefs'];\n\n  make<\n    TName extends string | undefined,\n    TParamsInput extends AnyParamsInput<NonNullable<T['params']>>,\n  >(args: {\n    name?: TName;\n    attachTo?: ExtensionAttachToSpec;\n    disabled?: boolean;\n    params: TParamsInput extends ExtensionBlueprintDefineParams\n      ? TParamsInput\n      : T['params'] extends ExtensionBlueprintDefineParams\n      ? 'Error: This blueprint uses advanced parameter types and requires you to pass parameters as using the following callback syntax: `<blueprint>.make({ params: defineParams => defineParams(<params>) })`'\n      : T['params'];\n  }): ExtensionDefinition<{\n    kind: T['kind'];\n    name: string | undefined extends TName ? undefined : TName;\n    config: T['config'];\n    configInput: T['configInput'];\n    output: T['output'];\n    inputs: T['inputs'];\n    params: T['params'];\n  }>;\n\n  /**\n   * Creates a new extension from the blueprint.\n   *\n   * You must either pass `params` directly, or define a `factory` that can\n   * optionally call the original factory with the same params.\n   */\n  makeWithOverrides<\n    TName extends string | undefined,\n    TExtensionConfigSchema extends {\n      [key in string]: (zImpl: typeof z) => z.ZodType;\n    },\n    UFactoryOutput extends ExtensionDataValue<any, any>,\n    UNewOutput extends ExtensionDataRef,\n    TExtraInputs extends {\n      [inputName in string]: ExtensionInput<\n        ExtensionDataRef,\n        { optional: boolean; singleton: boolean }\n      >;\n    },\n  >(args: {\n    name?: TName;\n    attachTo?: ExtensionAttachToSpec;\n    disabled?: boolean;\n    inputs?: TExtraInputs & {\n      [KName in keyof T['inputs']]?: `Error: Input '${KName &\n        string}' is already defined in parent definition`;\n    };\n    output?: Array<UNewOutput>;\n    config?: {\n      schema: TExtensionConfigSchema & {\n        [KName in keyof T['config']]?: `Error: Config key '${KName &\n          string}' is already defined in parent schema`;\n      };\n    };\n    factory(\n      originalFactory: <\n        TParamsInput extends AnyParamsInput<NonNullable<T['params']>>,\n      >(\n        params: TParamsInput extends ExtensionBlueprintDefineParams\n          ? TParamsInput\n          : T['params'] extends ExtensionBlueprintDefineParams\n          ? 'Error: This blueprint uses advanced parameter types and requires you to pass parameters as using the following callback syntax: `originalFactory(defineParams => defineParams(<params>))`'\n          : T['params'],\n        context?: {\n          config?: T['config'];\n          inputs?: ResolvedInputValueOverrides<NonNullable<T['inputs']>>;\n        },\n      ) => ExtensionDataContainer<NonNullable<T['output']>>,\n      context: {\n        node: AppNode;\n        apis: ApiHolder;\n        config: T['config'] & {\n          [key in keyof TExtensionConfigSchema]: z.infer<\n            ReturnType<TExtensionConfigSchema[key]>\n          >;\n        };\n        inputs: Expand<ResolvedExtensionInputs<T['inputs'] & TExtraInputs>>;\n      },\n    ): Iterable<UFactoryOutput> &\n      VerifyExtensionFactoryOutput<\n        ExtensionDataRef extends UNewOutput\n          ? NonNullable<T['output']>\n          : UNewOutput,\n        UFactoryOutput\n      >;\n  }): ExtensionDefinition<{\n    config: (string extends keyof TExtensionConfigSchema\n      ? {}\n      : {\n          [key in keyof TExtensionConfigSchema]: z.infer<\n            ReturnType<TExtensionConfigSchema[key]>\n          >;\n        }) &\n      T['config'];\n    configInput: (string extends keyof TExtensionConfigSchema\n      ? {}\n      : z.input<\n          z.ZodObject<{\n            [key in keyof TExtensionConfigSchema]: ReturnType<\n              TExtensionConfigSchema[key]\n            >;\n          }>\n        >) &\n      T['configInput'];\n    output: ExtensionDataRef extends UNewOutput ? T['output'] : UNewOutput;\n    inputs: T['inputs'] & TExtraInputs;\n    kind: T['kind'];\n    name: string | undefined extends TName ? undefined : TName;\n    params: T['params'];\n  }>;\n}\n\nfunction unwrapParamsFactory<TParams extends object>(\n  // Allow `Function` because `typeof <object> === 'function'` allows it, but in practice this should always be a param factory\n  params: ParamsFactory<ExtensionBlueprintDefineParams> | Function,\n  defineParams: ExtensionBlueprintDefineParams,\n  kind: string,\n): TParams {\n  const paramDefinition = (\n    params as ParamsFactory<ExtensionBlueprintDefineParams>\n  )(defineParams);\n  try {\n    return OpaqueBlueprintParams.toInternal(paramDefinition).params as TParams;\n  } catch (e) {\n    throw new TypeError(\n      `Invalid invocation of blueprint with kind '${kind}', the parameter definition callback function did not return a valid parameter definition object; Caused by: ${e.message}`,\n    );\n  }\n}\n\nfunction unwrapParams<TParams extends object>(\n  params: object | ParamsFactory<ExtensionBlueprintDefineParams> | string,\n  ctx: { node: AppNode; [ctxParamsSymbol]?: any },\n  defineParams: ExtensionBlueprintDefineParams | undefined,\n  kind: string,\n): TParams {\n  const overrideParams = ctx[ctxParamsSymbol] as\n    | object\n    | ParamsFactory<ExtensionBlueprintDefineParams>\n    | undefined;\n\n  if (defineParams) {\n    if (overrideParams) {\n      if (typeof overrideParams !== 'function') {\n        throw new TypeError(\n          `Invalid extension override of blueprint with kind '${kind}', the override params were passed as a plain object, but this blueprint requires them to be passed in callback form`,\n        );\n      }\n      return unwrapParamsFactory(overrideParams, defineParams, kind);\n    }\n\n    if (typeof params !== 'function') {\n      throw new TypeError(\n        `Invalid invocation of blueprint with kind '${kind}', the parameters where passed as a plain object, but this blueprint requires them to be passed in callback form`,\n      );\n    }\n    return unwrapParamsFactory(params, defineParams, kind);\n  }\n\n  const base =\n    typeof params === 'function'\n      ? unwrapParamsFactory<TParams>(\n          params,\n          createExtensionBlueprintParams,\n          kind,\n        )\n      : (params as TParams);\n  const overrides =\n    typeof overrideParams === 'function'\n      ? unwrapParamsFactory<TParams>(\n          overrideParams,\n          createExtensionBlueprintParams,\n          kind,\n        )\n      : (overrideParams as Partial<TParams>);\n\n  return {\n    ...base,\n    ...overrides,\n  };\n}\n\n/**\n * Creates a new extension blueprint that encapsulates the creation of\n * extensions of particular kinds.\n *\n * @remarks\n *\n * For details on how blueprints work, see the\n * {@link https://backstage.io/docs/frontend-system/architecture/extension-blueprints | documentation for extension blueprints}\n * in the frontend system documentation.\n *\n * Extension blueprints make it much easier for users to create new extensions\n * for your plugin. Rather than letting them use {@link createExtension}\n * directly, you can define a set of parameters and default factory for your\n * blueprint, removing a lot of the boilerplate and complexity that is otherwise\n * needed to create an extension.\n *\n * Each blueprint has its own `kind` that helps identify and group the\n * extensions that have been created with it. For example the\n * {@link PageBlueprint} has the kind `'page'`, and extensions created with it\n * will be given the ID `'page:<plugin-id>[/<name>]'`. Blueprints should always\n * be exported as `<PascalCaseKind>Blueprint`.\n *\n * When creating a blueprint the type of the parameters are inferred from the\n * `factory` function that you provide. The exception to that is when you need\n * your blueprint to include inferred type parameters, in which case you need to\n * use the `defineParams` option. See the documentation for the `defineParams`\n * option for more details on how that works.\n *\n * @example\n * ```tsx\n * // In your plugin library\n * export const GreetingBlueprint = createExtensionBlueprint({\n *   kind: 'greeting',\n *   attachTo: { id: 'example', input: 'greetings' },\n *   output: [coreExtensionData.reactElement],\n *   factory(params: { greeting: string }) {\n *     return [coreExtensionData.reactElement(<h1>{params.greeting}</h1>)];\n *   },\n * });\n *\n * // Someone using your blueprint in their plugin\n * const exampleGreeting = GreetingBlueprint.make({\n *   params: {\n *     greeting: 'Hello, world!',\n *   },\n * });\n * ```\n * @public\n */\nexport function createExtensionBlueprint<\n  TParams extends object | ExtensionBlueprintDefineParams,\n  UOutput extends ExtensionDataRef,\n  TInputs extends {\n    [inputName in string]: ExtensionInput<\n      ExtensionDataRef,\n      { optional: boolean; singleton: boolean }\n    >;\n  },\n  TConfigSchema extends { [key in string]: (zImpl: typeof z) => z.ZodType },\n  UFactoryOutput extends ExtensionDataValue<any, any>,\n  TKind extends string,\n  TDataRefs extends { [name in string]: ExtensionDataRef } = never,\n>(\n  options: CreateExtensionBlueprintOptions<\n    TKind,\n    TParams,\n    UOutput,\n    TInputs,\n    TConfigSchema,\n    UFactoryOutput,\n    TDataRefs\n  >,\n): ExtensionBlueprint<{\n  kind: TKind;\n  params: TParams;\n  // This inference and remapping back to ExtensionDataRef eliminates any occurrences ConfigurationExtensionDataRef\n  output: UOutput extends ExtensionDataRef<\n    infer IData,\n    infer IId,\n    infer IConfig\n  >\n    ? ExtensionDataRef<IData, IId, IConfig>\n    : never;\n  inputs: string extends keyof TInputs ? {} : TInputs;\n  config: string extends keyof TConfigSchema\n    ? {}\n    : { [key in keyof TConfigSchema]: z.infer<ReturnType<TConfigSchema[key]>> };\n  configInput: string extends keyof TConfigSchema\n    ? {}\n    : z.input<\n        z.ZodObject<{\n          [key in keyof TConfigSchema]: ReturnType<TConfigSchema[key]>;\n        }>\n      >;\n  dataRefs: TDataRefs;\n}> {\n  const defineParams = options.defineParams as\n    | ExtensionBlueprintDefineParams\n    | undefined;\n\n  return {\n    dataRefs: options.dataRefs,\n    make(args) {\n      return createExtension({\n        kind: options.kind,\n        name: args.name,\n        attachTo: args.attachTo ?? options.attachTo,\n        disabled: args.disabled ?? options.disabled,\n        inputs: options.inputs,\n        output: options.output as ExtensionDataRef[],\n        config: options.config,\n        factory: ctx =>\n          options.factory(\n            unwrapParams(args.params, ctx, defineParams, options.kind),\n            ctx,\n          ) as Iterable<ExtensionDataValue<any, any>>,\n      }) as ExtensionDefinition;\n    },\n    makeWithOverrides(args) {\n      return createExtension({\n        kind: options.kind,\n        name: args.name,\n        attachTo: args.attachTo ?? options.attachTo,\n        disabled: args.disabled ?? options.disabled,\n        inputs: { ...args.inputs, ...options.inputs },\n        output: (args.output ?? options.output) as ExtensionDataRef[],\n        config:\n          options.config || args.config\n            ? {\n                schema: {\n                  ...options.config?.schema,\n                  ...args.config?.schema,\n                },\n              }\n            : undefined,\n        factory: ctx => {\n          const { node, config, inputs, apis } = ctx;\n          return args.factory(\n            (innerParams, innerContext) => {\n              return createExtensionDataContainer<\n                UOutput extends ExtensionDataRef<\n                  infer IData,\n                  infer IId,\n                  infer IConfig\n                >\n                  ? ExtensionDataRef<IData, IId, IConfig>\n                  : never\n              >(\n                options.factory(\n                  unwrapParams(innerParams, ctx, defineParams, options.kind),\n                  {\n                    apis,\n                    node,\n                    config: (innerContext?.config ?? config) as any,\n                    inputs: resolveInputOverrides(\n                      options.inputs,\n                      inputs,\n                      innerContext?.inputs,\n                    ) as any,\n                  },\n                ) as Iterable<any>,\n                'original blueprint factory',\n                options.output,\n              );\n            },\n            {\n              apis,\n              node,\n              config: config as any,\n              inputs: inputs as any,\n            },\n          ) as Iterable<ExtensionDataValue<any, any>>;\n        },\n      }) as ExtensionDefinition;\n    },\n  } as ExtensionBlueprint<{\n    kind: TKind;\n    params: TParams;\n    output: any;\n    inputs: string extends keyof TInputs ? {} : TInputs;\n    config: string extends keyof TConfigSchema\n      ? {}\n      : {\n          [key in keyof TConfigSchema]: z.infer<ReturnType<TConfigSchema[key]>>;\n        };\n    configInput: string extends keyof TConfigSchema\n      ? {}\n      : z.input<\n          z.ZodObject<{\n            [key in keyof TConfigSchema]: ReturnType<TConfigSchema[key]>;\n          }>\n        >;\n    dataRefs: TDataRefs;\n  }>;\n}\n"],"names":[],"mappings":"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"}