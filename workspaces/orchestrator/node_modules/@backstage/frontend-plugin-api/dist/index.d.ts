import * as react_jsx_runtime from 'react/jsx-runtime';
import * as react from 'react';
import { ReactNode, JSX as JSX$1, ComponentType } from 'react';
import * as _backstage_core_plugin_api from '@backstage/core-plugin-api';
import { ApiHolder, ConfigApi, ApiRef, TypesToApiRefs, ApiFactory, AnyApiFactory, IconComponent as IconComponent$2, SignInPageProps, AppTheme } from '@backstage/core-plugin-api';
export { AlertApi, AlertMessage, AnyApiFactory, AnyApiRef, ApiFactory, ApiHolder, ApiRef, ApiRefConfig, AppTheme, AppThemeApi, AuthProviderInfo, AuthRequestOptions, BackstageIdentityApi, BackstageIdentityResponse, BackstageUserIdentity, ConfigApi, DiscoveryApi, ErrorApi, ErrorApiError, ErrorApiErrorContext, FeatureFlag, FeatureFlagState, FeatureFlagsApi, FeatureFlagsSaveOptions, FetchApi, IdentityApi, OAuthApi, OAuthRequestApi, OAuthRequester, OAuthRequesterOptions, OAuthScope, OpenIdConnectApi, PendingOAuthRequest, ProfileInfo, ProfileInfoApi, SessionApi, SessionState, StorageApi, StorageValueSnapshot, TypesToApiRefs, alertApiRef, appThemeApiRef, atlassianAuthApiRef, bitbucketAuthApiRef, bitbucketServerAuthApiRef, configApiRef, createApiFactory, createApiRef, discoveryApiRef, errorApiRef, featureFlagsApiRef, fetchApiRef, githubAuthApiRef, gitlabAuthApiRef, googleAuthApiRef, identityApiRef, microsoftAuthApiRef, oauthRequestApiRef, oktaAuthApiRef, oneloginAuthApiRef, openshiftAuthApiRef, storageApiRef, useApi, useApiHolder, vmwareCloudAuthApiRef, withApis } from '@backstage/core-plugin-api';
import { Expand, JsonObject } from '@backstage/types';
import { z } from 'zod';
import * as _backstage_frontend_plugin_api from '@backstage/frontend-plugin-api';
import { IconComponent as IconComponent$1, RouteRef as RouteRef$1 } from '@backstage/frontend-plugin-api';
import { TranslationResource, TranslationMessages } from '@backstage/core-plugin-api/alpha';
export { TranslationMessages, TranslationMessagesOptions, TranslationRef, TranslationRefOptions, TranslationResource, TranslationResourceOptions, createTranslationMessages, createTranslationRef, createTranslationResource, useTranslationRef } from '@backstage/core-plugin-api/alpha';

/**
 * Analytics context envelope.
 *
 * @public
 */
interface AnalyticsContextValue {
    /**
     * The nearest known parent plugin where the event was captured.
     */
    pluginId: string;
    /**
     * The nearest known parent extension where the event was captured.
     */
    extensionId: string;
    [key: string]: string | boolean | number | undefined;
}

/**
 * Provides components in the child react tree an Analytics Context, ensuring
 * all analytics events captured within the context have relevant attributes.
 *
 * @remarks
 *
 * Analytics contexts are additive, meaning the context ultimately emitted with
 * an event is the combination of all contexts in the parent tree.
 *
 * @public
 */
declare const AnalyticsContext: (options: {
    attributes: Partial<AnalyticsContextValue>;
    children: ReactNode;
}) => react_jsx_runtime.JSX.Element;

/** @public */
type ExtensionDataValue<TData, TId extends string> = {
    readonly $$type: '@backstage/ExtensionDataValue';
    readonly id: TId;
    readonly value: TData;
};
/** @public */
type ExtensionDataRef<TData = unknown, TId extends string = string, TConfig extends {
    optional?: true;
} = {
    optional?: true;
}> = {
    readonly $$type: '@backstage/ExtensionDataRef';
    readonly id: TId;
    readonly T: TData;
    readonly config: TConfig;
};
/** @public */
type ExtensionDataRefToValue<TDataRef extends AnyExtensionDataRef> = TDataRef extends ExtensionDataRef<infer IData, infer IId, any> ? ExtensionDataValue<IData, IId> : never;
/**
 * @deprecated Use `ExtensionDataRef` without type parameters instead.
 * @public
 */
type AnyExtensionDataRef = ExtensionDataRef;
/** @public */
interface ConfigurableExtensionDataRef<TData, TId extends string, TConfig extends {
    optional?: true;
} = {}> extends ExtensionDataRef<TData, TId, TConfig> {
    optional(): ConfigurableExtensionDataRef<TData, TId, TConfig & {
        optional: true;
    }>;
    (t: TData): ExtensionDataValue<TData, TId>;
}
/** @public */
declare function createExtensionDataRef<TData>(): {
    with<TId extends string>(options: {
        id: TId;
    }): ConfigurableExtensionDataRef<TData, TId>;
};

/**
 * Catch-all type for route params.
 *
 * @public
 */
type AnyRouteRefParams = {
    [param in string]: string;
} | undefined;

/**
 * Absolute route reference.
 *
 * @remarks
 *
 * See {@link https://backstage.io/docs/plugins/composability#routing-system}.
 *
 * @public
 */
interface RouteRef<TParams extends AnyRouteRefParams = AnyRouteRefParams> {
    readonly $$type: '@backstage/RouteRef';
    readonly T: TParams;
}
/**
 * Create a {@link RouteRef} from a route descriptor.
 *
 * @param config - Description of the route reference to be created.
 * @public
 */
declare function createRouteRef<TParams extends {
    [param in TParamKeys]: string;
} | undefined = undefined, TParamKeys extends string = string>(config?: {
    /** A list of parameter names that the path that this route ref is bound to must contain */
    readonly params?: string extends TParamKeys ? (keyof TParams)[] : TParamKeys[];
    aliasFor?: string;
}): RouteRef<keyof TParams extends never ? undefined : string extends TParamKeys ? TParams : {
    [param in TParamKeys]: string;
}>;

/** @public */
declare const coreExtensionData: {
    reactElement: ConfigurableExtensionDataRef<JSX$1.Element, "core.reactElement", {}>;
    routePath: ConfigurableExtensionDataRef<string, "core.routing.path", {}>;
    routeRef: ConfigurableExtensionDataRef<RouteRef<_backstage_frontend_plugin_api.AnyRouteRefParams>, "core.routing.ref", {}>;
};

/** @public */
interface ExtensionInput<UExtensionData extends ExtensionDataRef<unknown, string, {
    optional?: true;
}>, TConfig extends {
    singleton: boolean;
    optional: boolean;
}> {
    $$type: '@backstage/ExtensionInput';
    extensionData: Array<UExtensionData>;
    config: TConfig;
    replaces?: Array<{
        id: string;
        input: string;
    }>;
}
/** @public */
declare function createExtensionInput<UExtensionData extends ExtensionDataRef<unknown, string, {
    optional?: true;
}>, TConfig extends {
    singleton?: boolean;
    optional?: boolean;
}>(extensionData: Array<UExtensionData>, config?: TConfig & {
    replaces?: Array<{
        id: string;
        input: string;
    }>;
}): ExtensionInput<UExtensionData, {
    singleton: TConfig['singleton'] extends true ? true : false;
    optional: TConfig['optional'] extends true ? true : false;
}>;

/** @ignore */
type ResolvedInputValueOverrides<TInputs extends {
    [inputName in string]: ExtensionInput<ExtensionDataRef, {
        optional: boolean;
        singleton: boolean;
    }>;
} = {
    [inputName in string]: ExtensionInput<ExtensionDataRef, {
        optional: boolean;
        singleton: boolean;
    }>;
}> = Expand<{
    [KName in keyof TInputs as TInputs[KName] extends ExtensionInput<any, {
        optional: infer IOptional extends boolean;
        singleton: boolean;
    }> ? IOptional extends true ? never : KName : never]: TInputs[KName] extends ExtensionInput<infer IDataRefs, {
        optional: boolean;
        singleton: infer ISingleton extends boolean;
    }> ? ISingleton extends true ? Iterable<ExtensionDataRefToValue<IDataRefs>> : Array<Iterable<ExtensionDataRefToValue<IDataRefs>>> : never;
} & {
    [KName in keyof TInputs as TInputs[KName] extends ExtensionInput<any, {
        optional: infer IOptional extends boolean;
        singleton: boolean;
    }> ? IOptional extends true ? KName : never : never]?: TInputs[KName] extends ExtensionInput<infer IDataRefs, {
        optional: boolean;
        singleton: infer ISingleton extends boolean;
    }> ? ISingleton extends true ? Iterable<ExtensionDataRefToValue<IDataRefs>> : Array<Iterable<ExtensionDataRefToValue<IDataRefs>>> : never;
}>;

/** @public */
interface CreateFrontendModuleOptions<TPluginId extends string, TExtensions extends readonly ExtensionDefinition[]> {
    pluginId: TPluginId;
    extensions?: TExtensions;
    featureFlags?: FeatureFlagConfig[];
}
/** @public */
interface FrontendModule {
    readonly $$type: '@backstage/FrontendModule';
    readonly pluginId: string;
}
/**
 * Creates a new module that can be installed in a Backstage app.
 *
 * @remarks
 *
 * Modules are used to add or override extensions for an existing plugin. If a
 * module provides an extension with the same ID as one provided by the plugin,
 * the extension provided by the module will always take precedence.
 *
 * Every module is created for a specific plugin by providing the
 * unique ID of the plugin that the module should be installed for. If that
 * plugin is not present in the app, the module will be ignored and have no
 * effect.
 *
 * For more information on how modules work, see the
 * {@link https://backstage.io/docs/frontend-system/architecture/extension-overrides#creating-a-frontend-module | documentation for modules}
 * in the frontend system documentation.
 *
 * It is recommended to name the module variable of the form `<pluginId>Module<ModuleName>`.
 *
 * @example
 *
 * ```tsx
 * import { createFrontendModule } from '@backstage/frontend-plugin-api';
 *
 * export const exampleModuleCustomPage = createFrontendModule({
 *   pluginId: 'example',
 *   extensions: [
 *     // Overrides the default page for the 'example' plugin
 *     PageBlueprint.make({
 *       path: '/example',
 *       loader: () => import('./CustomPage').then(m => <m.CustomPage />),
 *     }),
 *   ],
 * });
 * ```
 *
 * @public
 */
declare function createFrontendModule<TId extends string, TExtensions extends readonly ExtensionDefinition[]>(options: CreateFrontendModuleOptions<TId, TExtensions>): FrontendModule;

/** @public */
type PortableSchema<TOutput, TInput = TOutput> = {
    parse: (input: TInput) => TOutput;
    schema: JsonObject;
};

/** @public */
interface Extension<TConfig, TConfigInput = TConfig> {
    $$type: '@backstage/Extension';
    readonly id: string;
    readonly attachTo: ExtensionAttachToSpec;
    readonly disabled: boolean;
    readonly configSchema?: PortableSchema<TConfig, TConfigInput>;
}
/** @ignore */
type ResolveExtensionId<TExtension extends ExtensionDefinition, TNamespace extends string> = TExtension extends ExtensionDefinition<{
    kind: infer IKind extends string | undefined;
    name: infer IName extends string | undefined;
    params: any;
}> ? [string] extends [IKind | IName] ? never : (undefined extends IName ? TNamespace : `${TNamespace}/${IName}`) extends infer INamePart extends string ? IKind extends string ? `${IKind}:${INamePart}` : INamePart : never : never;

type CompareChars<A extends string, B extends string> = [A, B] extends [
    `${infer IAHead}${infer IARest}`,
    `${infer IBHead}${infer IBRest}`
] ? IAHead extends IBHead ? IBRest extends '' ? IARest extends '' ? 'eq' : 'gt' : IARest extends '' ? 'lt' : CompareChars<IARest, IBRest> : `0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz` extends `${string}${IAHead}${string}${IBHead}${string}` ? 'lt' : 'gt' : 'eq';
type CompareStrings<A extends string | undefined, B extends string | undefined> = A extends B ? 'eq' : A extends undefined ? 'lt' : B extends undefined ? 'gt' : CompareChars<A & string, B & string>;
type CompareExtensions<A extends ExtensionDefinition, B extends ExtensionDefinition> = CompareStrings<A['T']['kind'], B['T']['kind']> extends 'eq' ? CompareStrings<A['T']['name'], B['T']['name']> : CompareStrings<A['T']['kind'], B['T']['kind']>;
type SortExtensionsInner<TPivot extends ExtensionDefinition, TRest extends readonly ExtensionDefinition[], TLow extends readonly ExtensionDefinition[], THigh extends readonly ExtensionDefinition[]> = TRest extends [
    infer IHead extends ExtensionDefinition,
    ...infer IRest extends readonly ExtensionDefinition[]
] ? CompareExtensions<IHead, TPivot> extends 'lt' ? SortExtensionsInner<TPivot, IRest, [...TLow, IHead], THigh> : SortExtensionsInner<TPivot, IRest, TLow, [...THigh, IHead]> : [low: TLow, high: THigh];
type SortExtensions<T extends readonly ExtensionDefinition[]> = T extends [
    infer IPivot extends ExtensionDefinition,
    ...infer IRest extends readonly ExtensionDefinition[]
] ? SortExtensionsInner<IPivot, IRest, [], []> extends [
    low: infer ILow extends readonly ExtensionDefinition[],
    high: infer IHigh extends readonly ExtensionDefinition[]
] ? [...SortExtensions<ILow>, IPivot, ...SortExtensions<IHigh>] : 'invalid SortExtensionsInner' : [];
type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never;
type PopUnion$1<U> = UnionToIntersection<U extends any ? () => U : never> extends () => infer R ? [next: R, rest: Exclude<U, R>] : undefined;
type UnionToArray<U, T = U, TResult extends T[] = []> = PopUnion$1<U> extends [
    next: infer INext extends T,
    rest: infer IRest extends T
] ? UnionToArray<IRest, T, [INext, ...TResult]> : TResult;
type ExtensionArrayToMap<T extends ExtensionDefinition[], TId extends string, TOut extends {
    [KId in string]: ExtensionDefinition;
} = {}> = T extends [
    infer IHead extends ExtensionDefinition,
    ...infer IRest extends ExtensionDefinition[]
] ? ExtensionArrayToMap<IRest, TId, TOut & {
    [K in ResolveExtensionId<IHead, TId>]: IHead;
}> : TOut extends infer O ? {
    [K in keyof O]: O[K];
} : never;
/** @ignore */
type MakeSortedExtensionsMap<UExtensions extends ExtensionDefinition, TId extends string> = ExtensionArrayToMap<SortExtensions<UnionToArray<UExtensions>>, TId>;

/**
 * Descriptor of a route relative to an absolute {@link RouteRef}.
 *
 * @remarks
 *
 * See {@link https://backstage.io/docs/plugins/composability#routing-system}.
 *
 * @public
 */
interface SubRouteRef<TParams extends AnyRouteRefParams = AnyRouteRefParams> {
    readonly $$type: '@backstage/SubRouteRef';
    readonly T: TParams;
    readonly path: string;
}
/**
 * Used in {@link PathParams} type declaration.
 * @ignore
 */
type ParamPart<S extends string> = S extends `:${infer Param}` ? Param : never;
/**
 * Used in {@link PathParams} type declaration.
 * @ignore
 */
type ParamNames<S extends string> = S extends `${infer Part}/${infer Rest}` ? ParamPart<Part> | ParamNames<Rest> : ParamPart<S>;
/**
 * This utility type helps us infer a Param object type from a string path
 * For example, `/foo/:bar/:baz` inferred to `{ bar: string, baz: string }`
 * @ignore
 */
type PathParams<S extends string> = {
    [name in ParamNames<S>]: string;
};
/**
 * Merges a param object type with an optional params type into a params object.
 * @ignore
 */
type MergeParams<P1 extends {
    [param in string]: string;
}, P2 extends AnyRouteRefParams> = (P1[keyof P1] extends never ? {} : P1) & (P2 extends undefined ? {} : P2);
/**
 * Convert empty params to undefined.
 * @ignore
 */
type TrimEmptyParams<Params extends {
    [param in string]: string;
}> = keyof Params extends never ? undefined : Params;
/**
 * Creates a SubRouteRef type given the desired parameters and parent route parameters.
 * The parameters types are merged together while ensuring that there is no overlap between the two.
 *
 * @ignore
 */
type MakeSubRouteRef<Params extends {
    [param in string]: string;
}, ParentParams extends AnyRouteRefParams> = keyof Params & keyof ParentParams extends never ? SubRouteRef<TrimEmptyParams<MergeParams<Params, ParentParams>>> : never;
/**
 * Create a {@link SubRouteRef} from a route descriptor.
 *
 * @param config - Description of the route reference to be created.
 * @public
 */
declare function createSubRouteRef<Path extends string, ParentParams extends AnyRouteRefParams = never>(config: {
    path: Path;
    parent: RouteRef<ParentParams>;
}): MakeSubRouteRef<PathParams<Path>, ParentParams>;

/**
 * Route descriptor, to be later bound to a concrete route by the app. Used to implement cross-plugin route references.
 *
 * @remarks
 *
 * See {@link https://backstage.io/docs/plugins/composability#routing-system}.
 *
 * @public
 */
interface ExternalRouteRef<TParams extends AnyRouteRefParams = AnyRouteRefParams> {
    readonly $$type: '@backstage/ExternalRouteRef';
    readonly T: TParams;
}
/**
 * Creates a route descriptor, to be later bound to a concrete route by the app. Used to implement cross-plugin route references.
 *
 * @remarks
 *
 * See {@link https://backstage.io/docs/plugins/composability#routing-system}.
 *
 * @param options - Description of the route reference to be created.
 * @public
 */
declare function createExternalRouteRef<TParams extends {
    [param in TParamKeys]: string;
} | undefined = undefined, TParamKeys extends string = string>(options?: {
    /**
     * The parameters that will be provided to the external route reference.
     */
    readonly params?: string extends TParamKeys ? (keyof TParams)[] : TParamKeys[];
    /**
     * The route (typically in another plugin) that this should map to by default.
     *
     * The string is expected to be on the standard `<plugin id>.<route id>` form,
     * for example `techdocs.docRoot`.
     */
    defaultTarget?: string;
}): ExternalRouteRef<keyof TParams extends never ? undefined : string extends TParamKeys ? TParams : {
    [param in TParamKeys]: string;
}>;

/**
 * React hook for constructing URLs to routes.
 *
 * @remarks
 *
 * See {@link https://backstage.io/docs/plugins/composability#routing-system}
 *
 * @param routeRef - The ref to route that should be converted to URL.
 * @returns A function that will in turn return the concrete URL of the `routeRef`, or `undefined` if the route is not available.
 * @public
 */
declare function useRouteRef<TParams extends AnyRouteRefParams>(routeRef: RouteRef<TParams> | SubRouteRef<TParams> | ExternalRouteRef<TParams>): RouteFunc<TParams> | undefined;

/**
 * React hook for retrieving dynamic params from the current URL.
 * @param _routeRef - Ref of the current route.
 * @public
 */
declare function useRouteRefParams<Params extends AnyRouteRefParams>(_routeRef: RouteRef<Params> | SubRouteRef<Params>): Params;

/**
 * Information about the plugin.
 *
 * @public
 * @remarks
 *
 * This interface is intended to be extended via [module
 * augmentation](https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation)
 * in order to add fields that are specific to each project.
 *
 * For example, one might add a `slackChannel` field that is read from the
 * opaque manifest file.
 *
 * See the options for `createApp` for more information about how to
 * customize the parsing of manifest files.
 */
interface FrontendPluginInfo {
    /**
     * The name of the package that implements the plugin.
     */
    packageName?: string;
    /**
     * The version of the plugin, typically the version of the package.json file.
     */
    version?: string;
    /**
     * As short description of the plugin, typically the description field in
     * package.json.
     */
    description?: string;
    /**
     * The owner entity references of the plugin.
     */
    ownerEntityRefs?: string[];
    /**
     * Links related to the plugin.
     */
    links?: Array<{
        title: string;
        url: string;
    }>;
}
/**
 * Options for providing information for a plugin.
 *
 * @public
 */
type FrontendPluginInfoOptions = {
    /**
     * A loader function for the package.json file for the plugin.
     */
    packageJson?: () => Promise<{
        name: string;
    } & JsonObject>;
    /**
     * A loader function for an opaque manifest file for the plugin.
     */
    manifest?: () => Promise<JsonObject>;
};
/**
 * A variant of the {@link FrontendPlugin} interface that can also be used to install overrides for the plugin.
 *
 * @public
 */
interface OverridableFrontendPlugin<TRoutes extends {
    [name in string]: RouteRef | SubRouteRef;
} = {
    [name in string]: RouteRef | SubRouteRef;
}, TExternalRoutes extends {
    [name in string]: ExternalRouteRef;
} = {
    [name in string]: ExternalRouteRef;
}, TExtensionMap extends {
    [id in string]: ExtensionDefinition;
} = {
    [id in string]: ExtensionDefinition;
}> extends FrontendPlugin<TRoutes, TExternalRoutes> {
    getExtension<TId extends keyof TExtensionMap>(id: TId): TExtensionMap[TId];
    withOverrides(options: {
        extensions: Array<ExtensionDefinition>;
        /**
         * Overrides the original info loaders of the plugin one by one.
         */
        info?: FrontendPluginInfoOptions;
    }): OverridableFrontendPlugin<TRoutes, TExternalRoutes, TExtensionMap>;
}
/** @public */
interface FrontendPlugin<TRoutes extends {
    [name in string]: RouteRef | SubRouteRef;
} = {
    [name in string]: RouteRef | SubRouteRef;
}, TExternalRoutes extends {
    [name in string]: ExternalRouteRef;
} = {
    [name in string]: ExternalRouteRef;
}> {
    readonly $$type: '@backstage/FrontendPlugin';
    readonly id: string;
    readonly routes: TRoutes;
    readonly externalRoutes: TExternalRoutes;
    /**
     * Loads the plugin info.
     */
    info(): Promise<FrontendPluginInfo>;
}
/** @public */
interface PluginOptions<TId extends string, TRoutes extends {
    [name in string]: RouteRef | SubRouteRef;
}, TExternalRoutes extends {
    [name in string]: ExternalRouteRef;
}, TExtensions extends readonly ExtensionDefinition[]> {
    pluginId: TId;
    routes?: TRoutes;
    externalRoutes?: TExternalRoutes;
    extensions?: TExtensions;
    featureFlags?: FeatureFlagConfig[];
    info?: FrontendPluginInfoOptions;
}
/**
 * Creates a new plugin that can be installed in a Backstage app.
 *
 * @remarks
 *
 * Every plugin is created with a unique ID and a set of extensions
 * that are installed as part of the plugin.
 *
 * For more information on how plugins work, see the
 * {@link https://backstage.io/docs/frontend-system/building-plugins/index | documentation for plugins}
 * in the frontend system documentation.
 *
 * @example
 *
 * ```tsx
 * import { createFrontendPlugin } from '@backstage/frontend-plugin-api';
 *
 * export const examplePlugin = createFrontendPlugin({
 *   pluginId: 'example',
 *   extensions: [
 *     PageBlueprint.make({
 *       path: '/example',
 *       loader: () => import('./ExamplePage').then(m => <m.ExamplePage />),
 *     }),
 *   ],
 * });
 * ```
 *
 * @public
 */
declare function createFrontendPlugin<TId extends string, TExtensions extends readonly ExtensionDefinition[], TRoutes extends {
    [name in string]: RouteRef | SubRouteRef;
} = {}, TExternalRoutes extends {
    [name in string]: ExternalRouteRef;
} = {}>(options: PluginOptions<TId, TRoutes, TExternalRoutes, TExtensions>): OverridableFrontendPlugin<TRoutes, TExternalRoutes, MakeSortedExtensionsMap<TExtensions[number], TId>>;

/**
 * Feature flag configuration.
 *
 * @public
 */
type FeatureFlagConfig = {
    /** Feature flag name */
    name: string;
};
/** @public */
type ExtensionDataContainer<UExtensionData extends ExtensionDataRef> = Iterable<UExtensionData extends ExtensionDataRef<infer IData, infer IId, infer IConfig> ? IConfig['optional'] extends true ? never : ExtensionDataValue<IData, IId> : never> & {
    get<TId extends UExtensionData['id']>(ref: ExtensionDataRef<any, TId, any>): UExtensionData extends ExtensionDataRef<infer IData, TId, infer IConfig> ? IConfig['optional'] extends true ? IData | undefined : IData : never;
};
/** @public */
type ExtensionFactoryMiddleware = (originalFactory: (contextOverrides?: {
    config?: JsonObject;
}) => ExtensionDataContainer<ExtensionDataRef>, context: {
    node: AppNode;
    apis: ApiHolder;
    config?: JsonObject;
}) => Iterable<ExtensionDataValue<any, any>>;
/** @public  */
type FrontendFeature = FrontendPlugin | FrontendModule;

/**
 * A function used to define a parameter mapping function in order to facilitate
 * advanced parameter typing for extension blueprints.
 *
 * @remarks
 *
 * This function is primarily intended to enable the use of inferred type
 * parameters for blueprint params, but it can also be used to transoform the
 * params before they are handed ot the blueprint.
 *
 * The function must return an object created with
 * {@link createExtensionBlueprintParams}.
 *
 * @public
 */
type ExtensionBlueprintDefineParams<TParams extends object = object, TInput = any> = (params: TInput) => ExtensionBlueprintParams<TParams>;
/**
 * An opaque type that represents a set of parameters to be passed to a blueprint.
 *
 * @remarks
 *
 * Created with {@link createExtensionBlueprintParams}.
 *
 * @public
 */
type ExtensionBlueprintParams<T extends object = object> = {
    $$type: '@backstage/BlueprintParams';
    T: T;
};
/**
 * Wraps a plain blueprint parameter object in an opaque {@link ExtensionBlueprintParams} object.
 *
 * This is used in the definition of the `defineParams` option of {@link ExtensionBlueprint}.
 *
 * @public
 * @param params - The plain blueprint parameter object to wrap.
 * @returns The wrapped blueprint parameter object.
 */
declare function createExtensionBlueprintParams<T extends object = object>(params: T): ExtensionBlueprintParams<T>;
/**
 * @public
 */
type CreateExtensionBlueprintOptions<TKind extends string, TParams extends object | ExtensionBlueprintDefineParams, UOutput extends ExtensionDataRef, TInputs extends {
    [inputName in string]: ExtensionInput<ExtensionDataRef, {
        optional: boolean;
        singleton: boolean;
    }>;
}, TConfigSchema extends {
    [key in string]: (zImpl: typeof z) => z.ZodType;
}, UFactoryOutput extends ExtensionDataValue<any, any>, TDataRefs extends {
    [name in string]: ExtensionDataRef;
}> = {
    kind: TKind;
    attachTo: ExtensionAttachToSpec;
    disabled?: boolean;
    inputs?: TInputs;
    output: Array<UOutput>;
    config?: {
        schema: TConfigSchema;
    };
    /**
     * This option is used to further refine the blueprint params. When this
     * option is used, the blueprint will require params to be passed in callback
     * form. This function can both transform the params before they are handed to
     * the blueprint factory, but importantly it also allows you to define
     * inferred type parameters for your blueprint params.
     *
     * @example
     * Blueprint definition with inferred type parameters:
     * ```ts
     * const ExampleBlueprint = createExtensionBlueprint({
     *   kind: 'example',
     *   attachTo: { id: 'example', input: 'example' },
     *   output: [exampleComponentDataRef, exampleFetcherDataRef],
     *   defineParams<T>(params: {
     *     component(props: ExampleProps<T>): JSX.Element | null
     *     fetcher(options: FetchOptions): Promise<FetchResult<T>>
     *   }) {
     *     return createExtensionBlueprintParams(params);
     *   },
     *   *factory(params) {
     *     yield exampleComponentDataRef(params.component)
     *     yield exampleFetcherDataRef(params.fetcher)
     *   },
     * });
     * ```
     *
     * @example
     * Usage of the above example blueprint:
     * ```ts
     * const example = ExampleBlueprint.make({
     *   params: defineParams => defineParams({
     *     component: ...,
     *     fetcher: ...,
     *   }),
     * });
     * ```
     */
    defineParams?: TParams extends ExtensionBlueprintDefineParams ? TParams : 'The defineParams option must be a function if provided, see the docs for details';
    factory(params: TParams extends ExtensionBlueprintDefineParams ? ReturnType<TParams>['T'] : TParams, context: {
        node: AppNode;
        apis: ApiHolder;
        config: {
            [key in keyof TConfigSchema]: z.infer<ReturnType<TConfigSchema[key]>>;
        };
        inputs: Expand<ResolvedExtensionInputs<TInputs>>;
    }): Iterable<UFactoryOutput>;
    dataRefs?: TDataRefs;
} & VerifyExtensionFactoryOutput<UOutput, UFactoryOutput>;
/** @public */
type ExtensionBlueprintParameters = {
    kind: string;
    params?: object | ExtensionBlueprintDefineParams;
    configInput?: {
        [K in string]: any;
    };
    config?: {
        [K in string]: any;
    };
    output?: ExtensionDataRef;
    inputs?: {
        [KName in string]: ExtensionInput<ExtensionDataRef, {
            optional: boolean;
            singleton: boolean;
        }>;
    };
    dataRefs?: {
        [name in string]: ExtensionDataRef;
    };
};
/** @ignore */
type ParamsFactory<TDefiner extends ExtensionBlueprintDefineParams> = (defineParams: TDefiner) => ReturnType<TDefiner>;
/**
 * Represents any form of params input that can be passed to a blueprint.
 * This also includes the invalid form of passing a plain params object to a blueprint that uses a definition callback.
 *
 * @ignore
 */
type AnyParamsInput$1<TParams extends object | ExtensionBlueprintDefineParams> = TParams extends ExtensionBlueprintDefineParams<infer IParams> ? IParams | ParamsFactory<TParams> : TParams | ParamsFactory<ExtensionBlueprintDefineParams<TParams, TParams>>;
/**
 * @public
 */
interface ExtensionBlueprint<T extends ExtensionBlueprintParameters = ExtensionBlueprintParameters> {
    dataRefs: T['dataRefs'];
    make<TName extends string | undefined, TParamsInput extends AnyParamsInput$1<NonNullable<T['params']>>>(args: {
        name?: TName;
        attachTo?: ExtensionAttachToSpec;
        disabled?: boolean;
        params: TParamsInput extends ExtensionBlueprintDefineParams ? TParamsInput : T['params'] extends ExtensionBlueprintDefineParams ? 'Error: This blueprint uses advanced parameter types and requires you to pass parameters as using the following callback syntax: `<blueprint>.make({ params: defineParams => defineParams(<params>) })`' : T['params'];
    }): ExtensionDefinition<{
        kind: T['kind'];
        name: string | undefined extends TName ? undefined : TName;
        config: T['config'];
        configInput: T['configInput'];
        output: T['output'];
        inputs: T['inputs'];
        params: T['params'];
    }>;
    /**
     * Creates a new extension from the blueprint.
     *
     * You must either pass `params` directly, or define a `factory` that can
     * optionally call the original factory with the same params.
     */
    makeWithOverrides<TName extends string | undefined, TExtensionConfigSchema extends {
        [key in string]: (zImpl: typeof z) => z.ZodType;
    }, UFactoryOutput extends ExtensionDataValue<any, any>, UNewOutput extends ExtensionDataRef, TExtraInputs extends {
        [inputName in string]: ExtensionInput<ExtensionDataRef, {
            optional: boolean;
            singleton: boolean;
        }>;
    }>(args: {
        name?: TName;
        attachTo?: ExtensionAttachToSpec;
        disabled?: boolean;
        inputs?: TExtraInputs & {
            [KName in keyof T['inputs']]?: `Error: Input '${KName & string}' is already defined in parent definition`;
        };
        output?: Array<UNewOutput>;
        config?: {
            schema: TExtensionConfigSchema & {
                [KName in keyof T['config']]?: `Error: Config key '${KName & string}' is already defined in parent schema`;
            };
        };
        factory(originalFactory: <TParamsInput extends AnyParamsInput$1<NonNullable<T['params']>>>(params: TParamsInput extends ExtensionBlueprintDefineParams ? TParamsInput : T['params'] extends ExtensionBlueprintDefineParams ? 'Error: This blueprint uses advanced parameter types and requires you to pass parameters as using the following callback syntax: `originalFactory(defineParams => defineParams(<params>))`' : T['params'], context?: {
            config?: T['config'];
            inputs?: ResolvedInputValueOverrides<NonNullable<T['inputs']>>;
        }) => ExtensionDataContainer<NonNullable<T['output']>>, context: {
            node: AppNode;
            apis: ApiHolder;
            config: T['config'] & {
                [key in keyof TExtensionConfigSchema]: z.infer<ReturnType<TExtensionConfigSchema[key]>>;
            };
            inputs: Expand<ResolvedExtensionInputs<T['inputs'] & TExtraInputs>>;
        }): Iterable<UFactoryOutput> & VerifyExtensionFactoryOutput<ExtensionDataRef extends UNewOutput ? NonNullable<T['output']> : UNewOutput, UFactoryOutput>;
    }): ExtensionDefinition<{
        config: (string extends keyof TExtensionConfigSchema ? {} : {
            [key in keyof TExtensionConfigSchema]: z.infer<ReturnType<TExtensionConfigSchema[key]>>;
        }) & T['config'];
        configInput: (string extends keyof TExtensionConfigSchema ? {} : z.input<z.ZodObject<{
            [key in keyof TExtensionConfigSchema]: ReturnType<TExtensionConfigSchema[key]>;
        }>>) & T['configInput'];
        output: ExtensionDataRef extends UNewOutput ? T['output'] : UNewOutput;
        inputs: T['inputs'] & TExtraInputs;
        kind: T['kind'];
        name: string | undefined extends TName ? undefined : TName;
        params: T['params'];
    }>;
}
/**
 * Creates a new extension blueprint that encapsulates the creation of
 * extensions of particular kinds.
 *
 * @remarks
 *
 * For details on how blueprints work, see the
 * {@link https://backstage.io/docs/frontend-system/architecture/extension-blueprints | documentation for extension blueprints}
 * in the frontend system documentation.
 *
 * Extension blueprints make it much easier for users to create new extensions
 * for your plugin. Rather than letting them use {@link createExtension}
 * directly, you can define a set of parameters and default factory for your
 * blueprint, removing a lot of the boilerplate and complexity that is otherwise
 * needed to create an extension.
 *
 * Each blueprint has its own `kind` that helps identify and group the
 * extensions that have been created with it. For example the
 * {@link PageBlueprint} has the kind `'page'`, and extensions created with it
 * will be given the ID `'page:<plugin-id>[/<name>]'`. Blueprints should always
 * be exported as `<PascalCaseKind>Blueprint`.
 *
 * When creating a blueprint the type of the parameters are inferred from the
 * `factory` function that you provide. The exception to that is when you need
 * your blueprint to include inferred type parameters, in which case you need to
 * use the `defineParams` option. See the documentation for the `defineParams`
 * option for more details on how that works.
 *
 * @example
 * ```tsx
 * // In your plugin library
 * export const GreetingBlueprint = createExtensionBlueprint({
 *   kind: 'greeting',
 *   attachTo: { id: 'example', input: 'greetings' },
 *   output: [coreExtensionData.reactElement],
 *   factory(params: { greeting: string }) {
 *     return [coreExtensionData.reactElement(<h1>{params.greeting}</h1>)];
 *   },
 * });
 *
 * // Someone using your blueprint in their plugin
 * const exampleGreeting = GreetingBlueprint.make({
 *   params: {
 *     greeting: 'Hello, world!',
 *   },
 * });
 * ```
 * @public
 */
declare function createExtensionBlueprint<TParams extends object | ExtensionBlueprintDefineParams, UOutput extends ExtensionDataRef, TInputs extends {
    [inputName in string]: ExtensionInput<ExtensionDataRef, {
        optional: boolean;
        singleton: boolean;
    }>;
}, TConfigSchema extends {
    [key in string]: (zImpl: typeof z) => z.ZodType;
}, UFactoryOutput extends ExtensionDataValue<any, any>, TKind extends string, TDataRefs extends {
    [name in string]: ExtensionDataRef;
} = never>(options: CreateExtensionBlueprintOptions<TKind, TParams, UOutput, TInputs, TConfigSchema, UFactoryOutput, TDataRefs>): ExtensionBlueprint<{
    kind: TKind;
    params: TParams;
    output: UOutput extends ExtensionDataRef<infer IData, infer IId, infer IConfig> ? ExtensionDataRef<IData, IId, IConfig> : never;
    inputs: string extends keyof TInputs ? {} : TInputs;
    config: string extends keyof TConfigSchema ? {} : {
        [key in keyof TConfigSchema]: z.infer<ReturnType<TConfigSchema[key]>>;
    };
    configInput: string extends keyof TConfigSchema ? {} : z.input<z.ZodObject<{
        [key in keyof TConfigSchema]: ReturnType<TConfigSchema[key]>;
    }>>;
    dataRefs: TDataRefs;
}>;

/**
 * Convert a single extension input into a matching resolved input.
 * @public
 */
type ResolvedExtensionInput<TExtensionInput extends ExtensionInput<any, any>> = TExtensionInput['extensionData'] extends Array<ExtensionDataRef> ? {
    node: AppNode;
} & ExtensionDataContainer<TExtensionInput['extensionData'][number]> : never;
/**
 * Converts an extension input map into a matching collection of resolved inputs.
 * @public
 */
type ResolvedExtensionInputs<TInputs extends {
    [name in string]: ExtensionInput<any, any>;
}> = {
    [InputName in keyof TInputs]: false extends TInputs[InputName]['config']['singleton'] ? Array<Expand<ResolvedExtensionInput<TInputs[InputName]>>> : false extends TInputs[InputName]['config']['optional'] ? Expand<ResolvedExtensionInput<TInputs[InputName]>> : Expand<ResolvedExtensionInput<TInputs[InputName]> | undefined>;
};
type ToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never;
type PopUnion<U> = ToIntersection<U extends any ? () => U : never> extends () => infer R ? [rest: Exclude<U, R>, next: R] : undefined;
/** @ignore */
type JoinStringUnion<U, TDiv extends string = ', ', TResult extends string = ''> = PopUnion<U> extends [infer IRest extends string, infer INext extends string] ? TResult extends '' ? JoinStringUnion<IRest, TDiv, INext> : JoinStringUnion<IRest, TDiv, `${TResult}${TDiv}${INext}`> : TResult;
/** @ignore */
type VerifyExtensionFactoryOutput<UDeclaredOutput extends ExtensionDataRef, UFactoryOutput extends ExtensionDataValue<any, any>> = (UDeclaredOutput extends any ? UDeclaredOutput['config']['optional'] extends true ? never : UDeclaredOutput['id'] : never) extends infer IRequiredOutputIds ? [IRequiredOutputIds] extends [UFactoryOutput['id']] ? [UFactoryOutput['id']] extends [UDeclaredOutput['id']] ? {} : `Error: The extension factory has undeclared output(s): ${JoinStringUnion<Exclude<UFactoryOutput['id'], UDeclaredOutput['id']>>}` : `Error: The extension factory is missing the following output(s): ${JoinStringUnion<Exclude<IRequiredOutputIds, UFactoryOutput['id']>>}` : never;
/** @public */
type ExtensionAttachToSpec = {
    id: string;
    input: string;
} | Array<{
    id: string;
    input: string;
}>;
/** @public */
type CreateExtensionOptions<TKind extends string | undefined, TName extends string | undefined, UOutput extends ExtensionDataRef, TInputs extends {
    [inputName in string]: ExtensionInput<ExtensionDataRef, {
        optional: boolean;
        singleton: boolean;
    }>;
}, TConfigSchema extends {
    [key: string]: (zImpl: typeof z) => z.ZodType;
}, UFactoryOutput extends ExtensionDataValue<any, any>> = {
    kind?: TKind;
    name?: TName;
    attachTo: ExtensionAttachToSpec;
    disabled?: boolean;
    inputs?: TInputs;
    output: Array<UOutput>;
    config?: {
        schema: TConfigSchema;
    };
    factory(context: {
        node: AppNode;
        apis: ApiHolder;
        config: {
            [key in keyof TConfigSchema]: z.infer<ReturnType<TConfigSchema[key]>>;
        };
        inputs: Expand<ResolvedExtensionInputs<TInputs>>;
    }): Iterable<UFactoryOutput>;
} & VerifyExtensionFactoryOutput<UOutput, UFactoryOutput>;
/** @public */
type ExtensionDefinitionParameters = {
    kind?: string;
    name?: string;
    configInput?: {
        [K in string]: any;
    };
    config?: {
        [K in string]: any;
    };
    output?: ExtensionDataRef;
    inputs?: {
        [KName in string]: ExtensionInput<ExtensionDataRef, {
            optional: boolean;
            singleton: boolean;
        }>;
    };
    params?: object | ExtensionBlueprintDefineParams;
};
/**
 * Same as the one in `createExtensionBlueprint`, but with `ParamsFactory` inlined.
 * It can't be exported because it breaks API reports.
 * @ignore
 */
type AnyParamsInput<TParams extends object | ExtensionBlueprintDefineParams> = TParams extends ExtensionBlueprintDefineParams<infer IParams> ? IParams | ((define: TParams) => ReturnType<TParams>) : TParams | ((define: ExtensionBlueprintDefineParams<TParams, TParams>) => ReturnType<ExtensionBlueprintDefineParams<TParams, TParams>>);
/** @public */
type ExtensionDefinition<T extends ExtensionDefinitionParameters = ExtensionDefinitionParameters> = {
    $$type: '@backstage/ExtensionDefinition';
    readonly T: T;
    override<TExtensionConfigSchema extends {
        [key in string]: (zImpl: typeof z) => z.ZodType;
    }, UFactoryOutput extends ExtensionDataValue<any, any>, UNewOutput extends ExtensionDataRef, TExtraInputs extends {
        [inputName in string]: ExtensionInput<ExtensionDataRef, {
            optional: boolean;
            singleton: boolean;
        }>;
    }, TParamsInput extends AnyParamsInput<NonNullable<T['params']>>>(args: Expand<{
        attachTo?: ExtensionAttachToSpec;
        disabled?: boolean;
        inputs?: TExtraInputs & {
            [KName in keyof T['inputs']]?: `Error: Input '${KName & string}' is already defined in parent definition`;
        };
        output?: Array<UNewOutput>;
        config?: {
            schema: TExtensionConfigSchema & {
                [KName in keyof T['config']]?: `Error: Config key '${KName & string}' is already defined in parent schema`;
            };
        };
        factory?(originalFactory: <TFactoryParamsReturn extends AnyParamsInput<NonNullable<T['params']>>>(context?: Expand<{
            config?: T['config'];
            inputs?: ResolvedInputValueOverrides<NonNullable<T['inputs']>>;
        } & ([T['params']] extends [never] ? {} : {
            params?: TFactoryParamsReturn extends ExtensionBlueprintDefineParams ? TFactoryParamsReturn : T['params'] extends ExtensionBlueprintDefineParams ? 'Error: This blueprint uses advanced parameter types and requires you to pass parameters as using the following callback syntax: `originalFactory(defineParams => defineParams(<params>))`' : Partial<T['params']>;
        })>) => ExtensionDataContainer<NonNullable<T['output']>>, context: {
            node: AppNode;
            apis: ApiHolder;
            config: T['config'] & {
                [key in keyof TExtensionConfigSchema]: z.infer<ReturnType<TExtensionConfigSchema[key]>>;
            };
            inputs: Expand<ResolvedExtensionInputs<T['inputs'] & TExtraInputs>>;
        }): Iterable<UFactoryOutput>;
    } & ([T['params']] extends [never] ? {} : {
        params?: TParamsInput extends ExtensionBlueprintDefineParams ? TParamsInput : T['params'] extends ExtensionBlueprintDefineParams ? 'Error: This blueprint uses advanced parameter types and requires you to pass parameters as using the following callback syntax: `originalFactory(defineParams => defineParams(<params>))`' : Partial<T['params']>;
    })> & VerifyExtensionFactoryOutput<ExtensionDataRef extends UNewOutput ? NonNullable<T['output']> : UNewOutput, UFactoryOutput>): ExtensionDefinition<{
        kind: T['kind'];
        name: T['name'];
        output: ExtensionDataRef extends UNewOutput ? T['output'] : UNewOutput;
        inputs: T['inputs'] & TExtraInputs;
        config: T['config'] & {
            [key in keyof TExtensionConfigSchema]: z.infer<ReturnType<TExtensionConfigSchema[key]>>;
        };
        configInput: T['configInput'] & z.input<z.ZodObject<{
            [key in keyof TExtensionConfigSchema]: ReturnType<TExtensionConfigSchema[key]>;
        }>>;
    }>;
};
/**
 * Creates a new extension definition for installation in a Backstage app.
 *
 * @remarks
 *
 * This is a low-level function for creation of extensions with arbitrary inputs
 * and outputs and is typically only intended to be used for advanced overrides
 * or framework-level extensions. For most extension creation needs, it is
 * recommended to use existing {@link ExtensionBlueprint}s instead. You can find
 * blueprints both in the `@backstage/frontend-plugin-api` package as well as
 * other plugin libraries. There is also a list of
 * {@link https://backstage.io/docs/frontend-system/building-plugins/common-extension-blueprints | commonly used blueprints}
 * in the frontend system documentation.
 *
 * Extension definitions that are created with this function can be installed in
 * a Backstage app via a {@link FrontendPlugin} or {@link FrontendModule}.
 *
 * For more details on how extensions work, see the
 * {@link https://backstage.io/docs/frontend-system/architecture/extensions | documentation for extensions}.
 *
 * @example
 *
 * ```ts
 * const myExtension = createExtension({
 *   name: 'example',
 *   attachTo: { id: 'app', input: 'root' },
 *   output: [coreExtensionData.reactElement],
 *   factory() {
 *     return [coreExtensionData.reactElement(<h1>Hello, world!</h1>)];
 *   },
 * });
 * ```
 *
 * @public
 */
declare function createExtension<UOutput extends ExtensionDataRef, TInputs extends {
    [inputName in string]: ExtensionInput<ExtensionDataRef, {
        optional: boolean;
        singleton: boolean;
    }>;
}, TConfigSchema extends {
    [key: string]: (zImpl: typeof z) => z.ZodType;
}, UFactoryOutput extends ExtensionDataValue<any, any>, const TKind extends string | undefined = undefined, const TName extends string | undefined = undefined>(options: CreateExtensionOptions<TKind, TName, UOutput, TInputs, TConfigSchema, UFactoryOutput>): ExtensionDefinition<{
    config: string extends keyof TConfigSchema ? {} : {
        [key in keyof TConfigSchema]: z.infer<ReturnType<TConfigSchema[key]>>;
    };
    configInput: string extends keyof TConfigSchema ? {} : z.input<z.ZodObject<{
        [key in keyof TConfigSchema]: ReturnType<TConfigSchema[key]>;
    }>>;
    output: UOutput extends ExtensionDataRef<infer IData, infer IId, infer IConfig> ? ExtensionDataRef<IData, IId, IConfig> : never;
    inputs: TInputs;
    params: never;
    kind: string | undefined extends TKind ? undefined : TKind;
    name: string | undefined extends TName ? undefined : TName;
}>;

/** @public */
interface CreateFrontendFeatureLoaderOptions {
    loader(deps: {
        config: ConfigApi;
    }): Iterable<FrontendFeature | FrontendFeatureLoader | Promise<{
        default: FrontendFeature | FrontendFeatureLoader;
    }>> | Promise<Iterable<FrontendFeature | FrontendFeatureLoader | Promise<{
        default: FrontendFeature | FrontendFeatureLoader;
    }>>> | AsyncIterable<FrontendFeature | FrontendFeatureLoader | {
        default: FrontendFeature | FrontendFeatureLoader;
    }>;
}
/** @public */
interface FrontendFeatureLoader {
    readonly $$type: '@backstage/FrontendFeatureLoader';
}
/** @public */
declare function createFrontendFeatureLoader(options: CreateFrontendFeatureLoaderOptions): FrontendFeatureLoader;

/**
 * The specification for this {@link AppNode} in the {@link AppTree}.
 *
 * @public
 * @remarks
 *
 * The specifications for a collection of app nodes is all the information needed
 * to build the tree and instantiate the nodes.
 */
interface AppNodeSpec {
    readonly id: string;
    readonly attachTo: ExtensionAttachToSpec;
    readonly extension: Extension<unknown, unknown>;
    readonly disabled: boolean;
    readonly config?: unknown;
    readonly plugin: FrontendPlugin;
}
/**
 * The connections from this {@link AppNode} to other nodes.
 *
 * @public
 * @remarks
 *
 * The app node edges are resolved based on the app node specs, regardless of whether
 * adjacent nodes are disabled or not. If no parent attachment is present or
 */
interface AppNodeEdges {
    readonly attachedTo?: {
        node: AppNode;
        input: string;
    };
    readonly attachments: ReadonlyMap<string, AppNode[]>;
}
/**
 * The instance of this {@link AppNode} in the {@link AppTree}.
 *
 * @public
 * @remarks
 *
 * The app node instance is created when the `factory` function of an extension is called.
 * Instances will only be present for nodes in the app that are connected to the root
 * node and not disabled
 */
interface AppNodeInstance {
    /** Returns a sequence of all extension data refs that were output by this instance */
    getDataRefs(): Iterable<ExtensionDataRef<unknown>>;
    /** Get the output data for a single extension data ref */
    getData<T>(ref: ExtensionDataRef<T>): T | undefined;
}
/**
 * A node in the {@link AppTree}.
 *
 * @public
 */
interface AppNode {
    /** The specification for how this node should be instantiated */
    readonly spec: AppNodeSpec;
    /** The edges from this node to other nodes in the app tree */
    readonly edges: AppNodeEdges;
    /** The instance of this node, if it was instantiated */
    readonly instance?: AppNodeInstance;
}
/**
 * The app tree containing all {@link AppNode}s of the app.
 *
 * @public
 */
interface AppTree {
    /** The root node of the app */
    readonly root: AppNode;
    /** A map of all nodes in the app by ID, including orphaned or disabled nodes */
    readonly nodes: ReadonlyMap<string, AppNode>;
    /** A sequence of all nodes with a parent that is not reachable from the app root node */
    readonly orphans: Iterable<AppNode>;
}
/**
 * The API for interacting with the {@link AppTree}.
 *
 * @public
 */
interface AppTreeApi {
    /**
     * Get the {@link AppTree} for the app.
     */
    getTree(): {
        tree: AppTree;
    };
    /**
     * Get all nodes in the app that are mounted at a given route path.
     */
    getNodesByRoutePath(routePath: string): {
        nodes: AppNode[];
    };
}
/**
 * The `ApiRef` of {@link AppTreeApi}.
 *
 * @public
 */
declare const appTreeApiRef: _backstage_core_plugin_api.ApiRef<AppTreeApi>;

/** @public */
interface ExtensionBoundaryProps {
    node: AppNode;
    children: ReactNode;
}
/** @public */
declare function ExtensionBoundary(props: ExtensionBoundaryProps): react_jsx_runtime.JSX.Element;
/** @public */
declare namespace ExtensionBoundary {
    function lazy(appNode: AppNode, loader: () => Promise<JSX.Element>): JSX.Element;
    function lazyComponent<TProps extends {}>(appNode: AppNode, loader: () => Promise<(props: TProps) => JSX.Element>): (props: TProps) => JSX.Element;
}

/** @public */
type SwappableComponentRef<TInnerComponentProps extends {} = {}, TExternalComponentProps extends {} = TInnerComponentProps> = {
    id: string;
    TProps: TInnerComponentProps;
    TExternalProps: TExternalComponentProps;
    $$type: '@backstage/SwappableComponentRef';
};
/**
 * Options for creating an SwappableComponent.
 *
 * @public
 */
type CreateSwappableComponentOptions<TInnerComponentProps extends {}, TExternalComponentProps extends {} = TInnerComponentProps> = {
    id: string;
    loader?: (() => (props: TInnerComponentProps) => JSX.Element | null) | (() => Promise<(props: TInnerComponentProps) => JSX.Element | null>);
    transformProps?: (props: TExternalComponentProps) => TInnerComponentProps;
};
/**
 * Creates a SwappableComponent that can be used to render the component, optionally overridden by the app.
 *
 * @public
 */
declare function createSwappableComponent<TInnerComponentProps extends {}, TExternalComponentProps extends {} = TInnerComponentProps>(options: CreateSwappableComponentOptions<TInnerComponentProps, TExternalComponentProps>): {
    (props: TExternalComponentProps): JSX.Element | null;
    ref: SwappableComponentRef<TInnerComponentProps, TExternalComponentProps>;
};

/**
 * React hook providing access to the current {@link AppNode}.
 *
 * @public
 * @remarks
 *
 * This hook will return the {@link AppNode} for the closest extension. This
 * relies on the extension using the {@link (ExtensionBoundary:function)} component in its
 * implementation, which is included by default for all common blueprints.
 *
 * If the current component is not inside an {@link (ExtensionBoundary:function)}, it will
 * return `undefined`.
 */
declare function useAppNode(): AppNode | undefined;

/** @public */
type ProgressProps = {};
/** @public */
type NotFoundErrorPageProps = {
    children?: ReactNode;
};
/** @public */
type ErrorDisplayProps = {
    plugin?: FrontendPlugin;
    error: Error;
    resetError: () => void;
};

/**
 * @public
 */
declare const Progress: {
    (props: ProgressProps): JSX.Element | null;
    ref: SwappableComponentRef<ProgressProps, ProgressProps>;
};
/**
 * @public
 */
declare const NotFoundErrorPage: {
    (props: NotFoundErrorPageProps): JSX.Element | null;
    ref: SwappableComponentRef<NotFoundErrorPageProps, NotFoundErrorPageProps>;
};
/**
 * @public
 */
declare const ErrorDisplay: {
    (props: ErrorDisplayProps): JSX.Element | null;
    ref: SwappableComponentRef<ErrorDisplayProps, ErrorDisplayProps>;
};

/**
 * API for looking up components based on component refs.
 *
 * @public
 */
interface SwappableComponentsApi {
    getComponent<TInnerComponentProps extends {}, TExternalComponentProps extends {} = TInnerComponentProps>(ref: SwappableComponentRef<TInnerComponentProps, TExternalComponentProps>): (props: TInnerComponentProps) => JSX.Element | null;
}
/**
 * The `ApiRef` of {@link SwappableComponentsApi}.
 *
 * @public
 */
declare const swappableComponentsApiRef: _backstage_core_plugin_api.ApiRef<SwappableComponentsApi>;

/**
 * IconComponent is the common icon type used throughout Backstage when
 * working with and rendering generic icons, including the app system icons.
 *
 * @remarks
 *
 * The type is based on SvgIcon from Material UI, but we do not want the plugin-api
 * package to have a dependency on Material UI, nor do we want the props to be as broad
 * as the SvgIconProps interface.
 *
 * If you have the need to forward additional props from SvgIconProps, you can
 * open an issue or submit a PR to the main Backstage repo. When doing so please
 * also describe your use-case and reasoning of the addition.
 *
 * @public
 */
type IconComponent = ComponentType<{
    fontSize?: 'medium' | 'large' | 'small' | 'inherit';
}>;

/**
 * API for accessing app icons.
 *
 * @public
 */
interface IconsApi {
    getIcon(key: string): IconComponent | undefined;
    listIconKeys(): string[];
}
/**
 * The `ApiRef` of {@link IconsApi}.
 *
 * @public
 */
declare const iconsApiRef: _backstage_core_plugin_api.ApiRef<IconsApi>;

/**
 * A handle for an open dialog that can be used to interact with it.
 *
 * @remarks
 *
 * Dialogs can be opened using either {@link DialogApi.show} or {@link DialogApi.showModal}.
 *
 * @public
 */
interface DialogApiDialog<TResult = void> {
    /**
     * Closes the dialog with that provided result.
     *
     * @remarks
     *
     * If the dialog is a modal dialog a result must always be provided. If it's a regular dialog then passing a result is optional.
     */
    close(...args: undefined extends TResult ? [result?: TResult] : [result: TResult]): void;
    /**
     * Replaces the content of the dialog with the provided element or component, causing it to be rerenedered.
     */
    update(elementOrComponent: React.JSX.Element | ((props: {
        dialog: DialogApiDialog<TResult>;
    }) => JSX.Element)): void;
    /**
     * Wait until the dialog is closed and return the result.
     *
     * @remarks
     *
     * If the dialog is a modal dialog a result will always be returned. If it's a regular dialog then the result may be `undefined`.
     */
    result(): Promise<TResult>;
}
/**
 * A Utility API for showing dialogs that render in the React tree and return a result.
 *
 * @public
 */
interface DialogApi {
    /**
     * Opens a modal dialog and returns a handle to it.
     *
     * @remarks
     *
     * This dialog can be closed by calling the `close` method on the returned handle, optionally providing a result.
     * The dialog can also be closed by the user by clicking the backdrop or pressing the escape key.
     *
     * If the dialog is closed without a result, the result will be `undefined`.
     *
     * @example
     *
     * ### Example with inline dialog content
     * ```tsx
     * const dialog = dialogApi.show<boolean>(
     *   <DialogContent>
     *     <DialogTitle>Are you sure?</DialogTitle>
     *     <DialogActions>
     *       <Button onClick={() => dialog.close(true)}>Yes</Button>
     *       <Button onClick={() => dialog.close(false)}>No</Button>
     *     </DialogActions>
     *   </DialogContent>
     * );
     * const result = await dialog.result();
     * ```
     *
     * @example
     *
     * ### Example with separate dialog component
     * ```tsx
     * function CustomDialog({ dialog }: { dialog: DialogApiDialog<boolean | undefined> }) {
     *   return (
     *     <DialogContent>
     *       <DialogTitle>Are you sure?</DialogTitle>
     *       <DialogActions>
     *         <Button onClick={() => dialog.close(true)}>Yes</Button>
     *         <Button onClick={() => dialog.close(false)}>No</Button>
     *       </DialogActions>
     *     </DialogContent>
     *   )
     * }
     * const result = await dialogApi.show(CustomDialog).result();
     * ```
     *
     * @param elementOrComponent - The element or component to render in the dialog. If a component is provided, it will be provided with a `dialog` prop that contains the dialog handle.
     * @public
     */
    show<TResult = void>(elementOrComponent: JSX.Element | ((props: {
        dialog: DialogApiDialog<TResult | undefined>;
    }) => JSX.Element)): DialogApiDialog<TResult | undefined>;
    /**
     * Opens a modal dialog and returns a handle to it.
     *
     * @remarks
     *
     * This dialog can not be closed in any other way than calling the `close` method on the returned handle and providing a result.
     *
     * @example
     *
     * ### Example with inline dialog content
     * ```tsx
     * const dialog = dialogApi.showModal<boolean>(
     *   <DialogContent>
     *     <DialogTitle>Are you sure?</DialogTitle>
     *     <DialogActions>
     *       <Button onClick={() => dialog.close(true)}>Yes</Button>
     *       <Button onClick={() => dialog.close(false)}>No</Button>
     *     </DialogActions>
     *   </DialogContent>
     * );
     * const result = await dialog.result();
     * ```
     *
     * @example
     *
     * ### Example with separate dialog component
     * ```tsx
     * function CustomDialog({ dialog }: { dialog: DialogApiDialog<boolean> }) {
     *   return (
     *     <DialogContent>
     *       <DialogTitle>Are you sure?</DialogTitle>
     *       <DialogActions>
     *         <Button onClick={() => dialog.close(true)}>Yes</Button>
     *         <Button onClick={() => dialog.close(false)}>No</Button>
     *       </DialogActions>
     *     </DialogContent>
     *   )
     * }
     * const result = await dialogApi.showModal(CustomDialog).result();
     * ```
     *
     * @param elementOrComponent - The element or component to render in the dialog. If a component is provided, it will be provided with a `dialog` prop that contains the dialog handle.
     * @public
     */
    showModal<TResult = void>(elementOrComponent: JSX.Element | ((props: {
        dialog: DialogApiDialog<TResult>;
    }) => JSX.Element)): DialogApiDialog<TResult>;
}
/**
 * The `ApiRef` of {@link DialogApi}.
 *
 * @public
 */
declare const dialogApiRef: _backstage_core_plugin_api.ApiRef<DialogApi>;

/**
 * TS magic for handling route parameters.
 *
 * @remarks
 *
 * The extra TS magic here is to require a single params argument if the RouteRef
 * had at least one param defined, but require 0 arguments if there are no params defined.
 * Without this we'd have to pass in empty object to all parameter-less RouteRefs
 * just to make TypeScript happy, or we would have to make the argument optional in
 * which case you might forget to pass it in when it is actually required.
 *
 * @public
 */
type RouteFunc<TParams extends AnyRouteRefParams> = (...[params]: TParams extends undefined ? readonly [] : readonly [params: TParams]) => string;
/**
 * @public
 */
interface RouteResolutionApi {
    resolve<TParams extends AnyRouteRefParams>(anyRouteRef: RouteRef<TParams> | SubRouteRef<TParams> | ExternalRouteRef<TParams>, options?: {
        /**
         * An absolute path to use as a starting point when resolving the route.
         * If no path is provided the route will be resolved from the root of the app.
         */
        sourcePath?: string;
    }): RouteFunc<TParams> | undefined;
}
/**
 * The `ApiRef` of {@link RouteResolutionApi}.
 *
 * @public
 */
declare const routeResolutionApiRef: _backstage_core_plugin_api.ApiRef<RouteResolutionApi>;

/**
 * Represents an event worth tracking in an analytics system that could inform
 * how users of a Backstage instance are using its features.
 *
 * @public
 */
type AnalyticsEvent = {
    /**
     * A string that identifies the event being tracked by the type of action the
     * event represents. Be careful not to encode extra metadata in this string
     * that should instead be placed in the Analytics Context or attributes.
     * Examples include:
     *
     * - view
     * - click
     * - filter
     * - search
     * - hover
     * - scroll
     */
    action: string;
    /**
     * A string that uniquely identifies the object that the action is being
     * taken on. Examples include:
     *
     * - The path of the page viewed
     * - The url of the link clicked
     * - The value that was filtered by
     * - The text that was searched for
     */
    subject: string;
    /**
     * An optional numeric value relevant to the event that could be aggregated
     * by analytics tools. Examples include:
     *
     * - The index or position of the clicked element in an ordered list
     * - The percentage of an element that has been scrolled through
     * - The amount of time that has elapsed since a fixed point
     * - A satisfaction score on a fixed scale
     */
    value?: number;
    /**
     * Optional, additional attributes (representing dimensions or metrics)
     * specific to the event that could be forwarded on to analytics systems.
     */
    attributes?: AnalyticsEventAttributes;
    /**
     * Contextual metadata relating to where the event was captured and by whom.
     * This could include information about the route, plugin, or extension in
     * which an event was captured.
     */
    context: AnalyticsContextValue;
};
/**
 * A structure allowing other arbitrary metadata to be provided by analytics
 * event emitters.
 *
 * @public
 */
type AnalyticsEventAttributes = {
    [attribute in string]: string | boolean | number;
};
/**
 * Represents a tracker with methods that can be called to track events in a
 * configured analytics service.
 *
 * @public
 */
type AnalyticsTracker = {
    captureEvent: (action: string, subject: string, options?: {
        value?: number;
        attributes?: AnalyticsEventAttributes;
    }) => void;
};
/**
 * Analytics implementations are used to track user behavior in a Backstage
 * instance.
 *
 * @remarks
 *
 * To instrument your App or Plugin, retrieve an analytics tracker using the
 * `useAnalytics()` hook. This will return a pre-configured `AnalyticsTracker`
 * with relevant methods for instrumentation.
 *
 * @public
 */
type AnalyticsImplementation = {
    /**
     * Primary event handler responsible for compiling and forwarding events to
     * an analytics system.
     */
    captureEvent(event: AnalyticsEvent): void;
};
/**
 * The Analytics API is used to track user behavior in a Backstage instance.
 *
 * @remarks
 *
 * To instrument your App or Plugin, retrieve an analytics tracker using the
 * useAnalytics() hook. This will return a pre-configured AnalyticsTracker
 * with relevant methods for instrumentation.
 *
 * @public
 */
type AnalyticsApi = {
    /**
     * Primary event handler responsible for compiling and forwarding events to
     * an analytics system.
     */
    captureEvent(event: AnalyticsEvent): void;
};
/**
 * The API reference of {@link AnalyticsApi}.
 *
 * @remarks
 *
 * To define a concrete Analytics Implementation, use
 * {@link AnalyticsImplementationBlueprint} instead.
 *
 * @public
 */
declare const analyticsApiRef: ApiRef<AnalyticsApi>;

/**
 * Gets a pre-configured analytics tracker.
 *
 * @public
 */
declare function useAnalytics(): AnalyticsTracker;

/** @public */
type AnalyticsImplementationFactory<Deps extends {
    [name in string]: unknown;
} = {}> = {
    deps: TypesToApiRefs<Deps>;
    factory(deps: Deps): AnalyticsImplementation;
};
/**
 * Creates analytics implementations.
 *
 * @public
 */
declare const AnalyticsImplementationBlueprint: ExtensionBlueprint<{
    kind: "analytics";
    params: <TDeps extends { [name in string]: unknown; }>(params: AnalyticsImplementationFactory<TDeps>) => ExtensionBlueprintParams<AnalyticsImplementationFactory<{}>>;
    output: ExtensionDataRef<AnalyticsImplementationFactory<{}>, "core.analytics.factory", {}>;
    inputs: {};
    config: {};
    configInput: {};
    dataRefs: {
        factory: ConfigurableExtensionDataRef<AnalyticsImplementationFactory<{}>, "core.analytics.factory", {}>;
    };
}>;

/**
 * Creates utility API extensions.
 *
 * @public
 */
declare const ApiBlueprint: ExtensionBlueprint<{
    kind: "api";
    params: <TApi, TImpl extends TApi, TDeps extends { [name in string]: unknown; }>(params: ApiFactory<TApi, TImpl, TDeps>) => ExtensionBlueprintParams<AnyApiFactory>;
    output: ExtensionDataRef<AnyApiFactory, "core.api.factory", {}>;
    inputs: {};
    config: {};
    configInput: {};
    dataRefs: {
        factory: ConfigurableExtensionDataRef<AnyApiFactory, "core.api.factory", {}>;
    };
}>;

/**
 * Creates extensions that render a React element at the app root, outside of
 * the app layout. This is useful for example for shared popups and similar.
 *
 * @public
 */
declare const AppRootElementBlueprint: ExtensionBlueprint<{
    kind: "app-root-element";
    params: {
        element: JSX.Element;
    };
    output: ExtensionDataRef<react.JSX.Element, "core.reactElement", {}>;
    inputs: {};
    config: {};
    configInput: {};
    dataRefs: never;
}>;

/**
 * Creates a extensions that render a React wrapper at the app root, enclosing
 * the app layout. This is useful for example for adding global React contexts
 * and similar.
 *
 * @public
 */
declare const AppRootWrapperBlueprint: ExtensionBlueprint<{
    kind: "app-root-wrapper";
    params: {
        /** @deprecated use the `component` parameter instead */
        Component?: [error: "Use the `component` parameter instead"];
        component: (props: {
            children: ReactNode;
        }) => JSX.Element | null;
    };
    output: ExtensionDataRef<(props: {
        children: ReactNode;
    }) => JSX.Element | null, "app.root.wrapper", {}>;
    inputs: {};
    config: {};
    configInput: {};
    dataRefs: {
        component: ConfigurableExtensionDataRef<(props: {
            children: ReactNode;
        }) => JSX.Element | null, "app.root.wrapper", {}>;
    };
}>;

/** @public */
declare const IconBundleBlueprint: ExtensionBlueprint<{
    kind: "icon-bundle";
    params: {
        icons: { [key in string]: IconComponent; };
    };
    output: ExtensionDataRef<{
        [x: string]: IconComponent;
    }, "core.icons", {}>;
    inputs: {};
    config: {};
    configInput: {};
    dataRefs: {
        icons: ConfigurableExtensionDataRef<{
            [x: string]: IconComponent;
        }, "core.icons", {}>;
    };
}>;

/**
 * The props for the {@link NavContentComponent}.
 *
 * @public
 */
interface NavContentComponentProps {
    /**
     * The nav items available to the component. These are all the items created
     * with the {@link NavItemBlueprint} in the app.
     *
     * In addition to the original properties from the nav items, these also
     * include a resolved route path as `to`, and duplicated `title` as `text` to
     * simplify rendering.
     */
    items: Array<{
        icon: IconComponent$1;
        title: string;
        routeRef: RouteRef$1<undefined>;
        to: string;
        text: string;
    }>;
}
/**
 * A component that renders the nav bar content, to be passed to the {@link NavContentBlueprint}.
 *
 * @public
 */
type NavContentComponent = (props: NavContentComponentProps) => JSX.Element | null;
/**
 * Creates an extension that replaces the entire nav bar with your own component.
 *
 * @public
 */
declare const NavContentBlueprint: _backstage_frontend_plugin_api.ExtensionBlueprint<{
    kind: "nav-content";
    params: {
        component: NavContentComponent;
    };
    output: _backstage_frontend_plugin_api.ExtensionDataRef<NavContentComponent, "core.nav-content.component", {}>;
    inputs: {};
    config: {};
    configInput: {};
    dataRefs: {
        component: _backstage_frontend_plugin_api.ConfigurableExtensionDataRef<NavContentComponent, "core.nav-content.component", {}>;
    };
}>;

/**
 * Creates extensions that make up the items of the nav bar.
 *
 * @public
 */
declare const NavItemBlueprint: ExtensionBlueprint<{
    kind: "nav-item";
    params: {
        title: string;
        icon: IconComponent$2;
        routeRef: RouteRef<undefined>;
    };
    output: ExtensionDataRef<{
        title: string;
        icon: IconComponent$2;
        routeRef: RouteRef<undefined>;
    }, "core.nav-item.target", {}>;
    inputs: {};
    config: {};
    configInput: {};
    dataRefs: {
        target: ConfigurableExtensionDataRef<{
            title: string;
            icon: IconComponent$2;
            routeRef: RouteRef<undefined>;
        }, "core.nav-item.target", {}>;
    };
}>;

/**
 * Createx extensions that are routable React page components.
 *
 * @public
 */
declare const PageBlueprint: ExtensionBlueprint<{
    kind: "page";
    params: {
        /**
         * @deprecated Use the `path` param instead.
         */
        defaultPath?: [Error: `Use the 'path' param instead`];
        path: string;
        loader: () => Promise<JSX.Element>;
        routeRef?: RouteRef;
    };
    output: ExtensionDataRef<string, "core.routing.path", {}> | ExtensionDataRef<react.JSX.Element, "core.reactElement", {}> | ExtensionDataRef<RouteRef<AnyRouteRefParams>, "core.routing.ref", {
        optional: true;
    }>;
    inputs: {};
    config: {
        path: string | undefined;
    };
    configInput: {
        path?: string | undefined;
    };
    dataRefs: never;
}>;

/** @public */
declare const RouterBlueprint: ExtensionBlueprint<{
    kind: "app-router-component";
    params: {
        /** @deprecated use the `component` parameter instead */
        Component?: [error: "Use the `component` parameter instead"];
        component: (props: {
            children: ReactNode;
        }) => JSX.Element | null;
    };
    output: ExtensionDataRef<(props: {
        children: ReactNode;
    }) => JSX.Element | null, "app.router.wrapper", {}>;
    inputs: {};
    config: {};
    configInput: {};
    dataRefs: {
        component: ConfigurableExtensionDataRef<(props: {
            children: ReactNode;
        }) => JSX.Element | null, "app.router.wrapper", {}>;
    };
}>;

/**
 * Creates an extension that replaces the sign in page.
 *
 * @public
 */
declare const SignInPageBlueprint: ExtensionBlueprint<{
    kind: "sign-in-page";
    params: {
        loader: () => Promise<ComponentType<SignInPageProps>>;
    };
    output: ExtensionDataRef<ComponentType<SignInPageProps>, "core.sign-in-page.component", {}>;
    inputs: {};
    config: {};
    configInput: {};
    dataRefs: {
        component: ConfigurableExtensionDataRef<ComponentType<SignInPageProps>, "core.sign-in-page.component", {}>;
    };
}>;

/**
 * Creates an extension that adds/replaces an app theme.
 *
 * @public
 */
declare const ThemeBlueprint: ExtensionBlueprint<{
    kind: "theme";
    params: {
        theme: AppTheme;
    };
    output: ExtensionDataRef<AppTheme, "core.theme.theme", {}>;
    inputs: {};
    config: {};
    configInput: {};
    dataRefs: {
        theme: ConfigurableExtensionDataRef<AppTheme, "core.theme.theme", {}>;
    };
}>;

/**
 * Creates an extension that adds translations to your app.
 *
 * @public
 */
declare const TranslationBlueprint: ExtensionBlueprint<{
    kind: "translation";
    params: {
        resource: TranslationResource | TranslationMessages;
    };
    output: ExtensionDataRef<TranslationResource<string> | TranslationMessages<string, {
        [x: string]: string;
    }, boolean>, "core.translation.translation", {}>;
    inputs: {};
    config: {};
    configInput: {};
    dataRefs: {
        translation: ConfigurableExtensionDataRef<TranslationResource<string> | TranslationMessages<string, {
            [x: string]: string;
        }, boolean>, "core.translation.translation", {}>;
    };
}>;

/**
 * Blueprint for creating swappable components from a SwappableComponentRef and a loader
 *
 * @public
 */
declare const SwappableComponentBlueprint: ExtensionBlueprint<{
    kind: "component";
    params: <Ref extends SwappableComponentRef<any>>(params: {
        component: Ref extends SwappableComponentRef<any, infer IExternalComponentProps> ? {
            ref: Ref;
        } & ((props: IExternalComponentProps) => JSX.Element | null) : never;
        loader: Ref extends SwappableComponentRef<infer IInnerComponentProps, any> ? (() => (props: IInnerComponentProps) => JSX.Element | null) | (() => Promise<(props: IInnerComponentProps) => JSX.Element | null>) : never;
    }) => ExtensionBlueprintParams<{
        component: Ref extends SwappableComponentRef<any, infer IExternalComponentProps> ? {
            ref: Ref;
        } & ((props: IExternalComponentProps) => JSX.Element | null) : never;
        loader: Ref extends SwappableComponentRef<infer IInnerComponentProps, any> ? (() => (props: IInnerComponentProps) => JSX.Element | null) | (() => Promise<(props: IInnerComponentProps) => JSX.Element | null>) : never;
    }>;
    output: ExtensionDataRef<{
        ref: SwappableComponentRef;
        loader: (() => (props: {}) => JSX.Element | null) | (() => Promise<(props: {}) => JSX.Element | null>);
    }, "core.swappableComponent", {}>;
    inputs: {};
    config: {};
    configInput: {};
    dataRefs: {
        component: ConfigurableExtensionDataRef<{
            ref: SwappableComponentRef;
            loader: (() => (props: {}) => JSX.Element | null) | (() => Promise<(props: {}) => JSX.Element | null>);
        }, "core.swappableComponent", {}>;
    };
}>;

export { type AnalyticsApi, AnalyticsContext, type AnalyticsContextValue, type AnalyticsEvent, type AnalyticsEventAttributes, type AnalyticsImplementation, AnalyticsImplementationBlueprint, type AnalyticsImplementationFactory, type AnalyticsTracker, type AnyExtensionDataRef, type AnyRouteRefParams, ApiBlueprint, type AppNode, type AppNodeEdges, type AppNodeInstance, type AppNodeSpec, AppRootElementBlueprint, AppRootWrapperBlueprint, type AppTree, type AppTreeApi, type ConfigurableExtensionDataRef, type CreateExtensionBlueprintOptions, type CreateExtensionOptions, type CreateFrontendFeatureLoaderOptions, type CreateFrontendModuleOptions, type CreateSwappableComponentOptions, type DialogApi, type DialogApiDialog, ErrorDisplay, type ErrorDisplayProps, type Extension, type ExtensionAttachToSpec, type ExtensionBlueprint, type ExtensionBlueprintDefineParams, type ExtensionBlueprintParameters, type ExtensionBlueprintParams, ExtensionBoundary, type ExtensionBoundaryProps, type ExtensionDataContainer, type ExtensionDataRef, type ExtensionDataRefToValue, type ExtensionDataValue, type ExtensionDefinition, type ExtensionDefinitionParameters, type ExtensionFactoryMiddleware, type ExtensionInput, type ExternalRouteRef, type FeatureFlagConfig, type FrontendFeature, type FrontendFeatureLoader, type FrontendModule, type FrontendPlugin, type FrontendPluginInfo, type FrontendPluginInfoOptions, IconBundleBlueprint, type IconComponent, type IconsApi, NavContentBlueprint, type NavContentComponent, type NavContentComponentProps, NavItemBlueprint, NotFoundErrorPage, type NotFoundErrorPageProps, type OverridableFrontendPlugin, PageBlueprint, type PluginOptions, type PortableSchema, Progress, type ProgressProps, type ResolvedExtensionInput, type ResolvedExtensionInputs, type RouteFunc, type RouteRef, type RouteResolutionApi, RouterBlueprint, SignInPageBlueprint, type SubRouteRef, SwappableComponentBlueprint, type SwappableComponentRef, type SwappableComponentsApi, ThemeBlueprint, TranslationBlueprint, analyticsApiRef, appTreeApiRef, coreExtensionData, createExtension, createExtensionBlueprint, createExtensionBlueprintParams, createExtensionDataRef, createExtensionInput, createExternalRouteRef, createFrontendFeatureLoader, createFrontendModule, createFrontendPlugin, createRouteRef, createSubRouteRef, createSwappableComponent, dialogApiRef, iconsApiRef, routeResolutionApiRef, swappableComponentsApiRef, useAnalytics, useAppNode, useRouteRef, useRouteRefParams };
