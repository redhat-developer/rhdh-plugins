import { jsx, jsxs, Fragment } from 'react/jsx-runtime';
import { useAnalytics, useElementFilter } from '@backstage/core-plugin-api';
import Badge from '@material-ui/core/Badge';
import Box from '@material-ui/core/Box';
import { styled, makeStyles } from '@material-ui/core/styles';
import TextField from '@material-ui/core/TextField';
import Typography from '@material-ui/core/Typography';
import useMediaQuery from '@material-ui/core/useMediaQuery';
import ArrowDropDownIcon from '@material-ui/icons/ArrowDropDown';
import ArrowDropUpIcon from '@material-ui/icons/ArrowDropUp';
import ArrowRightIcon from '@material-ui/icons/ArrowRight';
import Search from '@material-ui/icons/Search';
import classNames from 'classnames';
import { createElement, forwardRef, useContext, useCallback, useMemo, useState } from 'react';
import { useLocation, useResolvedPath, Link, resolvePath } from 'react-router-dom';
import { SidebarConfigContext, SidebarItemWithSubmenuContext } from './config.esm.js';
import DoubleArrowLeft from './icons/DoubleArrowLeft.esm.js';
import DoubleArrowRight from './icons/DoubleArrowRight.esm.js';
import { useSidebarOpenState } from './SidebarOpenStateContext.esm.js';
import { SidebarSubmenu } from './SidebarSubmenu.esm.js';
import { isLocationMatch } from './utils.esm.js';
import Button from '@material-ui/core/Button';

const makeSidebarStyles = (sidebarConfig) => makeStyles(
  (theme) => ({
    root: {
      color: theme.palette.navigation.color,
      display: "flex",
      flexFlow: "row nowrap",
      alignItems: "center",
      height: 48,
      cursor: "pointer"
    },
    buttonItem: {
      background: "none",
      border: "none",
      width: "100%",
      margin: 0,
      padding: 0,
      textAlign: "inherit",
      font: "inherit",
      textTransform: "none"
    },
    closed: {
      width: sidebarConfig.drawerWidthClosed,
      justifyContent: "center"
    },
    open: {
      [theme.breakpoints.up("sm")]: {
        width: sidebarConfig.drawerWidthOpen
      }
    },
    highlightable: {
      "&:hover": {
        background: theme.palette.navigation.navItem?.hoverBackground ?? "#404040"
      }
    },
    highlighted: {
      background: theme.palette.navigation.navItem?.hoverBackground ?? "#404040"
    },
    label: {
      // XXX (@koroeskohr): I can't seem to achieve the desired font-weight from the designs
      fontWeight: "bold",
      whiteSpace: "nowrap",
      lineHeight: "auto",
      flex: "3 1 auto",
      width: "110px",
      overflow: "hidden",
      "text-overflow": "ellipsis"
    },
    iconContainer: {
      boxSizing: "border-box",
      height: "100%",
      width: sidebarConfig.iconContainerWidth,
      marginRight: -theme.spacing(2),
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      lineHeight: "0"
    },
    searchRoot: {
      marginBottom: 12
    },
    searchField: {
      color: "#b5b5b5",
      fontWeight: theme.typography.fontWeightBold,
      fontSize: theme.typography.fontSize
    },
    searchFieldHTMLInput: {
      padding: theme.spacing(2, 0, 2)
    },
    searchContainer: {
      width: sidebarConfig.drawerWidthOpen - sidebarConfig.iconContainerWidth
    },
    secondaryAction: {
      width: theme.spacing(6),
      textAlign: "center",
      marginRight: theme.spacing(1)
    },
    closedItemIcon: {
      width: "100%",
      justifyContent: "center"
    },
    submenuArrow: {
      display: "flex"
    },
    expandButton: {
      background: "none",
      border: "none",
      color: theme.palette.navigation.color,
      width: "100%",
      cursor: "pointer",
      position: "relative",
      height: 48
    },
    arrows: {
      position: "absolute",
      right: 10
    },
    selected: {
      "&$root": {
        borderLeft: `solid ${sidebarConfig.selectedIndicatorWidth}px ${theme.palette.navigation.indicator}`,
        color: theme.palette.navigation.selectedColor
      },
      "&$closed": {
        width: sidebarConfig.drawerWidthClosed
      },
      "& $closedItemIcon": {
        paddingRight: sidebarConfig.selectedIndicatorWidth
      },
      "& $iconContainer": {
        marginLeft: -sidebarConfig.selectedIndicatorWidth
      }
    }
  }),
  { name: "BackstageSidebarItem" }
);
function useMemoStyles(sidebarConfig) {
  const useStyles = useMemo(
    () => makeSidebarStyles(sidebarConfig),
    [sidebarConfig]
  );
  return useStyles();
}
const useLocationMatch = (submenu, location) => useElementFilter(
  submenu.props.children,
  (elements) => {
    let active = false;
    elements.getElements().forEach(
      ({
        props: { to, dropdownItems }
      }) => {
        if (!active) {
          if (dropdownItems?.length) {
            dropdownItems.forEach(
              ({ to: _to }) => active = active || isLocationMatch(location, resolvePath(_to))
            );
            return;
          }
          if (to) {
            active = isLocationMatch(location, resolvePath(to));
          }
        }
      }
    );
    return active;
  },
  [location.pathname]
);
function isButtonItem(props) {
  return props.to === void 0;
}
const sidebarSubmenuType = createElement(SidebarSubmenu).type;
const WorkaroundNavLink = forwardRef(function WorkaroundNavLinkWithRef({
  to,
  end,
  style,
  className,
  activeStyle,
  caseSensitive,
  activeClassName = "active",
  "aria-current": ariaCurrentProp = "page",
  ...rest
}, ref) {
  let { pathname: locationPathname } = useLocation();
  let { pathname: toPathname } = useResolvedPath(to);
  if (!caseSensitive) {
    locationPathname = locationPathname.toLocaleLowerCase("en-US");
    toPathname = toPathname.toLocaleLowerCase("en-US");
  }
  let isActive = locationPathname === toPathname;
  if (!isActive && !end) {
    isActive = locationPathname.startsWith(`${toPathname}/`);
  }
  const ariaCurrent = isActive ? ariaCurrentProp : void 0;
  return /* @__PURE__ */ jsx(
    Link,
    {
      ...rest,
      to,
      ref,
      "aria-current": ariaCurrent,
      style: { ...style, ...isActive ? activeStyle : void 0 },
      className: classNames([
        typeof className !== "function" ? className : void 0,
        isActive ? activeClassName : void 0
      ])
    }
  );
});
const SidebarItemBase = forwardRef((props, ref) => {
  const {
    icon: Icon,
    text,
    hasNotifications = false,
    hasSubmenu = false,
    disableHighlight = false,
    onClick,
    noTrack,
    children,
    className,
    ...navLinkProps
  } = props;
  const { sidebarConfig } = useContext(SidebarConfigContext);
  const classes = useMemoStyles(sidebarConfig);
  const { isOpen } = useSidebarOpenState();
  const divStyle = !isOpen && hasSubmenu ? { display: "flex", marginLeft: "20px" } : { lineHeight: "0" };
  const displayItemIcon = /* @__PURE__ */ jsxs(Box, { style: divStyle, children: [
    /* @__PURE__ */ jsx(Icon, { fontSize: "small" }),
    !isOpen && hasSubmenu ? /* @__PURE__ */ jsx(ArrowRightIcon, { fontSize: "small" }) : /* @__PURE__ */ jsx(Fragment, {})
  ] });
  const itemIcon = /* @__PURE__ */ jsx(
    Badge,
    {
      color: "secondary",
      variant: "dot",
      overlap: "circular",
      invisible: !hasNotifications,
      className: classNames({ [classes.closedItemIcon]: !isOpen }),
      children: displayItemIcon
    }
  );
  const openContent = /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(Box, { "data-testid": "login-button", className: classes.iconContainer, children: itemIcon }),
    text && /* @__PURE__ */ jsx(
      Typography,
      {
        variant: "subtitle2",
        component: "span",
        className: classes.label,
        children: text
      }
    ),
    /* @__PURE__ */ jsx("div", { className: classes.secondaryAction, children })
  ] });
  const content = isOpen ? openContent : itemIcon;
  const childProps = {
    onClick,
    className: classNames(
      className,
      classes.root,
      isOpen ? classes.open : classes.closed,
      isButtonItem(props) && classes.buttonItem,
      { [classes.highlightable]: !disableHighlight }
    )
  };
  const analyticsApi = useAnalytics();
  const { pathname: to } = useResolvedPath(
    !isButtonItem(props) && props.to ? props.to : ""
  );
  const handleClick = useCallback(
    (event) => {
      if (!noTrack) {
        const action = "click";
        const subject = text ?? "Sidebar Item";
        const options = to ? { attributes: { to } } : void 0;
        analyticsApi.captureEvent(action, subject, options);
      }
      onClick?.(event);
    },
    [analyticsApi, text, to, noTrack, onClick]
  );
  if (isButtonItem(props)) {
    return /* @__PURE__ */ jsx(
      Button,
      {
        role: "button",
        "aria-label": text,
        ...childProps,
        ref,
        onClick: handleClick,
        children: content
      }
    );
  }
  return /* @__PURE__ */ jsx(
    WorkaroundNavLink,
    {
      ...childProps,
      activeClassName: classes.selected,
      to: props.to ? props.to : "",
      ref,
      "aria-label": text ? text : props.to,
      ...navLinkProps,
      onClick: handleClick,
      children: content
    }
  );
});
const SidebarItemWithSubmenu = ({
  children,
  ...props
}) => {
  const { sidebarConfig } = useContext(SidebarConfigContext);
  const classes = useMemoStyles(sidebarConfig);
  const [isHoveredOn, setIsHoveredOn] = useState(false);
  const location = useLocation();
  const isActive = useLocationMatch(children, location);
  const isSmallScreen = useMediaQuery(
    (theme) => theme.breakpoints.down("sm")
  );
  const handleMouseEnter = () => {
    setIsHoveredOn(true);
  };
  const handleMouseLeave = () => {
    setIsHoveredOn(false);
  };
  const arrowIcon = () => {
    if (isSmallScreen) {
      return isHoveredOn ? /* @__PURE__ */ jsx(ArrowDropUpIcon, { fontSize: "small", className: classes.submenuArrow }) : /* @__PURE__ */ jsx(ArrowDropDownIcon, { fontSize: "small", className: classes.submenuArrow });
    }
    return !isHoveredOn && /* @__PURE__ */ jsx(ArrowRightIcon, { fontSize: "small", className: classes.submenuArrow });
  };
  return /* @__PURE__ */ jsx(
    SidebarItemWithSubmenuContext.Provider,
    {
      value: {
        isHoveredOn,
        setIsHoveredOn
      },
      children: /* @__PURE__ */ jsxs(
        "div",
        {
          "data-testid": "item-with-submenu",
          onMouseLeave: handleMouseLeave,
          onTouchStart: isHoveredOn ? handleMouseLeave : handleMouseEnter,
          onMouseEnter: handleMouseEnter,
          className: classNames(isHoveredOn && classes.highlighted),
          children: [
            /* @__PURE__ */ jsx(
              SidebarItemBase,
              {
                hasSubmenu: true,
                className: isActive ? classes.selected : "",
                ...props,
                children: arrowIcon()
              }
            ),
            isHoveredOn && children
          ]
        }
      )
    }
  );
};
const SidebarItem = forwardRef((props, ref) => {
  const [submenu] = useElementFilter(
    props.children,
    (elements) => (
      // Directly comparing child.type with SidebarSubmenu will not work with in
      // combination with react-hot-loader
      //
      // https://github.com/gaearon/react-hot-loader/issues/304#issuecomment-456569720
      elements.getElements().filter((child) => child.type === sidebarSubmenuType)
    )
  );
  if (submenu) {
    return /* @__PURE__ */ jsx(SidebarItemWithSubmenu, { ...props, children: submenu });
  }
  return /* @__PURE__ */ jsx(SidebarItemBase, { ...props, ref });
});
function SidebarSearchField(props) {
  const { sidebarConfig } = useContext(SidebarConfigContext);
  const [input, setInput] = useState("");
  const classes = useMemoStyles(sidebarConfig);
  const Icon = props.icon ? props.icon : Search;
  const search = () => {
    props.onSearch(input);
    setInput("");
  };
  const handleEnter = (ev) => {
    if (ev.key === "Enter") {
      ev.preventDefault();
      search();
    }
  };
  const handleInput = (ev) => {
    setInput(ev.target.value);
  };
  const handleInputClick = (ev) => {
    ev.preventDefault();
    ev.stopPropagation();
  };
  const handleItemClick = (ev) => {
    search();
    ev.preventDefault();
  };
  return /* @__PURE__ */ jsx(Box, { className: classes.searchRoot, children: /* @__PURE__ */ jsx(
    SidebarItem,
    {
      icon: Icon,
      to: props.to,
      onClick: handleItemClick,
      disableHighlight: true,
      children: /* @__PURE__ */ jsx(
        TextField,
        {
          placeholder: "Search",
          value: input,
          onClick: handleInputClick,
          onChange: handleInput,
          onKeyDown: handleEnter,
          className: classes.searchContainer,
          InputProps: {
            disableUnderline: true,
            className: classes.searchField
          },
          inputProps: {
            className: classes.searchFieldHTMLInput
          }
        }
      )
    }
  ) });
}
const SidebarSpace = styled("div")(
  {
    flex: 1
  },
  { name: "BackstageSidebarSpace" }
);
const SidebarSpacer = styled("div")(
  {
    height: 8
  },
  { name: "BackstageSidebarSpacer" }
);
const SidebarDivider = styled("hr")(
  ({ theme }) => ({
    height: 1,
    width: "100%",
    background: "#383838",
    border: "none",
    margin: theme.spacing(1.2, 0)
  }),
  { name: "BackstageSidebarDivider" }
);
const styledScrollbar = (theme) => ({
  overflowY: "auto",
  "&::-webkit-scrollbar": {
    backgroundColor: theme.palette.background.default,
    width: "5px",
    borderRadius: "5px"
  },
  "&::-webkit-scrollbar-thumb": {
    backgroundColor: theme.palette.text.secondary,
    borderRadius: "5px"
  }
});
const SidebarScrollWrapper = styled("div")(({ theme }) => {
  const scrollbarStyles = styledScrollbar(theme);
  return {
    flex: "0 1 auto",
    overflowX: "hidden",
    width: "100%",
    // Display at least one item in the container
    // Question: Can this be a config/theme variable - if so, which? :/
    minHeight: "48px",
    overflowY: "hidden",
    "@media (hover: none)": scrollbarStyles,
    "&:hover": scrollbarStyles
  };
});
const SidebarExpandButton = () => {
  const { sidebarConfig } = useContext(SidebarConfigContext);
  const classes = useMemoStyles(sidebarConfig);
  const { isOpen, setOpen } = useSidebarOpenState();
  const isSmallScreen = useMediaQuery(
    (theme) => theme.breakpoints.down("md"),
    { noSsr: true }
  );
  if (isSmallScreen) {
    return null;
  }
  const handleClick = () => {
    setOpen(!isOpen);
  };
  return /* @__PURE__ */ jsx(
    Button,
    {
      role: "button",
      onClick: handleClick,
      className: classes.expandButton,
      "aria-label": "Expand Sidebar",
      "data-testid": "sidebar-expand-button",
      children: /* @__PURE__ */ jsx(Box, { className: classes.arrows, children: isOpen ? /* @__PURE__ */ jsx(DoubleArrowLeft, {}) : /* @__PURE__ */ jsx(DoubleArrowRight, {}) })
    }
  );
};

export { SidebarDivider, SidebarExpandButton, SidebarItem, SidebarScrollWrapper, SidebarSearchField, SidebarSpace, SidebarSpacer, WorkaroundNavLink };
//# sourceMappingURL=Items.esm.js.map
