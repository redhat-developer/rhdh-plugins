{"version":3,"file":"AnsiProcessor.esm.js","sources":["../../../src/components/LogViewer/AnsiProcessor.ts"],"sourcesContent":["/*\n * Copyright 2021 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport ansiRegexMaker from 'ansi-regex';\n\nconst ansiRegex = ansiRegexMaker();\nconst newlineRegex = /\\n\\r?/g;\n\n// A mapping of how each escape code changes the modifiers\nconst codeModifiers = Object.fromEntries(\n  Object.entries({\n    1: m => ({ ...m, bold: true }),\n    3: m => ({ ...m, italic: true }),\n    4: m => ({ ...m, underline: true }),\n    22: ({ bold: _, ...m }) => m,\n    23: ({ italic: _, ...m }) => m,\n    24: ({ underline: _, ...m }) => m,\n    30: m => ({ ...m, foreground: 'black' }),\n    31: m => ({ ...m, foreground: 'red' }),\n    32: m => ({ ...m, foreground: 'green' }),\n    33: m => ({ ...m, foreground: 'yellow' }),\n    34: m => ({ ...m, foreground: 'blue' }),\n    35: m => ({ ...m, foreground: 'magenta' }),\n    36: m => ({ ...m, foreground: 'cyan' }),\n    37: m => ({ ...m, foreground: 'white' }),\n    39: ({ foreground: _, ...m }) => m,\n    90: m => ({ ...m, foreground: 'grey' }),\n    40: m => ({ ...m, background: 'black' }),\n    41: m => ({ ...m, background: 'red' }),\n    42: m => ({ ...m, background: 'green' }),\n    43: m => ({ ...m, background: 'yellow' }),\n    44: m => ({ ...m, background: 'blue' }),\n    45: m => ({ ...m, background: 'magenta' }),\n    46: m => ({ ...m, background: 'cyan' }),\n    47: m => ({ ...m, background: 'white' }),\n    49: ({ background: _, ...m }) => m,\n  } as Record<string, (m: ChunkModifiers) => ChunkModifiers>).map(\n    ([code, modifier]) => [`\\x1b[${code}m`, modifier],\n  ),\n);\n\nexport type AnsiColor =\n  | 'black'\n  | 'red'\n  | 'green'\n  | 'yellow'\n  | 'blue'\n  | 'magenta'\n  | 'cyan'\n  | 'white'\n  | 'grey';\n\nexport interface ChunkModifiers {\n  foreground?: AnsiColor;\n  background?: AnsiColor;\n  bold?: boolean;\n  italic?: boolean;\n  underline?: boolean;\n}\n\nexport interface AnsiChunk {\n  text: string;\n  modifiers: ChunkModifiers;\n}\n\nexport class AnsiLine {\n  text: string;\n\n  constructor(\n    readonly lineNumber: number = 1,\n    readonly chunks: AnsiChunk[] = [],\n  ) {\n    this.text = chunks\n      .map(c => c.text)\n      .join('')\n      .toLocaleLowerCase('en-US');\n  }\n\n  lastChunk(): AnsiChunk | undefined {\n    return this.chunks[this.chunks.length - 1];\n  }\n\n  replaceLastChunk(newChunks?: AnsiChunk[]) {\n    if (newChunks) {\n      this.chunks.splice(this.chunks.length - 1, 1, ...newChunks);\n      this.text = this.chunks\n        .map(c => c.text)\n        .join('')\n        .toLocaleLowerCase('en-US');\n    }\n  }\n}\n\nexport class AnsiProcessor {\n  private text: string = '';\n  private lines: AnsiLine[] = [];\n\n  /**\n   * Processes a chunk of text while keeping internal state that optimizes\n   * subsequent processing that appends to the text.\n   */\n  process(text: string): AnsiLine[] {\n    if (this.text === text) {\n      return this.lines;\n    }\n\n    if (this.text && text.startsWith(this.text)) {\n      const lastLineIndex = this.lines.length > 0 ? this.lines.length - 1 : 0;\n      const lastLine = this.lines[lastLineIndex] ?? new AnsiLine();\n      const lastChunk = lastLine.lastChunk();\n\n      const newLines = this.processLines(\n        (lastChunk?.text ?? '') + text.slice(this.text.length),\n        lastChunk?.modifiers,\n        lastLine?.lineNumber,\n      );\n      lastLine.replaceLastChunk(newLines[0]?.chunks);\n\n      this.lines[lastLineIndex] = lastLine;\n      this.lines = this.lines.concat(newLines.slice(1));\n    } else {\n      this.lines = this.processLines(text);\n    }\n    this.text = text;\n\n    return this.lines;\n  }\n\n  // Split a chunk of text up into lines and process each line individually\n  private processLines = (\n    text: string,\n    modifiers: ChunkModifiers = {},\n    startingLineNumber: number = 1,\n  ): AnsiLine[] => {\n    const lines: AnsiLine[] = [];\n\n    let currentModifiers = modifiers;\n    let currentLineNumber = startingLineNumber;\n\n    let prevIndex = 0;\n    newlineRegex.lastIndex = 0;\n    for (;;) {\n      const match = newlineRegex.exec(text);\n      if (!match) {\n        const chunks = this.processText(\n          text.slice(prevIndex),\n          currentModifiers,\n        );\n        lines.push(new AnsiLine(currentLineNumber, chunks));\n        return lines;\n      }\n\n      const line = text.slice(prevIndex, match.index);\n      prevIndex = match.index + match[0].length;\n\n      const chunks = this.processText(line, currentModifiers);\n      lines.push(new AnsiLine(currentLineNumber, chunks));\n\n      // Modifiers that are active in the last chunk are carried over to the next line\n      currentModifiers =\n        chunks[chunks.length - 1].modifiers ?? currentModifiers;\n      currentLineNumber += 1;\n    }\n  };\n\n  // Processing of a one individual text chunk\n  private processText = (\n    fullText: string,\n    modifiers: ChunkModifiers,\n  ): AnsiChunk[] => {\n    const chunks: AnsiChunk[] = [];\n\n    let currentModifiers = modifiers;\n\n    let prevIndex = 0;\n    ansiRegex.lastIndex = 0;\n    for (;;) {\n      const match = ansiRegex.exec(fullText);\n      if (!match) {\n        chunks.push({\n          text: fullText.slice(prevIndex),\n          modifiers: currentModifiers,\n        });\n        return chunks;\n      }\n\n      const text = fullText.slice(prevIndex, match.index);\n      chunks.push({ text, modifiers: currentModifiers });\n\n      // For every escape code that we encounter we keep track of where the\n      // next chunk of text starts, and what modifiers it has\n      prevIndex = match.index + match[0].length;\n      currentModifiers = this.processCode(match[0], currentModifiers);\n    }\n  };\n\n  private processCode = (\n    code: string,\n    modifiers: ChunkModifiers,\n  ): ChunkModifiers => {\n    return codeModifiers[code]?.(modifiers) ?? modifiers;\n  };\n}\n"],"names":["chunks"],"mappings":"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"}