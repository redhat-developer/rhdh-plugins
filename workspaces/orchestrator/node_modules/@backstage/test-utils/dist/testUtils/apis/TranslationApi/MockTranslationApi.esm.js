import { createInstance } from 'i18next';
import ObservableImpl from 'zen-observable';
import { toInternalTranslationRef } from '../../../core-plugin-api/src/translation/TranslationRef.esm.js';
import { JsxInterpolator } from '../../../core-app-api/src/apis/implementations/TranslationApi/I18nextTranslationApi.esm.js';

const DEFAULT_LANGUAGE = "en";
class MockTranslationApi {
  static create() {
    const i18n = createInstance({
      fallbackLng: DEFAULT_LANGUAGE,
      supportedLngs: [DEFAULT_LANGUAGE],
      interpolation: {
        escapeValue: false,
        // Used for the JsxInterpolator format hook
        alwaysFormat: true
      },
      ns: [],
      defaultNS: false,
      fallbackNS: false,
      // Disable resource loading on init, meaning i18n will be ready to use immediately
      initImmediate: false
    });
    i18n.init();
    if (!i18n.isInitialized) {
      throw new Error("i18next was unexpectedly not initialized");
    }
    const interpolator = JsxInterpolator.fromI18n(i18n);
    return new MockTranslationApi(i18n, interpolator);
  }
  #i18n;
  #interpolator;
  #registeredRefs = /* @__PURE__ */ new Set();
  constructor(i18n, interpolator) {
    this.#i18n = i18n;
    this.#interpolator = interpolator;
  }
  getTranslation(translationRef) {
    const internalRef = toInternalTranslationRef(translationRef);
    if (!this.#registeredRefs.has(internalRef.id)) {
      this.#registeredRefs.add(internalRef.id);
      this.#i18n.addResourceBundle(
        DEFAULT_LANGUAGE,
        internalRef.id,
        internalRef.getDefaultMessages(),
        false,
        // do not merge
        true
        // overwrite existing
      );
    }
    const t = this.#interpolator.wrapT(
      this.#i18n.getFixedT(null, internalRef.id)
    );
    return {
      ready: true,
      t
    };
  }
  translation$() {
    return new ObservableImpl((_subscriber) => {
      return () => {
      };
    });
  }
}

export { MockTranslationApi };
//# sourceMappingURL=MockTranslationApi.esm.js.map
