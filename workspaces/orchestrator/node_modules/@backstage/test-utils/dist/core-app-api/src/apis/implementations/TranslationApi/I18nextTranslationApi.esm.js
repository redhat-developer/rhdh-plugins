import 'i18next';
import 'zen-observable';
import '@backstage/core-plugin-api';
import { isValidElement, createElement, Fragment } from 'react';

class JsxInterpolator {
  #setFormatHook;
  #marker;
  #pattern;
  static fromI18n(i18n) {
    const interpolator = i18n.services.interpolator;
    const originalFormat = interpolator.format;
    let formatHook;
    interpolator.format = (value, format, lng, formatOpts) => {
      if (format) {
        return originalFormat(value, format, lng, formatOpts);
      }
      return formatHook?.(value, format, lng, formatOpts) ?? value;
    };
    return new JsxInterpolator(
      // Using a random marker to ensure it can't be misused
      Math.random().toString(36).substring(2, 8),
      (hook) => {
        formatHook = hook;
      }
    );
  }
  constructor(marker, setFormatHook) {
    this.#setFormatHook = setFormatHook;
    this.#marker = marker;
    this.#pattern = new RegExp(`\\$${marker}\\(([^)]+)\\)`);
  }
  wrapT(originalT) {
    return (key, options) => {
      let elementsMap = void 0;
      this.#setFormatHook((value) => {
        if (isValidElement(value)) {
          if (!elementsMap) {
            elementsMap = /* @__PURE__ */ new Map();
          }
          const elementKey = elementsMap.size.toString();
          elementsMap.set(elementKey, value);
          return `$${this.#marker}(${elementKey})`;
        }
        return value;
      });
      const result = originalT(key, options);
      if (!elementsMap) {
        return result;
      }
      const split = result.split(this.#pattern);
      return createElement(
        Fragment,
        null,
        ...split.map((part, index) => {
          if (index % 2 === 0) {
            return part;
          }
          return elementsMap?.get(part);
        }).filter(Boolean)
      );
    };
  }
}

export { JsxInterpolator };
//# sourceMappingURL=I18nextTranslationApi.esm.js.map
