import { jsxs, Fragment, jsx } from 'react/jsx-runtime';
import { useAnalytics, useApiHolder } from '@backstage/core-plugin-api';
import { useTranslationRef } from '@backstage/frontend-plugin-api';
import Button from '@material-ui/core/Button';
import LinearProgress from '@material-ui/core/LinearProgress';
import MuiStep from '@material-ui/core/Step';
import MuiStepLabel from '@material-ui/core/StepLabel';
import MuiStepper from '@material-ui/core/Stepper';
import { makeStyles } from '@material-ui/core/styles';
import { customizeValidator } from '@rjsf/validator-ajv8';
import ajvErrors from 'ajv-errors';
import { merge } from 'lodash';
import { useState, useMemo, useCallback, useEffect } from 'react';
import { scaffolderReactTranslationRef } from '../../../translation.esm.js';
import { useFormDataFromQuery } from '../../hooks/useFormDataFromQuery.esm.js';
import { useTemplateSchema } from '../../hooks/useTemplateSchema.esm.js';
import 'react-use/esm/useAsync';
import '../../../api/ref.esm.js';
import 'lodash/cloneDeep';
import { useTransformSchemaToProps } from '../../hooks/useTransformSchemaToProps.esm.js';
import { Form } from '../Form/Form.esm.js';
import { PasswordWidget } from '../PasswordWidget/PasswordWidget.esm.js';
import { ReviewState } from '../ReviewState/ReviewState.esm.js';
import { createAsyncValidators } from './createAsyncValidators.esm.js';
import { ErrorListTemplate } from './ErrorListTemplate/errorListTemplate.esm.js';
import * as index from './FieldOverrides/index.esm.js';
import { hasErrors } from './utils.esm.js';

const validator = customizeValidator();
ajvErrors(validator.ajv);
const useStyles = makeStyles(
  (theme) => ({
    backButton: {
      marginRight: theme.spacing(1)
    },
    footer: {
      display: "flex",
      flexDirection: "row",
      justifyContent: "right",
      marginTop: theme.spacing(2)
    },
    formWrapper: {
      padding: theme.spacing(2)
    }
  }),
  { name: "BackstageTemplateStepper" }
);
const Stepper = (stepperProps) => {
  const { t } = useTranslationRef(scaffolderReactTranslationRef);
  const { layouts = [], components = {}, onCreate, ...props } = stepperProps;
  const {
    ReviewStateComponent = ReviewState,
    ReviewStepComponent,
    backButtonText = t("stepper.backButtonText"),
    createButtonText = t("stepper.createButtonText"),
    reviewButtonText = t("stepper.reviewButtonText")
  } = components;
  const analytics = useAnalytics();
  const { presentation, steps } = useTemplateSchema(props.manifest);
  const apiHolder = useApiHolder();
  const [activeStep, setActiveStep] = useState(0);
  const [isValidating, setIsValidating] = useState(false);
  const [initialState] = useFormDataFromQuery(props.initialState);
  const [stepsState, setStepsState] = useState(initialState);
  const [errors, setErrors] = useState();
  const styles = useStyles();
  const backLabel = presentation?.buttonLabels?.backButtonText ?? backButtonText;
  const createLabel = presentation?.buttonLabels?.createButtonText ?? createButtonText;
  const reviewLabel = presentation?.buttonLabels?.reviewButtonText ?? reviewButtonText;
  const extensions = useMemo(() => {
    return Object.fromEntries(
      props.extensions.map(({ name, component }) => [name, component])
    );
  }, [props.extensions]);
  const fields = useMemo(
    () => ({ ...index, ...extensions }),
    [extensions]
  );
  const validators = useMemo(() => {
    return Object.fromEntries(
      props.extensions.map(({ name, validation: validation2 }) => [name, validation2])
    );
  }, [props.extensions]);
  const validation = useMemo(() => {
    return createAsyncValidators(steps[activeStep]?.mergedSchema, validators, {
      apiHolder
    });
  }, [steps, activeStep, validators, apiHolder]);
  const handleBack = useCallback(() => {
    setActiveStep((prevActiveStep) => prevActiveStep - 1);
  }, [setActiveStep]);
  const currentStep = useTransformSchemaToProps(steps[activeStep], { layouts });
  const {
    formContext: propFormContext,
    uiSchema: propUiSchema,
    liveOmit: _shouldLiveOmit,
    omitExtraData: _shouldOmitExtraData,
    ...restFormProps
  } = props.formProps ?? {};
  const handleChange = useCallback(
    (e) => {
      setStepsState((current) => {
        return { ...current, ...e.formData };
      });
    },
    [setStepsState]
  );
  const handleNext = useCallback(
    async ({ formData = {} }) => {
      setErrors(void 0);
      setIsValidating(true);
      const returnedValidation = await validation(formData);
      setStepsState((current) => ({
        ...current,
        ...formData
      }));
      setIsValidating(false);
      if (hasErrors(returnedValidation)) {
        setErrors(returnedValidation);
      } else {
        setErrors(void 0);
        setActiveStep((prevActiveStep) => {
          const stepNum = prevActiveStep + 1;
          analytics.captureEvent("click", `Next Step (${stepNum})`);
          return stepNum;
        });
      }
    },
    [validation, analytics]
  );
  useEffect(() => {
    const main = document.querySelector("main");
    if (main && typeof main.scrollTo === "function") {
      main.scrollTo({ top: 0, behavior: "auto" });
    }
  }, [activeStep]);
  const mergedUiSchema = merge({}, propUiSchema, currentStep?.uiSchema);
  const [isCreating, setIsCreating] = useState(false);
  const handleCreate = useCallback(async () => {
    setIsCreating(true);
    analytics.captureEvent("click", `${createLabel}`);
    try {
      await onCreate(stepsState);
    } finally {
      setIsCreating(false);
    }
  }, [analytics, createLabel, onCreate, stepsState]);
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    isValidating && /* @__PURE__ */ jsx(LinearProgress, { variant: "indeterminate" }),
    /* @__PURE__ */ jsxs(
      MuiStepper,
      {
        activeStep,
        alternativeLabel: true,
        variant: "elevation",
        style: { overflowX: "auto" },
        children: [
          steps.map((step, index) => {
            const isAllowedLabelClick = activeStep > index;
            return /* @__PURE__ */ jsx(MuiStep, { children: /* @__PURE__ */ jsx(
              MuiStepLabel,
              {
                "aria-label": t("stepper.stepIndexLabel", { index: index + 1 }),
                style: { cursor: isAllowedLabelClick ? "pointer" : "default" },
                onClick: () => {
                  if (isAllowedLabelClick) setActiveStep(index);
                },
                children: step.title
              }
            ) }, index);
          }),
          /* @__PURE__ */ jsx(MuiStep, { children: /* @__PURE__ */ jsx(MuiStepLabel, { children: reviewLabel }) })
        ]
      }
    ),
    /* @__PURE__ */ jsx("div", { className: styles.formWrapper, children: activeStep < steps.length ? /* @__PURE__ */ jsx(
      Form,
      {
        validator,
        extraErrors: errors,
        formData: stepsState,
        formContext: { ...propFormContext, formData: stepsState },
        schema: currentStep.schema,
        uiSchema: mergedUiSchema,
        onSubmit: handleNext,
        fields,
        showErrorList: "top",
        templates: { ErrorListTemplate },
        onChange: handleChange,
        widgets: { password: PasswordWidget },
        experimental_defaultFormStateBehavior: {
          allOf: "populateDefaults"
        },
        ...restFormProps,
        children: /* @__PURE__ */ jsxs("div", { className: styles.footer, children: [
          /* @__PURE__ */ jsx(
            Button,
            {
              onClick: handleBack,
              className: styles.backButton,
              disabled: activeStep < 1 || isValidating,
              children: backLabel
            }
          ),
          /* @__PURE__ */ jsx(
            Button,
            {
              variant: "contained",
              color: "primary",
              type: "submit",
              disabled: isValidating,
              children: activeStep === steps.length - 1 ? reviewLabel : t("stepper.nextButtonText")
            }
          )
        ] })
      },
      activeStep
    ) : (
      // TODO: potentially move away from this pattern, deprecate?
      ReviewStepComponent ? /* @__PURE__ */ jsx(
        ReviewStepComponent,
        {
          disableButtons: isValidating,
          formData: stepsState,
          handleBack,
          handleReset: () => {
          },
          steps,
          handleCreate
        }
      ) : /* @__PURE__ */ jsxs(Fragment, { children: [
        /* @__PURE__ */ jsx(ReviewStateComponent, { formState: stepsState, schemas: steps }),
        /* @__PURE__ */ jsxs("div", { className: styles.footer, children: [
          /* @__PURE__ */ jsx(
            Button,
            {
              onClick: handleBack,
              className: styles.backButton,
              disabled: activeStep < 1,
              children: backLabel
            }
          ),
          /* @__PURE__ */ jsx(
            Button,
            {
              disabled: isCreating,
              variant: "contained",
              color: "primary",
              onClick: handleCreate,
              children: createLabel
            }
          )
        ] })
      ] })
    ) })
  ] });
};

export { Stepper };
//# sourceMappingURL=Stepper.esm.js.map
