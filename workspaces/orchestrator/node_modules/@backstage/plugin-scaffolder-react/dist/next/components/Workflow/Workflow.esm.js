import { jsx, jsxs } from 'react/jsx-runtime';
import { stringifyEntityRef } from '@backstage/catalog-model';
import { Content, Progress, InfoCard, MarkdownContent } from '@backstage/core-components';
import { useAnalytics, useApi, errorApiRef } from '@backstage/core-plugin-api';
import { useTranslationRef } from '@backstage/frontend-plugin-api';
import { makeStyles } from '@material-ui/core/styles';
import { useCallback, useEffect } from 'react';
import { SecretsContextProvider } from '../../../secrets/SecretsContext.esm.js';
import { scaffolderReactTranslationRef } from '../../../translation.esm.js';
import { useFilteredSchemaProperties } from '../../hooks/useFilteredSchemaProperties.esm.js';
import { useTemplateParameterSchema } from '../../hooks/useTemplateParameterSchema.esm.js';
import { useTemplateTimeSavedMinutes } from '../../hooks/useTemplateTimeSaved.esm.js';
import { Stepper } from '../Stepper/Stepper.esm.js';

const useStyles = makeStyles({
  markdown: {
    /** to make the styles for React Markdown not leak into the description */
    "& :first-child": {
      marginTop: 0
    },
    "& :last-child": {
      marginBottom: 0
    }
  }
});
const Workflow = (workflowProps) => {
  const { t } = useTranslationRef(scaffolderReactTranslationRef);
  const { title, description, namespace, templateName, onCreate, ...props } = workflowProps;
  const analytics = useAnalytics();
  const styles = useStyles();
  const templateRef = stringifyEntityRef({
    kind: "Template",
    namespace,
    name: templateName
  });
  const errorApi = useApi(errorApiRef);
  const { loading, manifest, error } = useTemplateParameterSchema(templateRef);
  const sortedManifest = useFilteredSchemaProperties(manifest);
  const minutesSaved = useTemplateTimeSavedMinutes(templateRef);
  const workflowOnCreate = useCallback(
    async (formState) => {
      await onCreate(formState);
      analytics.captureEvent("create", "Task has been created", {
        value: minutesSaved,
        attributes: {
          templateSteps: sortedManifest?.steps?.length ?? 0
        }
      });
    },
    [onCreate, analytics, minutesSaved, sortedManifest]
  );
  useEffect(() => {
    if (error) {
      errorApi.post(new Error(`Failed to load template, ${error}`));
    }
  }, [error, errorApi]);
  if (error) {
    return props.onError(error);
  }
  return /* @__PURE__ */ jsxs(Content, { children: [
    loading && /* @__PURE__ */ jsx(Progress, {}),
    sortedManifest && /* @__PURE__ */ jsx(
      InfoCard,
      {
        title: title ?? sortedManifest.title,
        subheader: /* @__PURE__ */ jsx(
          MarkdownContent,
          {
            className: styles.markdown,
            linkTarget: "_blank",
            content: description ?? sortedManifest.description ?? t("workflow.noDescription")
          }
        ),
        noPadding: true,
        titleTypographyProps: { component: "h2" },
        children: /* @__PURE__ */ jsx(
          Stepper,
          {
            manifest: sortedManifest,
            onCreate: workflowOnCreate,
            ...props
          }
        )
      }
    )
  ] });
};
const EmbeddableWorkflow = (props) => /* @__PURE__ */ jsx(SecretsContextProvider, { children: /* @__PURE__ */ jsx(Workflow, { ...props }) });

export { EmbeddableWorkflow, Workflow };
//# sourceMappingURL=Workflow.esm.js.map
