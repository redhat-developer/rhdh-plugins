import * as _backstage_frontend_plugin_api from '@backstage/frontend-plugin-api';
import { z } from 'zod';
import { FieldExtensionComponentProps, CustomFieldValidator, FieldSchema, TemplateParameterSchema, FieldExtensionOptions, FormProps, ReviewStepProps, LayoutOptions, TemplateGroupFilter, ScaffolderTaskOutput, ScaffolderRJSFFormProps, ScaffolderStep } from '@backstage/plugin-scaffolder-react';
import * as react_jsx_runtime from 'react/jsx-runtime';
import { JsonObject, JsonValue } from '@backstage/types';
import * as react from 'react';
import { ComponentType, ReactNode, PropsWithChildren, ReactElement } from 'react';
import { TemplatePresentationV1beta3, TemplateEntityV1beta3, TaskStep } from '@backstage/plugin-scaffolder-common';
import { UiSchema, FieldValidation, WidgetProps } from '@rjsf/utils';
import { AnyApiRef, ApiHolder, IconComponent } from '@backstage/core-plugin-api';
import { Overrides } from '@material-ui/core/styles/overrides';
import { StyleRules } from '@material-ui/core/styles/withStyles';
import * as _backstage_core_plugin_api_alpha from '@backstage/core-plugin-api/alpha';

/** @alpha */
type ScaffolderFormDecoratorContext<TInput extends JsonObject = JsonObject> = {
    input: TInput;
    formState: Record<string, JsonValue>;
    setFormState: (fn: (currentState: Record<string, JsonValue>) => Record<string, JsonValue>) => void;
    setSecrets: (fn: (currentState: Record<string, string>) => Record<string, string>) => void;
};
/** @alpha */
type ScaffolderFormDecorator<TInput extends JsonObject = JsonObject> = {
    readonly $$type: '@backstage/scaffolder/FormDecorator';
    readonly id: string;
    readonly TInput: TInput;
};
/**
 * Method for creating decorators which can be used to collect
 * secrets from the user before submitting to the backend.
 * @alpha
 */
declare function createScaffolderFormDecorator<TInputSchema extends {
    [key in string]: (zImpl: typeof z) => z.ZodType;
} = {
    [key in string]: (zImpl: typeof z) => z.ZodType;
}, TDeps extends {
    [key in string]: AnyApiRef;
} = {
    [key in string]: AnyApiRef;
}, TInput extends JsonObject = {
    [key in keyof TInputSchema]: z.infer<ReturnType<TInputSchema[key]>>;
}>(options: {
    id: string;
    schema?: {
        input?: TInputSchema;
    };
    deps?: TDeps;
    decorator: (ctx: ScaffolderFormDecoratorContext<TInput>, deps: TDeps extends {
        [key in string]: AnyApiRef;
    } ? {
        [key in keyof TDeps]: TDeps[key]['T'];
    } : never) => Promise<void>;
}): ScaffolderFormDecorator<TInput>;

/**
 * @alpha
 * Creates extensions that are Field Extensions for the Scaffolder
 * */
declare const FormDecoratorBlueprint: _backstage_frontend_plugin_api.ExtensionBlueprint<{
    kind: "scaffolder-form-decorator";
    params: {
        decorator: ScaffolderFormDecorator;
    };
    output: _backstage_frontend_plugin_api.ExtensionDataRef<ScaffolderFormDecorator, "scaffolder.form-decorator-loader", {}>;
    inputs: {};
    config: {};
    configInput: {};
    dataRefs: {
        formDecoratorLoader: _backstage_frontend_plugin_api.ConfigurableExtensionDataRef<ScaffolderFormDecorator, "scaffolder.form-decorator-loader", {}>;
    };
}>;

/** @alpha */
type FormFieldExtensionData<TReturnValue extends z.ZodType = z.ZodType, TUiOptions extends z.ZodType = z.ZodType> = {
    name: string;
    component: (props: FieldExtensionComponentProps<z.output<TReturnValue>, z.output<TUiOptions>>) => JSX.Element | null;
    validation?: CustomFieldValidator<z.output<TReturnValue>, z.output<TUiOptions>>;
    schema?: FieldSchema<z.output<TReturnValue>, z.output<TUiOptions>>;
};

/**
 * @alpha
 * Creates extensions that are Field Extensions for the Scaffolder
 * */
declare const FormFieldBlueprint: _backstage_frontend_plugin_api.ExtensionBlueprint<{
    kind: "scaffolder-form-field";
    params: {
        field: () => Promise<FormField>;
    };
    output: _backstage_frontend_plugin_api.ExtensionDataRef<() => Promise<FormField>, "scaffolder.form-field-loader", {}>;
    inputs: {};
    config: {};
    configInput: {};
    dataRefs: {
        formFieldLoader: _backstage_frontend_plugin_api.ConfigurableExtensionDataRef<() => Promise<FormField>, "scaffolder.form-field-loader", {}>;
    };
}>;
/**
 * @alpha
 * Used to create a form field binding with typechecking for compliance
 */
declare function createFormField<TReturnValue extends z.ZodType, TUiOptions extends z.ZodType>(opts: FormFieldExtensionData<TReturnValue, TUiOptions>): FormField;

/**
 * @alpha
 * @deprecated This API is no longer necessary and will be removed
 */
interface ScaffolderFormFieldsApi {
    getFormFields(): Promise<FormFieldExtensionData[]>;
}
/** @alpha */
interface FormField {
    readonly $$type: '@backstage/scaffolder/FormField';
}

/** @alpha */
declare const formFieldsApi: _backstage_frontend_plugin_api.ExtensionDefinition<{
    config: {};
    configInput: {};
    output: _backstage_frontend_plugin_api.ExtensionDataRef<_backstage_frontend_plugin_api.AnyApiFactory, "core.api.factory", {}>;
    inputs: {
        formFields: _backstage_frontend_plugin_api.ExtensionInput<_backstage_frontend_plugin_api.ConfigurableExtensionDataRef<() => Promise<FormField>, "scaffolder.form-field-loader", {}>, {
            singleton: false;
            optional: false;
        }>;
    };
    kind: "api";
    name: "form-fields";
    params: <TApi, TImpl extends TApi, TDeps extends { [name in string]: unknown; }>(params: _backstage_frontend_plugin_api.ApiFactory<TApi, TImpl, TDeps>) => _backstage_frontend_plugin_api.ExtensionBlueprintParams<_backstage_frontend_plugin_api.AnyApiFactory>;
}>;

/**
 * @alpha
 * @deprecated This API is no longer necessary and will be removed
 */
declare const formFieldsApiRef: _backstage_frontend_plugin_api.ApiRef<ScaffolderFormFieldsApi>;

/**
 * This is the parsed template schema that is returned from the {@link useTemplateSchema} hook.
 * @alpha
 */
interface ParsedTemplateSchema {
    uiSchema: UiSchema;
    mergedSchema: JsonObject;
    schema: JsonObject;
    title: string;
    description?: string;
}
/**
 * This hook will parse the template schema and return the steps with the
 * parsed schema and uiSchema. Filtering out any steps or properties that
 * are not enabled with feature flags.
 * @alpha
 */
declare const useTemplateSchema: (manifest: TemplateParameterSchema) => {
    steps: ParsedTemplateSchema[];
    presentation?: TemplatePresentationV1beta3;
};

/**
 * The props for the {@link ReviewState} component.
 * @alpha
 */
type ReviewStateProps = {
    schemas: ParsedTemplateSchema[];
    formState: JsonObject;
};
/**
 * The component used by the {@link Stepper} to render the review step.
 * @alpha
 */
declare const ReviewState: (props: ReviewStateProps) => react_jsx_runtime.JSX.Element;

/** @alpha */
type BackstageTemplateStepperClassKey = 'backButton' | 'footer' | 'formWrapper';
/**
 * The Props for {@link Stepper} component
 * @alpha
 */
type StepperProps = {
    manifest: TemplateParameterSchema;
    extensions: FieldExtensionOptions<any, any>[];
    /**
     * @deprecated This was only ever used for analytics tracking purposes, which
     * is now handled in the `<Workflow />` component. Passing it in will have no
     * effect.
     */
    templateName?: string;
    formProps?: FormProps;
    initialState?: Record<string, JsonValue>;
    onCreate: (values: Record<string, JsonValue>) => Promise<void>;
    components?: {
        ReviewStepComponent?: ComponentType<ReviewStepProps>;
        ReviewStateComponent?: (props: ReviewStateProps) => JSX.Element;
        backButtonText?: ReactNode;
        createButtonText?: ReactNode;
        reviewButtonText?: ReactNode;
    };
    layouts?: LayoutOptions[];
};
/**
 * The `Stepper` component is the Wizard that is rendered when a user selects a template
 * @alpha
 */
declare const Stepper: (stepperProps: StepperProps) => react_jsx_runtime.JSX.Element;

/** @alpha */
type FormValidation = {
    [name: string]: FieldValidation | FormValidation;
};
/** @alpha */
declare const createAsyncValidators: (rootSchema: JsonObject, validators: Record<string, undefined | CustomFieldValidator<unknown, unknown>>, context: {
    apiHolder: ApiHolder;
}) => (formData: JsonObject) => Promise<FormValidation>;

/**
 * The Props for the {@link TemplateCard} component
 * @alpha
 */
interface TemplateCardProps {
    template: TemplateEntityV1beta3;
    additionalLinks?: {
        icon: IconComponent;
        text: string;
        url: string;
    }[];
    onSelected?: (template: TemplateEntityV1beta3) => void;
}
/**
 * The `TemplateCard` component that is rendered in a list for each template
 * @alpha
 */
declare const TemplateCard: (props: TemplateCardProps) => react_jsx_runtime.JSX.Element;

/**
 * The props for the {@link TemplateGroup} component.
 * @alpha
 */
interface TemplateGroupProps {
    templates: {
        template: TemplateEntityV1beta3;
        additionalLinks?: {
            icon: IconComponent;
            text: string;
            url: string;
        }[];
    }[];
    onSelected: (template: TemplateEntityV1beta3) => void;
    title: ReactNode;
    components?: {
        CardComponent?: ComponentType<TemplateCardProps>;
    };
}
/**
 * The `TemplateGroup` component is used to display a group of templates with a title.
 * @alpha
 */
declare const TemplateGroup: (props: TemplateGroupProps) => react_jsx_runtime.JSX.Element | null;

/**
 * @alpha
 */
interface TemplateGroupsProps {
    groups: TemplateGroupFilter[];
    templateFilter?: (entity: TemplateEntityV1beta3) => boolean;
    TemplateCardComponent?: ComponentType<{
        template: TemplateEntityV1beta3;
    }>;
    onTemplateSelected?: (template: TemplateEntityV1beta3) => void;
    additionalLinksForEntity?: (template: TemplateEntityV1beta3) => {
        icon: IconComponent;
        text: string;
        url: string;
    }[];
}
/**
 * @alpha
 */
declare const TemplateGroups: (props: TemplateGroupsProps) => react_jsx_runtime.JSX.Element | null;

/**
 * @alpha
 */
type WorkflowProps = {
    title?: string;
    description?: string;
    namespace: string;
    templateName: string;
    components?: {
        ReviewStepComponent?: ComponentType<ReviewStepProps>;
    };
    onError(error: Error | undefined): JSX.Element | null;
} & Pick<StepperProps, 'extensions' | 'formProps' | 'components' | 'onCreate' | 'initialState' | 'layouts'>;
/**
 * @alpha
 */
declare const Workflow: (workflowProps: WorkflowProps) => JSX.Element | null;
/**
 * @alpha
 */
declare const EmbeddableWorkflow: (props: WorkflowProps) => react_jsx_runtime.JSX.Element;

/**
 * The DefaultOutputs renderer for the scaffolder task output
 *
 * @alpha
 */
declare const DefaultTemplateOutputs: (props: {
    output?: ScaffolderTaskOutput;
}) => react_jsx_runtime.JSX.Element | null;

/**
 * The Form component
 * @alpha
 */
declare const Form: (props: PropsWithChildren<ScaffolderRJSFFormProps>) => react_jsx_runtime.JSX.Element;

/**
 * Props for the TaskSteps component
 *
 * @alpha
 */
interface TaskStepsProps {
    steps: (TaskStep & ScaffolderStep)[];
    activeStep?: number;
    isComplete?: boolean;
    isError?: boolean;
}
/**
 * The visual stepper of the task event stream
 *
 * @alpha
 */
declare const TaskSteps: (props: TaskStepsProps) => react_jsx_runtime.JSX.Element;

/**
 * The text of the event stream
 *
 * @alpha
 */
declare const TaskLogStream: (props: {
    logs: {
        [k: string]: string[];
    };
}) => react_jsx_runtime.JSX.Element;

/** @alpha */
type ScaffolderReactTemplateCategoryPickerClassKey = 'root' | 'label';
/**
 * The Category Picker that is rendered on the left side for picking
 * categories and filtering the template list.
 * @alpha
 */
declare const TemplateCategoryPicker: () => react_jsx_runtime.JSX.Element | null;

/**
 * @alpha
 */
type ScaffolderPageContextMenuProps = {
    onEditorClicked?: () => void;
    onActionsClicked?: () => void;
    onTasksClicked?: () => void;
    onCreateClicked?: () => void;
    onTemplatingExtensionsClicked?: () => void;
};
/**
 * @alpha
 */
declare function ScaffolderPageContextMenu(props: ScaffolderPageContextMenuProps): react_jsx_runtime.JSX.Element | null;

/**
 * Props for the {@link ScaffolderField} component
 * @alpha
 */
interface ScaffolderFieldProps {
    rawDescription?: string;
    errors?: ReactElement;
    rawErrors?: string[];
    help?: ReactElement;
    rawHelp?: string;
    required?: boolean;
    disabled?: boolean;
    displayLabel?: boolean;
}
/**
 * A component to wrap up a input field which helps with formatting and supporting markdown
 * on the field types
 * @alpha
 */
declare const ScaffolderField: (props: PropsWithChildren<ScaffolderFieldProps>) => react_jsx_runtime.JSX.Element;

/**
 * Secret Widget for overriding the default password input widget
 * @alpha
 */
declare const SecretWidget: (props: Pick<WidgetProps, "name" | "onChange" | "schema" | "required" | "disabled">) => react_jsx_runtime.JSX.Element;

/**
 * Takes a step from a Backstage Template Manifest and converts it to a JSON Schema and UI Schema for rjsf
 * @alpha
 */
declare const extractSchemaFromStep: (inputStep: JsonObject) => {
    uiSchema: UiSchema;
    schema: JsonObject;
};
/**
 * Creates a field validation object for use in react jsonschema form
 * @alpha
 */
declare const createFieldValidation: () => FieldValidation;

/**
 * This hook is used to get the formData from the query string.
 * @alpha
 */
declare const useFormDataFromQuery: (initialState?: Record<string, JsonValue>) => [Record<string, any>, react.Dispatch<react.SetStateAction<Record<string, any>>>];

/**
 * @alpha
 */
declare const useTemplateParameterSchema: (templateRef: string) => {
    manifest?: TemplateParameterSchema;
    loading: boolean;
    error?: Error;
};

/**
 * Returns manifest of software templates with steps without a featureFlag tag.
 * @alpha
 */
declare const useFilteredSchemaProperties: (manifest: TemplateParameterSchema | undefined) => TemplateParameterSchema | undefined;

/** @alpha */
type ScaffolderReactComponentsNameToClassKey = {
    ScaffolderReactTemplateCategoryPicker: ScaffolderReactTemplateCategoryPickerClassKey;
    BackstageTemplateStepper: BackstageTemplateStepperClassKey;
};
/** @alpha */
type BackstageOverrides = Overrides & {
    [Name in keyof ScaffolderReactComponentsNameToClassKey]?: Partial<StyleRules<ScaffolderReactComponentsNameToClassKey[Name]>>;
};
declare module '@backstage/theme' {
    interface OverrideComponentNameToClassKeys extends ScaffolderReactComponentsNameToClassKey {
    }
}

/** @alpha */
declare const scaffolderReactTranslationRef: _backstage_core_plugin_api_alpha.TranslationRef<"scaffolder-react", {
    readonly "workflow.noDescription": "No description";
    readonly "passwordWidget.content": "This widget is insecure. Please use [`ui:field: Secret`](https://backstage.io/docs/features/software-templates/writing-templates/#using-secrets) instead of `ui:widget: password`";
    readonly "scaffolderPageContextMenu.createLabel": "Create";
    readonly "scaffolderPageContextMenu.moreLabel": "more";
    readonly "scaffolderPageContextMenu.editorLabel": "Manage Templates";
    readonly "scaffolderPageContextMenu.actionsLabel": "Installed Actions";
    readonly "scaffolderPageContextMenu.tasksLabel": "Task List";
    readonly "scaffolderPageContextMenu.templatingExtensionsLabel": "Templating Extensions";
    readonly "stepper.backButtonText": "Back";
    readonly "stepper.createButtonText": "Create";
    readonly "stepper.reviewButtonText": "Review";
    readonly "stepper.nextButtonText": "Next";
    readonly "stepper.stepIndexLabel": "Step {{index, number}}";
    readonly "templateCategoryPicker.title": "Categories";
    readonly "templateCard.noDescription": "No description";
    readonly "templateCard.chooseButtonText": "Choose";
    readonly "cardHeader.detailBtnTitle": "Show template entity details";
    readonly "templateOutputs.title": "Text Output";
}>;

export { type BackstageOverrides, type BackstageTemplateStepperClassKey, DefaultTemplateOutputs, EmbeddableWorkflow, Form, FormDecoratorBlueprint, type FormField, FormFieldBlueprint, type FormFieldExtensionData, type FormValidation, type ParsedTemplateSchema, ReviewState, type ReviewStateProps, ScaffolderField, type ScaffolderFieldProps, type ScaffolderFormDecorator, type ScaffolderFormDecoratorContext, type ScaffolderFormFieldsApi, ScaffolderPageContextMenu, type ScaffolderPageContextMenuProps, type ScaffolderReactComponentsNameToClassKey, type ScaffolderReactTemplateCategoryPickerClassKey, SecretWidget, Stepper, type StepperProps, TaskLogStream, TaskSteps, type TaskStepsProps, TemplateCard, type TemplateCardProps, TemplateCategoryPicker, TemplateGroup, type TemplateGroupProps, TemplateGroups, type TemplateGroupsProps, Workflow, type WorkflowProps, createAsyncValidators, createFieldValidation, createFormField, createScaffolderFormDecorator, extractSchemaFromStep, formFieldsApi, formFieldsApiRef, scaffolderReactTranslationRef, useFilteredSchemaProperties, useFormDataFromQuery, useTemplateParameterSchema, useTemplateSchema };
