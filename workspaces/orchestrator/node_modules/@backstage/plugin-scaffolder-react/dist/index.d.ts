import { ApiHolder, Extension } from '@backstage/core-plugin-api';
import { HTMLAttributes, ReactNode, ComponentType, FormEvent, ElementType, Ref, PropsWithChildren } from 'react';
import { JsonObject } from '@backstage/types';
import { JSONSchema7 } from 'json-schema';
import { StrictRJSFSchema, RJSFSchema, FormContextType, GenericObjectType, UiSchema, IdSchema, ErrorSchema, Registry, ValidatorType, TemplatesType, RegistryWidgetsType, RJSFValidationError, CustomValidator, ErrorTransformer, Experimental_DefaultFormStateBehavior, FieldValidation, UIOptionsType } from '@rjsf/utils';
import Form, { IChangeEvent, FormProps as FormProps$1 } from '@rjsf/core';
import * as _backstage_plugin_scaffolder_common from '@backstage/plugin-scaffolder-common';
import { TemplateEntityV1beta3, TemplateParameterSchema as TemplateParameterSchema$1, ScaffolderTaskStatus as ScaffolderTaskStatus$1, ScaffolderTask as ScaffolderTask$1, ScaffolderUsageExample as ScaffolderUsageExample$1, Action as Action$1, ListActionsResponse as ListActionsResponse$1, TemplateFilter as TemplateFilter$1, TemplateGlobalFunction as TemplateGlobalFunction$1, TemplateGlobalValue as TemplateGlobalValue$1, ListTemplatingExtensionsResponse as ListTemplatingExtensionsResponse$1, ScaffolderOutputLink as ScaffolderOutputLink$1, ScaffolderOutputText as ScaffolderOutputText$1, ScaffolderTaskOutput as ScaffolderTaskOutput$1, LogEvent as LogEvent$1, ScaffolderScaffoldOptions as ScaffolderScaffoldOptions$1, ScaffolderScaffoldResponse as ScaffolderScaffoldResponse$1, ScaffolderGetIntegrationsListOptions as ScaffolderGetIntegrationsListOptions$1, ScaffolderGetIntegrationsListResponse as ScaffolderGetIntegrationsListResponse$1, ScaffolderStreamLogsOptions as ScaffolderStreamLogsOptions$1, ScaffolderDryRunOptions as ScaffolderDryRunOptions$1, ScaffolderDryRunResponse as ScaffolderDryRunResponse$1, ScaffolderApi as ScaffolderApi$1 } from '@backstage/plugin-scaffolder-common';
import * as react_jsx_runtime from 'react/jsx-runtime';
import * as _backstage_frontend_plugin_api from '@backstage/frontend-plugin-api';
import { z } from 'zod';

/**
 * The props for the `Field` components
 * @public
 */
interface ScaffolderRJSFFieldProps<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any> extends GenericObjectType, Pick<HTMLAttributes<HTMLElement>, Exclude<keyof HTMLAttributes<HTMLElement>, 'onBlur' | 'onFocus' | 'onChange'>> {
    /** The JSON subschema object for this field */
    schema: S;
    /** The uiSchema for this field */
    uiSchema: UiSchema<T, S, F>;
    /** The tree of unique ids for every child field */
    idSchema: IdSchema<T>;
    /** The data for this field */
    formData?: T;
    /** The tree of errors for this field and its children */
    errorSchema?: ErrorSchema<T>;
    /** The field change event handler; called with the updated form data and an optional `ErrorSchema` */
    onChange: (newFormData: T | undefined, es?: ErrorSchema<T>, id?: string) => any;
    /** The input blur event handler; call it with the field id and value */
    onBlur: (id: string, value: any) => void;
    /** The input focus event handler; call it with the field id and value */
    onFocus: (id: string, value: any) => void;
    /** The `formContext` object that you passed to `Form` */
    formContext?: F;
    /** A boolean value stating if the field should autofocus */
    autofocus?: boolean;
    /** A boolean value stating if the field is disabled */
    disabled: boolean;
    /** A boolean value stating if the field is hiding its errors */
    hideError?: boolean;
    /** A boolean value stating if the field is read-only */
    readonly: boolean;
    /** The required status of this field */
    required?: boolean;
    /** The unique name of the field, usually derived from the name of the property in the JSONSchema */
    name: string;
    /** To avoid collisions with existing ids in the DOM, it is possible to change the prefix used for ids;
     * Default is `root`
     */
    idPrefix?: string;
    /** To avoid using a path separator that is present in field names, it is possible to change the separator used for
     * ids (Default is `_`)
     */
    idSeparator?: string;
    /** An array of strings listing all generated error messages from encountered errors for this field */
    rawErrors: string[];
    /** The `registry` object */
    registry: Registry<T, S, F>;
}
/**
 * The properties that are passed to the `Form`
 * @public
 */
interface ScaffolderRJSFFormProps<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any> {
    /** The JSON schema object for the form */
    schema: S;
    /** An implementation of the `ValidatorType` interface that is needed for form validation to work */
    validator: ValidatorType<T, S, F>;
    /** The optional children for the form, if provided, it will replace the default `SubmitButton` */
    children?: ReactNode;
    /** The uiSchema for the form */
    uiSchema?: UiSchema<T, S, F>;
    /** The data for the form, used to prefill a form with existing data */
    formData?: T;
    /** You can provide a `formContext` object to the form, which is passed down to all fields and widgets. Useful for
     * implementing context aware fields and widgets.
     *
     * NOTE: Setting `{readonlyAsDisabled: false}` on the formContext will make the antd theme treat readOnly fields as
     * disabled.
     */
    formContext?: F;
    /** To avoid collisions with existing ids in the DOM, it is possible to change the prefix used for ids;
     * Default is `root`
     */
    idPrefix?: string;
    /** To avoid using a path separator that is present in field names, it is possible to change the separator used for
     * ids (Default is `_`)
     */
    idSeparator?: string;
    /** It's possible to disable the whole form by setting the `disabled` prop. The `disabled` prop is then forwarded down
     * to each field of the form. If you just want to disable some fields, see the `ui:disabled` parameter in `uiSchema`
     */
    disabled?: boolean;
    /** It's possible to make the whole form read-only by setting the `readonly` prop. The `readonly` prop is then
     * forwarded down to each field of the form. If you just want to make some fields read-only, see the `ui:readonly`
     * parameter in `uiSchema`
     */
    readonly?: boolean;
    /** The dictionary of registered fields in the form */
    fields?: ScaffolderRJSFRegistryFieldsType<T, S, F>;
    /** The dictionary of registered templates in the form; Partial allows a subset to be provided beyond the defaults */
    templates?: Partial<Omit<TemplatesType<T, S, F>, 'ButtonTemplates'>> & {
        ButtonTemplates?: Partial<TemplatesType<T, S, F>['ButtonTemplates']>;
    };
    /** The dictionary of registered widgets in the form */
    widgets?: RegistryWidgetsType<T, S, F>;
    /** If you plan on being notified every time the form data are updated, you can pass an `onChange` handler, which will
     * receive the same args as `onSubmit` any time a value is updated in the form. Can also return the `id` of the field
     * that caused the change
     */
    onChange?: (data: IChangeEvent<T, S, F>, id?: string) => void;
    /** To react when submitted form data are invalid, pass an `onError` handler. It will be passed the list of
     * encountered errors
     */
    onError?: (errors: RJSFValidationError[]) => void;
    /** You can pass a function as the `onSubmit` prop of your `Form` component to listen to when the form is submitted
     * and its data are valid. It will be passed a result object having a `formData` attribute, which is the valid form
     * data you're usually after. The original event will also be passed as a second parameter
     */
    onSubmit?: (data: IChangeEvent<T, S, F>, event: FormEvent<any>) => void;
    /** Sometimes you may want to trigger events or modify external state when a field has been touched, so you can pass
     * an `onBlur` handler, which will receive the id of the input that was blurred and the field value
     */
    onBlur?: (id: string, data: any) => void;
    /** Sometimes you may want to trigger events or modify external state when a field has been focused, so you can pass
     * an `onFocus` handler, which will receive the id of the input that is focused and the field value
     */
    onFocus?: (id: string, data: any) => void;
    /** The value of this prop will be passed to the `accept-charset` HTML attribute on the form */
    acceptcharset?: string;
    /** The value of this prop will be passed to the `action` HTML attribute on the form
     *
     * NOTE: this just renders the `action` attribute in the HTML markup. There is no real network request being sent to
     * this `action` on submit. Instead, react-jsonschema-form catches the submit event with `event.preventDefault()`
     * and then calls the `onSubmit` function, where you could send a request programmatically with `fetch` or similar.
     */
    action?: string;
    /** The value of this prop will be passed to the `autocomplete` HTML attribute on the form */
    autoComplete?: string;
    /** The value of this prop will be passed to the `class` HTML attribute on the form */
    className?: string;
    /** The value of this prop will be passed to the `enctype` HTML attribute on the form */
    enctype?: string;
    /** The value of this prop will be passed to the `id` HTML attribute on the form */
    id?: string;
    /** The value of this prop will be passed to the `name` HTML attribute on the form */
    name?: string;
    /** The value of this prop will be passed to the `method` HTML attribute on the form */
    method?: string;
    /** It's possible to change the default `form` tag name to a different HTML tag, which can be helpful if you are
     * nesting forms. However, native browser form behaviour, such as submitting when the `Enter` key is pressed, may no
     * longer work
     */
    tagName?: ElementType;
    /** The value of this prop will be passed to the `target` HTML attribute on the form */
    target?: string;
    /** Formerly the `validate` prop; Takes a function that specifies custom validation rules for the form */
    customValidate?: CustomValidator<T, S, F>;
    /** This prop allows passing in custom errors that are augmented with the existing JSON Schema errors on the form; it
     * can be used to implement asynchronous validation
     */
    extraErrors?: ErrorSchema<T>;
    /** If set to true, turns off HTML5 validation on the form; Set to `false` by default */
    noHtml5Validate?: boolean;
    /** If set to true, turns off all validation. Set to `false` by default
     *
     * @deprecated - In a future release, this switch may be replaced by making `validator` prop optional
     */
    noValidate?: boolean;
    /** If set to true, the form will perform validation and show any validation errors whenever the form data is changed,
     * rather than just on submit
     */
    liveValidate?: boolean;
    /** If `omitExtraData` and `liveOmit` are both set to true, then extra form data values that are not in any form field
     * will be removed whenever `onChange` is called. Set to `false` by default
     */
    liveOmit?: boolean;
    /** If set to true, then extra form data values that are not in any form field will be removed whenever `onSubmit` is
     * called. Set to `false` by default.
     */
    omitExtraData?: boolean;
    /** When this prop is set to `top` or 'bottom', a list of errors (or the custom error list defined in the `ErrorList`) will also
     * show. When set to false, only inline input validation errors will be shown. Set to `top` by default
     */
    showErrorList?: false | 'top' | 'bottom';
    /** A function can be passed to this prop in order to make modifications to the default errors resulting from JSON
     * Schema validation
     */
    transformErrors?: ErrorTransformer<T, S, F>;
    /** If set to true, then the first field with an error will receive the focus when the form is submitted with errors
     */
    focusOnFirstError?: boolean | ((error: RJSFValidationError) => void);
    /** Optional string translation function, if provided, allows users to change the translation of the RJSF internal
     * strings. Some strings contain replaceable parameter values as indicated by `%1`, `%2`, etc. The number after the
     * `%` indicates the order of the parameter. The ordering of parameters is important because some languages may choose
     * to put the second parameter before the first in its translation.
     */
    translateString?: Registry['translateString'];
    /** Optional configuration object with flags, if provided, allows users to override default form state behavior
     * Currently only affecting minItems on array fields and handling of setting defaults based on the value of
     * `emptyObjectFields`
     */
    experimental_defaultFormStateBehavior?: Experimental_DefaultFormStateBehavior;
    /**
     * _internalFormWrapper is currently used by the semantic-ui theme to provide a custom wrapper around `<Form />`
     * that supports the proper rendering of those themes. To use this prop, one must pass a component that takes two
     * props: `children` and `as`. That component, at minimum, should render the `children` inside of a <form /> tag
     * unless `as` is provided, in which case, use the `as` prop in place of `<form />`.
     * i.e.:
     * ```
     * export default function InternalForm({ children, as }) {
     *   const FormTag = as || 'form';
     *   return <FormTag>{children}</FormTag>;
     * }
     * ```
     *
     * Use at your own risk as this prop is private and may change at any time without notice.
     */
    _internalFormWrapper?: ElementType;
    /** Support receiving a React ref to the Form
     */
    ref?: Ref<Form<T, S, F>>;
}
/**
 * The set of `Fields` stored in the `Registry`
 * @public
 */
type ScaffolderRJSFRegistryFieldsType<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any> = {
    /** A `Field` indexed by `name` */
    [name: string]: ScaffolderRJSFField<T, S, F>;
};
/**
 * The `Field` type for Field Extensions
 * @public
 */
type ScaffolderRJSFField<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any> = ComponentType<ScaffolderRJSFFieldProps<T, S, F>>;

/**
 * Type for Field Extension Props for RJSF v5
 *
 * @public
 */
interface FieldExtensionComponentProps<TFieldReturnValue, TUiOptions = {}> extends PropsWithChildren<ScaffolderRJSFFieldProps<TFieldReturnValue>> {
    uiSchema: FieldExtensionUiSchema<TFieldReturnValue, TUiOptions>;
}
/**
 * Type for the Custom Field Extension schema.
 *
 * @public
 */
type CustomFieldExtensionSchema = {
    returnValue: JSONSchema7;
    uiOptions?: JSONSchema7;
};
/**
 * Type for Field Extension UiSchema
 *
 * @public
 */
interface FieldExtensionUiSchema<TFieldReturnValue, TUiOptions> extends UiSchema<TFieldReturnValue> {
    'ui:options'?: TUiOptions & UIOptionsType<TFieldReturnValue>;
}
/**
 * Field validation type for Custom Field Extensions.
 *
 * @public
 */
type CustomFieldValidator<TFieldReturnValue, TUiOptions = unknown> = (data: TFieldReturnValue, field: FieldValidation, context: {
    apiHolder: ApiHolder;
    formData: JsonObject;
    schema: JsonObject;
    uiSchema?: FieldExtensionUiSchema<TFieldReturnValue, TUiOptions>;
}) => void | Promise<void>;
/**
 * Type for the Custom Field Extension with the
 * name and components and validation function.
 *
 * @public
 */
type FieldExtensionOptions<TFieldReturnValue = unknown, TUiOptions = unknown> = {
    name: string;
    component: (props: FieldExtensionComponentProps<TFieldReturnValue, TUiOptions>) => JSX.Element | null;
    validation?: CustomFieldValidator<TFieldReturnValue, TUiOptions>;
    schema?: CustomFieldExtensionSchema;
};

/**
 * Method for creating field extensions that can be used in the scaffolder
 * frontend form.
 * @public
 */
declare function createScaffolderFieldExtension<TReturnValue = unknown, TInputProps extends UIOptionsType = {}>(options: FieldExtensionOptions<TReturnValue, TInputProps>): Extension<FieldExtensionComponent<TReturnValue, TInputProps>>;
/**
 * The Wrapping component for defining fields extensions inside
 *
 * @public
 */
declare const ScaffolderFieldExtensions: React.ComponentType<React.PropsWithChildren<{}>>;
/**
 * The type used to wrap up the Layout and embed the input props
 *
 * @public
 */
type FieldExtensionComponent<_TReturnValue, _TInputProps> = () => null;

/** @public  */
type TemplateGroupFilter = {
    title?: React.ReactNode;
    filter: (entity: TemplateEntityV1beta3) => boolean;
};
/**
 * Any `@rjsf/core` form properties that are publicly exposed to the `ScaffolderPage`
 *
 * @public
 */
type FormProps = Pick<FormProps$1, 'transformErrors' | 'noHtml5Validate' | 'uiSchema' | 'formContext' | 'omitExtraData' | 'liveOmit'>;
/**
 * The props for the Last Step in scaffolder template form.
 * Which represents the summary of the input provided by the end user.
 *
 * @public
 */
type ReviewStepProps = {
    disableButtons: boolean;
    formData: JsonObject;
    handleBack: () => void;
    handleReset: () => void;
    handleCreate: () => void;
    steps: {
        uiSchema: UiSchema;
        mergedSchema: JsonObject;
        schema: JsonObject;
    }[];
};

/**
 * The shape of each entry of parameters which gets rendered
 * as a separate step in the wizard input
 *
 * @public
 * @deprecated use import from {@link @backstage/plugin-scaffolder-common#TemplateParameterSchema} instead as this has now been moved.
 */
type TemplateParameterSchema = TemplateParameterSchema$1;

/**
 * The Context Provider that holds the state for the secrets.
 * @public
 */
declare const SecretsContextProvider: (props: PropsWithChildren<{
    initialSecrets?: Record<string, string>;
}>) => react_jsx_runtime.JSX.Element;
/**
 * The return type from the useTemplateSecrets hook.
 * @public
 */
interface ScaffolderUseTemplateSecrets {
    setSecrets: (input: Record<string, string>) => void;
    secrets: Record<string, string>;
}
/**
 * Hook to access the secrets context to be able to set secrets that are
 * passed to the Scaffolder backend.
 * @public
 */
declare const useTemplateSecrets: () => ScaffolderUseTemplateSecrets;

/** @public */
declare const scaffolderApiRef: _backstage_frontend_plugin_api.ApiRef<_backstage_plugin_scaffolder_common.ScaffolderApi>;

/**
 * The status of each task in a Scaffolder Job
 *
 * @public
 * @deprecated use import from {@link @backstage/plugin-scaffolder-common#ScaffolderTaskStatus} instead as this has now been moved.
 */
type ScaffolderTaskStatus = ScaffolderTaskStatus$1;
/**
 * The shape of each task returned from the `scaffolder-backend`
 *
 * @public
 * @deprecated use import from {@link @backstage/plugin-scaffolder-common#ScaffolderTask} instead as this has now been moved.
 */
type ScaffolderTask = ScaffolderTask$1;
/**
 * A single scaffolder usage example
 *
 * @public
 * @deprecated use import from {@link @backstage/plugin-scaffolder-common#ScaffolderUsageExample} instead as this has now been moved.
 */
type ScaffolderUsageExample = ScaffolderUsageExample$1;
/**
 * A single action example
 *
 * @public
 * @deprecated in favor of ScaffolderUsageExample
 */
type ActionExample = ScaffolderUsageExample;
/**
 * The response shape for a single action in the `listActions` call to the `scaffolder-backend`
 *
 * @public
 * @deprecated use import from {@link @backstage/plugin-scaffolder-common#Action} instead as this has now been moved.
 */
type Action = Action$1;
/**
 * The response shape for the `listActions` call to the `scaffolder-backend`
 *
 * @public
 * @deprecated use import from {@link @backstage/plugin-scaffolder-common#ListActionsResponse} instead as this has now been moved.
 */
type ListActionsResponse = ListActionsResponse$1;
/**
 * The response shape for a single filter in the `listTemplatingExtensions` call to the `scaffolder-backend`
 *
 * @public
 * @deprecated use import from {@link @backstage/plugin-scaffolder-common#TemplateFilter} instead as this has now been moved.
 */
type TemplateFilter = TemplateFilter$1;
/**
 * The response shape for a single global function in the `listTemplatingExtensions` call to the `scaffolder-backend`
 *
 * @public
 * @deprecated use import from {@link @backstage/plugin-scaffolder-common#TemplateGlobalFunction} instead as this has now been moved.
 */
type TemplateGlobalFunction = TemplateGlobalFunction$1;
/**
 * The response shape for a single global value in the `listTemplatingExtensions` call to the `scaffolder-backend`
 *
 * @public
 * @deprecated use import from {@link @backstage/plugin-scaffolder-common#TemplateGlobalValue} instead as this has now been moved.
 */
type TemplateGlobalValue = TemplateGlobalValue$1;
/**
 * The response shape for the `listTemplatingExtensions` call to the `scaffolder-backend`
 *
 * @public
 * @deprecated use import from {@link @backstage/plugin-scaffolder-common#ListTemplatingExtensionsResponse} instead as this has now been moved.
 */
type ListTemplatingExtensionsResponse = ListTemplatingExtensionsResponse$1;
/**
 * @public
 * @deprecated use import from {@link @backstage/plugin-scaffolder-common#ScaffolderOutputLink} instead as this has now been moved.
 */
type ScaffolderOutputLink = ScaffolderOutputLink$1;
/**
 * @public
 * @deprecated use import from {@link @backstage/plugin-scaffolder-common#ScaffolderOutputText} instead as this has now been moved.
 */
type ScaffolderOutputText = ScaffolderOutputText$1;
/**
 * @public
 * @deprecated use import from {@link @backstage/plugin-scaffolder-common#ScaffolderTaskOutput} instead as this has now been moved.
 */
type ScaffolderTaskOutput = ScaffolderTaskOutput$1;
/**
 * The shape of a `LogEvent` message from the `scaffolder-backend`
 *
 * @public
 * @deprecated use import from {@link @backstage/plugin-scaffolder-common#LogEvent} instead as this has now been moved.
 */
type LogEvent = LogEvent$1;
/**
 * The input options to the `scaffold` method of the `ScaffolderClient`.
 *
 * @public
 * @deprecated use import from {@link @backstage/plugin-scaffolder-common#ScaffolderScaffoldOptions} instead as this has now been moved.
 */
type ScaffolderScaffoldOptions = ScaffolderScaffoldOptions$1;
/**
 * The response shape of the `scaffold` method of the `ScaffolderClient`.
 *
 * @public
 * @deprecated use import from {@link @backstage/plugin-scaffolder-common#ScaffolderScaffoldResponse} instead as this has now been moved.
 */
type ScaffolderScaffoldResponse = ScaffolderScaffoldResponse$1;
/**
 * The arguments for `getIntegrationsList`.
 *
 * @public
 * @deprecated use import from {@link @backstage/plugin-scaffolder-common#ScaffolderGetIntegrationsListOptions} instead as this has now been moved.
 */
type ScaffolderGetIntegrationsListOptions = ScaffolderGetIntegrationsListOptions$1;
/**
 * The response shape for `getIntegrationsList`.
 *
 * @public
 * @deprecated use import from {@link @backstage/plugin-scaffolder-common#ScaffolderGetIntegrationsListResponse} instead as this has now been moved.
 */
type ScaffolderGetIntegrationsListResponse = ScaffolderGetIntegrationsListResponse$1;
/**
 * The input options to the `streamLogs` method of the `ScaffolderClient`.
 *
 * @public
 * @deprecated use import from {@link @backstage/plugin-scaffolder-common#ScaffolderStreamLogsOptions} instead as this has now been moved.
 */
type ScaffolderStreamLogsOptions = ScaffolderStreamLogsOptions$1;
/**
 * @public
 * @deprecated use import from {@link @backstage/plugin-scaffolder-common#ScaffolderDryRunOptions} instead as this has now been moved.
 */
type ScaffolderDryRunOptions = ScaffolderDryRunOptions$1;
/**
 * @public
 * @deprecated use import from {@link @backstage/plugin-scaffolder-common#ScaffolderDryRunResponse} instead as this has now been moved.
 */
type ScaffolderDryRunResponse = ScaffolderDryRunResponse$1;
/**
 * An API to interact with the scaffolder backend.
 *
 * @public
 * @deprecated use import from {@link @backstage/plugin-scaffolder-common#ScaffolderApi} instead as this has now been moved.
 */
type ScaffolderApi = ScaffolderApi$1;

/**
 * Hook that returns all custom field extensions from the current outlet.
 * @public
 */
declare const useCustomFieldExtensions: <TComponentDataType = FieldExtensionOptions>(outlet: React.ReactNode) => TComponentDataType[];

/**
 * The field template from `@rjsf/core` which is a react component that gets passed `@rjsf/core` field related props.
 *
 * @public
 */
type LayoutTemplate<T = any> = NonNullable<FormProps$1<T>['uiSchema']>['ui:ObjectFieldTemplate'];
/**
 * The type of layouts that is passed to the TemplateForms
 *
 * @public
 */
interface LayoutOptions<P = any> {
    name: string;
    component: LayoutTemplate<P>;
}
/**
 * A type used to wrap up the FieldExtension to embed the ReturnValue and the InputProps
 * @public
 */
type LayoutComponent<_TInputProps> = () => null;
/**
 * Method for creating custom Layouts that can be used in the scaffolder frontend form
 *
 * @public
 */
declare function createScaffolderLayout<TInputProps = unknown>(options: LayoutOptions): Extension<LayoutComponent<TInputProps>>;
/**
 * The wrapping component for defining scaffolder layouts as children
 *
 * @public
 */
declare const ScaffolderLayouts: ComponentType<PropsWithChildren<{}>>;

/**
 * Hook that returns all custom field extensions from the current outlet.
 * @public
 */
declare const useCustomLayouts: <TComponentDataType = LayoutOptions<any>>(outlet: React.ReactNode) => TComponentDataType[];

/**
 * The status of the step being processed
 *
 * @public
 */
type ScaffolderStep = {
    id: string;
    status: ScaffolderTaskStatus;
    endedAt?: string;
    startedAt?: string;
};
/**
 * A task event from the event stream
 *
 * @public
 */
type TaskStream = {
    cancelled: boolean;
    loading: boolean;
    error?: Error;
    stepLogs: {
        [stepId in string]: string[];
    };
    completed: boolean;
    task?: ScaffolderTask;
    steps: {
        [stepId in string]: ScaffolderStep;
    };
    output?: ScaffolderTaskOutput;
};
/**
 * A hook to stream the logs of a task being processed
 *
 * @public
 */
declare const useTaskEventStream: (taskId: string) => TaskStream;

/** @public */
declare function makeFieldSchema<TReturnType extends z.ZodType, TUiOptions extends z.ZodType>(options: {
    output: (zImpl: typeof z) => TReturnType;
    uiOptions?: (zImpl: typeof z) => TUiOptions;
}): FieldSchema<z.output<TReturnType>, z.output<TUiOptions>>;
/**
 * @public
 * FieldSchema encapsulates a JSONSchema7 along with the
 * matching FieldExtensionComponentProps type for a field extension.
 */
interface FieldSchema<TReturn, TUiOptions> {
    /** @deprecated use TProps instead */
    readonly type: FieldExtensionComponentProps<TReturn, TUiOptions>;
    /** @deprecated will be removed */
    readonly uiOptionsType: TUiOptions;
    readonly schema: CustomFieldExtensionSchema;
    readonly TProps: FieldExtensionComponentProps<TReturn, TUiOptions>;
    readonly TOutput: TReturn;
}

export { type Action, type ActionExample, type CustomFieldExtensionSchema, type CustomFieldValidator, type FieldExtensionComponent, type FieldExtensionComponentProps, type FieldExtensionOptions, type FieldExtensionUiSchema, type FieldSchema, type FormProps, type LayoutComponent, type LayoutOptions, type LayoutTemplate, type ListActionsResponse, type ListTemplatingExtensionsResponse, type LogEvent, type ReviewStepProps, type ScaffolderApi, type ScaffolderDryRunOptions, type ScaffolderDryRunResponse, ScaffolderFieldExtensions, type ScaffolderGetIntegrationsListOptions, type ScaffolderGetIntegrationsListResponse, ScaffolderLayouts, type ScaffolderOutputLink, type ScaffolderOutputText, type ScaffolderRJSFField, type ScaffolderRJSFFieldProps, type ScaffolderRJSFFormProps, type ScaffolderRJSFRegistryFieldsType, type ScaffolderScaffoldOptions, type ScaffolderScaffoldResponse, type ScaffolderStep, type ScaffolderStreamLogsOptions, type ScaffolderTask, type ScaffolderTaskOutput, type ScaffolderTaskStatus, type ScaffolderUsageExample, type ScaffolderUseTemplateSecrets, SecretsContextProvider, type TaskStream, type TemplateFilter, type TemplateGlobalFunction, type TemplateGlobalValue, type TemplateGroupFilter, type TemplateParameterSchema, createScaffolderFieldExtension, createScaffolderLayout, makeFieldSchema, scaffolderApiRef, useCustomFieldExtensions, useCustomLayouts, useTaskEventStream, useTemplateSecrets };
