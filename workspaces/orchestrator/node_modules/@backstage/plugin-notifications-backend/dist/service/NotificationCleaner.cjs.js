'use strict';

var config = require('@backstage/config');
var errors = require('@backstage/errors');

class NotificationCleaner {
  constructor(config$1, scheduler, logger, database) {
    this.scheduler = scheduler;
    this.logger = logger;
    this.database = database;
    if (config$1.has("notifications.retention")) {
      const retentionConfig = config$1.get("notifications.retention");
      if (typeof retentionConfig === "boolean" && !retentionConfig) {
        logger.info(
          "Notification retention is disabled, skipping notification cleaner task"
        );
        this.enabled = false;
        return;
      }
      this.retention = config.readDurationFromConfig(config$1, {
        key: "notifications.retention"
      });
    }
  }
  retention = { years: 1 };
  enabled = true;
  async initTaskRunner() {
    if (!this.enabled) {
      return;
    }
    const schedule = {
      frequency: { cron: "0 0 * * *" },
      timeout: { hours: 1 },
      initialDelay: { hours: 1 },
      scope: "global"
    };
    const taskRunner = this.scheduler.createScheduledTaskRunner(schedule);
    await taskRunner.run({
      id: "notification-cleaner",
      fn: async () => {
        await this.clearNotifications(
          this.logger,
          this.database,
          this.retention
        );
      }
    });
  }
  async clearNotifications(logger, database, retention) {
    logger.info("Starting notification cleaner task");
    try {
      const result = await database.clearNotifications({ maxAge: retention });
      logger.info(
        `Notification cleaner task completed successfully, deleted ${result.deletedCount} notifications`
      );
    } catch (error) {
      throw new errors.ForwardedError("Notification cleaner task failed", error);
    }
  }
}

exports.NotificationCleaner = NotificationCleaner;
//# sourceMappingURL=NotificationCleaner.cjs.js.map
