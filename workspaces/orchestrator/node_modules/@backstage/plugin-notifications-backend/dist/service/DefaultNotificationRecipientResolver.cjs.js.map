{"version":3,"file":"DefaultNotificationRecipientResolver.cjs.js","sources":["../../src/service/DefaultNotificationRecipientResolver.ts"],"sourcesContent":["/*\n * Copyright 2024 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Entity,\n  isGroupEntity,\n  isUserEntity,\n  parseEntityRef,\n  RELATION_HAS_MEMBER,\n  RELATION_OWNED_BY,\n  RELATION_PARENT_OF,\n  stringifyEntityRef,\n} from '@backstage/catalog-model';\nimport { AuthService } from '@backstage/backend-plugin-api';\nimport { CatalogService } from '@backstage/plugin-catalog-node';\nimport { NotificationRecipientResolver } from '@backstage/plugin-notifications-node';\n\nconst isUserEntityRef = (ref: string) =>\n  parseEntityRef(ref).kind.toLocaleLowerCase() === 'user';\n\n// Partitions array of entity references to two arrays; user entity refs and other entity refs\nconst partitionEntityRefs = (refs: string[]): string[][] => {\n  const ret = [[], []] as string[][];\n  for (const ref of refs) {\n    if (isUserEntityRef(ref)) {\n      ret[0].push(ref);\n    } else {\n      ret[1].push(ref);\n    }\n  }\n  return ret;\n};\n\nexport class DefaultNotificationRecipientResolver\n  implements NotificationRecipientResolver\n{\n  constructor(\n    private readonly auth: AuthService,\n    private readonly catalog: CatalogService,\n  ) {}\n\n  async resolveNotificationRecipients(options: {\n    entityRefs: string[];\n    excludeEntityRefs?: string[];\n  }): Promise<{ userEntityRefs: string[] }> {\n    const { entityRefs, excludeEntityRefs = [] } = options;\n\n    const [userEntityRefs, otherEntityRefs] = partitionEntityRefs(entityRefs);\n    const users: string[] = userEntityRefs.filter(\n      ref => !excludeEntityRefs.includes(ref),\n    );\n    const filtered = otherEntityRefs.filter(\n      ref => !excludeEntityRefs.includes(ref),\n    );\n\n    const fields = ['kind', 'metadata.name', 'metadata.namespace', 'relations'];\n    let entities: Array<Entity | undefined> = [];\n    if (filtered.length > 0) {\n      const fetchedEntities = await this.catalog.getEntitiesByRefs(\n        {\n          entityRefs: filtered,\n          fields,\n        },\n        { credentials: await this.auth.getOwnServiceCredentials() },\n      );\n      entities = fetchedEntities.items;\n    }\n\n    const cachedEntityRefs = new Map<string, string[]>();\n\n    const mapEntity = async (entity: Entity | undefined): Promise<string[]> => {\n      if (!entity) {\n        return [];\n      }\n\n      const currentEntityRef = stringifyEntityRef(entity);\n      if (excludeEntityRefs.includes(currentEntityRef)) {\n        return [];\n      }\n\n      if (cachedEntityRefs.has(currentEntityRef)) {\n        return cachedEntityRefs.get(currentEntityRef)!;\n      }\n\n      if (isUserEntity(entity)) {\n        return [currentEntityRef];\n      }\n\n      if (isGroupEntity(entity)) {\n        if (!entity.relations?.length) {\n          return [];\n        }\n\n        const groupUsers = entity.relations\n          .filter(\n            relation =>\n              relation.type === RELATION_HAS_MEMBER &&\n              isUserEntityRef(relation.targetRef),\n          )\n          .map(r => r.targetRef);\n\n        const childGroupRefs = entity.relations\n          .filter(relation => relation.type === RELATION_PARENT_OF)\n          .map(r => r.targetRef);\n\n        let childGroupUsers: string[][] = [];\n        if (childGroupRefs.length > 0) {\n          const childGroups = await this.catalog.getEntitiesByRefs(\n            {\n              entityRefs: childGroupRefs,\n              fields,\n            },\n            { credentials: await this.auth.getOwnServiceCredentials() },\n          );\n          childGroupUsers = await Promise.all(childGroups.items.map(mapEntity));\n        }\n\n        const ret = [\n          ...new Set([...groupUsers, ...childGroupUsers.flat(2)]),\n        ].filter(ref => !excludeEntityRefs.includes(ref));\n        cachedEntityRefs.set(currentEntityRef, ret);\n        return ret;\n      }\n\n      if (entity.relations?.length) {\n        const ownerRef = entity.relations.find(\n          relation => relation.type === RELATION_OWNED_BY,\n        )?.targetRef;\n\n        if (!ownerRef) {\n          return [];\n        }\n\n        if (isUserEntityRef(ownerRef)) {\n          if (excludeEntityRefs.includes(ownerRef)) {\n            return [];\n          }\n          return [ownerRef];\n        }\n\n        const owner = await this.catalog.getEntityByRef(ownerRef, {\n          credentials: await this.auth.getOwnServiceCredentials(),\n        });\n        const ret = await mapEntity(owner);\n        cachedEntityRefs.set(currentEntityRef, ret);\n        return ret;\n      }\n\n      return [];\n    };\n\n    for (const entity of entities) {\n      const u = await mapEntity(entity);\n      users.push(...u);\n    }\n\n    return {\n      userEntityRefs: [...new Set(users)]\n        .filter(Boolean)\n        // Need to filter again after resolving users\n        .filter(ref => !excludeEntityRefs.includes(ref)),\n    };\n  }\n}\n"],"names":["parseEntityRef","stringifyEntityRef","isUserEntity","isGroupEntity","RELATION_HAS_MEMBER","RELATION_PARENT_OF","RELATION_OWNED_BY"],"mappings":"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"}