'use strict';

var catalogModel = require('@backstage/catalog-model');

const isUserEntityRef = (ref) => catalogModel.parseEntityRef(ref).kind.toLocaleLowerCase() === "user";
const partitionEntityRefs = (refs) => {
  const ret = [[], []];
  for (const ref of refs) {
    if (isUserEntityRef(ref)) {
      ret[0].push(ref);
    } else {
      ret[1].push(ref);
    }
  }
  return ret;
};
class DefaultNotificationRecipientResolver {
  constructor(auth, catalog) {
    this.auth = auth;
    this.catalog = catalog;
  }
  async resolveNotificationRecipients(options) {
    const { entityRefs, excludeEntityRefs = [] } = options;
    const [userEntityRefs, otherEntityRefs] = partitionEntityRefs(entityRefs);
    const users = userEntityRefs.filter(
      (ref) => !excludeEntityRefs.includes(ref)
    );
    const filtered = otherEntityRefs.filter(
      (ref) => !excludeEntityRefs.includes(ref)
    );
    const fields = ["kind", "metadata.name", "metadata.namespace", "relations"];
    let entities = [];
    if (filtered.length > 0) {
      const fetchedEntities = await this.catalog.getEntitiesByRefs(
        {
          entityRefs: filtered,
          fields
        },
        { credentials: await this.auth.getOwnServiceCredentials() }
      );
      entities = fetchedEntities.items;
    }
    const cachedEntityRefs = /* @__PURE__ */ new Map();
    const mapEntity = async (entity) => {
      if (!entity) {
        return [];
      }
      const currentEntityRef = catalogModel.stringifyEntityRef(entity);
      if (excludeEntityRefs.includes(currentEntityRef)) {
        return [];
      }
      if (cachedEntityRefs.has(currentEntityRef)) {
        return cachedEntityRefs.get(currentEntityRef);
      }
      if (catalogModel.isUserEntity(entity)) {
        return [currentEntityRef];
      }
      if (catalogModel.isGroupEntity(entity)) {
        if (!entity.relations?.length) {
          return [];
        }
        const groupUsers = entity.relations.filter(
          (relation) => relation.type === catalogModel.RELATION_HAS_MEMBER && isUserEntityRef(relation.targetRef)
        ).map((r) => r.targetRef);
        const childGroupRefs = entity.relations.filter((relation) => relation.type === catalogModel.RELATION_PARENT_OF).map((r) => r.targetRef);
        let childGroupUsers = [];
        if (childGroupRefs.length > 0) {
          const childGroups = await this.catalog.getEntitiesByRefs(
            {
              entityRefs: childGroupRefs,
              fields
            },
            { credentials: await this.auth.getOwnServiceCredentials() }
          );
          childGroupUsers = await Promise.all(childGroups.items.map(mapEntity));
        }
        const ret = [
          .../* @__PURE__ */ new Set([...groupUsers, ...childGroupUsers.flat(2)])
        ].filter((ref) => !excludeEntityRefs.includes(ref));
        cachedEntityRefs.set(currentEntityRef, ret);
        return ret;
      }
      if (entity.relations?.length) {
        const ownerRef = entity.relations.find(
          (relation) => relation.type === catalogModel.RELATION_OWNED_BY
        )?.targetRef;
        if (!ownerRef) {
          return [];
        }
        if (isUserEntityRef(ownerRef)) {
          if (excludeEntityRefs.includes(ownerRef)) {
            return [];
          }
          return [ownerRef];
        }
        const owner = await this.catalog.getEntityByRef(ownerRef, {
          credentials: await this.auth.getOwnServiceCredentials()
        });
        const ret = await mapEntity(owner);
        cachedEntityRefs.set(currentEntityRef, ret);
        return ret;
      }
      return [];
    };
    for (const entity of entities) {
      const u = await mapEntity(entity);
      users.push(...u);
    }
    return {
      userEntityRefs: [...new Set(users)].filter(Boolean).filter((ref) => !excludeEntityRefs.includes(ref))
    };
  }
}

exports.DefaultNotificationRecipientResolver = DefaultNotificationRecipientResolver;
//# sourceMappingURL=DefaultNotificationRecipientResolver.cjs.js.map
