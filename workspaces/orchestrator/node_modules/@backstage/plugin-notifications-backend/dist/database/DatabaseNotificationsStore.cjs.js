'use strict';

var backendPluginApi = require('@backstage/backend-plugin-api');
var pluginNotificationsCommon = require('@backstage/plugin-notifications-common');
var crypto = require('crypto');
var types = require('@backstage/types');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var crypto__default = /*#__PURE__*/_interopDefaultCompat(crypto);

const migrationsDir = backendPluginApi.resolvePackagePath(
  "@backstage/plugin-notifications-backend",
  "migrations"
);
const NOTIFICATION_COLUMNS = [
  "id",
  "title",
  "description",
  "severity",
  "link",
  "origin",
  "scope",
  "topic",
  "icon",
  "created",
  "updated",
  "user",
  "read",
  "saved"
];
const normalizeSeverity = (input) => {
  let lower = (input ?? "normal").toLowerCase();
  if (pluginNotificationsCommon.notificationSeverities.indexOf(lower) < 0) {
    lower = "normal";
  }
  return lower;
};
const generateSettingsHash = (user, channel, origin, topic) => {
  const rawKey = `${user}|${channel}|${origin}|${topic ?? ""}`;
  return crypto__default.default.createHash("sha256").update(rawKey).digest("hex");
};
class DatabaseNotificationsStore {
  constructor(db) {
    this.db = db;
    this.isSQLite = this.db.client.config.client.includes("sqlite3");
  }
  isSQLite = false;
  static async create({
    database,
    skipMigrations
  }) {
    const client = await database.getClient();
    if (!database.migrations?.skip && !skipMigrations) {
      await client.migrate.latest({
        directory: migrationsDir
      });
    }
    return new DatabaseNotificationsStore(client);
  }
  mapToInteger = (val) => {
    return typeof val === "string" ? Number.parseInt(val, 10) : val ?? 0;
  };
  mapToNotifications = (rows) => {
    return rows.map((row) => ({
      id: row.id,
      user: row.type === "broadcast" ? null : row.user,
      created: new Date(row.created),
      saved: row.saved,
      read: row.read,
      updated: row.updated,
      origin: row.origin,
      payload: {
        title: row.title,
        description: row.description,
        link: row.link,
        topic: row.topic,
        severity: row.severity,
        scope: row.scope,
        icon: row.icon
      }
    }));
  };
  mapToNotificationSettings = (rows) => {
    return rows.reduce(
      (acc, row) => {
        let chan = acc.channels.find(
          (channel) => channel.id === row.channel
        );
        if (!chan) {
          acc.channels.push({
            id: row.channel,
            origins: []
          });
          chan = acc.channels[acc.channels.length - 1];
        }
        let origin = chan.origins.find(
          (ori) => ori.id === row.origin
        );
        if (!origin) {
          origin = {
            id: row.origin,
            enabled: true,
            topics: []
          };
          chan.origins.push(origin);
        }
        if (row.topic === null) {
          origin.enabled = Boolean(row.enabled);
        } else {
          let topic = origin.topics.find(
            (top) => top.id === row.topic
          );
          if (!topic) {
            topic = {
              id: row.topic,
              enabled: Boolean(row.enabled)
            };
            origin.topics.push(topic);
          }
        }
        return acc;
      },
      { channels: [] }
    );
  };
  mapNotificationToDbRow = (notification) => {
    return {
      id: notification.id,
      user: notification.user,
      origin: notification.origin,
      created: notification.created,
      topic: notification.payload?.topic,
      link: notification.payload?.link,
      title: notification.payload?.title,
      description: notification.payload?.description,
      severity: normalizeSeverity(notification.payload?.severity),
      scope: notification.payload?.scope,
      icon: notification.payload.icon,
      saved: notification.saved,
      read: notification.read
    };
  };
  mapBroadcastToDbRow = (notification) => {
    return {
      id: notification.id,
      origin: notification.origin,
      created: notification.created,
      topic: notification.payload?.topic,
      link: notification.payload?.link,
      title: notification.payload?.title,
      description: notification.payload?.description,
      severity: normalizeSeverity(notification.payload?.severity),
      icon: notification.payload.icon,
      scope: notification.payload?.scope
    };
  };
  getBroadcastUnion = (user) => {
    return this.db("broadcast").leftJoin("broadcast_user_status", function clause() {
      const join = this.on("id", "=", "broadcast_user_status.broadcast_id");
      if (user !== null && user !== void 0) {
        join.andOnVal("user", "=", user);
      }
    }).select([...NOTIFICATION_COLUMNS, this.db.raw("'broadcast' as type")]);
  };
  getNotificationsBaseQuery = (options) => {
    const { user, orderField } = options;
    const subQuery = this.db("notification").select([...NOTIFICATION_COLUMNS, this.db.raw("'entity' as type")]).unionAll([this.getBroadcastUnion(user)]).as("notifications");
    const query = this.db.from(subQuery).where((q) => {
      q.where("user", user).orWhereNull("user");
    });
    if (orderField && orderField.length > 0) {
      orderField.forEach((orderBy) => {
        query.orderBy(orderBy.field, orderBy.order);
      });
    } else if (!orderField) {
      query.orderBy("created", "desc");
    }
    if (options.createdAfter) {
      if (this.isSQLite) {
        query.where("created", ">=", options.createdAfter.valueOf());
      } else {
        query.where("created", ">=", options.createdAfter.toISOString());
      }
    }
    if (options.limit) {
      query.limit(options.limit);
    }
    if (options.offset) {
      query.offset(options.offset);
    }
    if (options.search) {
      query.whereRaw(
        `(LOWER(title) LIKE LOWER(?) OR LOWER(description) LIKE LOWER(?))`,
        [`%${options.search}%`, `%${options.search}%`]
      );
    }
    if (options.ids) {
      query.whereIn("id", options.ids);
    }
    if (options.read) {
      query.whereNotNull("read");
    } else if (options.read === false) {
      query.whereNull("read");
    }
    if (options.topic) {
      query.where("topic", "=", options.topic);
    }
    if (options.saved) {
      query.whereNotNull("saved");
    } else if (options.saved === false) {
      query.whereNull("saved");
    }
    if (options.minimumSeverity !== void 0) {
      const idx = pluginNotificationsCommon.notificationSeverities.indexOf(options.minimumSeverity);
      const equalOrHigher = pluginNotificationsCommon.notificationSeverities.slice(0, idx + 1);
      query.whereIn("severity", equalOrHigher);
    }
    return query;
  };
  async getNotifications(options) {
    const notificationQuery = this.getNotificationsBaseQuery(options);
    const notifications = await notificationQuery.select([
      ...NOTIFICATION_COLUMNS,
      "type"
    ]);
    return this.mapToNotifications(notifications);
  }
  async getNotificationsCount(options) {
    const countOptions = { ...options };
    countOptions.limit = void 0;
    countOptions.offset = void 0;
    countOptions.orderField = [];
    const notificationQuery = this.getNotificationsBaseQuery(countOptions);
    const response = await notificationQuery.count("id as CNT");
    return Number(response[0].CNT);
  }
  async saveNotification(notification) {
    await this.db.insert(this.mapNotificationToDbRow(notification)).into("notification");
  }
  async saveBroadcast(notification) {
    await this.db.insert(this.mapBroadcastToDbRow(notification)).into("broadcast");
    if (notification.saved || notification.read) {
      await this.db.insert({
        user: notification.user,
        broadcast_id: notification.id,
        saved: notification.saved,
        read: notification.read
      }).into("broadcast_user_status");
    }
  }
  async getStatus(options) {
    const notificationQuery = this.getNotificationsBaseQuery({
      ...options,
      orderField: []
    });
    const readSubQuery = notificationQuery.clone().count("id").whereNotNull("read").as("READ");
    const unreadSubQuery = notificationQuery.clone().count("id").whereNull("read").as("UNREAD");
    const query = await notificationQuery.select(readSubQuery, unreadSubQuery).first();
    return {
      unread: this.mapToInteger(query?.UNREAD),
      read: this.mapToInteger(query?.READ)
    };
  }
  async getExistingScopeNotification(options) {
    const query = this.db("notification").where("user", options.user).where("scope", options.scope).where("origin", options.origin).limit(1);
    const rows = await query;
    if (!rows || rows.length === 0) {
      return null;
    }
    return this.mapToNotifications(rows)[0];
  }
  async getExistingScopeBroadcast(options) {
    const query = this.db("broadcast").where("scope", options.scope).where("origin", options.origin).limit(1);
    const rows = await query;
    if (!rows || rows.length === 0) {
      return null;
    }
    return this.mapToNotifications(rows)[0];
  }
  async restoreExistingNotification({
    id,
    notification
  }) {
    const updateColumns = {
      title: notification.payload.title,
      description: notification.payload.description,
      link: notification.payload.link,
      topic: notification.payload.topic,
      updated: /* @__PURE__ */ new Date(),
      severity: normalizeSeverity(notification.payload?.severity),
      read: null
    };
    const notificationQuery = this.db("notification").where("id", id).where("user", notification.user);
    const broadcastQuery = this.db("broadcast").where("id", id);
    await Promise.all([
      notificationQuery.update(updateColumns),
      broadcastQuery.update({ ...updateColumns, read: void 0 })
    ]);
    return await this.getNotification({ id, user: notification.user });
  }
  async getNotification(options) {
    const rows = await this.db.select("*").from(
      this.db("notification").select([...NOTIFICATION_COLUMNS, this.db.raw("'entity' as type")]).unionAll([this.getBroadcastUnion(options.user)]).as("notifications")
    ).where("id", options.id).limit(1);
    if (!rows || rows.length === 0) {
      return null;
    }
    return this.mapToNotifications(rows)[0];
  }
  markReadSaved = async (ids, user, read, saved) => {
    await this.db("notification").whereIn("id", ids).where("user", user).update({ read, saved });
    const broadcasts = this.mapToNotifications(
      await this.db("broadcast").whereIn("id", ids).select()
    );
    if (broadcasts.length > 0)
      if (!this.isSQLite) {
        await this.db("broadcast_user_status").insert(
          broadcasts.map((b) => ({
            broadcast_id: b.id,
            user,
            read,
            saved
          }))
        ).onConflict(["broadcast_id", "user"]).merge(["read", "saved"]);
      } else {
        for (const b of broadcasts) {
          const baseQuery = this.db(
            "broadcast_user_status"
          ).where("broadcast_id", b.id).where("user", user);
          const exists = await baseQuery.clone().limit(1).select().first();
          if (exists) {
            await baseQuery.clone().update({ read, saved });
          } else {
            await baseQuery.clone().insert({ broadcast_id: b.id, user, read, saved });
          }
        }
      }
  };
  async markRead(options) {
    await this.markReadSaved(options.ids, options.user, /* @__PURE__ */ new Date(), void 0);
  }
  async markUnread(options) {
    await this.markReadSaved(options.ids, options.user, null, void 0);
  }
  async markSaved(options) {
    await this.markReadSaved(options.ids, options.user, void 0, /* @__PURE__ */ new Date());
  }
  async markUnsaved(options) {
    await this.markReadSaved(options.ids, options.user, void 0, null);
  }
  async getUserNotificationOrigins(options) {
    const rows = await this.db(
      "notification"
    ).where("user", options.user).select("origin").distinct();
    return { origins: rows.map((row) => row.origin) };
  }
  async getUserNotificationTopics(options) {
    const rows = await this.db("notification").where("user", options.user).select("topic", "origin").whereNotNull("topic").distinct();
    return {
      topics: rows.map((row) => ({ origin: row.origin, topic: row.topic }))
    };
  }
  async getNotificationSettings(options) {
    const settingsQuery = this.db("user_settings").where(
      "user",
      options.user
    );
    if (options.origin) {
      settingsQuery.where("origin", options.origin);
    }
    if (options.channel) {
      settingsQuery.where("channel", options.channel);
    }
    if (options.topic) {
      settingsQuery.where("topic", options.topic);
    }
    const settings = await settingsQuery.select();
    return this.mapToNotificationSettings(settings);
  }
  async saveNotificationSettings(options) {
    const rows = [];
    options.settings.channels.forEach((channel) => {
      channel.origins.forEach((origin) => {
        rows.push({
          settings_key_hash: generateSettingsHash(
            options.user,
            channel.id,
            origin.id,
            null
          ),
          user: options.user,
          channel: channel.id,
          origin: origin.id,
          topic: null,
          enabled: origin.enabled
        });
        origin.topics?.forEach((topic) => {
          rows.push({
            settings_key_hash: generateSettingsHash(
              options.user,
              channel.id,
              origin.id,
              topic.id
            ),
            user: options.user,
            channel: channel.id,
            origin: origin.id,
            topic: topic.id,
            enabled: origin.enabled && topic.enabled
          });
        });
      });
    });
    await this.db("user_settings").where("user", options.user).delete();
    await this.db("user_settings").insert(rows);
  }
  async getTopics(options) {
    const notificationQuery = this.getNotificationsBaseQuery({
      ...options,
      orderField: [{ field: "topic", order: "asc" }]
    });
    const topics = await notificationQuery.whereNotNull("topic").distinct(["topic"]);
    return { topics: topics.map((row) => row.topic) };
  }
  async clearNotifications(options) {
    const ms = types.durationToMilliseconds(options.maxAge);
    const now = new Date((/* @__PURE__ */ new Date()).getTime() - ms);
    const notificationsCount = await this.db("notification").where((builder) => {
      builder.where("created", "<=", now).whereNull("updated");
    }).orWhere("updated", "<=", now).delete();
    const broadcastsCount = await this.db("broadcast").where((builder) => {
      builder.where("created", "<=", now).whereNull("updated");
    }).orWhere("updated", "<=", now).delete();
    return { deletedCount: notificationsCount + broadcastsCount };
  }
}

exports.DatabaseNotificationsStore = DatabaseNotificationsStore;
exports.generateSettingsHash = generateSettingsHash;
exports.normalizeSeverity = normalizeSeverity;
//# sourceMappingURL=DatabaseNotificationsStore.cjs.js.map
