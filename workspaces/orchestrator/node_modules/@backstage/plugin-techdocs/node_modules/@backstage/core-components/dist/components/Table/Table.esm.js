import { jsx, jsxs, Fragment } from 'react/jsx-runtime';
import { useTranslationRef } from '@backstage/core-plugin-api/alpha';
import MTable, { MTableHeader, MTableToolbar, MTableBody } from '@material-table/core';
import Box from '@material-ui/core/Box';
import IconButton from '@material-ui/core/IconButton';
import { withStyles, makeStyles, useTheme } from '@material-ui/core/styles';
import Typography from '@material-ui/core/Typography';
import AddBox from '@material-ui/icons/AddBox';
import ArrowUpward from '@material-ui/icons/ArrowUpward';
import Check from '@material-ui/icons/Check';
import ChevronLeftIcon from '@material-ui/icons/ChevronLeft';
import ChevronRight from '@material-ui/icons/ChevronRight';
import Clear from '@material-ui/icons/Clear';
import DeleteOutline from '@material-ui/icons/DeleteOutline';
import Edit from '@material-ui/icons/Edit';
import FilterList from '@material-ui/icons/FilterList';
import Search from '@material-ui/icons/Search';
import FirstPage from '@material-ui/icons/FirstPage';
import LastPage from '@material-ui/icons/LastPage';
import Remove from '@material-ui/icons/Remove';
import SaveAlt from '@material-ui/icons/SaveAlt';
import ViewColumn from '@material-ui/icons/ViewColumn';
import { transform, isEqual } from 'lodash';
import { forwardRef, useState, useCallback, useEffect, useMemo } from 'react';
import { coreComponentsTranslationRef } from '../../translation.esm.js';
import { Filters } from './Filters.esm.js';
import { TableLoadingBody } from './TableLoadingBody.esm.js';

const tableIcons = {
  Add: forwardRef((props, ref) => /* @__PURE__ */ jsx(AddBox, { ...props, ref })),
  Check: forwardRef((props, ref) => /* @__PURE__ */ jsx(Check, { ...props, ref })),
  Clear: forwardRef((props, ref) => /* @__PURE__ */ jsx(Clear, { ...props, ref })),
  Delete: forwardRef((props, ref) => /* @__PURE__ */ jsx(DeleteOutline, { ...props, ref })),
  DetailPanel: forwardRef((props, ref) => /* @__PURE__ */ jsx(ChevronRight, { ...props, ref })),
  Edit: forwardRef((props, ref) => /* @__PURE__ */ jsx(Edit, { ...props, ref })),
  Export: forwardRef((props, ref) => /* @__PURE__ */ jsx(SaveAlt, { ...props, ref })),
  Filter: forwardRef((props, ref) => /* @__PURE__ */ jsx(FilterList, { ...props, ref })),
  FirstPage: forwardRef((props, ref) => /* @__PURE__ */ jsx(FirstPage, { ...props, ref })),
  LastPage: forwardRef((props, ref) => /* @__PURE__ */ jsx(LastPage, { ...props, ref })),
  NextPage: forwardRef((props, ref) => /* @__PURE__ */ jsx(ChevronRight, { ...props, ref })),
  PreviousPage: forwardRef((props, ref) => /* @__PURE__ */ jsx(ChevronLeftIcon, { ...props, ref })),
  ResetSearch: forwardRef((props, ref) => /* @__PURE__ */ jsx(Clear, { ...props, ref })),
  Search: forwardRef((props, ref) => /* @__PURE__ */ jsx(Search, { ...props, ref })),
  SortArrow: forwardRef((props, ref) => /* @__PURE__ */ jsx(ArrowUpward, { ...props, ref })),
  ThirdStateCheck: forwardRef((props, ref) => /* @__PURE__ */ jsx(Remove, { ...props, ref })),
  ViewColumn: forwardRef((props, ref) => /* @__PURE__ */ jsx(ViewColumn, { ...props, ref }))
};
function extractValueByField(data, field) {
  const path = field.split(".");
  let value = data[path[0]];
  for (let i = 1; i < path.length; ++i) {
    if (value === void 0) {
      return value;
    }
    const f = path[i];
    value = value[f];
  }
  return value;
}
const StyledMTableHeader = withStyles(
  (theme) => ({
    header: {
      padding: theme.spacing(1, 2, 1, 2.5),
      borderTop: `1px solid ${theme.palette.grey.A100}`,
      borderBottom: `1px solid ${theme.palette.grey.A100}`,
      // withStyles hasn't a generic overload for theme
      fontWeight: theme.typography.fontWeightBold,
      position: "static",
      wordBreak: "normal",
      textTransform: "uppercase"
    }
  }),
  { name: "BackstageTableHeader" }
)(MTableHeader);
const StyledMTableToolbar = withStyles(
  (theme) => ({
    root: {
      padding: theme.spacing(3, 0, 2.5, 2.5)
    },
    title: {
      "& > h6": {
        fontWeight: theme.typography.fontWeightBold
      }
    },
    searchField: {
      paddingRight: theme.spacing(2)
    }
  }),
  { name: "BackstageTableToolbar" }
)(MTableToolbar);
const useFilterStyles = makeStyles(
  (theme) => ({
    root: {
      display: "flex",
      alignItems: "center",
      justifyContent: "space-between"
    },
    title: {
      fontWeight: theme.typography.fontWeightBold,
      fontSize: 18,
      whiteSpace: "nowrap"
    }
  }),
  { name: "BackstageTableFiltersContainer" }
);
const useTableStyles = makeStyles(
  () => ({
    root: {
      display: "flex",
      alignItems: "start"
    }
  }),
  { name: "BackstageTable" }
);
function convertColumns(columns, theme) {
  return columns.map((column) => {
    const headerStyle = column.headerStyle ?? {};
    let cellStyle = column.cellStyle || {};
    if (column.highlight) {
      headerStyle.color = theme.palette.textContrast;
      if (typeof cellStyle === "object") {
        cellStyle.fontWeight = theme.typography.fontWeightBold;
      } else {
        const cellStyleFn = cellStyle;
        cellStyle = (data, rowData, rowColumn) => {
          const style = cellStyleFn(data, rowData, rowColumn);
          return { ...style, fontWeight: theme.typography.fontWeightBold };
        };
      }
    }
    return {
      ...column,
      headerStyle,
      cellStyle
    };
  });
}
function removeDefaultValues(state, defaultState) {
  return transform(state, (result, value, key) => {
    if (!isEqual(value, defaultState[key])) {
      result[key] = value;
    }
  });
}
const defaultInitialState = {
  search: "",
  filtersOpen: false,
  filters: {}
};
function TableToolbar(toolbarProps) {
  const {
    toolbarRef,
    setSearch,
    hasFilters,
    selectedFiltersLength,
    toggleFilters
  } = toolbarProps;
  const { t } = useTranslationRef(coreComponentsTranslationRef);
  const filtersClasses = useFilterStyles();
  const onSearchChanged = useCallback(
    (searchText) => {
      toolbarProps.onSearchChanged(searchText);
      setSearch(searchText);
    },
    [toolbarProps, setSearch]
  );
  if (hasFilters) {
    return /* @__PURE__ */ jsxs(Box, { className: filtersClasses.root, children: [
      /* @__PURE__ */ jsxs(Box, { className: filtersClasses.root, children: [
        /* @__PURE__ */ jsx(IconButton, { onClick: toggleFilters, "aria-label": "filter list", children: /* @__PURE__ */ jsx(FilterList, {}) }),
        /* @__PURE__ */ jsxs(Typography, { className: filtersClasses.title, children: [
          t("table.filter.title"),
          " (",
          selectedFiltersLength,
          ")"
        ] })
      ] }),
      /* @__PURE__ */ jsx(
        StyledMTableToolbar,
        {
          ...toolbarProps,
          ref: toolbarRef,
          onSearchChanged
        }
      )
    ] });
  }
  return /* @__PURE__ */ jsx(
    StyledMTableToolbar,
    {
      ...toolbarProps,
      ref: toolbarRef,
      onSearchChanged
    }
  );
}
function Table(props) {
  const {
    data,
    columns,
    emptyContent,
    options,
    title,
    subtitle,
    localization,
    filters,
    initialState,
    onStateChange,
    components,
    isLoading: loading,
    style,
    ...restProps
  } = props;
  const { t } = useTranslationRef(coreComponentsTranslationRef);
  const tableClasses = useTableStyles();
  const theme = useTheme();
  const calculatedInitialState = { ...defaultInitialState, ...initialState };
  const [filtersOpen, setFiltersOpen] = useState(
    calculatedInitialState.filtersOpen
  );
  const toggleFilters = useCallback(
    () => setFiltersOpen((v) => !v),
    [setFiltersOpen]
  );
  const [selectedFilters, setSelectedFilters] = useState(
    calculatedInitialState.filters
  );
  const [search, setSearch] = useState(calculatedInitialState.search);
  useEffect(() => {
    if (onStateChange) {
      const state = removeDefaultValues(
        {
          search,
          filtersOpen,
          filters: selectedFilters
        },
        defaultInitialState
      );
      onStateChange(state);
    }
  }, [search, filtersOpen, selectedFilters, onStateChange]);
  const getFieldByTitle = useCallback(
    (titleValue) => columns.find((el) => el.title === titleValue)?.field,
    [columns]
  );
  const tableData = useMemo(() => {
    if (typeof data === "function" || !selectedFilters) {
      return data;
    }
    const selectedFiltersArray = Object.values(selectedFilters);
    if (data && selectedFiltersArray.flat().length) {
      const newData = data.filter(
        (el) => !!Object.entries(selectedFilters).filter(([, value]) => !!value.length).every(([key, filterValue]) => {
          const fieldValue = extractValueByField(
            el,
            getFieldByTitle(key)
          );
          if (Array.isArray(fieldValue) && Array.isArray(filterValue)) {
            return fieldValue.some((v) => filterValue.includes(v));
          } else if (Array.isArray(fieldValue)) {
            return fieldValue.includes(filterValue);
          } else if (Array.isArray(filterValue)) {
            return filterValue.includes(fieldValue);
          }
          return fieldValue === filterValue;
        })
      );
      return newData;
    }
    return data;
  }, [data, selectedFilters, getFieldByTitle]);
  const selectedFiltersLength = Object.values(selectedFilters).flat().length;
  const hasFilters = !!filters?.length;
  const Toolbar = useCallback(
    (toolbarProps) => {
      return /* @__PURE__ */ jsx(
        TableToolbar,
        {
          setSearch,
          hasFilters,
          selectedFiltersLength,
          toggleFilters,
          ...toolbarProps
        }
      );
    },
    [toggleFilters, hasFilters, selectedFiltersLength, setSearch]
  );
  const hasNoRows = typeof data !== "function" && data.length === 0;
  const columnCount = columns.length;
  const Body = useMemo(
    () => makeBody({ hasNoRows, emptyContent, columnCount, loading }),
    [hasNoRows, emptyContent, columnCount, loading]
  );
  return /* @__PURE__ */ jsxs(Box, { className: tableClasses.root, children: [
    filtersOpen && data && typeof data !== "function" && filters?.length && /* @__PURE__ */ jsx(
      Filters,
      {
        filters: constructFilters(filters, data, columns, t),
        selectedFilters,
        onChangeFilters: setSelectedFilters
      }
    ),
    /* @__PURE__ */ jsx(
      MTable,
      {
        components: {
          Header: StyledMTableHeader,
          Body,
          Toolbar,
          ...components
        },
        options,
        columns: convertColumns(columns, theme),
        icons: tableIcons,
        title: /* @__PURE__ */ jsxs(Fragment, { children: [
          /* @__PURE__ */ jsx(Typography, { variant: "h5", component: "h2", children: title }),
          subtitle && /* @__PURE__ */ jsx(Typography, { color: "textSecondary", variant: "body1", children: subtitle })
        ] }),
        data: tableData,
        style: { width: "100%", ...style },
        localization: {
          ...localization,
          body: {
            emptyDataSourceMessage: t("table.body.emptyDataSourceMessage"),
            ...localization?.body
          },
          pagination: {
            firstTooltip: t("table.pagination.firstTooltip"),
            labelDisplayedRows: t("table.pagination.labelDisplayedRows"),
            labelRowsSelect: t("table.pagination.labelRowsSelect"),
            lastTooltip: t("table.pagination.lastTooltip"),
            nextTooltip: t("table.pagination.nextTooltip"),
            previousTooltip: t("table.pagination.previousTooltip"),
            ...localization?.pagination
          },
          header: {
            actions: t("table.header.actions"),
            ...localization?.header
          },
          toolbar: {
            searchPlaceholder: t("table.toolbar.search"),
            searchTooltip: t("table.toolbar.search"),
            ...localization?.toolbar
          }
        },
        ...restProps
      }
    )
  ] });
}
Table.icons = Object.freeze(tableIcons);
function makeBody({
  columnCount,
  emptyContent,
  hasNoRows,
  loading
}) {
  return (bodyProps) => {
    if (loading) {
      return /* @__PURE__ */ jsx(TableLoadingBody, { colSpan: columnCount });
    }
    if (emptyContent && hasNoRows) {
      return /* @__PURE__ */ jsx("tbody", { children: /* @__PURE__ */ jsx("tr", { children: /* @__PURE__ */ jsx("td", { colSpan: columnCount, children: emptyContent }) }) });
    }
    return /* @__PURE__ */ jsx(MTableBody, { ...bodyProps });
  };
}
function constructFilters(filterConfig, dataValue, columns, t) {
  const extractDistinctValues = (field) => {
    const distinctValues = /* @__PURE__ */ new Set();
    const addValue = (value) => {
      if (value !== void 0 && value !== null) {
        distinctValues.add(value);
      }
    };
    if (dataValue) {
      dataValue.forEach((el) => {
        const value = extractValueByField(
          el,
          columns.find((c) => c.title === field)?.field
        );
        if (Array.isArray(value)) {
          value.forEach(addValue);
        } else {
          addValue(value);
        }
      });
    }
    return distinctValues;
  };
  const constructSelect = (filter) => {
    return {
      placeholder: t("table.filter.placeholder"),
      label: filter.column,
      multiple: filter.type === "multiple-select",
      items: [...extractDistinctValues(filter.column)].sort().map((value) => ({
        label: value,
        value
      }))
    };
  };
  return filterConfig.map((filter) => ({
    type: filter.type,
    element: constructSelect(filter)
  }));
}

export { Table, TableToolbar };
//# sourceMappingURL=Table.esm.js.map
