{"version":3,"file":"FilterWrapper.esm.js","sources":["../../../src/alpha/filter/FilterWrapper.tsx"],"sourcesContent":["/*\n * Copyright 2024 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Entity } from '@backstage/catalog-model';\nimport Grid from '@material-ui/core/Grid';\nimport { JSX, useMemo } from 'react';\nimport { parseFilterExpression } from './parseFilterExpression';\n\n// Keeps track of what filter expression strings that we've seen duplicates of\n// with functions, or which emitted parsing errors for so far\nconst seenParseErrorExpressionStrings = new Set<string>();\nconst seenDuplicateExpressionStrings = new Set<string>();\n\n// Given an optional filter function and an optional filter expression, make\n// sure that at most one of them was given, and return a filter function that\n// does the right thing.\nexport function buildFilterFn(\n  filterFunction?: (entity: Entity) => boolean,\n  filterExpression?: string,\n): (entity: Entity) => boolean {\n  if (\n    filterFunction &&\n    filterExpression &&\n    !seenDuplicateExpressionStrings.has(filterExpression)\n  ) {\n    // eslint-disable-next-line no-console\n    console.warn(\n      `Duplicate entity filter methods found, both '${filterExpression}' as well as a callback function, which is not permitted - using the callback`,\n    );\n    seenDuplicateExpressionStrings.add(filterExpression);\n  }\n\n  const filter = filterFunction || filterExpression;\n  if (!filter) {\n    return () => true;\n  } else if (typeof filter === 'function') {\n    return subject => filter(subject);\n  }\n\n  const result = parseFilterExpression(filter);\n  if (\n    result.expressionParseErrors.length &&\n    !seenParseErrorExpressionStrings.has(filter)\n  ) {\n    // eslint-disable-next-line no-console\n    console.warn(\n      `Error(s) in entity filter expression '${filter}'`,\n      result.expressionParseErrors,\n    );\n    seenParseErrorExpressionStrings.add(filter);\n  }\n\n  return result.filterFn;\n}\n\n// Handles the memoized parsing of filter expressions\nexport function FilterWrapper(props: {\n  entity: Entity;\n  element: JSX.Element;\n  filterFunction?: (entity: Entity) => boolean;\n  filterExpression?: string;\n}) {\n  const { entity, element, filterFunction, filterExpression } = props;\n\n  const filterFn = useMemo(\n    () => buildFilterFn(filterFunction, filterExpression),\n    [filterFunction, filterExpression],\n  );\n\n  return filterFn(entity) ? (\n    <Grid item md={6} xs={12}>\n      {element}\n    </Grid>\n  ) : null;\n}\n"],"names":[],"mappings":";;;;;AAuBA,MAAM,+BAAA,uBAAsC,GAAA,EAAY;AACxD,MAAM,8BAAA,uBAAqC,GAAA,EAAY;AAKhD,SAAS,aAAA,CACd,gBACA,gBAAA,EAC6B;AAC7B,EAAA,IACE,kBACA,gBAAA,IACA,CAAC,8BAAA,CAA+B,GAAA,CAAI,gBAAgB,CAAA,EACpD;AAEA,IAAA,OAAA,CAAQ,IAAA;AAAA,MACN,gDAAgD,gBAAgB,CAAA,6EAAA;AAAA,KAClE;AACA,IAAA,8BAAA,CAA+B,IAAI,gBAAgB,CAAA;AAAA,EACrD;AAEA,EAAA,MAAM,SAAS,cAAA,IAAkB,gBAAA;AACjC,EAAA,IAAI,CAAC,MAAA,EAAQ;AACX,IAAA,OAAO,MAAM,IAAA;AAAA,EACf,CAAA,MAAA,IAAW,OAAO,MAAA,KAAW,UAAA,EAAY;AACvC,IAAA,OAAO,CAAA,OAAA,KAAW,OAAO,OAAO,CAAA;AAAA,EAClC;AAEA,EAAA,MAAM,MAAA,GAAS,sBAAsB,MAAM,CAAA;AAC3C,EAAA,IACE,OAAO,qBAAA,CAAsB,MAAA,IAC7B,CAAC,+BAAA,CAAgC,GAAA,CAAI,MAAM,CAAA,EAC3C;AAEA,IAAA,OAAA,CAAQ,IAAA;AAAA,MACN,yCAAyC,MAAM,CAAA,CAAA,CAAA;AAAA,MAC/C,MAAA,CAAO;AAAA,KACT;AACA,IAAA,+BAAA,CAAgC,IAAI,MAAM,CAAA;AAAA,EAC5C;AAEA,EAAA,OAAO,MAAA,CAAO,QAAA;AAChB;;;;"}