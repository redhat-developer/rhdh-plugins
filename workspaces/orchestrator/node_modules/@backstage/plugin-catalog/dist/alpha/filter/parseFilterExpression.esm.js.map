{"version":3,"file":"parseFilterExpression.esm.js","sources":["../../../src/alpha/filter/parseFilterExpression.ts"],"sourcesContent":["/*\n * Copyright 2023 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Entity } from '@backstage/catalog-model';\nimport { InputError } from '@backstage/errors';\nimport { EntityMatcherFn } from './matchers/types';\nimport { createKindMatcher } from './matchers/createKindMatcher';\nimport { createTypeMatcher } from './matchers/createTypeMatcher';\nimport { createIsMatcher } from './matchers/createIsMatcher';\nimport { createHasMatcher } from './matchers/createHasMatcher';\n\nconst rootMatcherFactories: Record<\n  string,\n  (\n    parameters: string[],\n    onParseError: (error: Error) => void,\n    negation?: boolean,\n  ) => EntityMatcherFn\n> = {\n  kind: createKindMatcher,\n  type: createTypeMatcher,\n  is: createIsMatcher,\n  has: createHasMatcher,\n};\n\n/**\n * Parses a filter expression that decides whether to render an entity component\n * or not. Returns a function that matches entities based on that expression.\n *\n * @remarks\n *\n * Filter strings are on the form `kind:user,group is:orphan`. There's\n * effectively an AND between the space separated parts, and an OR between comma\n * separated parameters. So the example filter string semantically means\n * \"entities that are of either User or Group kind, and also are orphans\".\n *\n * The `expressionParseErrors` array contains any errors that were encountered\n * during initial parsing of the expression. Note that the parts of the input\n * expression that had errors are ignored entirely and parsing continues as if\n * they didn't exist.\n */\nexport function parseFilterExpression(expression: string): {\n  filterFn: (entity: Entity) => boolean;\n  expressionParseErrors: Error[];\n} {\n  const expressionParseErrors: Error[] = [];\n\n  const parts = splitFilterExpression(expression, e =>\n    expressionParseErrors.push(e),\n  );\n  const matchers = parts.flatMap(part => {\n    const factory = rootMatcherFactories[part.key];\n    const negation = part.negation;\n    if (!factory) {\n      const known = Object.keys(rootMatcherFactories).map(m => `'${m}'`);\n      expressionParseErrors.push(\n        new InputError(\n          `'${part.key}' is not a valid filter expression key, expected one of ${known}`,\n        ),\n      );\n      return [];\n    }\n\n    const matcher = factory(part.parameters, e =>\n      expressionParseErrors.push(e),\n    );\n\n    return [negation ? (entity: Entity) => !matcher(entity) : matcher];\n  });\n\n  const filterFn = (entity: Entity) =>\n    matchers.every(matcher => {\n      try {\n        return matcher(entity);\n      } catch {\n        return false;\n      }\n    });\n\n  return {\n    filterFn,\n    expressionParseErrors,\n  };\n}\n\nexport function splitFilterExpression(\n  expression: string,\n  onParseError: (error: Error) => void,\n): Array<{ key: string; parameters: string[]; negation: boolean }> {\n  const words = expression\n    .split(' ')\n    .map(w => w.trim())\n    .filter(Boolean);\n\n  const result = new Array<{\n    key: string;\n    parameters: string[];\n    negation: boolean;\n  }>();\n\n  for (const word of words) {\n    const match = word.match(/^(not:)?([^:]+):(.+)$/);\n    if (!match) {\n      onParseError(\n        new InputError(\n          `'${word}' is not a valid filter expression, expected 'key:parameter' form`,\n        ),\n      );\n      continue;\n    }\n    const key = match[2];\n    const parameters = match[3].split(',').filter(Boolean); // silently ignore double commas\n    const negation = Boolean(match[1]);\n    result.push({ key, parameters, negation });\n  }\n\n  return result;\n}\n"],"names":[],"mappings":";;;;;;AAwBA,MAAM,oBAAA,GAOF;AAAA,EACF,IAAA,EAAM,iBAAA;AAAA,EACN,IAAA,EAAM,iBAAA;AAAA,EACN,EAAA,EAAI,eAAA;AAAA,EACJ,GAAA,EAAK;AACP,CAAA;AAkBO,SAAS,sBAAsB,UAAA,EAGpC;AACA,EAAA,MAAM,wBAAiC,EAAC;AAExC,EAAA,MAAM,KAAA,GAAQ,qBAAA;AAAA,IAAsB,UAAA;AAAA,IAAY,CAAA,CAAA,KAC9C,qBAAA,CAAsB,IAAA,CAAK,CAAC;AAAA,GAC9B;AACA,EAAA,MAAM,QAAA,GAAW,KAAA,CAAM,OAAA,CAAQ,CAAA,IAAA,KAAQ;AACrC,IAAA,MAAM,OAAA,GAAU,oBAAA,CAAqB,IAAA,CAAK,GAAG,CAAA;AAC7C,IAAA,MAAM,WAAW,IAAA,CAAK,QAAA;AACtB,IAAA,IAAI,CAAC,OAAA,EAAS;AACZ,MAAA,MAAM,KAAA,GAAQ,OAAO,IAAA,CAAK,oBAAoB,EAAE,GAAA,CAAI,CAAA,CAAA,KAAK,CAAA,CAAA,EAAI,CAAC,CAAA,CAAA,CAAG,CAAA;AACjE,MAAA,qBAAA,CAAsB,IAAA;AAAA,QACpB,IAAI,UAAA;AAAA,UACF,CAAA,CAAA,EAAI,IAAA,CAAK,GAAG,CAAA,wDAAA,EAA2D,KAAK,CAAA;AAAA;AAC9E,OACF;AACA,MAAA,OAAO,EAAC;AAAA,IACV;AAEA,IAAA,MAAM,OAAA,GAAU,OAAA;AAAA,MAAQ,IAAA,CAAK,UAAA;AAAA,MAAY,CAAA,CAAA,KACvC,qBAAA,CAAsB,IAAA,CAAK,CAAC;AAAA,KAC9B;AAEA,IAAA,OAAO,CAAC,WAAW,CAAC,MAAA,KAAmB,CAAC,OAAA,CAAQ,MAAM,IAAI,OAAO,CAAA;AAAA,EACnE,CAAC,CAAA;AAED,EAAA,MAAM,QAAA,GAAW,CAAC,MAAA,KAChB,QAAA,CAAS,MAAM,CAAA,OAAA,KAAW;AACxB,IAAA,IAAI;AACF,MAAA,OAAO,QAAQ,MAAM,CAAA;AAAA,IACvB,CAAA,CAAA,MAAQ;AACN,MAAA,OAAO,KAAA;AAAA,IACT;AAAA,EACF,CAAC,CAAA;AAEH,EAAA,OAAO;AAAA,IACL,QAAA;AAAA,IACA;AAAA,GACF;AACF;AAEO,SAAS,qBAAA,CACd,YACA,YAAA,EACiE;AACjE,EAAA,MAAM,KAAA,GAAQ,UAAA,CACX,KAAA,CAAM,GAAG,CAAA,CACT,GAAA,CAAI,CAAA,CAAA,KAAK,CAAA,CAAE,IAAA,EAAM,CAAA,CACjB,MAAA,CAAO,OAAO,CAAA;AAEjB,EAAA,MAAM,MAAA,GAAS,IAAI,KAAA,EAIhB;AAEH,EAAA,KAAA,MAAW,QAAQ,KAAA,EAAO;AACxB,IAAA,MAAM,KAAA,GAAQ,IAAA,CAAK,KAAA,CAAM,uBAAuB,CAAA;AAChD,IAAA,IAAI,CAAC,KAAA,EAAO;AACV,MAAA,YAAA;AAAA,QACE,IAAI,UAAA;AAAA,UACF,IAAI,IAAI,CAAA,iEAAA;AAAA;AACV,OACF;AACA,MAAA;AAAA,IACF;AACA,IAAA,MAAM,GAAA,GAAM,MAAM,CAAC,CAAA;AACnB,IAAA,MAAM,UAAA,GAAa,MAAM,CAAC,CAAA,CAAE,MAAM,GAAG,CAAA,CAAE,OAAO,OAAO,CAAA;AACrD,IAAA,MAAM,QAAA,GAAW,OAAA,CAAQ,KAAA,CAAM,CAAC,CAAC,CAAA;AACjC,IAAA,MAAA,CAAO,IAAA,CAAK,EAAE,GAAA,EAAK,UAAA,EAAY,UAAU,CAAA;AAAA,EAC3C;AAEA,EAAA,OAAO,MAAA;AACT;;;;"}