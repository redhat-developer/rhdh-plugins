{"version":3,"file":"kindFilterUtils.esm.js","sources":["../../../src/components/CatalogKindHeader/kindFilterUtils.ts"],"sourcesContent":["/*\n * Copyright 2022 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { useApi } from '@backstage/core-plugin-api';\nimport { catalogApiRef } from '@backstage/plugin-catalog-react';\nimport useAsync from 'react-use/esm/useAsync';\n\n/**\n * Fetch and return all available kinds.\n */\nexport function useAllKinds(): {\n  loading: boolean;\n  error?: Error;\n  allKinds: Map<string, string>;\n} {\n  const catalogApi = useApi(catalogApiRef);\n\n  const {\n    error,\n    loading,\n    value: allKinds,\n  } = useAsync(async () => {\n    const { facets } = await catalogApi.getEntityFacets({ facets: ['kind'] });\n    const kindFacets = (facets.kind ?? []).map(f => f.value);\n    return new Map(\n      kindFacets.map(kind => [kind.toLocaleLowerCase('en-US'), kind]),\n    );\n  }, [catalogApi]);\n\n  return { loading, error, allKinds: allKinds ?? new Map() };\n}\n\n/**\n * Filter and capitalize accessible kinds.\n */\nexport function filterKinds(\n  allKinds: Map<string, string>,\n  allowedKinds?: string[],\n  forcedKinds?: string,\n): Map<string, string> {\n  // Before allKinds is loaded, or when a kind is entered manually in the URL, selectedKind may not\n  // be present in allKinds. It should still be shown in the dropdown, but may not have the nice\n  // enforced casing from the catalog-backend. This makes a key/value record for the Select options,\n  // including selectedKind if it's unknown - but allows the selectedKind to get clobbered by the\n  // more proper catalog kind if it exists.\n  let availableKinds = Array.from(allKinds.keys());\n  if (allowedKinds) {\n    availableKinds = allowedKinds\n      .map(k => k.toLocaleLowerCase('en-US'))\n      .filter(k => allKinds.has(k));\n  }\n\n  const kindsMap = new Map(\n    availableKinds.map(kind => [kind, allKinds.get(kind) || kind]),\n  );\n\n  if (forcedKinds && !kindsMap.has(forcedKinds)) {\n    // this is the only time we set a label for a kind which is not properly capitalized\n    kindsMap.set(forcedKinds.toLocaleLowerCase('en-US'), forcedKinds);\n  }\n\n  return kindsMap;\n}\n"],"names":[],"mappings":";;;;AAuBO,SAAS,WAAA,GAId;AACA,EAAA,MAAM,UAAA,GAAa,OAAO,aAAa,CAAA;AAEvC,EAAA,MAAM;AAAA,IACJ,KAAA;AAAA,IACA,OAAA;AAAA,IACA,KAAA,EAAO;AAAA,GACT,GAAI,SAAS,YAAY;AACvB,IAAA,MAAM,EAAE,MAAA,EAAO,GAAI,MAAM,UAAA,CAAW,eAAA,CAAgB,EAAE,MAAA,EAAQ,CAAC,MAAM,CAAA,EAAG,CAAA;AACxE,IAAA,MAAM,UAAA,GAAA,CAAc,OAAO,IAAA,IAAQ,IAAI,GAAA,CAAI,CAAA,CAAA,KAAK,EAAE,KAAK,CAAA;AACvD,IAAA,OAAO,IAAI,GAAA;AAAA,MACT,UAAA,CAAW,IAAI,CAAA,IAAA,KAAQ,CAAC,KAAK,iBAAA,CAAkB,OAAO,CAAA,EAAG,IAAI,CAAC;AAAA,KAChE;AAAA,EACF,CAAA,EAAG,CAAC,UAAU,CAAC,CAAA;AAEf,EAAA,OAAO,EAAE,OAAA,EAAS,KAAA,EAAO,UAAU,QAAA,oBAAY,IAAI,KAAI,EAAE;AAC3D;AAKO,SAAS,WAAA,CACd,QAAA,EACA,YAAA,EACA,WAAA,EACqB;AAMrB,EAAA,IAAI,cAAA,GAAiB,KAAA,CAAM,IAAA,CAAK,QAAA,CAAS,MAAM,CAAA;AAC/C,EAAA,IAAI,YAAA,EAAc;AAChB,IAAA,cAAA,GAAiB,YAAA,CACd,GAAA,CAAI,CAAA,CAAA,KAAK,CAAA,CAAE,iBAAA,CAAkB,OAAO,CAAC,CAAA,CACrC,MAAA,CAAO,CAAA,CAAA,KAAK,QAAA,CAAS,GAAA,CAAI,CAAC,CAAC,CAAA;AAAA,EAChC;AAEA,EAAA,MAAM,WAAW,IAAI,GAAA;AAAA,IACnB,cAAA,CAAe,GAAA,CAAI,CAAA,IAAA,KAAQ,CAAC,IAAA,EAAM,SAAS,GAAA,CAAI,IAAI,CAAA,IAAK,IAAI,CAAC;AAAA,GAC/D;AAEA,EAAA,IAAI,WAAA,IAAe,CAAC,QAAA,CAAS,GAAA,CAAI,WAAW,CAAA,EAAG;AAE7C,IAAA,QAAA,CAAS,GAAA,CAAI,WAAA,CAAY,iBAAA,CAAkB,OAAO,GAAG,WAAW,CAAA;AAAA,EAClE;AAEA,EAAA,OAAO,QAAA;AACT;;;;"}