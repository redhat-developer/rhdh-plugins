{"version":3,"file":"url.cjs.js","sources":["../../../src/stages/prepare/url.ts"],"sourcesContent":["/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assertError } from '@backstage/errors';\nimport { Entity } from '@backstage/catalog-model';\nimport { getDocFilesFromRepository } from '../../helpers';\nimport {\n  PreparerBase,\n  PreparerConfig,\n  PreparerOptions,\n  PreparerResponse,\n} from './types';\nimport { LoggerService, UrlReaderService } from '@backstage/backend-plugin-api';\n\n/**\n * Preparer used to retrieve documentation files from a remote repository\n * @public\n */\nexport class UrlPreparer implements PreparerBase {\n  private readonly logger: LoggerService;\n  private readonly reader: UrlReaderService;\n\n  /**\n   * Returns a directory preparer instance\n   * @param config - A URL preparer config containing the a logger and reader\n   */\n  static fromConfig(options: PreparerConfig): UrlPreparer {\n    return new UrlPreparer(options.reader, options.logger);\n  }\n\n  private constructor(reader: UrlReaderService, logger: LoggerService) {\n    this.logger = logger;\n    this.reader = reader;\n  }\n\n  /** {@inheritDoc PreparerBase.shouldCleanPreparedDirectory} */\n  shouldCleanPreparedDirectory() {\n    return true;\n  }\n\n  /** {@inheritDoc PreparerBase.prepare} */\n  async prepare(\n    entity: Entity,\n    options?: PreparerOptions,\n  ): Promise<PreparerResponse> {\n    try {\n      return await getDocFilesFromRepository(this.reader, entity, {\n        etag: options?.etag,\n        logger: this.logger,\n      });\n    } catch (error) {\n      assertError(error);\n      // NotModifiedError means that etag based cache is still valid.\n      if (error.name === 'NotModifiedError') {\n        this.logger.debug(`Cache is valid for etag ${options?.etag}`);\n      } else {\n        this.logger.debug(\n          `Unable to fetch files for building docs ${error.message}`,\n        );\n      }\n\n      throw error;\n    }\n  }\n}\n"],"names":["getDocFilesFromRepository","assertError"],"mappings":";;;;;AA+BO,MAAM,WAAA,CAAoC;AAAA,EAC9B,MAAA;AAAA,EACA,MAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMjB,OAAO,WAAW,OAAA,EAAsC;AACtD,IAAA,OAAO,IAAI,WAAA,CAAY,OAAA,CAAQ,MAAA,EAAQ,QAAQ,MAAM,CAAA;AAAA,EACvD;AAAA,EAEQ,WAAA,CAAY,QAA0B,MAAA,EAAuB;AACnE,IAAA,IAAA,CAAK,MAAA,GAAS,MAAA;AACd,IAAA,IAAA,CAAK,MAAA,GAAS,MAAA;AAAA,EAChB;AAAA;AAAA,EAGA,4BAAA,GAA+B;AAC7B,IAAA,OAAO,IAAA;AAAA,EACT;AAAA;AAAA,EAGA,MAAM,OAAA,CACJ,MAAA,EACA,OAAA,EAC2B;AAC3B,IAAA,IAAI;AACF,MAAA,OAAO,MAAMA,iCAAA,CAA0B,IAAA,CAAK,MAAA,EAAQ,MAAA,EAAQ;AAAA,QAC1D,MAAM,OAAA,EAAS,IAAA;AAAA,QACf,QAAQ,IAAA,CAAK;AAAA,OACd,CAAA;AAAA,IACH,SAAS,KAAA,EAAO;AACd,MAAAC,kBAAA,CAAY,KAAK,CAAA;AAEjB,MAAA,IAAI,KAAA,CAAM,SAAS,kBAAA,EAAoB;AACrC,QAAA,IAAA,CAAK,MAAA,CAAO,KAAA,CAAM,CAAA,wBAAA,EAA2B,OAAA,EAAS,IAAI,CAAA,CAAE,CAAA;AAAA,MAC9D,CAAA,MAAO;AACL,QAAA,IAAA,CAAK,MAAA,CAAO,KAAA;AAAA,UACV,CAAA,wCAAA,EAA2C,MAAM,OAAO,CAAA;AAAA,SAC1D;AAAA,MACF;AAEA,MAAA,MAAM,KAAA;AAAA,IACR;AAAA,EACF;AACF;;;;"}