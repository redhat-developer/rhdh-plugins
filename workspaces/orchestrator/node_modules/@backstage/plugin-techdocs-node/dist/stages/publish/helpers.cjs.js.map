{"version":3,"file":"helpers.cjs.js","sources":["../../../src/stages/publish/helpers.ts"],"sourcesContent":["/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Entity, DEFAULT_NAMESPACE } from '@backstage/catalog-model';\nimport mime from 'mime-types';\nimport path from 'path';\nimport createLimiter from 'p-limit';\nimport recursiveReadDir from 'recursive-readdir';\n\n/**\n * Helper to get the expected content-type for a given file extension. Also\n * takes XSS mitigation into account.\n */\nconst getContentTypeForExtension = (ext: string): string => {\n  const defaultContentType = 'text/plain; charset=utf-8';\n  const excludedTypes = [\n    'text/html',\n    'text/xml',\n    'image/svg+xml',\n    'text/xsl',\n    'application/vnd.wap.xhtml+xml',\n    'multipart/x-mixed-replace',\n    'text/rdf',\n    'application/mathml+xml',\n    'application/octet-stream',\n    'application/rdf+xml',\n    'application/xhtml+xml',\n    'application/xml',\n    'text/cache-manifest',\n    'text/vtt',\n  ];\n\n  // Prevent sanitization bypass by preventing browsers from directly rendering\n  // the contents of untrusted files.\n  if (\n    ext.match(\n      /htm|xml|svg|appcache|manifest|mathml|owl|rdf|rng|vtt|xht|xsd|xsl/i,\n    )\n  ) {\n    return defaultContentType;\n  }\n\n  // Check again to make sure that the content type is not in the excluded mime-type list\n  // We use .lookup here to avoid the \"; charset=...\" addition\n  const contentType = mime.lookup(ext);\n  if (contentType && excludedTypes.includes(contentType)) {\n    return defaultContentType;\n  }\n\n  return mime.contentType(ext) || defaultContentType;\n};\n\nexport type responseHeadersType = {\n  'Content-Type': string;\n};\n\n/**\n * Some files need special headers to be used correctly by the frontend. This function\n * generates headers in the response to those file requests.\n * @param fileExtension - .html, .css, .js, .png etc.\n */\nexport const getHeadersForFileExtension = (\n  fileExtension: string,\n): responseHeadersType => {\n  return {\n    'Content-Type': getContentTypeForExtension(fileExtension),\n  };\n};\n\n/**\n * Recursively traverse all the sub-directories of a path and return\n * a list of absolute paths of all the files. e.g. tree command in Unix\n *\n * @example\n *\n * /User/username/my_dir\n *     dirA\n *     |   subDirA\n *     |   |   file1\n *     EmptyDir\n *     dirB\n *     |   file2\n *     file3\n *\n * getFileListRecursively('/Users/username/myDir')\n * // returns\n * [\n *   '/User/username/my_dir/dirA/subDirA/file1',\n *   '/User/username/my_dir/dirB/file2',\n *   '/User/username/my_dir/file3'\n * ]\n * @param rootDirPath - Absolute path to the root directory.\n */\nexport const getFileTreeRecursively = async (\n  rootDirPath: string,\n): Promise<string[]> => {\n  // Iterate on all the files in the directory and its sub-directories\n  const fileList = await recursiveReadDir(rootDirPath).catch(error => {\n    throw new Error(`Failed to read template directory: ${error.message}`);\n  });\n  return fileList;\n};\n\n/**\n * Takes a posix path and returns a lower-cased version of entity's triplet\n * with the remaining path in posix.\n *\n * Path must not include a starting slash.\n *\n * @example\n * lowerCaseEntityTriplet('default/Component/backstage')\n * // return default/component/backstage\n */\nexport const lowerCaseEntityTriplet = (posixPath: string): string => {\n  const [namespace, kind, name, ...rest] = posixPath.split(path.posix.sep);\n  const lowerNamespace = namespace.toLowerCase();\n  const lowerKind = kind.toLowerCase();\n  const lowerName = name.toLowerCase();\n  return [lowerNamespace, lowerKind, lowerName, ...rest].join(path.posix.sep);\n};\n\n/**\n * Takes either a win32 or posix path and returns a lower-cased version of entity's triplet\n * with the remaining path in posix.\n *\n * Starting slashes will be trimmed.\n *\n * Throws an error if the path does not appear to be an entity triplet.\n *\n * @example\n * lowerCaseEntityTripletInStoragePath('/default/Component/backstage/file.txt')\n * // return default/component/backstage/file.txt\n */\nexport const lowerCaseEntityTripletInStoragePath = (\n  originalPath: string,\n): string => {\n  let posixPath = originalPath;\n  if (originalPath.includes(path.win32.sep)) {\n    posixPath = originalPath.split(path.win32.sep).join(path.posix.sep);\n  }\n\n  // remove leading slash\n  const parts = posixPath.split(path.posix.sep);\n  if (parts[0] === '') {\n    parts.shift();\n  }\n\n  // check if all parts of the entity exist (name, namespace, kind) plus filename\n  if (parts.length <= 3) {\n    throw new Error(\n      `Encountered file unmanaged by TechDocs ${originalPath}. Skipping.`,\n    );\n  }\n\n  return lowerCaseEntityTriplet(parts.join(path.posix.sep));\n};\n\n/**\n * Take a posix path and return a path without leading and trailing\n * separators\n *\n * @example\n * normalizeExternalStorageRootPath('/backstage-data/techdocs/')\n * // return backstage-data/techdocs\n */\nexport const normalizeExternalStorageRootPath = (posixPath: string): string => {\n  // remove leading slash\n  let normalizedPath = posixPath;\n  if (posixPath.startsWith(path.posix.sep)) {\n    normalizedPath = posixPath.slice(1);\n  }\n\n  // remove trailing slash\n  if (normalizedPath.endsWith(path.posix.sep)) {\n    normalizedPath = normalizedPath.slice(0, normalizedPath.length - 1);\n  }\n\n  return normalizedPath;\n};\n\n// Only returns the files that existed previously and are not present anymore.\nexport const getStaleFiles = (\n  newFiles: string[],\n  oldFiles: string[],\n): string[] => {\n  const staleFiles = new Set(oldFiles);\n  const removedParentDirs = new Set();\n  newFiles.forEach(newFile => {\n    staleFiles.delete(newFile);\n\n    // We have to traverse through the directory hierarchy of a new file and\n    // ensure that we won't try to delete one of the parent directories.\n    let parentDir = newFile.substring(0, newFile.lastIndexOf('/'));\n    while (\n      !removedParentDirs.has(parentDir) &&\n      parentDir.length >= newFile.indexOf('/')\n    ) {\n      staleFiles.delete(parentDir);\n      removedParentDirs.add(parentDir);\n      parentDir = parentDir.substring(0, parentDir.lastIndexOf('/'));\n    }\n  });\n  return Array.from(staleFiles);\n};\n\n// Compose actual filename on remote bucket including entity information\nexport const getCloudPathForLocalPath = (\n  entity: Entity,\n  localPath = '',\n  useLegacyPathCasing = false,\n  externalStorageRootPath = '',\n): string => {\n  // Convert destination file path to a POSIX path for uploading.\n  // GCS expects / as path separator and relativeFilePath will contain \\\\ on Windows.\n  // https://cloud.google.com/storage/docs/gsutil/addlhelp/HowSubdirectoriesWork\n  const relativeFilePathPosix = localPath.split(path.sep).join(path.posix.sep);\n\n  // The / delimiter is intentional since it represents the cloud storage and not the local file system.\n  const entityRootDir = `${entity.metadata?.namespace ?? DEFAULT_NAMESPACE}/${\n    entity.kind\n  }/${entity.metadata.name}`;\n\n  const relativeFilePathTriplet = `${entityRootDir}/${relativeFilePathPosix}`;\n\n  const destination = useLegacyPathCasing\n    ? relativeFilePathTriplet\n    : lowerCaseEntityTriplet(relativeFilePathTriplet);\n\n  // Again, the / delimiter is intentional, as it represents remote storage.\n  const destinationWithRoot = [\n    // The extra filter prevents unintended double slashes and prefixes.\n    ...externalStorageRootPath.split(path.posix.sep).filter(s => s !== ''),\n    destination,\n  ].join('/');\n\n  return destinationWithRoot; // Remote storage file relative path\n};\n\n// Perform rate limited generic operations by passing a function and a list of arguments\nexport const bulkStorageOperation = async <T>(\n  operation: (arg: T) => Promise<unknown>,\n  args: T[],\n  { concurrencyLimit } = { concurrencyLimit: 25 },\n) => {\n  const limiter = createLimiter(concurrencyLimit);\n  await Promise.all(args.map(arg => limiter(operation, arg)));\n};\n\n// Checks content path is the same as or a child path of bucketRoot, specifically for posix paths.\nexport const isValidContentPath = (\n  bucketRoot: string,\n  contentPath: string,\n): boolean => {\n  const relativePath = path.posix.relative(bucketRoot, contentPath);\n  if (relativePath === '') {\n    // The same directory\n    return true;\n  }\n\n  const outsideBase = relativePath.startsWith('..'); // not outside base\n  const differentDrive = path.posix.isAbsolute(relativePath); // on Windows, this means dir is on a different drive from base.\n\n  return !outsideBase && !differentDrive;\n};\n"],"names":["mime","recursiveReadDir","path","DEFAULT_NAMESPACE","createLimiter"],"mappings":"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"}