{"version":3,"file":"openStackSwift.cjs.js","sources":["../../../src/stages/publish/openStackSwift.ts"],"sourcesContent":["/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Entity, CompoundEntityRef } from '@backstage/catalog-model';\nimport { Config } from '@backstage/config';\nimport express from 'express';\nimport fs from 'fs-extra';\nimport JSON5 from 'json5';\nimport createLimiter from 'p-limit';\nimport path from 'path';\nimport { SwiftClient } from '@trendyol-js/openstack-swift-sdk';\nimport { NotFound } from '@trendyol-js/openstack-swift-sdk/lib/types';\nimport { Stream, Readable } from 'stream';\n\nimport {\n  getFileTreeRecursively,\n  getHeadersForFileExtension,\n  lowerCaseEntityTripletInStoragePath,\n} from './helpers';\nimport {\n  PublisherBase,\n  PublishRequest,\n  PublishResponse,\n  ReadinessResponse,\n  TechDocsMetadata,\n} from './types';\nimport { assertError, ForwardedError } from '@backstage/errors';\nimport { LoggerService } from '@backstage/backend-plugin-api';\n\nconst streamToBuffer = (stream: Stream | Readable): Promise<Buffer> => {\n  return new Promise((resolve, reject) => {\n    try {\n      const chunks: any[] = [];\n      stream.on('data', chunk => chunks.push(chunk));\n      stream.on('error', reject);\n      stream.on('end', () => resolve(Buffer.concat(chunks)));\n    } catch (e) {\n      throw new ForwardedError('Unable to parse the response data', e);\n    }\n  });\n};\n\nconst bufferToStream = (buffer: Buffer): Readable => {\n  const stream = new Readable();\n  stream.push(buffer);\n  stream.push(null);\n  return stream;\n};\n\nexport class OpenStackSwiftPublish implements PublisherBase {\n  private readonly storageClient: SwiftClient;\n  private readonly containerName: string;\n  private readonly logger: LoggerService;\n\n  constructor(options: {\n    storageClient: SwiftClient;\n    containerName: string;\n    logger: LoggerService;\n  }) {\n    this.storageClient = options.storageClient;\n    this.containerName = options.containerName;\n    this.logger = options.logger;\n  }\n\n  static fromConfig(config: Config, logger: LoggerService): PublisherBase {\n    let containerName = '';\n    try {\n      containerName = config.getString(\n        'techdocs.publisher.openStackSwift.containerName',\n      );\n    } catch (error) {\n      throw new Error(\n        \"Since techdocs.publisher.type is set to 'openStackSwift' in your app config, \" +\n          'techdocs.publisher.openStackSwift.containerName is required.',\n      );\n    }\n\n    const openStackSwiftConfig = config.getConfig(\n      'techdocs.publisher.openStackSwift',\n    );\n\n    const storageClient = new SwiftClient({\n      authEndpoint: openStackSwiftConfig.getString('authUrl'),\n      swiftEndpoint: openStackSwiftConfig.getString('swiftUrl'),\n      credentialId: openStackSwiftConfig.getString('credentials.id'),\n      secret: openStackSwiftConfig.getString('credentials.secret'),\n    });\n\n    return new OpenStackSwiftPublish({ storageClient, containerName, logger });\n  }\n\n  /*\n   * Check if the defined container exists. Being able to connect means the configuration is good\n   * and the storage client will work.\n   */\n  async getReadiness(): Promise<ReadinessResponse> {\n    try {\n      const container = await this.storageClient.getContainerMetadata(\n        this.containerName,\n      );\n\n      if (!(container instanceof NotFound)) {\n        this.logger.info(\n          `Successfully connected to the OpenStack Swift container ${this.containerName}.`,\n        );\n        return {\n          isAvailable: true,\n        };\n      }\n      this.logger.error(\n        `Could not retrieve metadata about the OpenStack Swift container ${this.containerName}. ` +\n          'Make sure the container exists. Also make sure that authentication is setup either by ' +\n          'explicitly defining credentials and region in techdocs.publisher.openStackSwift in app config or ' +\n          'by using environment variables. Refer to https://backstage.io/docs/features/techdocs/using-cloud-storage',\n      );\n      return {\n        isAvailable: false,\n      };\n    } catch (err) {\n      assertError(err);\n      this.logger.error(`from OpenStack client library: ${err.message}`);\n      return {\n        isAvailable: false,\n      };\n    }\n  }\n\n  /**\n   * Upload all the files from the generated `directory` to the OpenStack Swift container.\n   * Directory structure used in the bucket is - entityNamespace/entityKind/entityName/index.html\n   */\n  async publish({\n    entity,\n    directory,\n  }: PublishRequest): Promise<PublishResponse> {\n    try {\n      const objects: string[] = [];\n\n      // Note: OpenStack Swift manages creation of parent directories if they do not exist.\n      // So collecting path of only the files is good enough.\n      const allFilesToUpload = await getFileTreeRecursively(directory);\n      const limiter = createLimiter(10);\n      const uploadPromises: Array<Promise<unknown>> = [];\n      for (const filePath of allFilesToUpload) {\n        // Remove the absolute path prefix of the source directory\n        // Path of all files to upload, relative to the root of the source directory\n        // e.g. ['index.html', 'sub-page/index.html', 'assets/images/favicon.png']\n        const relativeFilePath = path.relative(directory, filePath);\n        // Convert destination file path to a POSIX path for uploading.\n        // Swift expects / as path separator and relativeFilePath will contain \\\\ on Windows.\n        // https://docs.openstack.org/python-openstackclient/pike/cli/man/openstack.html\n        const relativeFilePathPosix = relativeFilePath\n          .split(path.sep)\n          .join(path.posix.sep);\n\n        // The / delimiter is intentional since it represents the cloud storage and not the local file system.\n        const entityRootDir = `${entity.metadata.namespace}/${entity.kind}/${entity.metadata.name}`;\n        const destination = `${entityRootDir}/${relativeFilePathPosix}`; // Swift container file relative path\n        objects.push(destination);\n\n        // Rate limit the concurrent execution of file uploads to batches of 10 (per publish)\n        const uploadFile = limiter(async () => {\n          const fileBuffer = await fs.readFile(filePath);\n          const stream = bufferToStream(fileBuffer);\n          return this.storageClient.upload(\n            this.containerName,\n            destination,\n            stream,\n          );\n        });\n        uploadPromises.push(uploadFile);\n      }\n      await Promise.all(uploadPromises);\n      this.logger.info(\n        `Successfully uploaded all the generated files for Entity ${entity.metadata.name}. Total number of files: ${allFilesToUpload.length}`,\n      );\n      return { objects };\n    } catch (e) {\n      const errorMessage = `Unable to upload file(s) to OpenStack Swift. ${e}`;\n      this.logger.error(errorMessage);\n      throw new Error(errorMessage);\n    }\n  }\n\n  async fetchTechDocsMetadata(\n    entityName: CompoundEntityRef,\n  ): Promise<TechDocsMetadata> {\n    return await new Promise<TechDocsMetadata>(async (resolve, reject) => {\n      const entityRootDir = `${entityName.namespace}/${entityName.kind}/${entityName.name}`;\n\n      const downloadResponse = await this.storageClient.download(\n        this.containerName,\n        `${entityRootDir}/techdocs_metadata.json`,\n      );\n\n      if (!(downloadResponse instanceof NotFound)) {\n        const stream = downloadResponse.data;\n        try {\n          const techdocsMetadataJson = await streamToBuffer(stream);\n          if (!techdocsMetadataJson) {\n            throw new Error(\n              `Unable to parse the techdocs metadata file ${entityRootDir}/techdocs_metadata.json.`,\n            );\n          }\n\n          const techdocsMetadata = JSON5.parse(\n            techdocsMetadataJson.toString('utf-8'),\n          );\n\n          resolve(techdocsMetadata);\n        } catch (err) {\n          assertError(err);\n          this.logger.error(err.message);\n          reject(new Error(err.message));\n        }\n      } else {\n        reject({\n          message: `TechDocs metadata fetch failed, The file /rootDir/${entityRootDir}/techdocs_metadata.json does not exist !`,\n        });\n      }\n    });\n  }\n\n  /**\n   * Express route middleware to serve static files on a route in techdocs-backend.\n   */\n  docsRouter(): express.Handler {\n    return async (req, res) => {\n      // Decode and trim the leading forward slash\n      // filePath example - /default/Component/documented-component/index.html\n      const filePath = decodeURI(req.path.replace(/^\\//, ''));\n\n      // Files with different extensions (CSS, HTML) need to be served with different headers\n      const fileExtension = path.extname(filePath);\n      const responseHeaders = getHeadersForFileExtension(fileExtension);\n\n      const downloadResponse = await this.storageClient.download(\n        this.containerName,\n        filePath,\n      );\n\n      if (!(downloadResponse instanceof NotFound)) {\n        const stream = downloadResponse.data;\n\n        try {\n          // Inject response headers\n          for (const [headerKey, headerValue] of Object.entries(\n            responseHeaders,\n          )) {\n            res.setHeader(headerKey, headerValue);\n          }\n\n          res.send(await streamToBuffer(stream));\n        } catch (err) {\n          assertError(err);\n          this.logger.warn(\n            `TechDocs OpenStack swift router failed to serve content from container ${this.containerName} at path ${filePath}: ${err.message}`,\n          );\n          res.status(404).send('File Not Found');\n        }\n      } else {\n        this.logger.warn(\n          `TechDocs OpenStack swift router failed to serve content from container ${this.containerName} at path ${filePath}: Not found`,\n        );\n        res.status(404).send('File Not Found');\n      }\n    };\n  }\n\n  /**\n   * A helper function which checks if index.html of an Entity's docs site is available. This\n   * can be used to verify if there are any pre-generated docs available to serve.\n   */\n  async hasDocsBeenGenerated(entity: Entity): Promise<boolean> {\n    const entityRootDir = `${entity.metadata.namespace}/${entity.kind}/${entity.metadata.name}`;\n    try {\n      const fileResponse = await this.storageClient.getMetadata(\n        this.containerName,\n        `${entityRootDir}/index.html`,\n      );\n\n      if (!(fileResponse instanceof NotFound)) {\n        return true;\n      }\n      return false;\n    } catch (err) {\n      assertError(err);\n      this.logger.warn(err.message);\n      return false;\n    }\n  }\n\n  async migrateDocsCase({\n    removeOriginal = false,\n    concurrency = 25,\n  }): Promise<void> {\n    // Iterate through every file in the root of the publisher.\n    const allObjects = await this.getAllObjectsFromContainer();\n    const limiter = createLimiter(concurrency);\n    await Promise.all(\n      allObjects.map(f =>\n        limiter(async file => {\n          let newPath;\n          try {\n            newPath = lowerCaseEntityTripletInStoragePath(file);\n          } catch (e) {\n            assertError(e);\n            this.logger.warn(e.message);\n            return;\n          }\n\n          // If all parts are already lowercase, ignore.\n          if (file === newPath) {\n            return;\n          }\n\n          try {\n            this.logger.debug(`Migrating ${file} to ${newPath}`);\n            await this.storageClient.copy(\n              this.containerName,\n              file,\n              this.containerName,\n              newPath,\n            );\n            if (removeOriginal) {\n              await this.storageClient.delete(this.containerName, file);\n            }\n          } catch (e) {\n            assertError(e);\n            this.logger.warn(`Unable to migrate ${file}: ${e.message}`);\n          }\n        }, f),\n      ),\n    );\n  }\n\n  /**\n   * Returns a list of all object keys from the configured container.\n   */\n  protected async getAllObjectsFromContainer(\n    { prefix } = { prefix: '' },\n  ): Promise<string[]> {\n    let objects: string[] = [];\n    const OSS_MAX_LIMIT = Math.pow(2, 31) - 1;\n\n    const allObjects = await this.storageClient.list(\n      this.containerName,\n      prefix,\n      OSS_MAX_LIMIT,\n    );\n    objects = allObjects.map((object: any) => object.name);\n\n    return objects;\n  }\n}\n"],"names":["ForwardedError","stream","Readable","SwiftClient","NotFound","assertError","getFileTreeRecursively","createLimiter","path","fs","JSON5","getHeadersForFileExtension","lowerCaseEntityTripletInStoragePath"],"mappings":"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"}