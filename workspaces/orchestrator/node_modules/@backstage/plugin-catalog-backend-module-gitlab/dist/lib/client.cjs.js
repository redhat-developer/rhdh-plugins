'use strict';

var fetch = require('node-fetch');
var integration = require('@backstage/integration');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var fetch__default = /*#__PURE__*/_interopDefaultCompat(fetch);

class GitLabClient {
  config;
  logger;
  constructor(options) {
    this.config = options.config;
    this.logger = options.logger;
  }
  /**
   * Indicates whether the client is for a SaaS or self managed GitLab instance.
   */
  isSelfManaged() {
    return this.config.host !== "gitlab.com";
  }
  async listProjects(options) {
    if (options?.group) {
      return this.pagedRequest(
        `/groups/${encodeURIComponent(options?.group)}/projects`,
        {
          ...options,
          include_subgroups: true
        }
      );
    }
    return this.pagedRequest(`/projects`, options);
  }
  async getProjectById(projectId, options) {
    const response = await this.nonPagedRequest(
      `/projects/${projectId}`,
      options
    );
    return response;
  }
  async getGroupById(groupId, options) {
    const response = await this.nonPagedRequest(`/groups/${groupId}`, options);
    return response;
  }
  async getUserById(userId, options) {
    const response = await this.nonPagedRequest(`/users/${userId}`, options);
    return response;
  }
  async listGroupMembers(groupPath, options) {
    return this.pagedRequest(
      `/groups/${encodeURIComponent(groupPath)}/members/all`,
      options
    );
  }
  async listUsers(options) {
    return this.pagedRequest(`/users?`, {
      ...options,
      without_project_bots: true,
      exclude_internal: true
    });
  }
  async listSaaSUsers(groupPath, options, includeUsersWithoutSeat) {
    const botFilterRegex = /^(?:project|group)_(\w+)_bot_(\w+)$/;
    return this.listGroupMembers(groupPath, {
      ...options,
      active: true,
      // Users with seat are always active but for users without seat we need to filter
      show_seat_info: true
    }).then((resp) => {
      if (includeUsersWithoutSeat) {
        resp.items = resp.items.filter((user) => {
          return !botFilterRegex.test(user.username);
        });
      } else {
        resp.items = resp.items.filter((user) => user.is_using_seat);
      }
      return resp;
    });
  }
  async listGroups(options) {
    return this.pagedRequest(`/groups`, options);
  }
  // https://docs.gitlab.com/ee/api/groups.html#list-group-details
  // id can either be group id or encoded full path
  async getGroupByPath(groupPath, options) {
    return this.nonPagedRequest(
      `/groups/${encodeURIComponent(groupPath)}`,
      options
    );
  }
  async listDescendantGroups(groupPath) {
    const items = [];
    let hasNextPage = false;
    let endCursor = null;
    do {
      const response = await this.fetchWithRetry(`${this.config.baseUrl}/api/graphql`, {
        method: "POST",
        headers: {
          ...integration.getGitLabRequestOptions(this.config).headers,
          ["Content-Type"]: "application/json"
        },
        body: JSON.stringify({
          variables: { group: groupPath, endCursor },
          query: (
            /* GraphQL */
            `
              query listDescendantGroups($group: ID!, $endCursor: String) {
                group(fullPath: $group) {
                  descendantGroups(first: 100, after: $endCursor) {
                    nodes {
                      id
                      name
                      description
                      fullPath
                      visibility
                      parent {
                        id
                      }
                    }
                    pageInfo {
                      endCursor
                      hasNextPage
                    }
                  }
                }
              }
            `
          )
        })
      }).then((r) => r.json());
      if (response.errors) {
        throw new Error(`GraphQL errors: ${JSON.stringify(response.errors)}`);
      }
      if (!response.data.group?.descendantGroups?.nodes) {
        this.logger.warn(
          `Couldn't get groups under ${groupPath}. The provided token might not have sufficient permissions`
        );
        continue;
      }
      for (const groupItem of response.data.group.descendantGroups.nodes.filter(
        (group) => group?.id
      )) {
        const formattedGroupResponse = {
          id: Number(groupItem.id.replace(/^gid:\/\/gitlab\/Group\//, "")),
          name: groupItem.name,
          description: groupItem.description,
          full_path: groupItem.fullPath,
          visibility: groupItem.visibility,
          parent_id: Number(
            groupItem.parent.id.replace(/^gid:\/\/gitlab\/Group\//, "")
          )
        };
        items.push(formattedGroupResponse);
      }
      ({ hasNextPage, endCursor } = response.data.group.descendantGroups.pageInfo);
    } while (hasNextPage);
    return { items };
  }
  async getGroupMembers(groupPath, relations) {
    const items = [];
    let hasNextPage = false;
    let endCursor = null;
    do {
      const response = await this.fetchWithRetry(
        `${this.config.baseUrl}/api/graphql`,
        {
          method: "POST",
          headers: {
            ...integration.getGitLabRequestOptions(this.config).headers,
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            variables: { group: groupPath, relations, endCursor },
            query: (
              /* GraphQL */
              `
              query getGroupMembers(
                $group: ID!
                $relations: [GroupMemberRelation!]
                $endCursor: String
              ) {
                group(fullPath: $group) {
                  groupMembers(
                    first: 100
                    relations: $relations
                    after: $endCursor
                  ) {
                    nodes {
                      user {
                        id
                        username
                        publicEmail
                        name
                        state
                        webUrl
                        avatarUrl
                      }
                    }
                    pageInfo {
                      endCursor
                      hasNextPage
                    }
                  }
                }
              }
            `
            )
          })
        }
      ).then((r) => r.json());
      if (response.errors) {
        throw new Error(`GraphQL errors: ${JSON.stringify(response.errors)}`);
      }
      if (!response.data.group?.groupMembers?.nodes) {
        this.logger.warn(
          `Couldn't get members for group ${groupPath}. The provided token might not have sufficient permissions`
        );
        continue;
      }
      for (const userItem of response.data.group.groupMembers.nodes.filter(
        (user) => user.user?.id
      )) {
        const formattedUserResponse = {
          id: Number(userItem.user.id.replace(/^gid:\/\/gitlab\/User\//, "")),
          username: userItem.user.username,
          email: userItem.user.publicEmail,
          name: userItem.user.name,
          state: userItem.user.state,
          web_url: userItem.user.webUrl,
          avatar_url: userItem.user.avatarUrl
        };
        items.push(formattedUserResponse);
      }
      ({ hasNextPage, endCursor } = response.data.group.groupMembers.pageInfo);
    } while (hasNextPage);
    return { items };
  }
  /**
   * General existence check.
   *
   * @param projectPath - The path to the project
   * @param branch - The branch used to search
   * @param filePath - The path to the file
   */
  async hasFile(projectPath, branch, filePath) {
    const endpoint = `/projects/${encodeURIComponent(
      projectPath
    )}/repository/files/${encodeURIComponent(filePath)}`;
    const request = new URL(`${this.config.apiBaseUrl}${endpoint}`);
    request.searchParams.append("ref", branch);
    const response = await this.fetchWithRetry(request.toString(), {
      headers: integration.getGitLabRequestOptions(this.config).headers,
      method: "HEAD"
    });
    if (!response.ok) {
      if (response.status >= 500) {
        this.logger.debug(
          `Unexpected response when fetching ${request.toString()}. Expected 200 but got ${response.status} - ${response.statusText}`
        );
      }
      return false;
    }
    return true;
  }
  /**
   * Performs a request against a given paginated GitLab endpoint.
   *
   * This method may be used to perform authenticated REST calls against any
   * paginated GitLab endpoint which uses X-NEXT-PAGE headers. The return value
   * can be be used with the {@link paginated} async-generator function to yield
   * each item from the paged request.
   *
   * @see {@link paginated}
   * @param endpoint - The request endpoint, e.g. /projects.
   * @param options - Request queryString options which may also include page variables.
   */
  async pagedRequest(endpoint, options) {
    const request = new URL(`${this.config.apiBaseUrl}${endpoint}`);
    for (const key in options) {
      if (options.hasOwnProperty(key)) {
        const value = options[key];
        if (value !== void 0 && value !== "") {
          request.searchParams.append(key, value.toString());
        }
      }
    }
    this.logger.debug(`Fetching: ${request.toString()}`);
    const response = await this.fetchWithRetry(
      request.toString(),
      integration.getGitLabRequestOptions(this.config)
    );
    if (!response.ok) {
      throw new Error(
        `Unexpected response when fetching ${request.toString()}. Expected 200 but got ${response.status} - ${response.statusText}`
      );
    }
    return response.json().then((items) => {
      const nextPage = response.headers.get("x-next-page");
      return {
        items,
        nextPage: nextPage ? Number(nextPage) : null
      };
    });
  }
  async nonPagedRequest(endpoint, options) {
    const request = new URL(`${this.config.apiBaseUrl}${endpoint}`);
    for (const key in options) {
      if (options.hasOwnProperty(key)) {
        const value = options[key];
        if (value !== void 0 && value !== "") {
          request.searchParams.append(key, value.toString());
        }
      }
    }
    const response = await this.fetchWithRetry(
      request.toString(),
      integration.getGitLabRequestOptions(this.config)
    );
    if (!response.ok) {
      throw new Error(
        `Unexpected response when fetching ${request.toString()}. Expected 200 but got ${response.status} - ${response.statusText}`
      );
    }
    return response.json();
  }
  /**
   * Performs a fetch request with retry logic for rate limiting (429 errors)
   * @param url - The URL to fetch
   * @param options - Fetch options
   * @param retries - Maximum number of retries
   * @param initialBackoff - Initial backoff time in ms
   */
  async fetchWithRetry(url, options, retries = 5, initialBackoff = 100) {
    let currentRetry = 0;
    let backoff = initialBackoff;
    for (; ; ) {
      const response = await fetch__default.default(url, options);
      if (response.status !== 429 || currentRetry >= retries) {
        return response;
      }
      const retryAfter = response.headers.get("Retry-After");
      const waitTime = retryAfter ? parseInt(retryAfter, 10) * 1e3 : backoff;
      this.logger.warn(
        `GitLab API rate limit exceeded, retrying in ${waitTime}ms (retry ${currentRetry + 1}/${retries})`
      );
      await new Promise((resolve) => setTimeout(resolve, waitTime));
      backoff = backoff * 2 * (0.8 + Math.random() * 0.4);
      currentRetry++;
    }
  }
}
async function* paginated(request, options) {
  let res;
  do {
    res = await request(options);
    options.page = res.nextPage;
    for (const item of res.items) {
      yield item;
    }
  } while (res.nextPage);
}

exports.GitLabClient = GitLabClient;
exports.paginated = paginated;
//# sourceMappingURL=client.cjs.js.map
