'use strict';

var integration = require('@backstage/integration');
var pluginCatalogNode = require('@backstage/plugin-catalog-node');
require('@backstage/backend-plugin-api');
var client = require('./lib/client.cjs.js');
var cache = require('@backstage/backend-defaults/cache');

class GitLabDiscoveryProcessor {
  integrations;
  logger;
  cache;
  skipReposWithoutExactFileMatch;
  skipForkedRepos;
  includeArchivedRepos;
  static fromConfig(config, options) {
    const integrations = integration.ScmIntegrations.fromConfig(config);
    const pluginCache = cache.CacheManager.fromConfig(config).forPlugin("gitlab-discovery");
    return new GitLabDiscoveryProcessor({
      ...options,
      integrations,
      pluginCache
    });
  }
  constructor(options) {
    this.integrations = options.integrations;
    this.cache = options.pluginCache;
    this.logger = options.logger;
    this.skipReposWithoutExactFileMatch = options.skipReposWithoutExactFileMatch || false;
    this.skipForkedRepos = options.skipForkedRepos || false;
    this.includeArchivedRepos = options.includeArchivedRepos || false;
  }
  getProcessorName() {
    return "GitLabDiscoveryProcessor";
  }
  async readLocation(location, _optional, emit) {
    if (location.type !== "gitlab-discovery") {
      return false;
    }
    const startTime = /* @__PURE__ */ new Date();
    const { group, host, branch, catalogPath } = parseUrl(location.target);
    const integration = this.integrations.gitlab.byUrl(`https://${host}`);
    if (!integration) {
      throw new Error(
        `There is no GitLab integration that matches ${host}. Please add a configuration entry for it under integrations.gitlab`
      );
    }
    const client$1 = new client.GitLabClient({
      config: integration.config,
      logger: this.logger
    });
    this.logger.debug(`Reading GitLab projects from ${location.target}`);
    const lastActivity = await this.cache.get(this.getCacheKey());
    const opts = {
      group,
      page: 1,
      // We check for the existence of lastActivity and only set it if it's present to ensure
      // that the options doesn't include the key so that the API doesn't receive an empty query parameter.
      ...lastActivity && { last_activity_after: lastActivity },
      ...!this.includeArchivedRepos && { archived: false },
      // Only use simple=true when we don't need to skip forked repos.
      // The simple=true parameter reduces response size by returning fewer fields,
      // but it excludes the 'forked_from_project' field which is required for fork detection.
      // Therefore, we can only optimize with simple=true when skipForkedRepos is false.
      ...!this.skipForkedRepos && { simple: true }
    };
    const projects = client.paginated((options) => client$1.listProjects(options), opts);
    const res = {
      scanned: 0,
      matches: []
    };
    for await (const project of projects) {
      res.scanned++;
      if (branch === "*" && project.default_branch === void 0) {
        continue;
      }
      if (this.skipReposWithoutExactFileMatch) {
        const project_branch = branch === "*" ? project.default_branch : branch;
        const projectHasFile = await client$1.hasFile(
          project.path_with_namespace,
          project_branch,
          catalogPath
        );
        if (!projectHasFile) {
          continue;
        }
      }
      if (this.skipForkedRepos && project.hasOwnProperty("forked_from_project")) {
        continue;
      }
      res.matches.push(project);
    }
    for (const project of res.matches) {
      const project_branch = branch === "*" ? project.default_branch : branch;
      emit(
        pluginCatalogNode.processingResult.location({
          type: "url",
          // The format expected by the GitLabUrlReader:
          // https://gitlab.com/groupA/teams/teamA/subgroupA/repoA/-/blob/branch/filepath
          //
          // This unfortunately will trigger another API call in `getGitLabFileFetchUrl` to get the project ID.
          // The alternative is using the `buildRawUrl` function, which does not support subgroups, so providing a raw
          // URL here won't work either.
          target: `${project.web_url}/-/blob/${project_branch}/${catalogPath}`,
          presence: "optional"
        })
      );
    }
    await this.cache.set(this.getCacheKey(), startTime.toISOString());
    const duration = ((Date.now() - startTime.getTime()) / 1e3).toFixed(1);
    this.logger.debug(
      `Read ${res.scanned} GitLab repositories in ${duration} seconds`
    );
    return true;
  }
  getCacheKey() {
    return `processors/${this.getProcessorName()}/last-activity`;
  }
}
function parseUrl(urlString) {
  const url = new URL(urlString);
  const path = url.pathname.slice(1).split("/");
  const blobIndex = path.findIndex((p) => p === "blob");
  if (blobIndex !== -1 && path.length > blobIndex + 2) {
    const group = blobIndex > 0 ? path.slice(0, blobIndex).join("/") : void 0;
    return {
      group,
      host: url.host,
      branch: decodeURIComponent(path[blobIndex + 1]),
      catalogPath: decodeURIComponent(path.slice(blobIndex + 2).join("/"))
    };
  }
  throw new Error(`Failed to parse ${urlString}`);
}

exports.GitLabDiscoveryProcessor = GitLabDiscoveryProcessor;
exports.parseUrl = parseUrl;
//# sourceMappingURL=GitLabDiscoveryProcessor.cjs.js.map
