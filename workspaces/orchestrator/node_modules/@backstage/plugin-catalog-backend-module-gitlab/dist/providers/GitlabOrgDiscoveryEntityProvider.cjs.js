'use strict';

var catalogModel = require('@backstage/catalog-model');
var integration = require('@backstage/integration');
var lodash = require('lodash');
var uuid = require('uuid');
var config = require('./config.cjs.js');
var client = require('../lib/client.cjs.js');
var defaultTransformers = require('../lib/defaultTransformers.cjs.js');

function _interopNamespaceCompat(e) {
  if (e && typeof e === 'object' && 'default' in e) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var uuid__namespace = /*#__PURE__*/_interopNamespaceCompat(uuid);

const TOPIC_GROUP_CREATE = "gitlab.group_create";
const TOPIC_GROUP_DESTROY = "gitlab.group_destroy";
const TOPIC_GROUP_RENAME = "gitlab.group_rename";
const TOPIC_USER_CREATE = "gitlab.user_create";
const TOPIC_USER_DESTROY = "gitlab.user_destroy";
const TOPIC_USER_ADD_GROUP = "gitlab.user_add_to_group";
const TOPIC_USER_REMOVE_GROUP = "gitlab.user_remove_from_group";
class GitlabOrgDiscoveryEntityProvider {
  config;
  integration;
  logger;
  events;
  scheduleFn;
  connection;
  userTransformer;
  groupEntitiesTransformer;
  groupNameTransformer;
  gitLabClient;
  groupPatterns;
  static fromConfig(config$1, options) {
    if (!options.schedule && !options.scheduler) {
      throw new Error("Either schedule or scheduler must be provided.");
    }
    const providerConfigs = config.readGitlabConfigs(config$1);
    const integrations = integration.ScmIntegrations.fromConfig(config$1).gitlab;
    const providers = [];
    providerConfigs.forEach((providerConfig) => {
      const integration = integrations.byHost(providerConfig.host);
      if (!providerConfig.orgEnabled) {
        options.logger.info(`Org not enabled for ${providerConfig.id}.`);
        return;
      }
      if (!integration) {
        throw new Error(
          `No gitlab integration found that matches host ${providerConfig.host}`
        );
      }
      if (!providerConfig.group && providerConfig.host === "gitlab.com") {
        throw new Error(
          `Missing 'group' value for GitlabOrgDiscoveryEntityProvider:${providerConfig.id}.`
        );
      }
      if (!options.schedule && !providerConfig.schedule) {
        throw new Error(
          `No schedule provided neither via code nor config for GitlabOrgDiscoveryEntityProvider:${providerConfig.id}.`
        );
      }
      const taskRunner = options.schedule ?? options.scheduler.createScheduledTaskRunner(providerConfig.schedule);
      providers.push(
        new GitlabOrgDiscoveryEntityProvider({
          ...options,
          config: providerConfig,
          integration,
          taskRunner
        })
      );
    });
    return providers;
  }
  constructor(options) {
    this.config = options.config;
    this.integration = options.integration;
    this.logger = options.logger.child({
      target: this.getProviderName()
    });
    this.scheduleFn = this.createScheduleFn(options.taskRunner);
    this.events = options.events;
    this.userTransformer = options.userTransformer ?? defaultTransformers.defaultUserTransformer;
    this.groupEntitiesTransformer = options.groupEntitiesTransformer ?? defaultTransformers.defaultGroupEntitiesTransformer;
    this.groupNameTransformer = options.groupNameTransformer ?? defaultTransformers.defaultGroupNameTransformer;
    this.groupPatterns = Array.isArray(this.config.groupPattern) ? this.config.groupPattern : [this.config.groupPattern];
    this.gitLabClient = new client.GitLabClient({
      config: this.integration.config,
      logger: this.logger
    });
  }
  getProviderName() {
    return `GitlabOrgDiscoveryEntityProvider:${this.config.id}`;
  }
  async connect(connection) {
    this.connection = connection;
    await this.scheduleFn();
    if (this.events) {
      await this.events.subscribe({
        id: this.getProviderName(),
        topics: [
          TOPIC_GROUP_CREATE,
          TOPIC_GROUP_DESTROY,
          TOPIC_GROUP_RENAME,
          TOPIC_USER_CREATE,
          TOPIC_USER_DESTROY,
          TOPIC_USER_ADD_GROUP,
          TOPIC_USER_REMOVE_GROUP
        ],
        onEvent: async (params) => {
          this.logger.info(`Received event from topic ${params.topic}`);
          const addEntitiesOperation = (entities) => ({
            removed: [],
            added: entities.map((entity) => ({
              locationKey: this.getProviderName(),
              entity: this.withLocations(
                this.integration.config.host,
                this.integration.config.baseUrl,
                entity
              )
            }))
          });
          const removeEntitiesOperation = (entities) => ({
            added: [],
            removed: entities.map((entity) => ({
              locationKey: this.getProviderName(),
              entity: this.withLocations(
                this.integration.config.host,
                this.integration.config.baseUrl,
                entity
              )
            }))
          });
          const replaceEntitiesOperation = (entities) => {
            const entitiesToReplace = entities.map((entity) => ({
              locationKey: this.getProviderName(),
              entity: this.withLocations(
                this.integration.config.host,
                this.integration.config.baseUrl,
                entity
              )
            }));
            return {
              removed: entitiesToReplace,
              added: entitiesToReplace
            };
          };
          if (params.topic === TOPIC_GROUP_CREATE || params.topic === TOPIC_GROUP_DESTROY) {
            const payload = params.eventPayload;
            const createDeltaOperation = params.topic === TOPIC_GROUP_CREATE ? addEntitiesOperation : removeEntitiesOperation;
            await this.onGroupChange(payload, createDeltaOperation);
          }
          if (params.topic === TOPIC_GROUP_RENAME) {
            const payload = params.eventPayload;
            await this.onGroupEdit(payload, replaceEntitiesOperation);
          }
          if (params.topic === TOPIC_USER_CREATE || params.topic === TOPIC_USER_DESTROY) {
            const payload = params.eventPayload;
            const createDeltaOperation = params.topic === TOPIC_USER_CREATE ? addEntitiesOperation : removeEntitiesOperation;
            await this.onUserChange(payload, createDeltaOperation);
          }
          if (params.topic === TOPIC_USER_ADD_GROUP || params.topic === TOPIC_USER_REMOVE_GROUP) {
            const payload = params.eventPayload;
            const createDeltaOperation = addEntitiesOperation;
            await this.onMembershipChange(payload, createDeltaOperation);
          }
        }
      });
    }
  }
  createScheduleFn(taskRunner) {
    return async () => {
      const taskId = `${this.getProviderName()}:refresh`;
      return taskRunner.run({
        id: taskId,
        fn: async () => {
          const logger = this.logger.child({
            class: GitlabOrgDiscoveryEntityProvider.prototype.constructor.name,
            taskId,
            taskInstanceId: uuid__namespace.v4()
          });
          try {
            await this.refresh(logger);
          } catch (error) {
            logger.error(
              `${this.getProviderName()} refresh failed, ${error}`,
              error
            );
          }
        }
      });
    };
  }
  async refresh(logger) {
    if (!this.connection) {
      throw new Error(
        `Gitlab discovery connection not initialized for ${this.getProviderName()}`
      );
    }
    let groups;
    const allUsers = [];
    if (this.gitLabClient.isSelfManaged() && this.config.restrictUsersToGroup) {
      groups = (await this.gitLabClient.listDescendantGroups(this.config.group)).items;
      groups.push(await this.gitLabClient.getGroupByPath(this.config.group));
      allUsers.push(
        client.paginated(
          (options) => this.gitLabClient.listGroupMembers(this.config.group, options),
          // calls /groups/<groupId>/members
          {
            page: 1,
            per_page: 100
          }
        )
      );
    } else if (this.gitLabClient.isSelfManaged() && !this.config.restrictUsersToGroup) {
      groups = client.paginated(
        (options) => this.gitLabClient.listGroups(options),
        {
          page: 1,
          per_page: 100,
          all_available: true
        }
      );
      allUsers.push(
        client.paginated(
          (options) => this.gitLabClient.listUsers(options),
          // calls /users?
          { page: 1, per_page: 100, active: true }
        )
      );
    } else {
      const descendantGroups = (await this.gitLabClient.listDescendantGroups(this.config.group)).items;
      groups = descendantGroups;
      groups.push(await this.gitLabClient.getGroupByPath(this.config.group));
      const rootGroupSplit = this.config.group.split("/");
      const groupPaths = this.config.restrictUsersToGroup ? [this.config.group] : [rootGroupSplit[0], ...descendantGroups.map((g) => `${g.id}`)];
      for (const group of groupPaths) {
        logger.debug(`Fetching users for group: ${group}`);
        allUsers.push(
          client.paginated(
            (options) => this.gitLabClient.listSaaSUsers(
              group,
              options,
              this.config.includeUsersWithoutSeat
            ),
            {
              page: 1,
              per_page: 100
            }
          )
        );
      }
    }
    const idMappedUser = {};
    const userRes = {
      scanned: 0,
      matches: []
    };
    const groupRes = {
      scanned: 0,
      matches: []
    };
    for (const users of allUsers) {
      for await (const user of users) {
        if (user.id in idMappedUser) {
          continue;
        }
        userRes.scanned++;
        if (!this.shouldProcessUser(user)) {
          logger.debug(`Skipped user: ${user.username}`);
          continue;
        }
        idMappedUser[user.id] = user;
        userRes.matches.push(user);
      }
    }
    for await (const group of groups) {
      groupRes.scanned++;
      if (!this.shouldProcessGroup(group)) {
        logger.debug(`Skipped group: ${group.full_path}`);
        continue;
      }
      logger.debug(`Processed group: ${group.full_path}`);
      groupRes.matches.push(group);
      let groupUsers = { items: [] };
      try {
        const relations = this.getRelations(this.config);
        groupUsers = await this.gitLabClient.getGroupMembers(
          group.full_path,
          relations
        );
      } catch (e) {
        logger.error(
          `Failed fetching users for group '${group.full_path}': ${e}`
        );
      }
      for (const groupUser of groupUsers.items) {
        const user = idMappedUser[groupUser.id];
        if (user) {
          user.groups = (user.groups ?? []).concat(group);
        }
      }
    }
    const groupsWithUsers = groupRes.matches.filter((group) => {
      return userRes.matches.filter((x) => {
        return !!x.groups?.find((y) => y.id === group.id);
      }).length > 0;
    });
    const userEntities = userRes.matches.map(
      (p) => this.userTransformer({
        user: p,
        integrationConfig: this.integration.config,
        providerConfig: this.config,
        groupNameTransformer: this.groupNameTransformer
      })
    );
    const groupEntities = this.groupEntitiesTransformer({
      groups: groupsWithUsers,
      providerConfig: this.config,
      groupNameTransformer: this.groupNameTransformer
    });
    logger.info(
      `Scanned ${userRes.scanned} users and processed ${userEntities.length} users`
    );
    logger.info(
      `Scanned ${groupRes.scanned} groups and processed ${groupEntities.length} groups`
    );
    await this.connection.applyMutation({
      type: "full",
      entities: [...userEntities, ...groupEntities].map((entity) => ({
        locationKey: this.getProviderName(),
        entity: this.withLocations(
          this.integration.config.host,
          this.integration.config.baseUrl,
          entity
        )
      }))
    });
  }
  async onGroupChange(event, createDeltaOperation) {
    if (!this.connection) {
      throw new Error(
        `Gitlab discovery connection not initialized for ${this.getProviderName()}`
      );
    }
    let group;
    if (event.event_name === "group_destroy") {
      group = {
        id: event.group_id,
        full_path: event.full_path,
        name: event.name,
        description: "",
        parent_id: 0
      };
    } else {
      group = await this.gitLabClient.getGroupById(event.group_id);
    }
    if (!this.shouldProcessGroup(group)) {
      this.logger.debug(`Skipped group ${group.full_path}.`);
      return;
    }
    const groupEntity = this.groupEntitiesTransformer({
      groups: [group],
      providerConfig: this.config,
      groupNameTransformer: this.groupNameTransformer
    });
    if (group.parent_id) {
      const parentGroup = await this.gitLabClient.getGroupById(group.parent_id);
      groupEntity[0].spec.parent = this.groupNameTransformer({
        group: parentGroup,
        providerConfig: this.config
      });
    }
    this.logger.debug(`Applying mutation for group ${group.full_path}.`);
    await this.connection.applyMutation({
      type: "delta",
      ...createDeltaOperation(groupEntity)
    });
  }
  // the goal here is to trigger a mutation to remove the old entity and add the new one.
  async onGroupEdit(event, createDeltaOperation) {
    if (!this.connection) {
      throw new Error(
        `Gitlab discovery connection not initialized for ${this.getProviderName()}`
      );
    }
    const groupToRemove = {
      id: event.group_id,
      full_path: event.old_full_path,
      name: event.name,
      description: "",
      parent_id: 0
    };
    if (!this.shouldProcessGroup(groupToRemove)) {
      this.logger.debug(`Skipped group ${groupToRemove.full_path}.`);
      return;
    }
    const groupEntityToRemove = await this.groupEntitiesTransformer({
      groups: [groupToRemove],
      providerConfig: this.config,
      groupNameTransformer: this.groupNameTransformer
    });
    const groupToAdd = await this.gitLabClient.getGroupById(event.group_id);
    if (!this.shouldProcessGroup(groupToAdd)) {
      this.logger.debug(`Skipped group ${groupToAdd.full_path}.`);
      return;
    }
    const groupEntityToAdd = await this.groupEntitiesTransformer({
      groups: [groupToAdd],
      providerConfig: this.config,
      groupNameTransformer: this.groupNameTransformer
    });
    if (groupToAdd.parent_id) {
      const parentGroup = await this.gitLabClient.getGroupById(
        groupToAdd.parent_id
      );
      groupEntityToAdd[0].spec.parent = this.groupNameTransformer({
        group: parentGroup,
        providerConfig: this.config
      });
    }
    const { added } = createDeltaOperation(groupEntityToAdd);
    const { removed } = createDeltaOperation(groupEntityToRemove);
    this.logger.debug(`Applying mutation for group ${groupToAdd.full_path}.`);
    await this.connection.applyMutation({
      type: "delta",
      removed,
      added
    });
  }
  async onUserChange(event, createDeltaOperation) {
    if (!this.connection) {
      throw new Error(
        `Gitlab discovery connection not initialized for ${this.getProviderName()}`
      );
    }
    let user = void 0;
    if (event.event_name === "user_destroy") {
      user = {
        id: event.user_id,
        username: event.username,
        email: event.email,
        name: event.name,
        state: "active",
        // in the delete case it doesn't really matter if the user is active or not
        web_url: "",
        avatar_url: ""
      };
    }
    if (event.event_name === "user_create") {
      user = await this.gitLabClient.getUserById(event.user_id);
    }
    if (!user) {
      this.logger.debug(
        `Couldn't retrieve user data. Skipped ${event.event_name} event processing for user ${event.username}`
      );
      return;
    }
    if (!this.shouldProcessUser(user)) {
      this.logger.debug(`Skipped user ${user.username}.`);
      return;
    }
    const userEntity = await this.userTransformer({
      user,
      integrationConfig: this.integration.config,
      providerConfig: this.config,
      groupNameTransformer: this.groupNameTransformer
    });
    const { added, removed } = createDeltaOperation([userEntity]);
    this.logger.debug(`Applying mutation for user ${user.username}.`);
    await this.connection.applyMutation({
      type: "delta",
      removed,
      added
    });
  }
  // the goal here is to reconstruct the group either from which the user was removed or to which the user was added. Specifically, we add/remove the new user to/from the spec.member property array of the group entity. The Processor should take care of updating the relations
  async onMembershipChange(event, createDeltaOperation) {
    if (!this.connection) {
      throw new Error(
        `Gitlab discovery connection not initialized for ${this.getProviderName()}`
      );
    }
    const groupToRebuild = await this.gitLabClient.getGroupById(
      event.group_id
    );
    if (!groupToRebuild) {
      this.logger.debug(
        `Couldn't retrieve group data. Skipped ${event.event_name} event processing.`
      );
      return;
    }
    if (!this.shouldProcessGroup(groupToRebuild)) {
      this.logger.debug(`Skipped group ${groupToRebuild.full_path}.`);
      return;
    }
    const relations = this.getRelations(this.config);
    const groupMembers = await this.gitLabClient.getGroupMembers(
      groupToRebuild.full_path,
      relations
    );
    const usersToBeAdded = groupMembers.items;
    const groupEntityToModify = await this.groupEntitiesTransformer({
      groups: [groupToRebuild],
      providerConfig: this.config,
      groupNameTransformer: this.groupNameTransformer
    });
    if (groupToRebuild.parent_id) {
      const parentGroup = await this.gitLabClient.getGroupById(
        groupToRebuild.parent_id
      );
      groupEntityToModify[0].spec.parent = this.groupNameTransformer({
        group: parentGroup,
        providerConfig: this.config
      });
    }
    groupEntityToModify[0].spec.members = usersToBeAdded.length !== 0 ? usersToBeAdded.map((e) => e.username) : [];
    const { added, removed } = createDeltaOperation(groupEntityToModify);
    this.logger.debug(
      `Applying mutation for group ${groupToRebuild.full_path}.`
    );
    await this.connection.applyMutation({
      type: "delta",
      removed,
      added
    });
  }
  shouldProcessGroup(group) {
    return this.groupPatterns.some((pattern) => pattern.test(group.full_path)) && (!this.config.group || group.full_path.startsWith(`${this.config.group}/`) || group.full_path === this.config.group);
  }
  shouldProcessUser(user) {
    return this.config.userPattern.test(user.email ?? user.username ?? "") && user.state === "active";
  }
  withLocations(host, baseUrl, entity) {
    const location = entity.kind === "Group" ? `url:${baseUrl}/${entity.metadata.annotations?.[`${host}/team-path`]}` : `url:${baseUrl}/${entity.metadata.name}`;
    return lodash.merge(
      {
        metadata: {
          annotations: {
            [catalogModel.ANNOTATION_LOCATION]: location,
            [catalogModel.ANNOTATION_ORIGIN_LOCATION]: location
          }
        }
      },
      entity
    );
  }
  getRelations(config) {
    if (Array.isArray(config.relations)) {
      const relationsSet = /* @__PURE__ */ new Set(["DIRECT", ...config.relations]);
      return Array.from(relationsSet);
    }
    return ["DIRECT", ...config.allowInherited ? ["INHERITED"] : []];
  }
}

exports.GitlabOrgDiscoveryEntityProvider = GitlabOrgDiscoveryEntityProvider;
//# sourceMappingURL=GitlabOrgDiscoveryEntityProvider.cjs.js.map
