'use strict';

var integration = require('@backstage/integration');
var pluginCatalogNode = require('@backstage/plugin-catalog-node');
var uuid = require('uuid');
var config = require('./config.cjs.js');
var client = require('../lib/client.cjs.js');
var path = require('path');

function _interopNamespaceCompat(e) {
  if (e && typeof e === 'object' && 'default' in e) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var uuid__namespace = /*#__PURE__*/_interopNamespaceCompat(uuid);
var path__namespace = /*#__PURE__*/_interopNamespaceCompat(path);

const TOPIC_REPO_PUSH = "gitlab.push";
class GitlabDiscoveryEntityProvider {
  config;
  integration;
  logger;
  scheduleFn;
  connection;
  events;
  gitLabClient;
  static fromConfig(config$1, options) {
    if (!options.schedule && !options.scheduler) {
      throw new Error("Either schedule or scheduler must be provided.");
    }
    const providerConfigs = config.readGitlabConfigs(config$1);
    const integrations = integration.ScmIntegrations.fromConfig(config$1).gitlab;
    const providers = [];
    providerConfigs.forEach((providerConfig) => {
      const integration = integrations.byHost(providerConfig.host);
      if (!integration) {
        throw new Error(
          `No gitlab integration found that matches host ${providerConfig.host}`
        );
      }
      if (!options.schedule && !providerConfig.schedule) {
        throw new Error(
          `No schedule provided neither via code nor config for GitlabDiscoveryEntityProvider:${providerConfig.id}.`
        );
      }
      const taskRunner = options.schedule ?? options.scheduler.createScheduledTaskRunner(providerConfig.schedule);
      providers.push(
        new GitlabDiscoveryEntityProvider({
          ...options,
          config: providerConfig,
          integration,
          taskRunner
        })
      );
    });
    return providers;
  }
  /**
   * Constructs a GitlabDiscoveryEntityProvider instance.
   *
   * @param options - Configuration options including config, integration, logger, and taskRunner.
   */
  constructor(options) {
    this.config = options.config;
    this.integration = options.integration;
    this.logger = options.logger.child({
      target: this.getProviderName()
    });
    this.scheduleFn = this.createScheduleFn(options.taskRunner);
    this.events = options.events;
    this.gitLabClient = new client.GitLabClient({
      config: this.integration.config,
      logger: this.logger
    });
  }
  getProviderName() {
    return `GitlabDiscoveryEntityProvider:${this.config.id}`;
  }
  async connect(connection) {
    this.connection = connection;
    await this.scheduleFn();
    if (this.events) {
      await this.events.subscribe({
        id: this.getProviderName(),
        topics: [TOPIC_REPO_PUSH],
        onEvent: async (params) => {
          if (params.topic !== TOPIC_REPO_PUSH) {
            return;
          }
          await this.onRepoPush(params.eventPayload);
        }
      });
    }
  }
  /**
   * Creates a scheduled task runner for refreshing the entity provider.
   *
   * @param taskRunner - The task runner instance.
   * @returns The scheduled function.
   */
  createScheduleFn(taskRunner) {
    return async () => {
      const taskId = `${this.getProviderName()}:refresh`;
      return taskRunner.run({
        id: taskId,
        fn: async () => {
          const logger = this.logger.child({
            class: GitlabDiscoveryEntityProvider.prototype.constructor.name,
            taskId,
            taskInstanceId: uuid__namespace.v4()
          });
          try {
            await this.refresh(logger);
          } catch (error) {
            logger.error(
              `${this.getProviderName()} refresh failed, ${error}`,
              error
            );
          }
        }
      });
    };
  }
  /**
   * Performs a full scan on the GitLab instance searching for locations to be ingested
   *
   * @param logger - The logger instance for logging.
   */
  async refresh(logger) {
    if (!this.connection) {
      throw new Error(
        `Gitlab discovery connection not initialized for ${this.getProviderName()}`
      );
    }
    const locations = await this.getEntities();
    await this.connection.applyMutation({
      type: "full",
      entities: locations.map((location) => ({
        locationKey: this.getProviderName(),
        entity: pluginCatalogNode.locationSpecToLocationEntity({ location })
      }))
    });
    logger.info(`Processed ${locations.length} locations`);
  }
  /**
   * Determine the location on GitLab to be ingested base on configured groups and filters.
   *
   * @returns A list of location to be ingested
   */
  async getEntities() {
    let res = {
      scanned: 0,
      matches: []
    };
    const groupToProcess = /* @__PURE__ */ new Map();
    let groupFilters;
    if (this.config.groupPattern !== void 0) {
      const patterns = Array.isArray(this.config.groupPattern) ? this.config.groupPattern : [this.config.groupPattern];
      if (patterns.length === 1 && patterns[0].source === "[\\s\\S]*") {
        groupFilters = new Array();
      } else {
        groupFilters = patterns;
      }
    }
    if (groupFilters && groupFilters.length > 0) {
      const groups = client.paginated(
        (options) => this.gitLabClient.listGroups(options),
        {
          page: 1,
          per_page: 50
        }
      );
      for await (const group of groups) {
        if (groupFilters.some((groupFilter) => groupFilter.test(group.full_path)) && !groupToProcess.has(group.full_path)) {
          groupToProcess.set(group.full_path, group);
        }
      }
      for (const group of groupToProcess.values()) {
        const tmpRes = await this.getProjectsToProcess(group.full_path);
        res.scanned += tmpRes.scanned;
        for (const project of tmpRes.matches) {
          res.matches.push(project);
        }
      }
    } else {
      res = await this.getProjectsToProcess(this.config.group);
    }
    const locations = this.deduplicateProjects(res.matches).map(
      (p) => this.createLocationSpec(p)
    );
    this.logger.info(
      `Processed ${locations.length} from scanned ${res.scanned} projects.`
    );
    return locations;
  }
  /**
   * Deduplicate a list of projects based on their id.
   *
   * @param projects - a list of projects to be deduplicated
   * @returns a list of projects with unique id
   */
  deduplicateProjects(projects) {
    const uniqueProjects = /* @__PURE__ */ new Map();
    for (const project of projects) {
      uniqueProjects.set(project.id, project);
    }
    return Array.from(uniqueProjects.values());
  }
  /**
   * Retrieve a list of projects that match configuration.
   *
   * @param group - a full path of a GitLab group, can be empty
   * @returns An array of project to be processed and the number of project scanned
   */
  async getProjectsToProcess(group) {
    const res = {
      scanned: 0,
      matches: []
    };
    const projects = client.paginated(
      (options) => this.gitLabClient.listProjects(options),
      {
        group,
        page: 1,
        per_page: 50,
        ...!this.config.includeArchivedRepos && { archived: false },
        ...this.config.membership && { membership: true },
        ...this.config.topics && { topics: this.config.topics },
        // Only use simple=true when we don't need to skip forked repos.
        // The simple=true parameter reduces response size by returning fewer fields,
        // but it excludes the 'forked_from_project' field which is required for fork detection.
        // Therefore, we can only optimize with simple=true when skipForkedRepos is false.
        ...!this.config.skipForkedRepos && { simple: true }
      }
    );
    for await (const project of projects) {
      res.scanned++;
      if (await this.shouldProcessProject(project, this.gitLabClient)) {
        res.matches.push(project);
      }
    }
    return res;
  }
  createLocationSpec(project) {
    const project_branch = this.config.branch ?? project.default_branch ?? this.config.fallbackBranch;
    return {
      type: "url",
      target: `${project.web_url}/-/blob/${project_branch}/${this.config.catalogFile}`,
      presence: "optional"
    };
  }
  /**
   * Handles the "gitlab.push" event.
   *
   * @param event - The push event payload.
   */
  async onRepoPush(event) {
    if (!this.connection) {
      throw new Error(
        `Gitlab discovery connection not initialized for ${this.getProviderName()}`
      );
    }
    this.logger.info(
      `Received push event for ${event.project.path_with_namespace}`
    );
    const project = await this.gitLabClient.getProjectById(event.project_id);
    if (!project) {
      this.logger.debug(
        `Ignoring push event for ${event.project.path_with_namespace}`
      );
      return;
    }
    if (!await this.shouldProcessProject(project, this.gitLabClient)) {
      this.logger.debug(`Skipping event ${event.project.path_with_namespace}`);
      return;
    }
    const added = this.getFilesMatchingConfig(
      event,
      "added",
      this.config.catalogFile
    );
    const removed = this.getFilesMatchingConfig(
      event,
      "removed",
      this.config.catalogFile
    );
    const modified = this.getFilesMatchingConfig(
      event,
      "modified",
      this.config.catalogFile
    );
    const addedEntities = this.createLocationSpecCommitedFiles(
      event.project,
      added
    );
    const removedEntities = this.createLocationSpecCommitedFiles(
      event.project,
      removed
    );
    if (addedEntities.length > 0 || removedEntities.length > 0) {
      await this.connection.applyMutation({
        type: "delta",
        added: this.toDeferredEntities(
          addedEntities.map((entity) => entity.target)
        ),
        removed: this.toDeferredEntities(
          removedEntities.map((entity) => entity.target)
        )
      });
    }
    if (modified.length > 0) {
      const projectBranch = this.config.branch ?? event.project.default_branch ?? this.config.fallbackBranch;
      await this.connection.refresh({
        keys: [
          ...modified.map(
            (filePath) => `url:${event.project.web_url}/-/tree/${projectBranch}/${filePath}`
          ),
          ...modified.map(
            (filePath) => `url:${event.project.web_url}/-/blob/${projectBranch}/${filePath}`
          )
        ]
      });
    }
    this.logger.info(
      `Processed GitLab push event from ${event.project.web_url}: added ${added.length} - removed ${removed.length} - modified ${modified.length}`
    );
  }
  /**
   * Gets files matching the specified commit action and catalog file name.
   *
   * @param event - The push event payload.
   * @param action - The action type ('added', 'removed', or 'modified').
   * @param catalogFile - The catalog file name.
   * @returns An array of file paths.
   */
  getFilesMatchingConfig(event, action, catalogFile) {
    if (!event.commits) {
      return [];
    }
    const matchingFiles = event.commits.flatMap(
      (element) => element[action].filter(
        (file) => path__namespace.basename(file) === catalogFile
      )
    );
    if (matchingFiles.length === 0) {
      this.logger.debug(
        `No files matching '${catalogFile}' found in the commits.`
      );
    }
    return matchingFiles;
  }
  /**
   * Creates Backstage location specs for committed files.
   *
   * @param project - The GitLab project information.
   * @param addedFiles - The array of added file paths.
   * @returns An array of location specs.
   */
  createLocationSpecCommitedFiles(project, addedFiles) {
    const projectBranch = this.config.branch ?? project.default_branch ?? this.config.fallbackBranch;
    const matchingFiles = addedFiles.filter(
      (file) => path__namespace.basename(file) === this.config.catalogFile
    );
    const locationSpecs = matchingFiles.map((file) => ({
      type: "url",
      target: `${project.web_url}/-/blob/${projectBranch}/${file}`,
      presence: "optional"
    }));
    return locationSpecs;
  }
  /**
   * Converts a target URL to a LocationSpec object.
   *
   * @param target - The target URL to be converted.
   * @returns The LocationSpec object representing the URL.
   */
  toLocationSpec(target) {
    return {
      type: "url",
      target,
      presence: "optional"
    };
  }
  toDeferredEntities(targets) {
    return targets.map((target) => {
      const location = this.toLocationSpec(target);
      return pluginCatalogNode.locationSpecToLocationEntity({ location });
    }).map((entity) => {
      return {
        locationKey: this.getProviderName(),
        entity
      };
    });
  }
  async shouldProcessProject(project, client) {
    if (!this.config.projectPattern.test(project.path_with_namespace ?? "")) {
      this.logger.debug(
        `Skipping project ${project.path_with_namespace} as it does not match the project pattern ${this.config.projectPattern}.`
      );
      return false;
    }
    if (this.config.group && !project.path_with_namespace.startsWith(`${this.config.group}/`)) {
      this.logger.debug(
        `Skipping project ${project.path_with_namespace} as it does not match the group pattern ${this.config.group}.`
      );
      return false;
    }
    if (this.config.skipForkedRepos && project.hasOwnProperty("forked_from_project")) {
      this.logger.debug(
        `Skipping project ${project.path_with_namespace} as it is a forked project.`
      );
      return false;
    }
    if (this.config.excludeRepos?.includes(project.path_with_namespace ?? "")) {
      this.logger.debug(
        `Skipping project ${project.path_with_namespace} as it is excluded.`
      );
      return false;
    }
    const project_branch = this.config.branch ?? project.default_branch ?? this.config.fallbackBranch;
    const hasFile = await client.hasFile(
      project.path_with_namespace ?? "",
      project_branch,
      this.config.catalogFile
    );
    return hasFile;
  }
}

exports.GitlabDiscoveryEntityProvider = GitlabDiscoveryEntityProvider;
//# sourceMappingURL=GitlabDiscoveryEntityProvider.cjs.js.map
