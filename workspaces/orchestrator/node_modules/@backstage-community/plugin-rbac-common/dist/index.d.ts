import { NotAllowedError } from '@backstage/errors';
import { PermissionAttributes, ConditionalPolicyDecision, ResourcePermission } from '@backstage/plugin-permission-common';

type Source = string;
type PermissionPolicyMetadata = {
    source: Source;
};
type RoleMetadata = {
    description?: string;
    source?: Source;
    modifiedBy?: string;
    author?: string;
    lastModified?: string;
    createdAt?: string;
};
type Policy = {
    permission?: string;
    policy?: string;
};
type RoleBasedPolicy = Policy & {
    entityReference?: string;
    effect?: string;
    metadata?: PermissionPolicyMetadata;
};
type Role = {
    memberReferences: string[];
    name: string;
    metadata?: RoleMetadata;
};
type UpdatePolicy = {
    oldPolicy: Policy;
    newPolicy: Policy;
};
type NamedPolicy = {
    name: string;
    policy: string;
};
type ResourcedPolicy = NamedPolicy & {
    resourceType: string;
};
type PolicyDetails = NamedPolicy | ResourcedPolicy;
declare function isResourcedPolicy(policy: PolicyDetails): policy is ResourcedPolicy;
type PluginPermissionMetaData = {
    pluginId: string;
    policies: PolicyDetails[];
};
type NonEmptyArray<T> = [T, ...T[]];
declare const PermissionActionValues: readonly ["create", "read", "update", "delete", "use"];
type PermissionAction = (typeof PermissionActionValues)[number];
declare const toPermissionAction: (attr: PermissionAttributes) => PermissionAction;
declare function isValidPermissionAction(action: string): action is PermissionAction;
type PermissionInfo = {
    name: string;
    action: PermissionAction;
};
type RoleConditionalPolicyDecision<T extends PermissionAction | PermissionInfo> = ConditionalPolicyDecision & {
    id: number;
    roleEntityRef: string;
    permissionMapping: T[];
};
declare const ConditionalAliases: {
    readonly CURRENT_USER: "currentUser";
    readonly OWNER_REFS: "ownerRefs";
};
declare const CONDITION_ALIAS_SIGN = "$";
declare class UnauthorizedError extends NotAllowedError {
    constructor();
}

declare const RESOURCE_TYPE_POLICY_ENTITY = "policy-entity";
/**
 * Convenience type for permission entity
 */
type PolicyEntityPermission = ResourcePermission<typeof RESOURCE_TYPE_POLICY_ENTITY>;
/**
 * This permission is used to authorize actions that involve reading
 * permission policies.
 */
declare const policyEntityReadPermission: ResourcePermission<"policy-entity">;
/**
 * This permission is used to authorize the creation of new permission policies.
 */
declare const policyEntityCreatePermission: ResourcePermission<"policy-entity">;
/**
 * This permission is used to authorize actions that involve removing permission
 * policies.
 */
declare const policyEntityDeletePermission: ResourcePermission<"policy-entity">;
/**
 * This permission is used to authorize updating permission policies
 */
declare const policyEntityUpdatePermission: ResourcePermission<"policy-entity">;
/**
 * List of all permissions on permission polices.
 */
declare const policyEntityPermissions: ResourcePermission<"policy-entity">[];

export { CONDITION_ALIAS_SIGN, ConditionalAliases, type NamedPolicy, type NonEmptyArray, type PermissionAction, PermissionActionValues, type PermissionInfo, type PermissionPolicyMetadata, type PluginPermissionMetaData, type Policy, type PolicyDetails, type PolicyEntityPermission, RESOURCE_TYPE_POLICY_ENTITY, type ResourcedPolicy, type Role, type RoleBasedPolicy, type RoleConditionalPolicyDecision, type RoleMetadata, type Source, UnauthorizedError, type UpdatePolicy, isResourcedPolicy, isValidPermissionAction, policyEntityCreatePermission, policyEntityDeletePermission, policyEntityPermissions, policyEntityReadPermission, policyEntityUpdatePermission, toPermissionAction };
