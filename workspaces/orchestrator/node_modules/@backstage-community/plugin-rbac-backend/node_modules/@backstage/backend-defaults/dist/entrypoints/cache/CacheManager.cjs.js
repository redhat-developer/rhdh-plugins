'use strict';

var Keyv = require('keyv');
var CacheClient = require('./CacheClient.cjs.js');
var types$1 = require('./types.cjs.js');
var types = require('@backstage/types');
var config = require('@backstage/config');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var Keyv__default = /*#__PURE__*/_interopDefaultCompat(Keyv);

class CacheManager {
  /**
   * Keys represent supported `backend.cache.store` values, mapped to factories
   * that return Keyv instances appropriate to the store.
   */
  storeFactories = {
    redis: this.createRedisStoreFactory(),
    memcache: this.createMemcacheStoreFactory(),
    memory: this.createMemoryStoreFactory()
  };
  logger;
  store;
  connection;
  useRedisSets;
  errorHandler;
  defaultTtl;
  /**
   * Creates a new {@link CacheManager} instance by reading from the `backend`
   * config section, specifically the `.cache` key.
   *
   * @param config - The loaded application configuration.
   */
  static fromConfig(config$1, options = {}) {
    const store = config$1.getOptionalString("backend.cache.store") || "memory";
    const defaultTtlConfig = config$1.getOptional("backend.cache.defaultTtl");
    const connectionString = config$1.getOptionalString("backend.cache.connection") || "";
    const useRedisSets = config$1.getOptionalBoolean("backend.cache.useRedisSets") ?? true;
    const logger = options.logger?.child({
      type: "cacheManager"
    });
    let defaultTtl;
    if (defaultTtlConfig !== void 0) {
      if (typeof defaultTtlConfig === "number") {
        defaultTtl = defaultTtlConfig;
      } else {
        defaultTtl = types.durationToMilliseconds(
          config.readDurationFromConfig(config$1, { key: "backend.cache.defaultTtl" })
        );
      }
    }
    return new CacheManager(
      store,
      connectionString,
      useRedisSets,
      options.onError,
      logger,
      defaultTtl
    );
  }
  /** @internal */
  constructor(store, connectionString, useRedisSets, errorHandler, logger, defaultTtl) {
    if (!this.storeFactories.hasOwnProperty(store)) {
      throw new Error(`Unknown cache store: ${store}`);
    }
    this.logger = logger;
    this.store = store;
    this.connection = connectionString;
    this.useRedisSets = useRedisSets;
    this.errorHandler = errorHandler;
    this.defaultTtl = defaultTtl;
  }
  /**
   * Generates a PluginCacheManager for consumption by plugins.
   *
   * @param pluginId - The plugin that the cache manager should be created for.
   *        Plugin names should be unique.
   */
  forPlugin(pluginId) {
    const clientFactory = (options) => {
      const ttl = options.defaultTtl ?? this.defaultTtl;
      return this.getClientWithTtl(
        pluginId,
        ttl !== void 0 ? types$1.ttlToMilliseconds(ttl) : void 0
      );
    };
    return new CacheClient.DefaultCacheClient(clientFactory({}), clientFactory, {});
  }
  getClientWithTtl(pluginId, ttl) {
    return this.storeFactories[this.store](pluginId, ttl);
  }
  createRedisStoreFactory() {
    const KeyvRedis = require("@keyv/redis");
    let store;
    return (pluginId, defaultTtl) => {
      if (!store) {
        store = new KeyvRedis(this.connection, {
          useRedisSets: this.useRedisSets
        });
        store.on("error", (err) => {
          this.logger?.error("Failed to create redis cache client", err);
          this.errorHandler?.(err);
        });
      }
      return new Keyv__default.default({
        namespace: pluginId,
        ttl: defaultTtl,
        store,
        emitErrors: false,
        useRedisSets: this.useRedisSets
      });
    };
  }
  createMemcacheStoreFactory() {
    const KeyvMemcache = require("@keyv/memcache");
    let store;
    return (pluginId, defaultTtl) => {
      if (!store) {
        store = new KeyvMemcache(this.connection);
        store.on("error", (err) => {
          this.logger?.error("Failed to create memcache cache client", err);
          this.errorHandler?.(err);
        });
      }
      return new Keyv__default.default({
        namespace: pluginId,
        ttl: defaultTtl,
        emitErrors: false,
        store
      });
    };
  }
  createMemoryStoreFactory() {
    const store = /* @__PURE__ */ new Map();
    return (pluginId, defaultTtl) => new Keyv__default.default({
      namespace: pluginId,
      ttl: defaultTtl,
      emitErrors: false,
      store
    });
  }
}

exports.CacheManager = CacheManager;
//# sourceMappingURL=CacheManager.cjs.js.map
