'use strict';

var urlReader = require('@backstage/backend-defaults/urlReader');
var errors = require('@backstage/errors');
var pluginPermissionCommon = require('@backstage/plugin-permission-common');

class PluginPermissionMetadataCollector {
  pluginIds;
  discovery;
  logger;
  urlReader;
  constructor({
    deps,
    optional
  }) {
    const { discovery, pluginIdProvider, logger, config } = deps;
    this.pluginIds = pluginIdProvider.getPluginIds();
    this.discovery = discovery;
    this.logger = logger;
    this.urlReader = optional?.urlReader ?? urlReader.UrlReaders.default({
      config,
      logger,
      factories: [PluginPermissionMetadataCollector.permissionFactory]
    });
  }
  async getPluginConditionRules(auth) {
    const pluginMetadata = await this.getPluginMetaData(auth);
    return pluginMetadata.filter((metadata) => metadata.metaDataResponse.rules.length > 0).map((metadata) => {
      return {
        pluginId: metadata.pluginId,
        rules: metadata.metaDataResponse.rules
      };
    });
  }
  async getPluginPolicies(auth) {
    const pluginMetadata = await this.getPluginMetaData(auth);
    return pluginMetadata.filter((metadata) => metadata.metaDataResponse.permissions !== void 0).map((metadata) => {
      return {
        pluginId: metadata.pluginId,
        policies: permissionsToCasbinPolicies(
          metadata.metaDataResponse.permissions
        )
      };
    });
  }
  static permissionFactory = () => {
    return [{ reader: new urlReader.FetchUrlReader(), predicate: (_url) => true }];
  };
  async getPluginMetaData(auth) {
    let pluginResponses = [];
    for (const pluginId of this.pluginIds) {
      try {
        const { token } = await auth.getPluginRequestToken({
          onBehalfOf: await auth.getOwnServiceCredentials(),
          targetPluginId: pluginId
        });
        const permMetaData = await this.getMetadataByPluginId(pluginId, token);
        if (permMetaData) {
          pluginResponses = [
            ...pluginResponses,
            {
              metaDataResponse: permMetaData,
              pluginId
            }
          ];
        }
      } catch (error) {
        this.logger.error(
          `Failed to retrieve permission metadata for ${pluginId}. ${error}`
        );
      }
    }
    return pluginResponses;
  }
  async getMetadataByPluginId(pluginId, token) {
    let permMetaData;
    try {
      const baseEndpoint = await this.discovery.getBaseUrl(pluginId);
      const wellKnownURL = `${baseEndpoint}/.well-known/backstage/permissions/metadata`;
      const permResp = await this.urlReader.readUrl(wellKnownURL, { token });
      const permMetaDataRaw = (await permResp.buffer()).toString();
      try {
        permMetaData = JSON.parse(permMetaDataRaw);
      } catch (err) {
        return void 0;
      }
    } catch (err) {
      if (errors.isError(err) && err.name === "NotFoundError") {
        this.logger.warn(
          `No permission metadata found for ${pluginId}. ${err}`
        );
        return void 0;
      }
      this.logger.error(
        `Failed to retrieve permission metadata for ${pluginId}. ${err}`
      );
    }
    return permMetaData;
  }
}
function permissionsToCasbinPolicies(permissions) {
  const policies = [];
  for (const permission of permissions) {
    if (pluginPermissionCommon.isResourcePermission(permission)) {
      policies.push({
        resourceType: permission.resourceType,
        name: permission.name,
        policy: permission.attributes.action || "use"
      });
    } else {
      policies.push({
        name: permission.name,
        policy: permission.attributes.action || "use"
      });
    }
  }
  return policies;
}

exports.PluginPermissionMetadataCollector = PluginPermissionMetadataCollector;
//# sourceMappingURL=plugin-endpoints.cjs.js.map
