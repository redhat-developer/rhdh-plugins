'use strict';

var auditLogger = require('../audit-log/audit-logger.cjs.js');
var helper = require('../helper.cjs.js');
var policiesValidation = require('../validation/policies-validation.cjs.js');

const ADMIN_ROLE_NAME = "role:default/rbac_admin";
const ADMIN_ROLE_AUTHOR = "application configuration";
const DEF_ADMIN_ROLE_DESCRIPTION = "The default permission policy for the admin role allows for the creation, deletion, updating, and reading of roles and permission policies.";
const getAdminRoleMetadata = () => {
  const currentDate = /* @__PURE__ */ new Date();
  return {
    source: "configuration",
    roleEntityRef: ADMIN_ROLE_NAME,
    description: DEF_ADMIN_ROLE_DESCRIPTION,
    author: ADMIN_ROLE_AUTHOR,
    modifiedBy: ADMIN_ROLE_AUTHOR,
    lastModified: currentDate.toUTCString(),
    createdAt: currentDate.toUTCString()
  };
};
const useAdminsFromConfig = async (admins, enf, auditLogger$1, roleMetadataStorage, knex) => {
  const addedGroupPolicies = /* @__PURE__ */ new Map();
  const newGroupPolicies = /* @__PURE__ */ new Map();
  for (const admin of admins) {
    const entityRef = admin.getString("name");
    policiesValidation.validateEntityReference(entityRef);
    addedGroupPolicies.set(entityRef, ADMIN_ROLE_NAME);
    if (!await enf.hasGroupingPolicy(...[entityRef, ADMIN_ROLE_NAME])) {
      newGroupPolicies.set(entityRef, ADMIN_ROLE_NAME);
    }
  }
  const adminRoleMeta = await roleMetadataStorage.findRoleMetadata(ADMIN_ROLE_NAME);
  const trx = await knex.transaction();
  let addedRoleMembers;
  try {
    if (!adminRoleMeta) {
      await roleMetadataStorage.createRoleMetadata(getAdminRoleMetadata(), trx);
    } else if (adminRoleMeta.source === "legacy") {
      await roleMetadataStorage.updateRoleMetadata(
        getAdminRoleMetadata(),
        ADMIN_ROLE_NAME,
        trx
      );
    }
    addedRoleMembers = Array.from(newGroupPolicies.entries());
    await enf.addGroupingPolicies(
      addedRoleMembers,
      getAdminRoleMetadata(),
      trx
    );
    await trx.commit();
  } catch (error) {
    await trx.rollback(error);
    throw error;
  }
  await auditLogger$1.auditLog({
    actorId: auditLogger.RBAC_BACKEND,
    message: `Created or updated role`,
    eventName: auditLogger.RoleEvents.CREATE_OR_UPDATE_ROLE,
    metadata: {
      ...getAdminRoleMetadata(),
      members: addedRoleMembers.map((gp) => gp[0])
    },
    stage: auditLogger.HANDLE_RBAC_DATA_STAGE,
    status: "succeeded"
  });
  const configGroupPolicies = await enf.getFilteredGroupingPolicy(
    1,
    ADMIN_ROLE_NAME
  );
  await helper.removeTheDifference(
    configGroupPolicies.map((gp) => gp[0]),
    Array.from(addedGroupPolicies.keys()),
    "configuration",
    ADMIN_ROLE_NAME,
    enf,
    auditLogger$1,
    ADMIN_ROLE_AUTHOR
  );
};
const addAdminPermissions = async (policies, enf, auditLogger$1) => {
  const policiesToAdd = [];
  for (const policy of policies) {
    if (!await enf.hasPolicy(...policy)) {
      policiesToAdd.push(policy);
    }
  }
  await enf.addPolicies(policiesToAdd);
  await auditLogger$1.auditLog({
    actorId: auditLogger.RBAC_BACKEND,
    message: `Created RBAC admin permissions`,
    eventName: auditLogger.PermissionEvents.CREATE_POLICY,
    metadata: { policies, source: "configuration" },
    stage: auditLogger.HANDLE_RBAC_DATA_STAGE,
    status: "succeeded"
  });
};
const setAdminPermissions = async (enf, auditLogger) => {
  const adminPermissions = [
    [ADMIN_ROLE_NAME, "policy-entity", "read", "allow"],
    [ADMIN_ROLE_NAME, "policy-entity", "create", "allow"],
    [ADMIN_ROLE_NAME, "policy-entity", "delete", "allow"],
    [ADMIN_ROLE_NAME, "policy-entity", "update", "allow"],
    // Needed for the RBAC frontend plugin.
    [ADMIN_ROLE_NAME, "catalog-entity", "read", "allow"]
  ];
  await addAdminPermissions(adminPermissions, enf, auditLogger);
};

exports.ADMIN_ROLE_AUTHOR = ADMIN_ROLE_AUTHOR;
exports.ADMIN_ROLE_NAME = ADMIN_ROLE_NAME;
exports.setAdminPermissions = setAdminPermissions;
exports.useAdminsFromConfig = useAdminsFromConfig;
//# sourceMappingURL=admin-creation.cjs.js.map
