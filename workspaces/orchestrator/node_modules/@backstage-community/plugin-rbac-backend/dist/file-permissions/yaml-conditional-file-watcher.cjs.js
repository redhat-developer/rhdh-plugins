'use strict';

var yaml = require('js-yaml');
var lodash = require('lodash');
var fs = require('fs');
var auditLogger = require('../audit-log/audit-logger.cjs.js');
var helper = require('../helper.cjs.js');
var conditionValidation = require('../validation/condition-validation.cjs.js');
var fileWatcher = require('./file-watcher.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var yaml__default = /*#__PURE__*/_interopDefaultCompat(yaml);
var fs__default = /*#__PURE__*/_interopDefaultCompat(fs);

class YamlConditinalPoliciesFileWatcher extends fileWatcher.AbstractFileWatcher {
  constructor(filePath, allowReload, logger, conditionalStorage, auditLogger, auth, pluginMetadataCollector, roleMetadataStorage, roleEventEmitter) {
    super(filePath, allowReload, logger);
    this.conditionalStorage = conditionalStorage;
    this.auditLogger = auditLogger;
    this.auth = auth;
    this.pluginMetadataCollector = pluginMetadataCollector;
    this.roleMetadataStorage = roleMetadataStorage;
    this.roleEventEmitter = roleEventEmitter;
    this.conditionsDiff = {
      addedConditions: [],
      removedConditions: []
    };
  }
  conditionsDiff;
  async initialize() {
    if (!this.filePath) {
      return;
    }
    const fileExists = fs__default.default.existsSync(this.filePath);
    if (!fileExists) {
      const err = new Error(`File '${this.filePath}' was not found`);
      this.handleError(
        err.message,
        err,
        auditLogger.ConditionEvents.CONDITIONAL_POLICIES_FILE_NOT_FOUND
      );
      return;
    }
    this.roleEventEmitter.on("roleAdded", this.onChange.bind(this));
    await this.onChange();
    if (this.allowReload) {
      this.watchFile();
    }
  }
  async onChange() {
    try {
      const newConds = this.parse().filter((c) => c);
      const addedConds = [];
      const removedConds = [];
      const csvFileRoles = await this.roleMetadataStorage.filterRoleMetadata("csv-file");
      const existedFileConds = (await this.conditionalStorage.filterConditions(
        csvFileRoles.map((role) => role.roleEntityRef)
      )).map((condition) => {
        return {
          ...condition,
          permissionMapping: condition.permissionMapping.map((pm) => pm.action)
        };
      });
      for (const condition of newConds) {
        const roleMetadata = csvFileRoles.find(
          (role) => condition.roleEntityRef === role.roleEntityRef
        );
        if (!roleMetadata) {
          this.logger.warn(
            `skip to add condition for role '${condition.roleEntityRef}'. The role either does not exist or was not created from a CSV file.`
          );
          continue;
        }
        if (roleMetadata.source !== "csv-file") {
          this.logger.warn(
            `skip to add condition for role '${condition.roleEntityRef}'. Role is not from csv-file`
          );
          continue;
        }
        const existingCondition = existedFileConds.find(
          (c) => helper.deepSortEqual(lodash.omit(c, ["id"]), lodash.omit(condition, ["id"]))
        );
        if (!existingCondition) {
          addedConds.push(condition);
        }
      }
      for (const condition of existedFileConds) {
        if (!newConds.find(
          (c) => helper.deepSortEqual(lodash.omit(c, ["id"]), lodash.omit(condition, ["id"]))
        )) {
          removedConds.push(condition);
        }
      }
      this.conditionsDiff = {
        addedConditions: addedConds,
        removedConditions: removedConds
      };
      await this.handleFileChanges();
    } catch (error) {
      await this.handleError(
        `Error handling changes from conditional policies file ${this.filePath}`,
        error,
        auditLogger.ConditionEvents.CHANGE_CONDITIONAL_POLICIES_FILE_ERROR
      );
    }
  }
  /**
   * Reads the current contents of the file and parses it.
   * @returns parsed data.
   */
  parse() {
    const fileContents = this.getCurrentContents();
    const data = yaml__default.default.loadAll(
      fileContents
    );
    for (const condition of data) {
      conditionValidation.validateRoleCondition(condition);
    }
    return data;
  }
  async handleFileChanges() {
    await this.removeConditions();
    await this.addConditions();
  }
  async addConditions() {
    try {
      for (const condition of this.conditionsDiff.addedConditions) {
        const conditionToCreate = await helper.processConditionMapping(
          condition,
          this.pluginMetadataCollector,
          this.auth
        );
        await this.conditionalStorage.createCondition(conditionToCreate);
        await this.auditLogger.auditLog({
          message: `Created conditional permission policy`,
          eventName: auditLogger.ConditionEvents.CREATE_CONDITION,
          metadata: { condition },
          stage: auditLogger.HANDLE_RBAC_DATA_STAGE,
          status: "succeeded"
        });
      }
    } catch (error) {
      await this.handleError(
        "Failed to create condition",
        error,
        auditLogger.ConditionEvents.CREATE_CONDITION_ERROR
      );
    }
    this.conditionsDiff.addedConditions = [];
  }
  async removeConditions() {
    try {
      for (const condition of this.conditionsDiff.removedConditions) {
        const conditionToDelete = (await this.conditionalStorage.filterConditions(
          condition.roleEntityRef,
          condition.pluginId,
          condition.resourceType,
          condition.permissionMapping
        ))[0];
        await this.conditionalStorage.deleteCondition(conditionToDelete.id);
        await this.auditLogger.auditLog({
          message: `Deleted conditional permission policy`,
          eventName: auditLogger.ConditionEvents.DELETE_CONDITION,
          metadata: { condition },
          stage: auditLogger.HANDLE_RBAC_DATA_STAGE,
          status: "succeeded"
        });
      }
    } catch (error) {
      await this.handleError(
        "Failed to delete condition by id",
        error,
        auditLogger.ConditionEvents.DELETE_CONDITION_ERROR
      );
    }
    this.conditionsDiff.removedConditions = [];
  }
  async handleError(message, error, event) {
    await this.auditLogger.auditLog({
      message,
      eventName: event,
      stage: auditLogger.HANDLE_RBAC_DATA_STAGE,
      status: "failed",
      errors: [error]
    });
  }
  async cleanUpConditionalPolicies() {
    const csvFileRoles = await this.roleMetadataStorage.filterRoleMetadata("csv-file");
    const existedFileConds = (await this.conditionalStorage.filterConditions(
      csvFileRoles.map((role) => role.roleEntityRef)
    )).map((condition) => {
      return {
        ...condition,
        permissionMapping: condition.permissionMapping.map((pm) => pm.action)
      };
    });
    this.conditionsDiff.removedConditions = existedFileConds;
    await this.removeConditions();
  }
}

exports.YamlConditinalPoliciesFileWatcher = YamlConditinalPoliciesFileWatcher;
//# sourceMappingURL=yaml-conditional-file-watcher.cjs.js.map
