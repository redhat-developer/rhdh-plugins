'use strict';

var casbin = require('casbin');
var sync = require('csv-parse/sync');
var lodash = require('lodash');
var auditLogger = require('../audit-log/audit-logger.cjs.js');
var helper = require('../helper.cjs.js');
var permissionModel = require('../service/permission-model.cjs.js');
var policiesValidation = require('../validation/policies-validation.cjs.js');
var fileWatcher = require('./file-watcher.cjs.js');

const CSV_PERMISSION_POLICY_FILE_AUTHOR = "csv permission policy file";
class CSVFileWatcher extends fileWatcher.AbstractFileWatcher {
  constructor(filePath, allowReload, logger, enforcer, roleMetadataStorage, auditLogger) {
    super(filePath, allowReload, logger);
    this.enforcer = enforcer;
    this.roleMetadataStorage = roleMetadataStorage;
    this.auditLogger = auditLogger;
    this.currentContent = [];
    this.csvFilePolicies = {
      addedPolicies: [],
      addedGroupPolicies: [],
      removedPolicies: [],
      removedGroupPolicies: []
    };
  }
  currentContent;
  csvFilePolicies;
  /**
   * parse is used to parse the current contents of the CSV file.
   * @returns The CSV file parsed into a string[][].
   */
  parse() {
    const content = this.getCurrentContents();
    const parser = sync.parse(content, {
      skip_empty_lines: true,
      relax_column_count: true,
      trim: true
    });
    return parser;
  }
  /**
   * initialize will initialize the CSV file by loading all of the permission policies and roles into
   * the enforcer.
   * First, we will remove all roles and permission policies if they do not exist in the temporary file enforcer.
   * Next, we will add all roles and permission polices if they are new to the CSV file
   * Finally, we will set the file to be watched if allow reload is set
   * @param csvFileName The name of the csvFile
   * @param allowReload Whether or not we will allow reloads of the CSV file
   */
  async initialize() {
    if (!this.filePath) {
      return;
    }
    let content = [];
    content = this.parse();
    const tempEnforcer = await casbin.newEnforcer(
      casbin.newModelFromString(permissionModel.MODEL),
      new casbin.FileAdapter(this.filePath)
    );
    await this.cleanUpRolesAndPolicies();
    const policiesToAdd = await tempEnforcer.getPolicy();
    const groupPoliciesToAdd = await tempEnforcer.getGroupingPolicy();
    for (const policy of policiesToAdd) {
      if (!await this.enforcer.hasPolicy(...policy)) {
        this.csvFilePolicies.addedPolicies.push(policy);
      }
    }
    for (const groupPolicy of groupPoliciesToAdd) {
      if (!await this.enforcer.hasGroupingPolicy(...groupPolicy)) {
        this.csvFilePolicies.addedGroupPolicies.push(groupPolicy);
      }
    }
    await this.migrateLegacyMetadata(tempEnforcer);
    await this.updatePolicies(content, tempEnforcer);
    if (this.allowReload) {
      this.watchFile();
    }
  }
  // Check for policies that might need to be updated
  // This will involve update "legacy" source in the role metadata if it exist in both the
  // temp enforcer (csv file) and a role metadata storage.
  // We will update role metadata with the new source "csv-file"
  async migrateLegacyMetadata(tempEnforcer) {
    let legacyRolesMetadata = await this.roleMetadataStorage.filterRoleMetadata("legacy");
    const legacyRoles = legacyRolesMetadata.map((meta) => meta.roleEntityRef);
    if (legacyRoles.length > 0) {
      const legacyGroupPolicies = await tempEnforcer.getFilteredGroupingPolicy(
        1,
        ...legacyRoles
      );
      const legacyPolicies = await tempEnforcer.getFilteredPolicy(
        0,
        ...legacyRoles
      );
      const legacyRolesFromFile = /* @__PURE__ */ new Set([
        ...legacyGroupPolicies.map((gp) => gp[1]),
        ...legacyPolicies.map((p) => p[0])
      ]);
      legacyRolesMetadata = legacyRolesMetadata.filter(
        (meta) => legacyRolesFromFile.has(meta.roleEntityRef)
      );
      for (const legacyRoleMeta of legacyRolesMetadata) {
        const nonLegacyRole = helper.mergeRoleMetadata(legacyRoleMeta, {
          modifiedBy: CSV_PERMISSION_POLICY_FILE_AUTHOR,
          source: "csv-file",
          roleEntityRef: legacyRoleMeta.roleEntityRef
        });
        await this.roleMetadataStorage.updateRoleMetadata(
          nonLegacyRole,
          legacyRoleMeta.roleEntityRef
        );
      }
    }
  }
  /**
   * onChange is called whenever there is a change to the CSV file.
   * It will parse the current and new contents of the CSV file and process the roles and permission policies present.
   * Afterwards, it will find the difference between the current and new contents of the CSV file
   * and sort them into added / removed, permission policies / roles.
   * It will finally call updatePolicies with the new content.
   */
  async onChange() {
    const newContent = this.parse();
    const tempEnforcer = await casbin.newEnforcer(
      casbin.newModelFromString(permissionModel.MODEL),
      new casbin.FileAdapter(this.filePath)
    );
    const currentFlatContent = this.currentContent.flatMap((data) => {
      return helper.policyToString(data);
    });
    const newFlatContent = newContent.flatMap((data) => {
      return helper.policyToString(data);
    });
    const diffRemoved = lodash.difference(currentFlatContent, newFlatContent);
    const diffAdded = lodash.difference(newFlatContent, currentFlatContent);
    await this.migrateLegacyMetadata(tempEnforcer);
    if (diffRemoved.length === 0 && diffAdded.length === 0) {
      return;
    }
    diffRemoved.forEach((policy) => {
      const convertedPolicy = helper.metadataStringToPolicy(policy);
      if (convertedPolicy[0] === "p") {
        convertedPolicy.splice(0, 1);
        this.csvFilePolicies.removedPolicies.push(convertedPolicy);
      } else if (convertedPolicy[0] === "g") {
        convertedPolicy.splice(0, 1);
        this.csvFilePolicies.removedGroupPolicies.push(convertedPolicy);
      }
    });
    diffAdded.forEach((policy) => {
      const convertedPolicy = helper.metadataStringToPolicy(policy);
      if (convertedPolicy[0] === "p") {
        convertedPolicy.splice(0, 1);
        this.csvFilePolicies.addedPolicies.push(convertedPolicy);
      } else if (convertedPolicy[0] === "g") {
        convertedPolicy.splice(0, 1);
        this.csvFilePolicies.addedGroupPolicies.push(convertedPolicy);
      }
    });
    await this.updatePolicies(newContent, tempEnforcer);
  }
  /**
   * updatePolicies is used to update all of the permission policies and roles within a CSV file.
   * It will check the number of added and removed permissions policies and roles and call the appropriate
   * methods for these.
   * It will also update the current contents of the CSV file to the most recent
   * @param newContent The new content present in the CSV file
   * @param tempEnforcer Temporary enforcer for checking for duplicates when adding policies
   */
  async updatePolicies(newContent, tempEnforcer) {
    this.currentContent = newContent;
    if (this.csvFilePolicies.addedPolicies.length > 0)
      await this.addPermissionPolicies(tempEnforcer);
    if (this.csvFilePolicies.removedPolicies.length > 0)
      await this.removePermissionPolicies();
    if (this.csvFilePolicies.addedGroupPolicies.length > 0)
      await this.addRoles(tempEnforcer);
    if (this.csvFilePolicies.removedGroupPolicies.length > 0)
      await this.removeRoles();
  }
  /**
   * addPermissionPolicies will add the new permission policies that are present in the CSV file.
   * We will attempt to validate the permission policy and log any warnings that are encountered.
   * If a warning is encountered, we will skip adding the permission policy to the enforcer.
   * @param tempEnforcer Temporary enforcer for checking for duplicates when adding policies
   */
  async addPermissionPolicies(tempEnforcer) {
    for (const policy of this.csvFilePolicies.addedPolicies) {
      const transformedPolicy = helper.transformArrayToPolicy(policy);
      const metadata = await this.roleMetadataStorage.findRoleMetadata(
        policy[0]
      );
      let err = policiesValidation.validatePolicy(transformedPolicy);
      if (err) {
        this.logger.warn(
          `Failed to validate policy from file ${this.filePath}. Cause: ${err.message}`
        );
        continue;
      }
      err = await policiesValidation.validateSource("csv-file", metadata);
      if (err) {
        this.logger.warn(
          `Unable to add policy ${policy} from file ${this.filePath}. Cause: ${err.message}`
        );
        continue;
      }
      err = await policiesValidation.checkForDuplicatePolicies(
        tempEnforcer,
        policy,
        this.filePath
      );
      if (err) {
        this.logger.warn(err.message);
        continue;
      }
      try {
        await this.enforcer.addPolicy(policy);
        await this.auditLogger.auditLog({
          actorId: auditLogger.RBAC_BACKEND,
          message: `Created policy`,
          eventName: auditLogger.PermissionEvents.CREATE_POLICY,
          metadata: { policies: [policy], source: "csv-file" },
          stage: auditLogger.HANDLE_RBAC_DATA_STAGE,
          status: "succeeded"
        });
      } catch (e) {
        this.logger.warn(
          `Failed to add or update policy ${policy} after modification ${this.filePath}. Cause: ${e}`
        );
      }
    }
    this.csvFilePolicies.addedPolicies = [];
  }
  /**
   * removePermissionPolicies will remove the permission policies that are no longer present in the CSV file.
   */
  async removePermissionPolicies() {
    try {
      await this.enforcer.removePolicies(this.csvFilePolicies.removedPolicies);
      await this.auditLogger.auditLog({
        actorId: auditLogger.RBAC_BACKEND,
        message: `Deleted policies`,
        eventName: auditLogger.PermissionEvents.DELETE_POLICY,
        metadata: {
          policies: this.csvFilePolicies.removedPolicies,
          source: "csv-file"
        },
        stage: auditLogger.HANDLE_RBAC_DATA_STAGE,
        status: "succeeded"
      });
    } catch (e) {
      this.logger.warn(
        `Failed to remove policies ${JSON.stringify(
          this.csvFilePolicies.removedPolicies
        )} after modification ${this.filePath}. Cause: ${e}`
      );
    }
    this.csvFilePolicies.removedPolicies = [];
  }
  /**
   * addRoles will add the new roles that are present in the CSV file.
   * We will attempt to validate the role and log any warnings that are encountered.
   * If a warning is encountered, we will skip adding the role to the enforcer.
   * @param tempEnforcer Temporary enforcer for checking for duplicates when adding policies
   */
  async addRoles(tempEnforcer) {
    for (const groupPolicy of this.csvFilePolicies.addedGroupPolicies) {
      let err = await policiesValidation.validateGroupingPolicy(
        groupPolicy,
        this.roleMetadataStorage,
        "csv-file"
      );
      if (err) {
        this.logger.warn(
          `${err.message}, error originates from file ${this.filePath}`
        );
        continue;
      }
      err = await policiesValidation.checkForDuplicateGroupPolicies(
        tempEnforcer,
        groupPolicy,
        this.filePath
      );
      if (err) {
        this.logger.warn(err.message);
        continue;
      }
      try {
        const roleMetadata = {
          source: "csv-file",
          roleEntityRef: groupPolicy[1],
          author: CSV_PERMISSION_POLICY_FILE_AUTHOR,
          modifiedBy: CSV_PERMISSION_POLICY_FILE_AUTHOR
        };
        const currentMetadata = await this.roleMetadataStorage.findRoleMetadata(
          roleMetadata.roleEntityRef
        );
        await this.enforcer.addGroupingPolicy(groupPolicy, roleMetadata);
        const eventName = currentMetadata ? auditLogger.RoleEvents.UPDATE_ROLE : auditLogger.RoleEvents.CREATE_ROLE;
        const message = currentMetadata ? "Updated role" : "Created role";
        await this.auditLogger.auditLog({
          actorId: auditLogger.RBAC_BACKEND,
          message,
          eventName,
          metadata: { ...roleMetadata, members: [groupPolicy[0]] },
          stage: auditLogger.HANDLE_RBAC_DATA_STAGE,
          status: "succeeded"
        });
      } catch (e) {
        this.logger.warn(
          `Failed to add or update group policy ${groupPolicy} after modification ${this.filePath}. Cause: ${e}`
        );
      }
    }
    this.csvFilePolicies.addedGroupPolicies = [];
  }
  /**
   * removeRoles will remove the roles that are no longer present in the CSV file.
   * If the role exists with multiple groups and or users, we will update it role information.
   * Otherwise, we will remove the role completely.
   */
  async removeRoles() {
    for (const groupPolicy of this.csvFilePolicies.removedGroupPolicies) {
      const roleEntityRef = groupPolicy[1];
      const isUpdate = await this.enforcer.getFilteredGroupingPolicy(
        1,
        roleEntityRef
      );
      try {
        const metadata = {
          source: "csv-file",
          roleEntityRef,
          author: CSV_PERMISSION_POLICY_FILE_AUTHOR,
          modifiedBy: CSV_PERMISSION_POLICY_FILE_AUTHOR
        };
        await this.enforcer.removeGroupingPolicy(
          groupPolicy,
          metadata,
          isUpdate.length > 1
        );
        const isRolePresent = await this.roleMetadataStorage.findRoleMetadata(roleEntityRef);
        const eventName = isRolePresent ? auditLogger.RoleEvents.UPDATE_ROLE : auditLogger.RoleEvents.DELETE_ROLE;
        const message = isRolePresent ? "Updated role: deleted members" : "Deleted role";
        await this.auditLogger.auditLog({
          actorId: auditLogger.RBAC_BACKEND,
          message,
          eventName,
          metadata: { ...metadata, members: [groupPolicy[0]] },
          stage: auditLogger.HANDLE_RBAC_DATA_STAGE,
          status: "succeeded"
        });
      } catch (e) {
        this.logger.warn(
          `Failed to remove group policy ${groupPolicy} after modification ${this.filePath}. Cause: ${e}`
        );
      }
    }
    this.csvFilePolicies.removedGroupPolicies = [];
  }
  async cleanUpRolesAndPolicies() {
    const roleMetadatas = await this.roleMetadataStorage.filterRoleMetadata("csv-file");
    const fileRoles = roleMetadatas.map((meta) => meta.roleEntityRef);
    if (fileRoles.length > 0) {
      for (const fileRole of fileRoles) {
        this.csvFilePolicies.removedGroupPolicies.push(
          ...await this.enforcer.getFilteredGroupingPolicy(1, fileRole)
        );
        this.csvFilePolicies.removedPolicies.push(
          ...await this.enforcer.getFilteredPolicy(0, fileRole)
        );
      }
    }
    await this.removePermissionPolicies();
    await this.removeRoles();
  }
}

exports.CSVFileWatcher = CSVFileWatcher;
exports.CSV_PERMISSION_POLICY_FILE_AUTHOR = CSV_PERMISSION_POLICY_FILE_AUTHOR;
//# sourceMappingURL=csv-file-watcher.cjs.js.map
