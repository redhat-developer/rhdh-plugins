'use strict';

var casbin = require('casbin');
var auditLogger = require('../audit-log/audit-logger.cjs.js');
var helper = require('../helper.cjs.js');
var permissionModel = require('../service/permission-model.cjs.js');
var policiesValidation = require('../validation/policies-validation.cjs.js');

class Connection {
  constructor(id, enforcer, roleMetadataStorage, logger, auditLogger) {
    this.id = id;
    this.enforcer = enforcer;
    this.roleMetadataStorage = roleMetadataStorage;
    this.logger = logger;
    this.auditLogger = auditLogger;
  }
  async applyRoles(roles) {
    const stringPolicy = helper.typedPoliciesToString(roles, "g");
    const providerRolesforRemoval = [];
    const tempEnforcer = await casbin.newEnforcer(
      casbin.newModelFromString(permissionModel.MODEL),
      new casbin.StringAdapter(stringPolicy)
    );
    const providerRoles = await this.getProviderRoles();
    for (const providerRole of providerRoles) {
      providerRolesforRemoval.push(
        ...await this.enforcer.getFilteredGroupingPolicy(1, providerRole)
      );
    }
    await this.removeRoles(providerRolesforRemoval, tempEnforcer);
    await this.addRoles(roles);
  }
  async applyPermissions(permissions) {
    const stringPolicy = helper.typedPoliciesToString(permissions, "p");
    const providerPermissions = [];
    const tempEnforcer = await casbin.newEnforcer(
      casbin.newModelFromString(permissionModel.MODEL),
      new casbin.StringAdapter(stringPolicy)
    );
    const providerRoles = await this.getProviderRoles();
    for (const providerRole of providerRoles) {
      providerPermissions.push(
        ...await this.enforcer.getFilteredPolicy(0, providerRole)
      );
    }
    await this.removePermissions(providerPermissions, tempEnforcer);
    await this.addPermissions(permissions);
  }
  async addRoles(roles) {
    for (const role of roles) {
      if (!await this.enforcer.hasGroupingPolicy(...role)) {
        const err = await policiesValidation.validateGroupingPolicy(
          role,
          this.roleMetadataStorage,
          this.id
        );
        if (err) {
          this.logger.warn(err.message);
          continue;
        }
        let roleMeta = await this.roleMetadataStorage.findRoleMetadata(role[1]);
        const eventName = roleMeta ? auditLogger.RoleEvents.UPDATE_ROLE : auditLogger.RoleEvents.CREATE_ROLE;
        const message = roleMeta ? "Updated role" : "Created role";
        if (!roleMeta) {
          roleMeta = {
            modifiedBy: this.id,
            source: this.id,
            roleEntityRef: role[1]
          };
        }
        await this.enforcer.addGroupingPolicy(role, roleMeta);
        await this.auditLogger.auditLog({
          actorId: auditLogger.RBAC_BACKEND,
          message,
          eventName,
          metadata: { ...roleMeta, members: [role[0]] },
          stage: auditLogger.HANDLE_RBAC_DATA_STAGE,
          status: "succeeded"
        });
      }
    }
  }
  async removeRoles(providerRoles, tempEnforcer) {
    for (const role of providerRoles) {
      if (!await tempEnforcer.hasGroupingPolicy(...role)) {
        const roleMeta = await this.roleMetadataStorage.findRoleMetadata(
          role[1]
        );
        const currentRole = await this.enforcer.getFilteredGroupingPolicy(
          1,
          role[1]
        );
        if (!roleMeta) {
          this.logger.warn("role does not exist");
          continue;
        }
        const singleRole = roleMeta && currentRole.length === 1;
        let eventName;
        let message;
        if (singleRole) {
          eventName = auditLogger.RoleEvents.DELETE_ROLE;
          message = "Deleted role";
          await this.enforcer.removeGroupingPolicy(role, roleMeta);
          await this.auditLogger.auditLog({
            actorId: auditLogger.RBAC_BACKEND,
            message,
            eventName,
            metadata: { ...roleMeta, members: [role[0]] },
            stage: auditLogger.HANDLE_RBAC_DATA_STAGE,
            status: "succeeded"
          });
          continue;
        }
        eventName = auditLogger.RoleEvents.UPDATE_ROLE;
        message = "Updated role: deleted members";
        await this.enforcer.removeGroupingPolicy(role, roleMeta, true);
        await this.auditLogger.auditLog({
          actorId: auditLogger.RBAC_BACKEND,
          message,
          eventName,
          metadata: { ...roleMeta, members: [role[0]] },
          stage: auditLogger.HANDLE_RBAC_DATA_STAGE,
          status: "succeeded"
        });
      }
    }
  }
  async addPermissions(permissions) {
    for (const permission of permissions) {
      if (!await this.enforcer.hasPolicy(...permission)) {
        const transformedPolicy = helper.transformArrayToPolicy(permission);
        const metadata = await this.roleMetadataStorage.findRoleMetadata(
          permission[0]
        );
        let err = policiesValidation.validatePolicy(transformedPolicy);
        if (err) {
          this.logger.warn(`Invalid permission policy, ${err}`);
          continue;
        }
        err = await policiesValidation.validateSource(this.id, metadata);
        if (err) {
          this.logger.warn(
            `Unable to add policy ${permission}. Cause: ${err.message}`
          );
          continue;
        }
        await this.enforcer.addPolicy(permission);
        await this.auditLogger.auditLog({
          actorId: auditLogger.RBAC_BACKEND,
          message: `Created policy`,
          eventName: auditLogger.PermissionEvents.CREATE_POLICY,
          metadata: { policies: [permission], source: this.id },
          stage: auditLogger.HANDLE_RBAC_DATA_STAGE,
          status: "succeeded"
        });
      }
    }
  }
  async removePermissions(providerPermissions, tempEnforcer) {
    const removedPermissions = [];
    for (const permission of providerPermissions) {
      if (!await tempEnforcer.hasPolicy(...permission)) {
        await this.enforcer.removePolicy(permission);
        removedPermissions.push(permission);
      }
      if (removedPermissions.length > 0) {
        await this.auditLogger.auditLog({
          actorId: auditLogger.RBAC_BACKEND,
          message: `Deleted policies`,
          eventName: auditLogger.PermissionEvents.DELETE_POLICY,
          metadata: {
            policies: removedPermissions,
            source: this.id
          },
          stage: auditLogger.HANDLE_RBAC_DATA_STAGE,
          status: "succeeded"
        });
      }
    }
  }
  async getProviderRoles() {
    const currentRoles = await this.roleMetadataStorage.filterRoleMetadata(
      this.id
    );
    return currentRoles.map((meta) => meta.roleEntityRef);
  }
}
async function connectRBACProviders(providers, enforcer, roleMetadataStorage, logger, auditLogger) {
  await Promise.all(
    providers.map(async (provider) => {
      try {
        const connection = new Connection(
          provider.getProviderName(),
          enforcer,
          roleMetadataStorage,
          logger,
          auditLogger
        );
        return provider.connect(connection);
      } catch (error) {
        throw new Error(
          `Unable to connect provider ${provider.getProviderName()}, ${error}`
        );
      }
    })
  );
}

exports.Connection = Connection;
exports.connectRBACProviders = connectRBACProviders;
//# sourceMappingURL=connect-providers.cjs.js.map
