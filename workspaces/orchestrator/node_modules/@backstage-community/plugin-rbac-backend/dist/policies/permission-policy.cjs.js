'use strict';

var pluginPermissionCommon = require('@backstage/plugin-permission-common');
var pluginRbacCommon = require('@backstage-community/plugin-rbac-common');
var adminCreation = require('../admin-permissions/admin-creation.cjs.js');
var auditLogger = require('../audit-log/audit-logger.cjs.js');
var aliasResolver = require('../conditional-aliases/alias-resolver.cjs.js');
var csvFileWatcher = require('../file-permissions/csv-file-watcher.cjs.js');
var yamlConditionalFileWatcher = require('../file-permissions/yaml-conditional-file-watcher.cjs.js');

const evaluatePermMsg = (userEntityRef, result, permission) => `${userEntityRef} is ${result} for permission '${permission.name}'${pluginPermissionCommon.isResourcePermission(permission) ? `, resource type '${permission.resourceType}'` : ""} and action '${pluginRbacCommon.toPermissionAction(permission.attributes)}'`;
class RBACPermissionPolicy {
  constructor(enforcer, auditLogger, conditionStorage, superUserList) {
    this.enforcer = enforcer;
    this.auditLogger = auditLogger;
    this.conditionStorage = conditionStorage;
    this.superUserList = superUserList;
  }
  superUserList;
  static async build(logger, auditLogger, configApi, conditionalStorage, enforcerDelegate, roleMetadataStorage, knex, pluginMetadataCollector, auth) {
    const superUserList = [];
    const adminUsers = configApi.getOptionalConfigArray(
      "permission.rbac.admin.users"
    );
    const superUsers = configApi.getOptionalConfigArray(
      "permission.rbac.admin.superUsers"
    );
    const policiesFile = configApi.getOptionalString(
      "permission.rbac.policies-csv-file"
    );
    const allowReload = configApi.getOptionalBoolean("permission.rbac.policyFileReload") || false;
    const conditionalPoliciesFile = configApi.getOptionalString(
      "permission.rbac.conditionalPoliciesFile"
    );
    if (superUsers && superUsers.length > 0) {
      for (const user of superUsers) {
        const userName = user.getString("name");
        superUserList.push(userName);
      }
    }
    await adminCreation.useAdminsFromConfig(
      adminUsers || [],
      enforcerDelegate,
      auditLogger,
      roleMetadataStorage,
      knex
    );
    await adminCreation.setAdminPermissions(enforcerDelegate, auditLogger);
    if ((!adminUsers || adminUsers.length === 0) && (!superUsers || superUsers.length === 0)) {
      logger.warn(
        "There are no admins or super admins configured for the RBAC-backend plugin."
      );
    }
    const csvFile = new csvFileWatcher.CSVFileWatcher(
      policiesFile,
      allowReload,
      logger,
      enforcerDelegate,
      roleMetadataStorage,
      auditLogger
    );
    await csvFile.initialize();
    const conditionalFile = new yamlConditionalFileWatcher.YamlConditinalPoliciesFileWatcher(
      conditionalPoliciesFile,
      allowReload,
      logger,
      conditionalStorage,
      auditLogger,
      auth,
      pluginMetadataCollector,
      roleMetadataStorage,
      enforcerDelegate
    );
    await conditionalFile.initialize();
    if (!conditionalPoliciesFile) {
      logger.info("conditional policies file feature was disabled");
      await conditionalFile.cleanUpConditionalPolicies();
    }
    if (!policiesFile) {
      logger.info("csv policies file feature was disabled");
      await csvFile.cleanUpRolesAndPolicies();
    }
    return new RBACPermissionPolicy(
      enforcerDelegate,
      auditLogger,
      conditionalStorage,
      superUserList
    );
  }
  async handle(request, user) {
    const userEntityRef = user?.info.userEntityRef ?? `user without entity`;
    let auditOptions = auditLogger.createPermissionEvaluationOptions(
      `Policy check for ${userEntityRef}`,
      userEntityRef,
      request
    );
    this.auditLogger.auditLog(auditOptions);
    try {
      let status = false;
      const action = pluginRbacCommon.toPermissionAction(request.permission.attributes);
      if (!user) {
        const msg2 = evaluatePermMsg(
          userEntityRef,
          pluginPermissionCommon.AuthorizeResult.DENY,
          request.permission
        );
        auditOptions = auditLogger.createPermissionEvaluationOptions(
          msg2,
          userEntityRef,
          request,
          { result: pluginPermissionCommon.AuthorizeResult.DENY }
        );
        await this.auditLogger.auditLog(auditOptions);
        return { result: pluginPermissionCommon.AuthorizeResult.DENY };
      }
      const permissionName = request.permission.name;
      const roles = await this.enforcer.getRolesForUser(userEntityRef);
      if (pluginPermissionCommon.isResourcePermission(request.permission)) {
        const resourceType = request.permission.resourceType;
        if (user) {
          const conditionResult = await this.handleConditions(
            userEntityRef,
            request,
            roles,
            user.info
          );
          if (conditionResult) {
            return conditionResult;
          }
        }
        const hasNamedPermission = await this.hasImplicitPermissionSpecifiedByName(
          userEntityRef,
          permissionName,
          action
        );
        const obj = hasNamedPermission ? permissionName : resourceType;
        status = await this.isAuthorized(userEntityRef, obj, action, roles);
      } else {
        status = await this.isAuthorized(
          userEntityRef,
          permissionName,
          action,
          roles
        );
      }
      const result = status ? pluginPermissionCommon.AuthorizeResult.ALLOW : pluginPermissionCommon.AuthorizeResult.DENY;
      const msg = evaluatePermMsg(userEntityRef, result, request.permission);
      auditOptions = auditLogger.createPermissionEvaluationOptions(
        msg,
        userEntityRef,
        request,
        { result }
      );
      await this.auditLogger.auditLog(auditOptions);
      return { result };
    } catch (error) {
      await this.auditLogger.auditLog({
        message: "Permission policy check failed",
        eventName: auditLogger.EvaluationEvents.PERMISSION_EVALUATION_FAILED,
        stage: auditLogger.EVALUATE_PERMISSION_ACCESS_STAGE,
        status: "failed",
        errors: [error]
      });
      return { result: pluginPermissionCommon.AuthorizeResult.DENY };
    }
  }
  async hasImplicitPermissionSpecifiedByName(userEntityRef, permissionName, action) {
    const userPerms = await this.enforcer.getImplicitPermissionsForUser(userEntityRef);
    for (const perm of userPerms) {
      if (permissionName === perm[1] && action === perm[2]) {
        return true;
      }
    }
    return false;
  }
  isAuthorized = async (userIdentity, permission, action, roles) => {
    if (this.superUserList.includes(userIdentity)) {
      return true;
    }
    return await this.enforcer.enforce(userIdentity, permission, action, roles);
  };
  async handleConditions(userEntityRef, request, roles, userInfo) {
    const permissionName = request.permission.name;
    const resourceType = request.permission.resourceType;
    const action = pluginRbacCommon.toPermissionAction(request.permission.attributes);
    const conditions = [];
    let pluginId = "";
    for (const role of roles) {
      const conditionalDecisions = await this.conditionStorage.filterConditions(
        role,
        void 0,
        resourceType,
        [action],
        [permissionName]
      );
      if (conditionalDecisions.length === 1) {
        pluginId = conditionalDecisions[0].pluginId;
        conditions.push(conditionalDecisions[0].conditions);
      }
      if (conditionalDecisions.length > 1) {
        const msg = `Detected ${JSON.stringify(
          conditionalDecisions
        )} collisions for conditional policies. Expected to find a stored single condition for permission with name ${permissionName}, resource type ${resourceType}, action ${action} for user ${userEntityRef}`;
        const auditOptions = auditLogger.createPermissionEvaluationOptions(
          msg,
          userEntityRef,
          request,
          { result: pluginPermissionCommon.AuthorizeResult.DENY }
        );
        await this.auditLogger.auditLog(auditOptions);
        return {
          result: pluginPermissionCommon.AuthorizeResult.DENY
        };
      }
    }
    if (conditions.length > 0) {
      const result = {
        pluginId,
        result: pluginPermissionCommon.AuthorizeResult.CONDITIONAL,
        resourceType,
        conditions: {
          anyOf: conditions
        }
      };
      aliasResolver.replaceAliases(result.conditions, userInfo);
      const msg = `Send condition to plugin with id ${pluginId} to evaluate permission ${permissionName} with resource type ${resourceType} and action ${action} for user ${userEntityRef}`;
      const auditOptions = auditLogger.createPermissionEvaluationOptions(
        msg,
        userEntityRef,
        request,
        result
      );
      await this.auditLogger.auditLog(auditOptions);
      return result;
    }
    return void 0;
  }
}

exports.RBACPermissionPolicy = RBACPermissionPolicy;
//# sourceMappingURL=permission-policy.cjs.js.map
