'use strict';

var graphlib = require('@dagrejs/graphlib');

class AncestorSearchMemo {
  graph;
  catalogApi;
  catalogDBClient;
  auth;
  userEntityRef;
  maxDepth;
  constructor(userEntityRef, catalogApi, catalogDBClient, auth, maxDepth) {
    this.graph = new graphlib.Graph({ directed: true });
    this.userEntityRef = userEntityRef;
    this.catalogApi = catalogApi;
    this.catalogDBClient = catalogDBClient;
    this.auth = auth;
    this.maxDepth = maxDepth;
  }
  isAcyclic() {
    return graphlib.alg.isAcyclic(this.graph);
  }
  findCycles() {
    return graphlib.alg.findCycles(this.graph);
  }
  setEdge(parentEntityRef, childEntityRef) {
    this.graph.setEdge(parentEntityRef, childEntityRef);
  }
  setNode(entityRef) {
    this.graph.setNode(entityRef);
  }
  hasEntityRef(groupRef) {
    return this.graph.hasNode(groupRef);
  }
  debugNodesAndEdges(logger, userEntity) {
    logger.debug(
      `SubGraph edges: ${JSON.stringify(this.graph.edges())} for ${userEntity}`
    );
    logger.debug(
      `SubGraph nodes: ${JSON.stringify(this.graph.nodes())} for ${userEntity}`
    );
  }
  getNodes() {
    return this.graph.nodes();
  }
  async doesRelationTableExist() {
    try {
      return await this.catalogDBClient.schema.hasTable("relations");
    } catch (error) {
      return false;
    }
  }
  async getAllGroups() {
    const { token } = await this.auth.getPluginRequestToken({
      onBehalfOf: await this.auth.getOwnServiceCredentials(),
      targetPluginId: "catalog"
    });
    const { items } = await this.catalogApi.getEntities(
      {
        filter: { kind: "Group" },
        fields: ["metadata.name", "metadata.namespace", "spec.parent"]
      },
      { token }
    );
    return items;
  }
  async getAllRelations() {
    try {
      const rows = await this.catalogDBClient("relations").select("source_entity_ref", "target_entity_ref").where("type", "childOf");
      return rows;
    } catch (error) {
      return [];
    }
  }
  async getUserGroups() {
    const { token } = await this.auth.getPluginRequestToken({
      onBehalfOf: await this.auth.getOwnServiceCredentials(),
      targetPluginId: "catalog"
    });
    const { items } = await this.catalogApi.getEntities(
      {
        filter: { kind: "Group", "relations.hasMember": this.userEntityRef },
        fields: ["metadata.name", "metadata.namespace", "spec.parent"]
      },
      { token }
    );
    return items;
  }
  async getUserRelations() {
    try {
      const rows = await this.catalogDBClient("relations").select("source_entity_ref", "target_entity_ref").where({ type: "memberOf", source_entity_ref: this.userEntityRef });
      return rows;
    } catch (error) {
      return [];
    }
  }
  traverseGroups(memo, group, allGroups, current_depth) {
    const groupName = `group:${group.metadata.namespace?.toLocaleLowerCase(
      "en-US"
    )}/${group.metadata.name.toLocaleLowerCase("en-US")}`;
    if (!memo.hasEntityRef(groupName)) {
      memo.setNode(groupName);
    }
    if (this.maxDepth !== void 0 && current_depth >= this.maxDepth) {
      return;
    }
    const depth = current_depth + 1;
    const parent = group.spec?.parent;
    const parentGroup = allGroups.find((g) => g.metadata.name === parent);
    if (parentGroup) {
      const parentName = `group:${group.metadata.namespace?.toLocaleLowerCase(
        "en-US"
      )}/${parentGroup.metadata.name.toLocaleLowerCase("en-US")}`;
      memo.setEdge(parentName, groupName);
      if (memo.isAcyclic()) {
        this.traverseGroups(memo, parentGroup, allGroups, depth);
      }
    }
  }
  traverseRelations(memo, relation, allRelations, current_depth) {
    if (this.maxDepth !== void 0 && current_depth >= this.maxDepth + 1) {
      return;
    }
    const depth = current_depth + 1;
    if (!memo.hasEntityRef(relation.source_entity_ref)) {
      memo.setNode(relation.source_entity_ref);
    }
    memo.setEdge(relation.target_entity_ref, relation.source_entity_ref);
    const parentGroup = allRelations.find(
      (g) => g.source_entity_ref === relation.target_entity_ref
    );
    if (parentGroup && memo.isAcyclic()) {
      this.traverseRelations(memo, parentGroup, allRelations, depth);
    }
  }
  async buildUserGraph(memo) {
    if (await this.doesRelationTableExist()) {
      const userRelations = await this.getUserRelations();
      const allRelations = await this.getAllRelations();
      userRelations.forEach(
        (group) => this.traverseRelations(
          memo,
          group,
          allRelations,
          0
        )
      );
    } else {
      const userGroups = await this.getUserGroups();
      const allGroups = await this.getAllGroups();
      userGroups.forEach(
        (group) => this.traverseGroups(memo, group, allGroups, 0)
      );
    }
  }
}

exports.AncestorSearchMemo = AncestorSearchMemo;
//# sourceMappingURL=ancestor-search-memo.cjs.js.map
