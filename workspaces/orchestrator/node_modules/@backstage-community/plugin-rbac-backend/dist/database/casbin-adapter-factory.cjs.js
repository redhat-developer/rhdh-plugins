'use strict';

var TypeORMAdapter = require('typeorm-adapter');
var path = require('path');
require('@backstage/backend-defaults/database');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var TypeORMAdapter__default = /*#__PURE__*/_interopDefaultCompat(TypeORMAdapter);

const DEFAULT_SQLITE3_STORAGE_FILE_NAME = "rbac.sqlite";
class CasbinDBAdapterFactory {
  constructor(config, databaseClient) {
    this.config = config;
    this.databaseClient = databaseClient;
  }
  async createAdapter() {
    const databaseConfig = this.config.getOptionalConfig("backend.database");
    const client = databaseConfig?.getOptionalString("client");
    let adapter;
    if (client === "pg") {
      const dbName = await this.databaseClient.client.config.connection.database;
      const schema = await this.databaseClient.client.searchPath?.[0] ?? "public";
      const ssl = this.handlePostgresSSL(databaseConfig);
      adapter = await TypeORMAdapter__default.default.newAdapter({
        type: "postgres",
        host: databaseConfig?.getString("connection.host"),
        port: databaseConfig?.getNumber("connection.port"),
        username: databaseConfig?.getString("connection.user"),
        password: databaseConfig?.getString("connection.password"),
        ssl,
        database: dbName,
        schema
      });
    }
    if (client === "better-sqlite3") {
      let storage;
      if (typeof databaseConfig?.get("connection")?.valueOf() === "string") {
        storage = databaseConfig?.getString("connection");
      } else if (databaseConfig?.has("connection.directory")) {
        const storageDir = databaseConfig?.getString("connection.directory");
        storage = path.resolve(storageDir, DEFAULT_SQLITE3_STORAGE_FILE_NAME);
      }
      adapter = await TypeORMAdapter__default.default.newAdapter({
        type: "better-sqlite3",
        // Storage type or path to the storage.
        database: storage || ":memory:"
      });
    }
    if (!adapter) {
      throw new Error(`Unsupported database client ${client}`);
    }
    return adapter;
  }
  handlePostgresSSL(dbConfig) {
    const connection = dbConfig.getOptional(
      "connection"
    );
    if (!connection) {
      return void 0;
    }
    if (typeof connection === "string" || connection instanceof String) {
      throw new Error(
        `rbac backend plugin doesn't support postgres connection in a string format yet`
      );
    }
    const ssl = connection.ssl;
    if (ssl === void 0) {
      return void 0;
    }
    if (typeof ssl === "boolean") {
      return ssl;
    }
    if (typeof ssl === "object") {
      const { ca, rejectUnauthorized } = ssl;
      const tlsOpts = { ca, rejectUnauthorized };
      if (Object.values(tlsOpts).every((el) => el === void 0)) {
        return true;
      }
      return tlsOpts;
    }
    return void 0;
  }
}

exports.CasbinDBAdapterFactory = CasbinDBAdapterFactory;
//# sourceMappingURL=casbin-adapter-factory.cjs.js.map
