'use strict';

var errors = require('@backstage/errors');
var helper = require('../helper.cjs.js');

const ROLE_METADATA_TABLE = "role-metadata";
class DataBaseRoleMetadataStorage {
  constructor(knex) {
    this.knex = knex;
  }
  async filterRoleMetadata(source) {
    return await this.knex.table(ROLE_METADATA_TABLE).where((builder) => {
      if (source) {
        builder.where("source", source);
      }
    });
  }
  async findRoleMetadata(roleEntityRef, trx) {
    const db = trx || this.knex;
    return await db.table(ROLE_METADATA_TABLE).where("roleEntityRef", roleEntityRef).first();
  }
  async createRoleMetadata(metadata, trx) {
    if (await this.findRoleMetadata(metadata.roleEntityRef, trx)) {
      throw new errors.ConflictError(
        `A metadata for role ${metadata.roleEntityRef} has already been stored`
      );
    }
    const result = await trx(ROLE_METADATA_TABLE).insert(metadata).returning("id");
    if (result && result?.length > 0) {
      return result[0].id;
    }
    throw new Error(
      `Failed to create the role metadata: '${JSON.stringify(metadata)}'.`
    );
  }
  async updateRoleMetadata(newRoleMetadata, oldRoleEntityRef, externalTrx) {
    const trx = externalTrx ?? await this.knex.transaction();
    const currentMetadataDao = await this.findRoleMetadata(
      oldRoleEntityRef,
      trx
    );
    if (!currentMetadataDao) {
      throw new errors.NotFoundError(
        `A metadata for role '${oldRoleEntityRef}' was not found`
      );
    }
    if (currentMetadataDao.source !== "legacy" && currentMetadataDao.source !== newRoleMetadata.source) {
      throw new errors.InputError(`The RoleMetadata.source field is 'read-only'.`);
    }
    if (helper.deepSortedEqual(currentMetadataDao, newRoleMetadata)) {
      return;
    }
    const result = await trx(ROLE_METADATA_TABLE).where("id", currentMetadataDao.id).update(newRoleMetadata).returning("id");
    if (!externalTrx) {
      await trx.commit();
    }
    if (!result || result.length === 0) {
      throw new Error(
        `Failed to update the role metadata '${JSON.stringify(
          currentMetadataDao
        )}' with new value: '${JSON.stringify(newRoleMetadata)}'.`
      );
    }
  }
  async removeRoleMetadata(roleEntityRef, trx) {
    const metadataDao = await this.findRoleMetadata(roleEntityRef, trx);
    if (!metadataDao) {
      throw new errors.NotFoundError(
        `A metadata for role '${roleEntityRef}' was not found`
      );
    }
    await trx(ROLE_METADATA_TABLE).delete().whereIn("id", [metadataDao.id]);
  }
}
function daoToMetadata(dao) {
  return {
    source: dao.source,
    description: dao.description,
    author: dao.author,
    modifiedBy: dao.modifiedBy,
    createdAt: dao.createdAt,
    lastModified: dao.lastModified
  };
}

exports.DataBaseRoleMetadataStorage = DataBaseRoleMetadataStorage;
exports.ROLE_METADATA_TABLE = ROLE_METADATA_TABLE;
exports.daoToMetadata = daoToMetadata;
//# sourceMappingURL=role-metadata.cjs.js.map
