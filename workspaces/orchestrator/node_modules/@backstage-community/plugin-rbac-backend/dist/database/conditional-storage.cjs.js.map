{"version":3,"file":"conditional-storage.cjs.js","sources":["../../src/database/conditional-storage.ts"],"sourcesContent":["/*\n * Copyright 2024 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ConflictError, InputError, NotFoundError } from '@backstage/errors';\nimport { AuthorizeResult } from '@backstage/plugin-permission-common';\n\nimport { Knex } from 'knex';\n\nimport type {\n  PermissionAction,\n  PermissionInfo,\n  RoleConditionalPolicyDecision,\n} from '@backstage-community/plugin-rbac-common';\n\nexport const CONDITIONAL_TABLE = 'role-condition-policies';\n\nexport interface ConditionalPolicyDecisionDAO {\n  result: AuthorizeResult.CONDITIONAL;\n  id?: number;\n  roleEntityRef: string;\n  permissions: string;\n  pluginId: string;\n  resourceType: string;\n  conditionsJson: string;\n}\n\nexport interface ConditionalStorage {\n  filterConditions(\n    roleEntityRef?: string | string[],\n    pluginId?: string,\n    resourceType?: string,\n    actions?: PermissionAction[],\n    permissionNames?: string[],\n  ): Promise<RoleConditionalPolicyDecision<PermissionInfo>[]>;\n  createCondition(\n    conditionalDecision: RoleConditionalPolicyDecision<PermissionInfo>,\n  ): Promise<number>;\n  checkConflictedConditions(\n    roleEntityRef: string,\n    resourceType: string,\n    pluginId: string,\n    queryPermissionNames: string[],\n    idToExclude?: number,\n  ): Promise<void>;\n  getCondition(\n    id: number,\n  ): Promise<RoleConditionalPolicyDecision<PermissionInfo> | undefined>;\n  deleteCondition(id: number): Promise<void>;\n  updateCondition(\n    id: number,\n    conditionalDecision: RoleConditionalPolicyDecision<PermissionInfo>,\n  ): Promise<void>;\n}\n\nexport class DataBaseConditionalStorage implements ConditionalStorage {\n  public constructor(private readonly knex: Knex<any, any[]>) {}\n\n  async filterConditions(\n    roleEntityRef?: string | string[],\n    pluginId?: string,\n    resourceType?: string,\n    actions?: PermissionAction[],\n    permissionNames?: string[],\n  ): Promise<RoleConditionalPolicyDecision<PermissionInfo>[]> {\n    const daoRaws = await this.knex.table(CONDITIONAL_TABLE).where(builder => {\n      if (pluginId) {\n        builder.where('pluginId', pluginId);\n      }\n      if (resourceType) {\n        builder.where('resourceType', resourceType);\n      }\n      if (roleEntityRef) {\n        if (Array.isArray(roleEntityRef)) {\n          builder.whereIn('roleEntityRef', roleEntityRef);\n        } else {\n          builder.where('roleEntityRef', roleEntityRef);\n        }\n      }\n    });\n\n    let conditions: RoleConditionalPolicyDecision<PermissionInfo>[] = [];\n    if (daoRaws) {\n      conditions = daoRaws.map(dao => this.daoToConditionalDecision(dao));\n    }\n\n    if (permissionNames && permissionNames.length > 0) {\n      conditions = conditions.filter(condition => {\n        return permissionNames.every(permissionName =>\n          condition.permissionMapping\n            .map(permInfo => permInfo.name)\n            .includes(permissionName),\n        );\n      });\n    }\n\n    if (actions && actions.length > 0) {\n      conditions = conditions.filter(condition => {\n        return actions.every(action =>\n          condition.permissionMapping\n            .map(permInfo => permInfo.action)\n            .includes(action),\n        );\n      });\n    }\n\n    return conditions;\n  }\n\n  async createCondition(\n    conditionalDecision: RoleConditionalPolicyDecision<PermissionInfo>,\n  ): Promise<number> {\n    await this.checkConflictedConditions(\n      conditionalDecision.roleEntityRef,\n      conditionalDecision.resourceType,\n      conditionalDecision.pluginId,\n      conditionalDecision.permissionMapping.map(permInfo => permInfo.action),\n    );\n\n    const conditionRaw = this.toDAO(conditionalDecision);\n    const result = await this.knex\n      .table(CONDITIONAL_TABLE)\n      .insert<ConditionalPolicyDecisionDAO>(conditionRaw)\n      .returning('id');\n    if (result && result?.length > 0) {\n      return result[0].id;\n    }\n\n    throw new Error(`Failed to create the condition.`);\n  }\n\n  async checkConflictedConditions(\n    roleEntityRef: string,\n    resourceType: string,\n    pluginId: string,\n    queryConditionActions: PermissionAction[],\n    idToExclude?: number,\n  ): Promise<void> {\n    let conditionsForTheSameResource = await this.filterConditions(\n      roleEntityRef,\n      pluginId,\n      resourceType,\n    );\n    conditionsForTheSameResource = conditionsForTheSameResource.filter(\n      c => c.id !== idToExclude,\n    );\n\n    if (conditionsForTheSameResource) {\n      const conflictedCondition = conditionsForTheSameResource.find(\n        condition => {\n          const conditionActions = condition.permissionMapping.map(\n            permInfo => permInfo.action,\n          );\n          return queryConditionActions.some(action =>\n            conditionActions.includes(action),\n          );\n        },\n      );\n\n      if (conflictedCondition) {\n        const conflictedActions = queryConditionActions.filter(action =>\n          conflictedCondition.permissionMapping.some(p => p.action === action),\n        );\n        throw new ConflictError(\n          `Found condition with conflicted permission action '${JSON.stringify(\n            conflictedActions,\n          )}'. Role could have multiple ` +\n            `conditions for the same resource type '${conflictedCondition.resourceType}', but with different permission action sets.`,\n        );\n      }\n    }\n  }\n\n  async getCondition(\n    id: number,\n  ): Promise<RoleConditionalPolicyDecision<PermissionInfo> | undefined> {\n    const daoRaw = await this.knex\n      .table(CONDITIONAL_TABLE)\n      .where('id', id)\n      .first();\n\n    if (daoRaw) {\n      return this.daoToConditionalDecision(daoRaw);\n    }\n    return undefined;\n  }\n\n  async deleteCondition(id: number): Promise<void> {\n    const condition = await this.getCondition(id);\n    if (!condition) {\n      throw new NotFoundError(`Condition with id ${id} was not found`);\n    }\n    await this.knex?.table(CONDITIONAL_TABLE).delete().whereIn('id', [id]);\n  }\n\n  async updateCondition(\n    id: number,\n    conditionalDecision: RoleConditionalPolicyDecision<PermissionInfo>,\n  ): Promise<void> {\n    const condition = await this.getCondition(id);\n    if (!condition) {\n      throw new NotFoundError(`Condition with id ${id} was not found`);\n    }\n\n    await this.checkConflictedConditions(\n      conditionalDecision.roleEntityRef,\n      conditionalDecision.resourceType,\n      conditionalDecision.pluginId,\n      conditionalDecision.permissionMapping.map(perm => perm.action),\n      id,\n    );\n\n    const conditionRaw = this.toDAO(conditionalDecision);\n    conditionRaw.id = id;\n    const result = await this.knex\n      .table(CONDITIONAL_TABLE)\n      .where('id', conditionRaw.id)\n      .update<ConditionalPolicyDecisionDAO>(conditionRaw)\n      .returning('id');\n\n    if (!result || result.length === 0) {\n      throw new Error(`Failed to update the condition with id: ${id}.`);\n    }\n  }\n\n  private toDAO(\n    conditionalDecision: RoleConditionalPolicyDecision<PermissionInfo>,\n  ): ConditionalPolicyDecisionDAO {\n    const {\n      result,\n      pluginId,\n      resourceType,\n      conditions,\n      roleEntityRef,\n      permissionMapping,\n    } = conditionalDecision;\n    const conditionsJson = JSON.stringify(conditions);\n    return {\n      result,\n      pluginId,\n      resourceType,\n      conditionsJson,\n      roleEntityRef,\n      permissions: JSON.stringify(permissionMapping),\n    };\n  }\n\n  private daoToConditionalDecision(\n    dao: ConditionalPolicyDecisionDAO,\n  ): RoleConditionalPolicyDecision<PermissionInfo> {\n    if (!dao.id) {\n      throw new InputError(`Missed id in the dao object: ${dao}`);\n    }\n    const {\n      id,\n      result,\n      pluginId,\n      resourceType,\n      conditionsJson,\n      roleEntityRef,\n      permissions,\n    } = dao;\n\n    const conditions = JSON.parse(conditionsJson);\n    return {\n      id,\n      result,\n      pluginId,\n      resourceType,\n      conditions,\n      roleEntityRef,\n      permissionMapping: JSON.parse(permissions),\n    };\n  }\n}\n"],"names":["ConflictError","NotFoundError","InputError"],"mappings":"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"}