import { conditionButtons, criterias } from '../components/ConditionalAccess/const.esm.js';
import { NotConditionType } from '../components/ConditionalAccess/types.esm.js';

const ruleOptionDisabled = (ruleOption, conditions) => {
  return !!(conditions || []).find((con) => con.rule === ruleOption);
};
const nestedConditionButtons = conditionButtons.filter(
  (button) => button.val !== "condition"
);
const extractNestedConditions = (conditions, criteriaTypes, nestedConditions) => {
  conditions.forEach((c) => {
    criteriaTypes.forEach((ct) => {
      if (Object.keys(c).includes(ct)) {
        nestedConditions.push(c);
      }
    });
  });
};
const getDefaultRule = (selPluginResourceType) => ({
  rule: "",
  resourceType: selPluginResourceType,
  params: {}
});
const getSimpleRulesCount = (conditionRow, criteria) => {
  if (criteria === criterias.not) {
    return conditionRow[criteria].resourceType ? 1 : 0;
  }
  if (criteria === criterias.condition) {
    return 1;
  }
  return conditionRow[criteria].filter(
    (e) => "rule" in e
  ).length;
};
const initializeErrors = (criteria, conditions) => {
  const errors = {};
  const initialize = (cond) => {
    if ("rule" in cond) {
      return "";
    }
    const nestedErrors = {};
    if (cond.allOf) {
      nestedErrors.allOf = cond.allOf.map(initialize) || [];
    }
    if (cond.anyOf) {
      nestedErrors.anyOf = cond.anyOf.map(initialize) || [];
    }
    if (cond.not) {
      nestedErrors.not = initialize(cond.not) || "";
    }
    return nestedErrors;
  };
  if (criteria === criterias.condition) {
    errors.condition = "";
  } else if (criteria === criterias.not) {
    const notCondition = conditions.not;
    let notConditionType;
    if (notCondition === void 0) {
      notConditionType = NotConditionType.SimpleCondition;
    } else if ("rule" in notCondition) {
      notConditionType = NotConditionType.SimpleCondition;
    } else {
      notConditionType = NotConditionType.NestedCondition;
    }
    if (notConditionType === NotConditionType.SimpleCondition) {
      errors.not = "";
    } else {
      errors.not = initialize(conditions.not);
    }
  } else if (criteria === criterias.allOf || criteria === criterias.anyOf) {
    errors[criteria] = Array.isArray(conditions[criteria]) ? conditions[criteria].map(initialize) : [""];
  }
  return errors;
};
const resetErrors = (criteria, notConditionType = NotConditionType.SimpleCondition) => {
  const errors = {};
  if (criteria === criterias.condition || criteria === criterias.not && notConditionType === NotConditionType.SimpleCondition) {
    errors[criteria] = "";
  }
  if (criteria === criterias.allOf || criteria === criterias.anyOf) {
    errors[criteria] = [""];
  }
  if (criteria === criterias.not && notConditionType === NotConditionType.NestedCondition) {
    errors[criteria] = { [criterias.allOf]: [""] };
  }
  return errors;
};
const setErrorMessage = (errors) => errors[0] ? `Error in the ${errors[0].property} field.` : "";
const getSimpleRuleErrors = (errors) => errors.filter(
  (err) => typeof err === "string"
) || [];
const getNestedRuleErrors = (errors) => errors.filter(
  (err) => typeof err !== "string"
) || [];
const isNestedConditionRule = (r) => {
  return criterias.allOf in r || criterias.anyOf in r || criterias.not in r;
};
const getNestedConditionSimpleRulesCount = (nc, c) => {
  if (c === criterias.not) {
    return nc[c].resourceType ? 1 : 0;
  }
  return nc[c].filter(
    (r) => "resourceType" in r
  ).length;
};
const getRowStyle = (c, isNestedCondition) => isNestedCondition ? {
  display: c.rule !== void 0 ? "flex" : "none"
} : { display: "flex", gap: "10px" };
const getRowKey = (isNestedCondition, ruleIndex) => isNestedCondition ? `nestedCondition-rule-${ruleIndex}` : `condition-rule-${ruleIndex}`;
const hasAllOfOrAnyOfErrors = (errors, criteria) => {
  if (!errors) return false;
  const criteriaErrors = errors[criteria];
  const simpleRuleErrors = criteriaErrors.filter(
    (e) => typeof e === "string"
  );
  const nestedRuleErrors = criteriaErrors.filter(
    (e) => typeof e !== "string"
  );
  if (simpleRuleErrors.some((e) => e.length > 0)) {
    return true;
  }
  return nestedRuleErrors.some((err) => {
    const nestedCriteria = Object.keys(err)[0];
    const nestedErrors = err[nestedCriteria];
    if (Array.isArray(nestedErrors)) {
      return nestedErrors.some((e) => e.length > 0);
    }
    return nestedErrors?.length > 0;
  });
};
const hasSimpleConditionOrNotErrors = (errors, criteria) => {
  if (!errors) return false;
  return (errors[criteria] || "").length > 0;
};
const hasNestedNotErrors = (errors, conditions, criteria) => {
  if (!errors) return false;
  const nestedCriteria = Object.keys(conditions[criteria])[0];
  const nestedErrors = errors[criterias.not][nestedCriteria];
  if (Array.isArray(nestedErrors)) {
    return nestedErrors.some((e) => e.length > 0);
  }
  return nestedErrors?.length > 0;
};
const isSimpleRule = (con) => "rule" in con;

export { extractNestedConditions, getDefaultRule, getNestedConditionSimpleRulesCount, getNestedRuleErrors, getRowKey, getRowStyle, getSimpleRuleErrors, getSimpleRulesCount, hasAllOfOrAnyOfErrors, hasNestedNotErrors, hasSimpleConditionOrNotErrors, initializeErrors, isNestedConditionRule, isSimpleRule, nestedConditionButtons, resetErrors, ruleOptionDisabled, setErrorMessage };
//# sourceMappingURL=conditional-access-utils.esm.js.map
