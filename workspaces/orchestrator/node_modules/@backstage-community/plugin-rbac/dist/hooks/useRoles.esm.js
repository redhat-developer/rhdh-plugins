import React from 'react';
import { useAsyncRetry, useAsync, useInterval } from 'react-use';
import { useApi } from '@backstage/core-plugin-api';
import { usePermission } from '@backstage/plugin-permission-react';
import { policyEntityDeletePermission, policyEntityCreatePermission, policyEntityUpdatePermission, isResourcedPolicy } from '@backstage-community/plugin-rbac-common';
import { rbacApiRef } from '../api/RBACBackendClient.esm.js';
import { getPermissions, getPermissionsArray } from '../utils/rbac-utils.esm.js';

const useRoles = (pollInterval) => {
  const rbacApi = useApi(rbacApiRef);
  const [newRoles, setNewRoles] = React.useState([]);
  const [roleConditionError, setRoleConditionError] = React.useState("");
  const {
    value: roles,
    retry: roleRetry,
    error: rolesError
  } = useAsyncRetry(async () => await rbacApi.getRoles());
  const {
    value: policies,
    retry: policiesRetry,
    error: policiesError
  } = useAsyncRetry(async () => await rbacApi.getPolicies(), []);
  const {
    loading: membersLoading,
    value: members,
    error: membersError
  } = useAsync(async () => {
    return await rbacApi.getMembers();
  });
  const {
    value: permissionPolicies,
    loading: loadingPermissionPolicies,
    error: permissionPoliciesError
  } = useAsync(async () => {
    return await rbacApi.listPermissions();
  });
  const canReadUsersAndGroups = !membersLoading && !membersError && Array.isArray(members) && members.length > 0;
  const deletePermissionResult = usePermission({
    permission: policyEntityDeletePermission,
    resourceRef: policyEntityDeletePermission.resourceType
  });
  const policyEntityCreatePermissionResult = usePermission({
    permission: policyEntityCreatePermission,
    resourceRef: policyEntityCreatePermission.resourceType
  });
  const createRoleLoading = policyEntityCreatePermissionResult.loading || membersLoading;
  const createRoleAllowed = policyEntityCreatePermissionResult.allowed && canReadUsersAndGroups;
  const editPermissionResult = usePermission({
    permission: policyEntityUpdatePermission,
    resourceRef: policyEntityUpdatePermission.resourceType
  });
  React.useEffect(() => {
    const fetchAllPermissionPolicies = async () => {
      if (!Array.isArray(roles)) return;
      const failedFetchConditionRoles = [];
      const conditionPromises = roles.map(async (role) => {
        try {
          const conditionalPolicies = await rbacApi.getRoleConditions(
            role.name
          );
          if (conditionalPolicies?.statusText) {
            failedFetchConditionRoles.push(role.name);
            throw new Error(
              conditionalPolicies.statusText
            );
          }
          const accessiblePlugins = Array.isArray(conditionalPolicies) && conditionalPolicies.length > 0 ? conditionalPolicies.map((c) => c.pluginId) : [];
          return {
            ...role,
            conditionalPoliciesCount: Array.isArray(conditionalPolicies) ? conditionalPolicies.length : 0,
            accessiblePlugins
          };
        } catch (error) {
          setRoleConditionError(
            `Error fetching role conditions for ${failedFetchConditionRoles.length > 1 ? "roles" : "role"} ${failedFetchConditionRoles.join(", ")}, please try again later.`
          );
          return {
            ...role,
            conditionalPoliciesCount: 0,
            accessiblePlugins: []
          };
        }
      });
      const updatedRoles = await Promise.all(conditionPromises);
      setNewRoles(updatedRoles);
    };
    fetchAllPermissionPolicies();
  }, [roles, rbacApi]);
  const data = React.useMemo(
    () => Array.isArray(newRoles) && newRoles?.length > 0 ? newRoles.reduce(
      (acc, role) => {
        const permissions = getPermissions(
          role.name,
          policies
        );
        let accPls = role.accessiblePlugins;
        if (!loadingPermissionPolicies && !permissionPoliciesError && permissionPolicies?.length > 0) {
          const pls = getPermissionsArray(
            role.name,
            policies
          ).map(
            (po) => permissionPolicies.find(
              (pp) => pp.policies?.find(
                (pol) => isResourcedPolicy(pol) ? po.permission === pol.resourceType : po.permission === pol.name
              )
            )?.pluginId
          );
          accPls = [...accPls, ...pls].filter((val) => !!val);
        }
        const accessiblePlugins = accPls.filter((val, index, plugins) => plugins.indexOf(val) === index).sort();
        return [
          ...acc,
          {
            id: role.name,
            name: role.name,
            description: role.metadata?.description ?? "-",
            members: role.memberReferences,
            permissions: role.conditionalPoliciesCount + permissions,
            modifiedBy: "-",
            lastModified: "-",
            actionsPermissionResults: {
              delete: deletePermissionResult,
              edit: {
                allowed: editPermissionResult.allowed && canReadUsersAndGroups,
                loading: editPermissionResult.loading
              }
            },
            accessiblePlugins
          }
        ];
      },
      []
    ) : [],
    [
      newRoles,
      policies,
      loadingPermissionPolicies,
      permissionPoliciesError,
      permissionPolicies,
      deletePermissionResult,
      editPermissionResult.allowed,
      editPermissionResult.loading,
      canReadUsersAndGroups
    ]
  );
  const loading = !rolesError && !policiesError && !roles && !policies;
  useInterval(
    () => {
      roleRetry();
      policiesRetry();
    },
    loading ? null : 1e4
  );
  return {
    loading,
    data,
    error: {
      rolesError: rolesError?.message || (typeof roles === "object" ? roles?.statusText : ""),
      policiesError: policiesError?.message || (typeof policies === "object" ? policies?.statusText : ""),
      roleConditionError
    },
    createRoleLoading,
    createRoleAllowed,
    retry: { roleRetry, policiesRetry }
  };
};

export { useRoles };
//# sourceMappingURL=useRoles.esm.js.map
