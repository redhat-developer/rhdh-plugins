import React from 'react';
import Autocomplete from '@mui/material/Autocomplete';
import Box from '@mui/material/Box';
import { useTheme } from '@mui/material/styles';
import TextField from '@mui/material/TextField';
import { makeStyles } from '@mui/styles';
import Form from '@rjsf/mui';
import validator from '@rjsf/validator-ajv8';
import { isSimpleRule, setErrorMessage, getSimpleRuleErrors, getNestedRuleErrors } from '../../utils/conditional-access-utils.esm.js';
import { criterias } from './const.esm.js';
import { CustomArrayField } from './CustomArrayField.esm.js';
import { RulesDropdownOption } from './RulesDropdownOption.esm.js';

const makeConditionsFormRowFieldsStyles = makeStyles(() => ({
  inputFieldContainer: {
    display: "flex",
    flexFlow: "row",
    gap: "10px",
    flexGrow: 1,
    margin: ({ isNotSimpleCondition }) => isNotSimpleCondition ? "-1.5rem 0 0 1.85rem" : "0"
  }
}));
const getTextFieldStyles = (theme) => ({
  '& div[class*="MuiInputBase-root"]': {
    backgroundColor: theme.palette.background.paper
  },
  "& span": {
    color: theme.palette.textSubtle
  },
  "& input": {
    color: theme.palette.textContrast
  },
  "& fieldset.MuiOutlinedInput-notchedOutline": {
    borderColor: theme.palette.grey[500]
  },
  "& div.MuiOutlinedInput-root": {
    "&.Mui-focused .MuiOutlinedInput-notchedOutline": {
      borderColor: theme.palette.primary.light
    },
    "&.Mui-error .MuiOutlinedInput-notchedOutline": {
      borderColor: theme.palette.status.error,
      "&:hover": {
        borderColor: theme.palette.status.error
      }
    }
  },
  "& label.MuiFormLabel-root.Mui-focused": {
    color: theme.palette.primary.light
  },
  "& label.MuiFormLabel-root.Mui-error": {
    color: theme.palette.status.error
  },
  "& div.MuiOutlinedInput-root:hover fieldset": {
    borderColor: theme.palette.mode === "dark" ? theme.palette.textContrast : "unset"
  },
  "& label": {
    color: theme.palette.textSubtle
  }
});
const ConditionsFormRowFields = ({
  oldCondition,
  index,
  criteria,
  onRuleChange,
  conditionRow,
  conditionRulesData,
  setErrors,
  optionDisabled,
  setRemoveAllClicked,
  nestedConditionRow,
  nestedConditionCriteria,
  nestedConditionIndex,
  nestedConditionRuleIndex,
  updateRules
}) => {
  const isNotSimpleCondition = criteria === criterias.not && !nestedConditionCriteria;
  const theme = useTheme();
  const classes = makeConditionsFormRowFieldsStyles({
    isNotSimpleCondition
  });
  const rules = conditionRulesData?.rules ?? [];
  const paramsSchema = conditionRulesData?.[oldCondition.rule]?.schema;
  const schema = paramsSchema;
  const uiSchema = {
    "ui:submitButtonOptions": {
      norender: true
    },
    "ui:classNames": `{
      '& div[class*="MuiInputBase-root"]': {
        backgroundColor: theme.palette.background.paper,
      },
      '& span': {
        color: theme.palette.textSubtle,
      },
      '& input': {
        color: theme.palette.textContrast,
      },
      '& fieldset.MuiOutlinedInput-notchedOutline': {
        borderColor: theme.palette.grey[500],
      },
      '& div.MuiOutlinedInput-root': {
        '&.Mui-focused .MuiOutlinedInput-notchedOutline': {
          borderColor: theme.palette.primary.light,
        },
        '&.Mui-error .MuiOutlinedInput-notchedOutline': {
          borderColor: theme.palette.status.error,
          '&:hover': {
            borderColor: theme.palette.status.error,
          },
        },
      },
      '& label.MuiFormLabel-root.Mui-focused': {
        color: theme.palette.primary.light,
      },
      '& label.MuiFormLabel-root.Mui-error': {
        color: theme.palette.status.error,
      },
      '& div.MuiOutlinedInput-root:hover fieldset': {
        borderColor:
          theme.palette.mode === 'dark' ? theme.palette.textContrast : 'unset',
      },
      '& label': {
        color: theme.palette.textSubtle,
      },
    }`,
    "ui:field": "array"
  };
  const customFields = { ArrayField: CustomArrayField };
  const handleConditionChange = (newCondition) => {
    setRemoveAllClicked(false);
    switch (criteria) {
      case criterias.condition: {
        onRuleChange({ condition: newCondition });
        break;
      }
      case criterias.allOf: {
        const updatedCriteria = conditionRow.allOf ?? [];
        updatedCriteria[index ?? 0] = newCondition;
        onRuleChange({ allOf: updatedCriteria });
        break;
      }
      case criterias.anyOf: {
        const updatedCriteria = conditionRow.anyOf ?? [];
        updatedCriteria[index ?? 0] = newCondition;
        onRuleChange({ anyOf: updatedCriteria });
        break;
      }
      case criterias.not: {
        onRuleChange({ not: newCondition });
        break;
      }
    }
  };
  const handleNestedConditionChange = (newCondition) => {
    if (!nestedConditionRow || !nestedConditionCriteria || nestedConditionIndex === void 0 || !updateRules) {
      return;
    }
    const updatedNestedConditionRow = nestedConditionRow.map(
      (c, i) => {
        if (i === nestedConditionIndex) {
          if (nestedConditionCriteria === criterias.not) {
            return {
              [nestedConditionCriteria]: newCondition
            };
          }
          const updatedNestedConditionRules = (c[nestedConditionCriteria] || []).map((rule, rindex) => {
            return rindex === nestedConditionRuleIndex ? newCondition : rule;
          });
          return {
            [nestedConditionCriteria]: updatedNestedConditionRules
          };
        }
        return c;
      }
    );
    updateRules(
      criteria === criterias.not ? updatedNestedConditionRow[0] : updatedNestedConditionRow
    );
  };
  const handleTransformErrors = (errors) => {
    if (criteria === criterias.condition || criteria === criterias.not && isSimpleRule(conditionRow[criteria])) {
      setErrors((prevErrors) => {
        const updatedErrors = { ...prevErrors };
        updatedErrors[criteria] = setErrorMessage(errors);
        return updatedErrors;
      });
    }
    if (criteria === criterias.not && nestedConditionCriteria && !isSimpleRule(conditionRow[criteria])) {
      setErrors((prevErrors) => {
        const updatedErrors = { ...prevErrors };
        const nestedErrors = updatedErrors[criteria][nestedConditionCriteria];
        if (Array.isArray(nestedErrors) && nestedConditionRuleIndex !== void 0) {
          nestedErrors[nestedConditionRuleIndex] = setErrorMessage(errors);
        } else {
          updatedErrors[criteria] = {
            [nestedConditionCriteria]: setErrorMessage(errors)
          };
        }
        return updatedErrors;
      });
    }
    if (criteria === criterias.allOf || criteria === criterias.anyOf) {
      setErrors((prevErrors) => {
        const updatedErrors = { ...prevErrors };
        const simpleRuleErrors = getSimpleRuleErrors(
          updatedErrors[criteria]
        );
        if (Array.isArray(simpleRuleErrors) && simpleRuleErrors.length > 0 && index !== void 0) {
          simpleRuleErrors[index] = setErrorMessage(errors);
        }
        const nestedRuleErrors = getNestedRuleErrors(
          updatedErrors[criteria]
        );
        if (nestedConditionCriteria && nestedConditionIndex !== void 0 && nestedConditionRuleIndex !== void 0) {
          const nestedConditionRuleList = nestedRuleErrors[nestedConditionIndex][nestedConditionCriteria];
          if (Array.isArray(nestedConditionRuleList)) {
            nestedConditionRuleList[nestedConditionRuleIndex] = setErrorMessage(errors);
          }
        }
        if (Array.isArray(nestedRuleErrors) && nestedRuleErrors.length > 0 && nestedConditionCriteria === criterias.not && nestedConditionIndex !== void 0) {
          nestedRuleErrors[nestedConditionIndex][nestedConditionCriteria] = setErrorMessage(errors);
        }
        updatedErrors[criteria] = [...simpleRuleErrors, ...nestedRuleErrors];
        return updatedErrors;
      });
    }
    return errors;
  };
  const onConditionChange = (newCondition) => {
    if (nestedConditionRow) {
      handleNestedConditionChange(newCondition);
    } else {
      handleConditionChange(newCondition);
    }
  };
  return /* @__PURE__ */ React.createElement(Box, { className: classes.inputFieldContainer }, /* @__PURE__ */ React.createElement(
    Autocomplete,
    {
      style: { width: "50%", marginTop: "26px" },
      sx: getTextFieldStyles(theme),
      options: rules ?? [],
      value: oldCondition?.rule || null,
      getOptionDisabled: (option) => optionDisabled ? optionDisabled(option) : false,
      onChange: (_event, ruleVal) => onConditionChange({
        ...oldCondition,
        rule: ruleVal ?? "",
        params: {}
      }),
      renderOption: (props, option) => /* @__PURE__ */ React.createElement(
        RulesDropdownOption,
        {
          props,
          label: option ?? "",
          rulesData: conditionRulesData
        }
      ),
      renderInput: (params) => /* @__PURE__ */ React.createElement(
        TextField,
        {
          ...params,
          label: "Rule",
          variant: "outlined",
          placeholder: "Select a rule",
          required: true
        }
      )
    }
  ), /* @__PURE__ */ React.createElement(Box, { style: { width: "50%" } }, schema ? /* @__PURE__ */ React.createElement(
    Form,
    {
      schema: paramsSchema,
      formData: oldCondition?.params || {},
      validator,
      uiSchema,
      fields: customFields,
      onChange: (data) => onConditionChange({
        ...oldCondition,
        params: data.formData || {}
      }),
      transformErrors: handleTransformErrors,
      showErrorList: false,
      liveValidate: true
    }
  ) : /* @__PURE__ */ React.createElement(
    TextField,
    {
      style: { width: "100%", marginTop: "26px" },
      sx: getTextFieldStyles(theme),
      disabled: true,
      label: "string, string",
      required: true,
      variant: "outlined"
    }
  )));
};

export { ConditionsFormRowFields, getTextFieldStyles };
//# sourceMappingURL=ConditionsFormRowFields.esm.js.map
