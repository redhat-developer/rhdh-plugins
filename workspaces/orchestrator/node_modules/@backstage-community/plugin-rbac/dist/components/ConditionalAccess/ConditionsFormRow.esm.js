import React from 'react';
import AddIcon from '@mui/icons-material/Add';
import RemoveIcon from '@mui/icons-material/Remove';
import Box from '@mui/material/Box';
import Button from '@mui/material/Button';
import FormControlLabel from '@mui/material/FormControlLabel';
import IconButton from '@mui/material/IconButton';
import Radio from '@mui/material/Radio';
import RadioGroup from '@mui/material/RadioGroup';
import { useTheme } from '@mui/material/styles';
import ToggleButtonGroup from '@mui/material/ToggleButtonGroup';
import { extractNestedConditions, getDefaultRule, ruleOptionDisabled, isNestedConditionRule, resetErrors, isSimpleRule, getSimpleRulesCount, getNestedConditionSimpleRulesCount, nestedConditionButtons } from '../../utils/conditional-access-utils.esm.js';
import { AddNestedConditionButton } from './AddNestedConditionButton.esm.js';
import { ComplexConditionRow } from './ComplexConditionRow.esm.js';
import { ComplexConditionRowButtons } from './ComplexConditionRowButtons.esm.js';
import { ConditionRule } from './ConditionRule.esm.js';
import { ConditionsFormRowFields } from './ConditionsFormRowFields.esm.js';
import { criterias, conditionButtons } from './const.esm.js';
import { CriteriaToggleButton } from './CriteriaToggleButton.esm.js';
import { NotConditionType } from './types.esm.js';

const ConditionsFormRow = ({
  conditionRulesData,
  conditionRow,
  selPluginResourceType,
  criteria,
  onRuleChange,
  setCriteria,
  setErrors,
  setRemoveAllClicked
}) => {
  const theme = useTheme();
  const [nestedConditionRow, setNestedConditionRow] = React.useState([]);
  const [notConditionType, setNotConditionType] = React.useState(NotConditionType.SimpleCondition);
  React.useEffect(() => {
    const nestedConditions = [];
    const criteriaTypes = [criterias.allOf, criterias.anyOf, criterias.not];
    switch (criteria) {
      case criterias.allOf:
        extractNestedConditions(
          conditionRow.allOf || [],
          criteriaTypes,
          nestedConditions
        );
        break;
      case criterias.anyOf:
        extractNestedConditions(
          conditionRow.anyOf || [],
          criteriaTypes,
          nestedConditions
        );
        break;
      case criterias.not:
        if (conditionRow.not && criteriaTypes.includes(
          Object.keys(conditionRow.not)[0]
        )) {
          nestedConditions.push(conditionRow.not);
          setNotConditionType(NotConditionType.NestedCondition);
        }
        break;
    }
    setNestedConditionRow(nestedConditions);
  }, [conditionRow, criteria]);
  const handleCriteriaChange = (val) => {
    setCriteria(val);
    setErrors(resetErrors(val));
    const defaultRule = getDefaultRule(selPluginResourceType);
    const ruleMap = {
      [criterias.condition]: { condition: defaultRule },
      [criterias.allOf]: { allOf: [defaultRule] },
      [criterias.anyOf]: { anyOf: [defaultRule] },
      [criterias.not]: { not: defaultRule }
    };
    if (val === criterias.not) {
      setNotConditionType(NotConditionType.SimpleCondition);
    }
    const ruleChange = ruleMap[val];
    if (ruleChange) {
      onRuleChange(ruleChange);
    }
  };
  const updateRules = (updatedNestedConditionRow) => {
    const existingSimpleCondition = criteria !== criterias.not ? conditionRow[criteria]?.filter(
      (con) => isSimpleRule(con)
    ) || [] : [];
    const newCondition = Array.isArray(updatedNestedConditionRow) ? [...existingSimpleCondition, ...updatedNestedConditionRow] : [...existingSimpleCondition, updatedNestedConditionRow];
    if (criteria === criterias.anyOf || criteria === criterias.allOf) {
      onRuleChange({
        [criteria]: newCondition
      });
    } else if (criteria === criterias.not && !Array.isArray(updatedNestedConditionRow)) {
      onRuleChange({
        not: updatedNestedConditionRow
      });
    }
  };
  const handleNestedConditionCriteriaChange = (val, nestedConditionIndex) => {
    const defaultRule = getDefaultRule(selPluginResourceType);
    const nestedConditionMap = {
      [criterias.not]: { [val]: defaultRule },
      [criterias.allOf]: { [val]: [defaultRule] },
      [criterias.anyOf]: { [val]: [defaultRule] },
      [criterias.condition]: { [val]: [defaultRule] }
    };
    const newCondition = nestedConditionMap[val] || { [val]: [defaultRule] };
    setErrors((prevErrors) => {
      const updatedErrors = { ...prevErrors };
      if (updatedErrors[criteria] !== void 0) {
        if (criteria === criterias.not) {
          updatedErrors[criteria] = val !== criterias.not ? { [val]: [""] } : { [val]: "" };
          return updatedErrors;
        }
        const criteriaErrors = updatedErrors[criteria];
        const simpleRuleErrors = criteriaErrors.filter(
          (err) => typeof err === "string"
        );
        const nestedConditionErrors = criteriaErrors.filter((err) => typeof err !== "string");
        nestedConditionErrors[nestedConditionIndex] = val !== criterias.not ? { [val]: [""] } : { [val]: "" };
        updatedErrors[criteria] = [
          ...simpleRuleErrors,
          ...nestedConditionErrors
        ];
      }
      return updatedErrors;
    });
    if (criteria === criterias.not) {
      updateRules(newCondition);
    } else {
      const updatedNestedConditionRow = nestedConditionRow.map((c, index) => {
        if (index === nestedConditionIndex) {
          return newCondition;
        }
        return c;
      });
      updateRules(updatedNestedConditionRow);
    }
  };
  const handleAddNestedCondition = (currentCriteria) => {
    const newNestedCondition = {
      [criterias.allOf]: [getDefaultRule(selPluginResourceType)]
    };
    const updatedNestedConditionRow = [
      ...nestedConditionRow,
      newNestedCondition
    ];
    updateRules(
      currentCriteria === criterias.not ? newNestedCondition : updatedNestedConditionRow
    );
    setErrors((prevErrors) => {
      const updatedErrors = { ...prevErrors };
      if (updatedErrors[currentCriteria]) {
        const criteriaErrors = updatedErrors[currentCriteria];
        if (Array.isArray(criteriaErrors)) {
          criteriaErrors.push({ [criterias.allOf]: [""] });
        } else {
          updatedErrors[currentCriteria] = {
            [criterias.allOf]: [""]
          };
        }
      }
      return updatedErrors;
    });
  };
  const handleNotConditionTypeChange = (val) => {
    setNotConditionType(val);
    setErrors(resetErrors(criteria, val));
    if (val === "nested-condition") {
      handleAddNestedCondition(criterias.not);
    } else {
      onRuleChange({
        not: getDefaultRule(selPluginResourceType)
      });
    }
  };
  const handleAddRuleInNestedCondition = (nestedConditionCriteria, nestedConditionIndex) => {
    const updatedNestedConditionRow = [];
    nestedConditionRow.forEach((c, index) => {
      if (index === nestedConditionIndex) {
        updatedNestedConditionRow.push({
          [nestedConditionCriteria]: [
            ...c[nestedConditionCriteria] || [],
            getDefaultRule(selPluginResourceType)
          ]
        });
      } else {
        updatedNestedConditionRow.push(c);
      }
    });
    updateRules(
      criteria === criterias.not ? updatedNestedConditionRow[0] : updatedNestedConditionRow
    );
    setErrors((prevErrors) => {
      const updatedErrors = { ...prevErrors };
      if (updatedErrors[criteria] !== void 0) {
        const criteriaErrors = updatedErrors[criteria];
        if (criteria === criterias.not && notConditionType === "nested-condition") {
          criteriaErrors[nestedConditionCriteria].push("");
          return updatedErrors;
        }
        const simpleRuleErrors = criteriaErrors.filter(
          (err) => typeof err === "string"
        );
        const nestedConditionErrors = criteriaErrors.filter((err) => typeof err !== "string");
        (nestedConditionErrors[nestedConditionIndex][nestedConditionCriteria] || []).push("");
        updatedErrors[criteria] = [
          ...simpleRuleErrors,
          ...nestedConditionErrors
        ];
      }
      return updatedErrors;
    });
  };
  const handleRemoveNestedCondition = (nestedConditionIndex) => {
    const updatedNestedConditionRow = nestedConditionRow.filter(
      (_, index) => index !== nestedConditionIndex
    );
    updateRules(updatedNestedConditionRow);
    setErrors((prevErrors) => {
      const updatedErrors = { ...prevErrors };
      if (updatedErrors[criteria] !== void 0) {
        const criteriaErrors = updatedErrors[criteria];
        const simpleRuleErrors = criteriaErrors.filter(
          (err) => typeof err === "string"
        );
        const nestedConditionErrors = criteriaErrors.filter(
          (err) => typeof err !== "string"
        );
        nestedConditionErrors.splice(nestedConditionIndex, 1);
        updatedErrors[criteria] = [
          ...simpleRuleErrors,
          ...nestedConditionErrors
        ];
      }
      return updatedErrors;
    });
  };
  const updateErrors = (_index) => {
    setErrors((prevErrors) => {
      const updatedErrors = { ...prevErrors };
      if (!Array.isArray(updatedErrors[criteria])) {
        updatedErrors[criteria] = [];
      }
      const firstNestedConditionErrorIndex = updatedErrors[criteria].findIndex(
        (e) => typeof e !== "string"
      ) || 0;
      updatedErrors[criteria].splice(
        firstNestedConditionErrorIndex,
        0,
        ""
      );
      return updatedErrors;
    });
  };
  const renderNestedConditionRow = (nc, nestedConditionIndex) => {
    const selectedNestedConditionCriteria = Object.keys(nc)[0];
    const simpleRulesCount = getSimpleRulesCount(conditionRow, criteria);
    const nestedConditionsCount = nestedConditionRow.length;
    const nestedConditionSimpleRulesCount = getNestedConditionSimpleRulesCount(
      nc,
      selectedNestedConditionCriteria
    );
    return nestedConditionSimpleRulesCount > 0 && /* @__PURE__ */ React.createElement(
      Box,
      {
        mt: 2,
        key: `nestedCondition-${nestedConditionIndex}`,
        sx: {
          padding: "20px",
          marginLeft: theme.spacing(3),
          border: `1px solid ${theme.palette.border}`,
          borderRadius: "4px",
          backgroundColor: theme.palette.background.default,
          "& input": {
            backgroundColor: `${theme.palette.background.paper}!important`
          }
        }
      },
      /* @__PURE__ */ React.createElement("div", { style: { display: "flex", justifyContent: "space-between" } }, /* @__PURE__ */ React.createElement(
        ToggleButtonGroup,
        {
          exclusive: true,
          value: selectedNestedConditionCriteria,
          onChange: (_event, newNestedCriteria) => handleNestedConditionCriteriaChange(
            newNestedCriteria,
            nestedConditionIndex
          ),
          sx: {
            backgroundColor: theme.palette.background.paper,
            width: "60%",
            height: "100%"
          }
        },
        nestedConditionButtons.map(({ val, label }) => /* @__PURE__ */ React.createElement(
          CriteriaToggleButton,
          {
            key: `nested-criteria-${val}`,
            val,
            label,
            selectedCriteria: selectedNestedConditionCriteria,
            theme
          }
        ))
      ), criteria !== criterias.not && /* @__PURE__ */ React.createElement(
        IconButton,
        {
          title: "Remove nested condition",
          sx: {
            color: theme.palette.grey[500],
            flexGrow: 0,
            alignSelf: "baseline"
          },
          disabled: simpleRulesCount === 0 && nestedConditionsCount === 1,
          onClick: () => handleRemoveNestedCondition(nestedConditionIndex)
        },
        /* @__PURE__ */ React.createElement(RemoveIcon, { "data-testid": "remove-nested-condition" })
      )),
      /* @__PURE__ */ React.createElement(Box, null, selectedNestedConditionCriteria !== criterias.not && nc[selectedNestedConditionCriteria].map((c, ncrIndex) => /* @__PURE__ */ React.createElement(
        ComplexConditionRow,
        {
          key: `nested-condition-${nestedConditionIndex}-${ncrIndex}`,
          conditionRow,
          nestedConditionRow,
          criteria,
          onRuleChange,
          updateRules,
          setErrors,
          setRemoveAllClicked,
          conditionRulesData,
          notConditionType,
          currentCondition: c,
          ruleIndex: ncrIndex,
          isNestedCondition: true,
          nestedConditionIndex,
          activeNestedCriteria: selectedNestedConditionCriteria
        }
      )), selectedNestedConditionCriteria === criterias.not && nc.not.resourceType && /* @__PURE__ */ React.createElement(
        ConditionsFormRowFields,
        {
          oldCondition: nc.not ?? getDefaultRule(selPluginResourceType),
          onRuleChange,
          conditionRow,
          criteria,
          conditionRulesData,
          setErrors,
          optionDisabled: (ruleOption) => ruleOptionDisabled(
            ruleOption,
            nc.not ? [nc.not] : void 0
          ),
          setRemoveAllClicked,
          nestedConditionRow,
          nestedConditionCriteria: selectedNestedConditionCriteria,
          nestedConditionIndex,
          updateRules
        }
      ), selectedNestedConditionCriteria !== criterias.not && /* @__PURE__ */ React.createElement(
        Button,
        {
          sx: {
            mt: 1,
            color: theme.palette.primary.light
          },
          size: "small",
          onClick: () => handleAddRuleInNestedCondition(
            selectedNestedConditionCriteria,
            nestedConditionIndex
          ),
          startIcon: /* @__PURE__ */ React.createElement(AddIcon, { fontSize: "small" })
        },
        "Add rule"
      ))
    );
  };
  return /* @__PURE__ */ React.createElement(
    Box,
    {
      sx: {
        padding: "20px",
        border: `1px solid ${theme.palette.border}`,
        borderRadius: "4px",
        backgroundColor: theme.palette.background.default,
        "& input": {
          color: `${theme.palette.textContrast}!important`,
          "&:-internal-autofill-selected, &:-webkit-autofill, &:-webkit-autofill:hover, &:-webkit-autofill:focus, &:-webkit-autofill:active": {
            WebkitBoxShadow: `0 0 0px 1000px ${theme.palette.background.paper} inset`,
            WebkitTextFillColor: `${theme.palette.textContrast}!important`,
            caretColor: `${theme.palette.textContrast}!important`
          }
        },
        "& button": {
          textTransform: "none"
        }
      },
      "data-testid": "conditions-row"
    },
    /* @__PURE__ */ React.createElement(
      ToggleButtonGroup,
      {
        exclusive: true,
        value: criteria,
        onChange: (_event, newCriteria) => handleCriteriaChange(newCriteria),
        sx: {
          backgroundColor: theme.palette.background.paper,
          width: "80%"
        }
      },
      conditionButtons.map(({ val, label }) => /* @__PURE__ */ React.createElement(
        CriteriaToggleButton,
        {
          key: `criteria-${val}`,
          val,
          label,
          selectedCriteria: criteria,
          theme
        }
      ))
    ),
    /* @__PURE__ */ React.createElement(
      ConditionRule,
      {
        conditionRow,
        selPluginResourceType,
        onRuleChange,
        criteria,
        conditionRulesData,
        setErrors,
        setRemoveAllClicked
      }
    ),
    criteria !== criterias.condition && /* @__PURE__ */ React.createElement(Box, null, criteria !== criterias.not && conditionRow[criteria]?.map(
      (c, srIndex) => /* @__PURE__ */ React.createElement(
        ComplexConditionRow,
        {
          key: `${criteria}-simple-condition-${srIndex}`,
          conditionRow,
          nestedConditionRow,
          criteria,
          onRuleChange,
          updateRules,
          setErrors,
          setRemoveAllClicked,
          conditionRulesData,
          notConditionType,
          currentCondition: c,
          ruleIndex: srIndex,
          activeCriteria: criteria
        }
      )
    ), criteria === criterias.not && /* @__PURE__ */ React.createElement(
      RadioGroup,
      {
        sx: {
          margin: theme.spacing(1)
        },
        value: notConditionType,
        onChange: (_event, value) => handleNotConditionTypeChange(value)
      },
      /* @__PURE__ */ React.createElement(
        FormControlLabel,
        {
          value: NotConditionType.SimpleCondition,
          control: /* @__PURE__ */ React.createElement(Radio, { color: "primary" }),
          label: "Add rule",
          sx: {
            marginTop: theme.spacing(1)
          }
        }
      ),
      notConditionType === NotConditionType.SimpleCondition && /* @__PURE__ */ React.createElement(
        ConditionsFormRowFields,
        {
          oldCondition: conditionRow.not ?? getDefaultRule(selPluginResourceType),
          onRuleChange,
          conditionRow,
          criteria,
          conditionRulesData,
          setErrors,
          optionDisabled: (ruleOption) => ruleOptionDisabled(
            ruleOption,
            conditionRow.not ? [conditionRow.not] : void 0
          ),
          setRemoveAllClicked
        }
      ),
      /* @__PURE__ */ React.createElement(
        FormControlLabel,
        {
          value: NotConditionType.NestedCondition,
          control: /* @__PURE__ */ React.createElement(Radio, { color: "primary" }),
          label: /* @__PURE__ */ React.createElement(AddNestedConditionButton, null),
          sx: {
            marginTop: theme.spacing(1)
          }
        }
      )
    ), /* @__PURE__ */ React.createElement(
      ComplexConditionRowButtons,
      {
        conditionRow,
        onRuleChange,
        criteria,
        selPluginResourceType,
        updateErrors,
        isNestedConditionRule,
        handleAddNestedCondition
      }
    ), nestedConditionRow?.length > 0 && nestedConditionRow.map(
      (nc, nestedConditionIndex) => renderNestedConditionRow(nc, nestedConditionIndex)
    ))
  );
};

export { ConditionsFormRow };
//# sourceMappingURL=ConditionsFormRow.esm.js.map
