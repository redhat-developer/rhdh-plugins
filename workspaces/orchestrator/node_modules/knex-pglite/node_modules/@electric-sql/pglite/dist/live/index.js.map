{"version":3,"sources":["../../src/live/index.ts"],"sourcesContent":["import type {\n  Extension,\n  PGliteInterface,\n  Results,\n  Transaction,\n} from '../interface'\nimport type {\n  LiveQueryOptions,\n  LiveIncrementalQueryOptions,\n  LiveChangesOptions,\n  LiveNamespace,\n  LiveQuery,\n  LiveChanges,\n  Change,\n  LiveQueryResults,\n} from './interface'\nimport { uuid, formatQuery, debounceMutex } from '../utils.js'\n\nexport type {\n  LiveNamespace,\n  LiveQuery,\n  LiveChanges,\n  Change,\n  LiveQueryResults,\n} from './interface.js'\n\nconst MAX_RETRIES = 5\n\nconst setup = async (pg: PGliteInterface, _emscriptenOpts: any) => {\n  // The notify triggers are only ever added and never removed\n  // Keep track of which triggers have been added to avoid adding them multiple times\n  const tableNotifyTriggersAdded = new Set<string>()\n\n  const namespaceObj: LiveNamespace = {\n    async query<T>(\n      query: string | LiveQueryOptions<T>,\n      params?: any[] | null,\n      callback?: (results: Results<T>) => void,\n    ) {\n      let signal: AbortSignal | undefined\n      let offset: number | undefined\n      let limit: number | undefined\n      if (typeof query !== 'string') {\n        signal = query.signal\n        params = query.params\n        callback = query.callback\n        offset = query.offset\n        limit = query.limit\n        query = query.query\n      }\n\n      // Offset and limit must be provided together\n      if ((offset === undefined) !== (limit === undefined)) {\n        throw new Error('offset and limit must be provided together')\n      }\n\n      const isWindowed = offset !== undefined && limit !== undefined\n      let totalCount: number | undefined = undefined\n\n      if (\n        isWindowed &&\n        (typeof offset !== 'number' ||\n          isNaN(offset) ||\n          typeof limit !== 'number' ||\n          isNaN(limit))\n      ) {\n        throw new Error('offset and limit must be numbers')\n      }\n\n      let callbacks: Array<(results: Results<T>) => void> = callback\n        ? [callback]\n        : []\n      const id = uuid().replace(/-/g, '')\n      let dead = false\n\n      let results: LiveQueryResults<T>\n      let tables: { table_name: string; schema_name: string }[]\n\n      const init = async () => {\n        await pg.transaction(async (tx) => {\n          // Create a temporary view with the query\n          const formattedQuery =\n            params && params.length > 0\n              ? await formatQuery(pg, query, params, tx)\n              : query\n          await tx.exec(\n            `CREATE OR REPLACE TEMP VIEW live_query_${id}_view AS ${formattedQuery}`,\n          )\n\n          // Get the tables used in the view and add triggers to notify when they change\n          tables = await getTablesForView(tx, `live_query_${id}_view`)\n          await addNotifyTriggersToTables(tx, tables, tableNotifyTriggersAdded)\n\n          if (isWindowed) {\n            await tx.exec(`\n              PREPARE live_query_${id}_get(int, int) AS\n              SELECT * FROM live_query_${id}_view\n              LIMIT $1 OFFSET $2;\n            `)\n            await tx.exec(`\n              PREPARE live_query_${id}_get_total_count AS\n              SELECT COUNT(*) FROM live_query_${id}_view;\n            `)\n            totalCount = (\n              await tx.query<{ count: number }>(\n                `EXECUTE live_query_${id}_get_total_count;`,\n              )\n            ).rows[0].count\n            results = {\n              ...(await tx.query<T>(\n                `EXECUTE live_query_${id}_get(${limit}, ${offset});`,\n              )),\n              offset,\n              limit,\n              totalCount,\n            }\n          } else {\n            await tx.exec(`\n              PREPARE live_query_${id}_get AS\n              SELECT * FROM live_query_${id}_view;\n            `)\n            results = await tx.query<T>(`EXECUTE live_query_${id}_get;`)\n          }\n        })\n      }\n      await init()\n\n      // Function to refresh the query\n      const refresh = debounceMutex(\n        async ({\n          offset: newOffset,\n          limit: newLimit,\n        }: {\n          offset?: number\n          limit?: number\n        } = {}) => {\n          // We can optionally provide new offset and limit values to refresh with\n          if (\n            !isWindowed &&\n            (newOffset !== undefined || newLimit !== undefined)\n          ) {\n            throw new Error(\n              'offset and limit cannot be provided for non-windowed queries',\n            )\n          }\n          if (\n            (newOffset &&\n              (typeof newOffset !== 'number' || isNaN(newOffset))) ||\n            (newLimit && (typeof newLimit !== 'number' || isNaN(newLimit)))\n          ) {\n            throw new Error('offset and limit must be numbers')\n          }\n          offset = newOffset ?? offset\n          limit = newLimit ?? limit\n\n          const run = async (count = 0) => {\n            if (callbacks.length === 0) {\n              return\n            }\n            try {\n              if (isWindowed) {\n                // For a windowed query we defer the refresh of the total count until\n                // after we have returned the results with the old total count. This\n                // is due to a count(*) being a fairly slow query and we want to update\n                // the rows on screen as quickly as possible.\n                results = {\n                  ...(await pg.query<T>(\n                    `EXECUTE live_query_${id}_get(${limit}, ${offset});`,\n                  )),\n                  offset,\n                  limit,\n                  totalCount, // This is the old total count\n                }\n              } else {\n                results = await pg.query<T>(`EXECUTE live_query_${id}_get;`)\n              }\n            } catch (e) {\n              const msg = (e as Error).message\n              if (\n                msg.startsWith(`prepared statement \"live_query_${id}`) &&\n                msg.endsWith('does not exist')\n              ) {\n                // If the prepared statement does not exist, reset and try again\n                // This can happen if using the multi-tab worker\n                if (count > MAX_RETRIES) {\n                  throw e\n                }\n                await init()\n                run(count + 1)\n              } else {\n                throw e\n              }\n            }\n\n            runResultCallbacks(callbacks, results)\n\n            // Update the total count\n            // If the total count has changed, refresh the query\n            if (isWindowed) {\n              const newTotalCount = (\n                await pg.query<{ count: number }>(\n                  `EXECUTE live_query_${id}_get_total_count;`,\n                )\n              ).rows[0].count\n              if (newTotalCount !== totalCount) {\n                // The total count has changed, refresh the query\n                totalCount = newTotalCount\n                refresh()\n              }\n            }\n          }\n          await run()\n        },\n      )\n\n      // Setup the listeners\n      const unsubList: Array<() => Promise<void>> = await Promise.all(\n        tables!.map((table) =>\n          pg.listen(\n            `table_change__${table.schema_name}__${table.table_name}`,\n            async () => {\n              refresh()\n            },\n          ),\n        ),\n      )\n\n      // Function to subscribe to the query\n      const subscribe = (callback: (results: Results<T>) => void) => {\n        if (dead) {\n          throw new Error(\n            'Live query is no longer active and cannot be subscribed to',\n          )\n        }\n        callbacks.push(callback)\n      }\n\n      // Function to unsubscribe from the query\n      // If no function is provided, unsubscribe all callbacks\n      // If there are no callbacks, unsubscribe from the notify triggers\n      const unsubscribe = async (callback?: (results: Results<T>) => void) => {\n        if (callback) {\n          callbacks = callbacks.filter((callback) => callback !== callback)\n        } else {\n          callbacks = []\n        }\n        if (callbacks.length === 0) {\n          dead = true\n          await Promise.all(unsubList.map((unsub) => unsub()))\n          await pg.exec(`\n            DROP VIEW IF EXISTS live_query_${id}_view;\n            DEALLOCATE live_query_${id}_get;\n          `)\n        }\n      }\n\n      // If the signal has already been aborted, unsubscribe\n      if (signal?.aborted) {\n        await unsubscribe()\n      } else {\n        // Add an event listener to unsubscribe if the signal is aborted\n        signal?.addEventListener(\n          'abort',\n          () => {\n            unsubscribe()\n          },\n          { once: true },\n        )\n      }\n\n      // Run the callback with the initial results\n      runResultCallbacks(callbacks, results!)\n\n      // Return the initial results\n      return {\n        initialResults: results!,\n        subscribe,\n        unsubscribe,\n        refresh,\n      } satisfies LiveQuery<T>\n    },\n\n    async changes<T>(\n      query: string | LiveChangesOptions<T>,\n      params?: any[] | null,\n      key?: string,\n      callback?: (changes: Array<Change<T>>) => void,\n    ) {\n      let signal: AbortSignal | undefined\n      if (typeof query !== 'string') {\n        signal = query.signal\n        params = query.params\n        key = query.key\n        callback = query.callback\n        query = query.query\n      }\n      if (!key) {\n        throw new Error('key is required for changes queries')\n      }\n      let callbacks: Array<(changes: Array<Change<T>>) => void> = callback\n        ? [callback]\n        : []\n      const id = uuid().replace(/-/g, '')\n      let dead = false\n\n      let tables: { table_name: string; schema_name: string }[]\n      let stateSwitch: 1 | 2 = 1\n      let changes: Results<Change<T>>\n\n      const init = async () => {\n        await pg.transaction(async (tx) => {\n          // Create a temporary view with the query\n          const formattedQuery = await formatQuery(pg, query, params, tx)\n          await tx.query(\n            `CREATE OR REPLACE TEMP VIEW live_query_${id}_view AS ${formattedQuery}`,\n          )\n\n          // Get the tables used in the view and add triggers to notify when they change\n          tables = await getTablesForView(tx, `live_query_${id}_view`)\n          await addNotifyTriggersToTables(tx, tables, tableNotifyTriggersAdded)\n\n          // Get the columns of the view\n          const columns = [\n            ...(\n              await tx.query<any>(`\n                SELECT column_name, data_type, udt_name\n                FROM information_schema.columns \n                WHERE table_name = 'live_query_${id}_view'\n              `)\n            ).rows,\n            { column_name: '__after__', data_type: 'integer' },\n          ]\n\n          // Init state tables as empty temp table\n          await tx.exec(`\n            CREATE TEMP TABLE live_query_${id}_state1 (LIKE live_query_${id}_view INCLUDING ALL);\n            CREATE TEMP TABLE live_query_${id}_state2 (LIKE live_query_${id}_view INCLUDING ALL);\n          `)\n\n          // Create Diff views and prepared statements\n          for (const curr of [1, 2]) {\n            const prev = curr === 1 ? 2 : 1\n            await tx.exec(`\n              PREPARE live_query_${id}_diff${curr} AS\n              WITH\n                prev AS (SELECT LAG(\"${key}\") OVER () as __after__, * FROM live_query_${id}_state${prev}),\n                curr AS (SELECT LAG(\"${key}\") OVER () as __after__, * FROM live_query_${id}_state${curr}),\n                data_diff AS (\n                  -- INSERT operations: Include all columns\n                  SELECT \n                    'INSERT' AS __op__,\n                    ${columns\n                      .map(\n                        ({ column_name }) =>\n                          `curr.\"${column_name}\" AS \"${column_name}\"`,\n                      )\n                      .join(',\\n')},\n                    ARRAY[]::text[] AS __changed_columns__\n                  FROM curr\n                  LEFT JOIN prev ON curr.${key} = prev.${key}\n                  WHERE prev.${key} IS NULL\n                UNION ALL\n                  -- DELETE operations: Include only the primary key\n                  SELECT \n                    'DELETE' AS __op__,\n                    ${columns\n                      .map(({ column_name, data_type, udt_name }) => {\n                        if (column_name === key) {\n                          return `prev.\"${column_name}\" AS \"${column_name}\"`\n                        } else {\n                          return `NULL${data_type === 'USER-DEFINED' ? `::${udt_name}` : ``} AS \"${column_name}\"`\n                        }\n                      })\n                      .join(',\\n')},\n                      ARRAY[]::text[] AS __changed_columns__\n                  FROM prev\n                  LEFT JOIN curr ON prev.${key} = curr.${key}\n                  WHERE curr.${key} IS NULL\n                UNION ALL\n                  -- UPDATE operations: Include only changed columns\n                  SELECT \n                    'UPDATE' AS __op__,\n                    ${columns\n                      .map(({ column_name, data_type, udt_name }) =>\n                        column_name === key\n                          ? `curr.\"${column_name}\" AS \"${column_name}\"`\n                          : `CASE \n                              WHEN curr.\"${column_name}\" IS DISTINCT FROM prev.\"${column_name}\" \n                              THEN curr.\"${column_name}\"\n                              ELSE NULL${data_type === 'USER-DEFINED' ? `::${udt_name}` : ``}\n                              END AS \"${column_name}\"`,\n                      )\n                      .join(',\\n')},\n                      ARRAY(SELECT unnest FROM unnest(ARRAY[${columns\n                        .filter(({ column_name }) => column_name !== key)\n                        .map(\n                          ({ column_name }) =>\n                            `CASE\n                              WHEN curr.\"${column_name}\" IS DISTINCT FROM prev.\"${column_name}\" \n                              THEN '${column_name}' \n                              ELSE NULL \n                              END`,\n                        )\n                        .join(\n                          ', ',\n                        )}]) WHERE unnest IS NOT NULL) AS __changed_columns__\n                  FROM curr\n                  INNER JOIN prev ON curr.${key} = prev.${key}\n                  WHERE NOT (curr IS NOT DISTINCT FROM prev)\n                )\n              SELECT * FROM data_diff;\n            `)\n          }\n        })\n      }\n\n      await init()\n\n      const refresh = debounceMutex(async () => {\n        if (callbacks.length === 0 && changes) {\n          return\n        }\n        let reset = false\n        for (let i = 0; i < 5; i++) {\n          try {\n            await pg.transaction(async (tx) => {\n              // Populate the state table\n              await tx.exec(`\n                INSERT INTO live_query_${id}_state${stateSwitch} \n                  SELECT * FROM live_query_${id}_view;\n              `)\n\n              // Get the changes\n              changes = await tx.query<any>(\n                `EXECUTE live_query_${id}_diff${stateSwitch};`,\n              )\n\n              // Switch state\n              stateSwitch = stateSwitch === 1 ? 2 : 1\n\n              // Truncate the old state table\n              await tx.exec(`\n                TRUNCATE live_query_${id}_state${stateSwitch};\n              `)\n            })\n            break\n          } catch (e) {\n            const msg = (e as Error).message\n            if (\n              msg ===\n              `relation \"live_query_${id}_state${stateSwitch}\" does not exist`\n            ) {\n              // If the state table does not exist, reset and try again\n              // This can happen if using the multi-tab worker\n              reset = true\n              await init()\n              continue\n            } else {\n              throw e\n            }\n          }\n        }\n\n        runChangeCallbacks(callbacks, [\n          ...(reset\n            ? [\n                {\n                  __op__: 'RESET' as const,\n                },\n              ]\n            : []),\n          ...changes!.rows,\n        ])\n      })\n\n      // Setup the listeners\n      const unsubList: Array<() => Promise<void>> = await Promise.all(\n        tables!.map((table) =>\n          pg.listen(\n            `table_change__${table.schema_name}__${table.table_name}`,\n            async () => refresh(),\n          ),\n        ),\n      )\n\n      // Function to subscribe to the query\n      const subscribe = (callback: (changes: Array<Change<T>>) => void) => {\n        if (dead) {\n          throw new Error(\n            'Live query is no longer active and cannot be subscribed to',\n          )\n        }\n        callbacks.push(callback)\n      }\n\n      // Function to unsubscribe from the query\n      const unsubscribe = async (\n        callback?: (changes: Array<Change<T>>) => void,\n      ) => {\n        if (callback) {\n          callbacks = callbacks.filter((callback) => callback !== callback)\n        } else {\n          callbacks = []\n        }\n        if (callbacks.length === 0) {\n          dead = true\n          await Promise.all(unsubList.map((unsub) => unsub()))\n          await pg.exec(`\n            DROP VIEW IF EXISTS live_query_${id}_view;\n            DROP TABLE IF EXISTS live_query_${id}_state1;\n            DROP TABLE IF EXISTS live_query_${id}_state2;\n            DEALLOCATE live_query_${id}_diff1;\n            DEALLOCATE live_query_${id}_diff2;\n          `)\n        }\n      }\n\n      // If the signal has already been aborted, unsubscribe\n      if (signal?.aborted) {\n        await unsubscribe()\n      } else {\n        // Add an event listener to unsubscribe if the signal is aborted\n        signal?.addEventListener(\n          'abort',\n          () => {\n            unsubscribe()\n          },\n          { once: true },\n        )\n      }\n\n      // Run the callback with the initial changes\n      await refresh()\n\n      // Fields\n      const fields = changes!.fields.filter(\n        (field) =>\n          !['__after__', '__op__', '__changed_columns__'].includes(field.name),\n      )\n\n      // Return the initial results\n      return {\n        fields,\n        initialChanges: changes!.rows,\n        subscribe,\n        unsubscribe,\n        refresh,\n      } satisfies LiveChanges<T>\n    },\n\n    async incrementalQuery<T>(\n      query: string | LiveIncrementalQueryOptions<T>,\n      params?: any[] | null,\n      key?: string,\n      callback?: (results: Results<T>) => void,\n    ) {\n      let signal: AbortSignal | undefined\n      if (typeof query !== 'string') {\n        signal = query.signal\n        params = query.params\n        key = query.key\n        callback = query.callback\n        query = query.query\n      }\n      if (!key) {\n        throw new Error('key is required for incremental queries')\n      }\n      let callbacks: Array<(results: Results<T>) => void> = callback\n        ? [callback]\n        : []\n      const rowsMap: Map<any, any> = new Map()\n      const afterMap: Map<any, any> = new Map()\n      let lastRows: T[] = []\n      let firstRun = true\n\n      const {\n        fields,\n        unsubscribe: unsubscribeChanges,\n        refresh,\n      } = await namespaceObj.changes<T>(query, params, key, (changes) => {\n        // Process the changes\n        for (const change of changes) {\n          const {\n            __op__: op,\n            __changed_columns__: changedColumns,\n            ...obj\n          } = change as typeof change & { [key: string]: any }\n          switch (op) {\n            case 'RESET':\n              rowsMap.clear()\n              afterMap.clear()\n              break\n            case 'INSERT':\n              rowsMap.set(obj[key], obj)\n              afterMap.set(obj.__after__, obj[key])\n              break\n            case 'DELETE': {\n              const oldObj = rowsMap.get(obj[key])\n              rowsMap.delete(obj[key])\n              // null is the starting point, we don't delete it as another insert\n              // may have happened thats replacing it\n              if (oldObj.__after__ !== null) {\n                afterMap.delete(oldObj.__after__)\n              }\n              break\n            }\n            case 'UPDATE': {\n              const newObj = { ...(rowsMap.get(obj[key]) ?? {}) }\n              for (const columnName of changedColumns) {\n                newObj[columnName] = obj[columnName]\n                if (columnName === '__after__') {\n                  afterMap.set(obj.__after__, obj[key])\n                }\n              }\n              rowsMap.set(obj[key], newObj)\n              break\n            }\n          }\n        }\n\n        // Get the rows in order\n        const rows: T[] = []\n        let lastKey: any = null\n        for (let i = 0; i < rowsMap.size; i++) {\n          const nextKey = afterMap.get(lastKey)\n          const obj = rowsMap.get(nextKey)\n          if (!obj) {\n            break\n          }\n          // Remove the __after__ key from the exposed row\n          const cleanObj = { ...obj }\n          delete cleanObj.__after__\n          rows.push(cleanObj)\n          lastKey = nextKey\n        }\n        lastRows = rows\n\n        // Run the callbacks\n        if (!firstRun) {\n          runResultCallbacks(callbacks, {\n            rows,\n            fields,\n          })\n        }\n      })\n\n      firstRun = false\n      runResultCallbacks(callbacks, {\n        rows: lastRows,\n        fields,\n      })\n\n      const subscribe = (callback: (results: Results<T>) => void) => {\n        callbacks.push(callback)\n      }\n\n      const unsubscribe = async (callback?: (results: Results<T>) => void) => {\n        if (callback) {\n          callbacks = callbacks.filter((callback) => callback !== callback)\n        } else {\n          callbacks = []\n        }\n        if (callbacks.length === 0) {\n          await unsubscribeChanges()\n        }\n      }\n\n      if (signal?.aborted) {\n        await unsubscribe()\n      } else {\n        signal?.addEventListener(\n          'abort',\n          () => {\n            unsubscribe()\n          },\n          { once: true },\n        )\n      }\n\n      return {\n        initialResults: {\n          rows: lastRows,\n          fields,\n        },\n        subscribe,\n        unsubscribe,\n        refresh,\n      } satisfies LiveQuery<T>\n    },\n  }\n\n  return {\n    namespaceObj,\n  }\n}\n\nexport const live = {\n  name: 'Live Queries',\n  setup,\n} satisfies Extension\n\nexport type PGliteWithLive = PGliteInterface & {\n  live: LiveNamespace\n}\n\n/**\n * Get a list of all the tables used in a view, recursively\n * @param tx a transaction or PGlite instance\n * @param viewName the name of the view\n * @returns list of tables used in the view\n */\nasync function getTablesForView(\n  tx: Transaction | PGliteInterface,\n  viewName: string,\n): Promise<{ table_name: string; schema_name: string }[]> {\n  const result = await tx.query<{\n    table_name: string\n    schema_name: string\n  }>(\n    `\n      WITH RECURSIVE view_dependencies AS (\n        -- Base case: Get the initial view's dependencies\n        SELECT DISTINCT\n          cl.relname AS dependent_name,\n          n.nspname AS schema_name,\n          cl.relkind = 'v' AS is_view\n        FROM pg_rewrite r\n        JOIN pg_depend d ON r.oid = d.objid\n        JOIN pg_class cl ON d.refobjid = cl.oid\n        JOIN pg_namespace n ON cl.relnamespace = n.oid\n        WHERE\n          r.ev_class = (\n              SELECT oid FROM pg_class WHERE relname = $1 AND relkind = 'v'\n          )\n          AND d.deptype = 'n'\n\n        UNION ALL\n\n        -- Recursive case: Traverse dependencies for views\n        SELECT DISTINCT\n          cl.relname AS dependent_name,\n          n.nspname AS schema_name,\n          cl.relkind = 'v' AS is_view\n        FROM view_dependencies vd\n        JOIN pg_rewrite r ON vd.dependent_name = (\n          SELECT relname FROM pg_class WHERE oid = r.ev_class AND relkind = 'v'\n        )\n        JOIN pg_depend d ON r.oid = d.objid\n        JOIN pg_class cl ON d.refobjid = cl.oid\n        JOIN pg_namespace n ON cl.relnamespace = n.oid\n        WHERE d.deptype = 'n'\n      )\n      SELECT DISTINCT\n        dependent_name AS table_name,\n        schema_name\n      FROM view_dependencies\n      WHERE NOT is_view; -- Exclude intermediate views\n    `,\n    [viewName],\n  )\n\n  return result.rows.map((row) => ({\n    table_name: row.table_name,\n    schema_name: row.schema_name,\n  }))\n}\n\n/**\n * Add triggers to tables to notify when they change\n * @param tx a transaction or PGlite instance\n * @param tables list of tables to add triggers to\n */\nasync function addNotifyTriggersToTables(\n  tx: Transaction | PGliteInterface,\n  tables: { table_name: string; schema_name: string }[],\n  tableNotifyTriggersAdded: Set<string>,\n) {\n  const triggers = tables\n    .filter(\n      (table) =>\n        !tableNotifyTriggersAdded.has(\n          `${table.schema_name}_${table.table_name}`,\n        ),\n    )\n    .map((table) => {\n      return `\n      CREATE OR REPLACE FUNCTION \"_notify_${table.schema_name}_${table.table_name}\"() RETURNS TRIGGER AS $$\n      BEGIN\n        PERFORM pg_notify('table_change__${table.schema_name}__${table.table_name}', '');\n        RETURN NULL;\n      END;\n      $$ LANGUAGE plpgsql;\n      CREATE OR REPLACE TRIGGER \"_notify_trigger_${table.schema_name}_${table.table_name}\"\n      AFTER INSERT OR UPDATE OR DELETE ON \"${table.schema_name}\".\"${table.table_name}\"\n      FOR EACH STATEMENT EXECUTE FUNCTION \"_notify_${table.schema_name}_${table.table_name}\"();\n      `\n    })\n    .join('\\n')\n  if (triggers.trim() !== '') {\n    await tx.exec(triggers)\n  }\n  tables.map((table) =>\n    tableNotifyTriggersAdded.add(`${table.schema_name}_${table.table_name}`),\n  )\n}\n\nconst runResultCallbacks = <T>(\n  callbacks: Array<(results: Results<T>) => void>,\n  results: Results<T>,\n) => {\n  for (const callback of callbacks) {\n    callback(results)\n  }\n}\n\nconst runChangeCallbacks = <T>(\n  callbacks: Array<(changes: Array<Change<T>>) => void>,\n  changes: Array<Change<T>>,\n) => {\n  for (const callback of callbacks) {\n    callback(changes)\n  }\n}\n"],"mappings":"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","names":["init_esm_shims","MAX_RETRIES","setup","pg","_emscriptenOpts","tableNotifyTriggersAdded","namespaceObj","query","params","callback","signal","offset","limit","isWindowed","totalCount","callbacks","id","uuid","dead","results","tables","init","tx","formattedQuery","formatQuery","getTablesForView","addNotifyTriggersToTables","refresh","debounceMutex","newOffset","newLimit","run","count","e","msg","runResultCallbacks","newTotalCount","unsubList","table","subscribe","unsubscribe","unsub","key","stateSwitch","changes","columns","curr","prev","column_name","data_type","udt_name","reset","i","runChangeCallbacks","field","rowsMap","afterMap","lastRows","firstRun","fields","unsubscribeChanges","change","op","changedColumns","obj","oldObj","newObj","columnName","rows","lastKey","nextKey","cleanObj","live","viewName","row","triggers"]}