import{a as j}from"../chunk-A7RFOIQ7.js";import{u as N,x as z}from"../chunk-EADU5A67.js";import"../chunk-STOZMFXW.js";import{e as t,f as d,g as u,h as p,j as Q}from"../chunk-BTBUZ646.js";Q();var W,C,_,M,B,m,L,x,k,T,A,O,E,v,G,P,b,I,$,c,K,D,w,J,F=class F extends j{constructor(e,r){super();d(this,c);d(this,W);d(this,C,0);d(this,_,!1);d(this,M,!1);d(this,B,!1);d(this,m,new EventTarget);d(this,L);d(this,x,!1);d(this,k);d(this,T);d(this,A);d(this,O);d(this,E);d(this,v);d(this,G);d(this,P,new Map);d(this,b,new Set);d(this,I);d(this,$,[]);u(this,k,e),u(this,L,N()),u(this,I,r?.extensions??{}),u(this,A,new Promise(i=>{t(this,k).addEventListener("message",s=>{if(s.data.type==="here")i();else throw new Error("Invalid message")},{once:!0})})),u(this,O,new Promise(i=>{let s=o=>{o.data.type==="ready"&&(u(this,T,o.data.id),t(this,k).removeEventListener("message",s),i())};t(this,k).addEventListener("message",s)})),u(this,W,p(this,c,K).call(this,r))}static async create(e,r){let i=new F(e,r);return await t(i,W),i}get waitReady(){return new Promise(e=>{t(this,W).then(()=>{t(this,x)?e():e(new Promise(r=>{t(this,m).addEventListener("connected",()=>{r()})}))})})}get debug(){return t(this,C)}get ready(){return t(this,_)}get closed(){return t(this,M)}get isLeader(){return t(this,B)}async close(){var e;t(this,M)||(u(this,M,!0),t(this,E)?.close(),t(this,v)?.close(),(e=t(this,G))==null||e.call(this),t(this,k).terminate())}async[Symbol.asyncDispose](){await this.close()}async execProtocolRaw(e){return await p(this,c,w).call(this,"execProtocolRaw",e)}async execProtocol(e){return await p(this,c,w).call(this,"execProtocol",e)}async syncToFs(){await p(this,c,w).call(this,"syncToFs")}async listen(e,r){let i=z(e);return t(this,P).has(i)||t(this,P).set(i,new Set),t(this,P).get(i).add(r),await this.exec(`LISTEN ${e}`),async()=>{await this.unlisten(i,r)}}async unlisten(e,r){await this.waitReady,r?t(this,P).get(e)?.delete(r):t(this,P).delete(e),t(this,P).get(e)?.size===0&&await this.exec(`UNLISTEN ${e}`)}onNotification(e){return t(this,b).add(e),()=>{t(this,b).delete(e)}}offNotification(e){t(this,b).delete(e)}async dumpDataDir(){return await p(this,c,w).call(this,"dumpDataDir")}onLeaderChange(e){return t(this,m).addEventListener("leader-change",e),()=>{t(this,m).removeEventListener("leader-change",e)}}offLeaderChange(e){t(this,m).removeEventListener("leader-change",e)}async _handleBlob(e){await p(this,c,w).call(this,"_handleBlob",e)}async _getWrittenBlob(){return await p(this,c,w).call(this,"_getWrittenBlob")}async _cleanupBlob(){await p(this,c,w).call(this,"_cleanupBlob")}async _checkReady(){await this.waitReady}async _runExclusiveQuery(e){await p(this,c,w).call(this,"_acquireQueryLock");try{return await e()}finally{await p(this,c,w).call(this,"_releaseQueryLock")}}async _runExclusiveTransaction(e){await p(this,c,w).call(this,"_acquireTransactionLock");try{return await e()}finally{await p(this,c,w).call(this,"_releaseTransactionLock")}}};W=new WeakMap,C=new WeakMap,_=new WeakMap,M=new WeakMap,B=new WeakMap,m=new WeakMap,L=new WeakMap,x=new WeakMap,k=new WeakMap,T=new WeakMap,A=new WeakMap,O=new WeakMap,E=new WeakMap,v=new WeakMap,G=new WeakMap,P=new WeakMap,b=new WeakMap,I=new WeakMap,$=new WeakMap,c=new WeakSet,K=async function(e={}){for(let[a,y]of Object.entries(t(this,I))){if(y instanceof URL)throw new Error("URL extensions are not supported on the client side of a worker");{let l=await y.setup(this,{},!0);if(l.emscriptenOpts&&console.warn(`PGlite extension ${a} returned emscriptenOpts, these are not supported on the client side of a worker`),l.namespaceObj){let R=this;R[a]=l.namespaceObj}l.bundlePath&&console.warn(`PGlite extension ${a} returned bundlePath, this is not supported on the client side of a worker`),l.init&&await l.init(),l.close&&t(this,$).push(l.close)}}await t(this,A);let{extensions:r,...i}=e;t(this,k).postMessage({type:"init",options:i}),await t(this,O);let s=`pglite-tab-close:${t(this,L)}`;u(this,G,await q(s));let o=`pglite-broadcast:${t(this,T)}`;u(this,E,new BroadcastChannel(o));let h=`pglite-tab:${t(this,L)}`;u(this,v,new BroadcastChannel(h)),t(this,E).addEventListener("message",async a=>{a.data.type==="leader-here"?(u(this,x,!1),t(this,m).dispatchEvent(new Event("leader-change")),p(this,c,D).call(this)):a.data.type==="notify"&&p(this,c,J).call(this,a.data.channel,a.data.payload)}),t(this,v).addEventListener("message",async a=>{a.data.type==="connected"&&(u(this,x,!0),t(this,m).dispatchEvent(new Event("connected")),u(this,C,await p(this,c,w).call(this,"getDebugLevel")),u(this,_,!0))}),t(this,k).addEventListener("message",async a=>{a.data.type==="leader-now"&&(u(this,B,!0),t(this,m).dispatchEvent(new Event("leader-change")))}),p(this,c,D).call(this),this._initArrayTypes()},D=async function(){t(this,x)||(t(this,E).postMessage({type:"tab-here",id:t(this,L)}),setTimeout(()=>p(this,c,D).call(this),16))},w=async function(e,...r){let i=N(),s={type:"rpc-call",callId:i,method:e,args:r};return t(this,v).postMessage(s),await new Promise((o,h)=>{let a=R=>{if(R.data.callId!==i)return;l();let f=R.data;if(f.type==="rpc-return")o(f.result);else if(f.type==="rpc-error"){let S=new Error(f.error.message);Object.assign(S,f.error),h(S)}else h(new Error("Invalid message"))},y=()=>{l(),h(new U)},l=()=>{t(this,v).removeEventListener("message",a),t(this,m).removeEventListener("leader-change",y)};t(this,m).addEventListener("leader-change",y),t(this,v).addEventListener("message",a)})},J=function(e,r){let i=t(this,P).get(e);if(i)for(let s of i)queueMicrotask(()=>s(r));for(let s of t(this,b))queueMicrotask(()=>s(e,r))};var H=F;async function se({init:g}){postMessage({type:"here"});let n=await new Promise(y=>{addEventListener("message",l=>{l.data.type==="init"&&y(l.data.options)},{once:!0})}),e=n.id??`${import.meta.url}:${n.dataDir??""}`;postMessage({type:"ready",id:e});let r=`pglite-election-lock:${e}`,i=`pglite-broadcast:${e}`,s=new BroadcastChannel(i),o=new Set;await q(r);let h=g(n);s.onmessage=async y=>{let l=y.data;switch(l.type){case"tab-here":V(l.id,await h,o);break}},s.postMessage({type:"leader-here",id:e}),postMessage({type:"leader-now"}),(await h).onNotification((y,l)=>{s.postMessage({type:"notify",channel:y,payload:l})})}function V(g,n,e){if(e.has(g))return;e.add(g);let r=`pglite-tab:${g}`,i=`pglite-tab-close:${g}`,s=new BroadcastChannel(r);navigator.locks.request(i,()=>new Promise(h=>{s.close(),e.delete(g),h()}));let o=X(g,n);s.addEventListener("message",async h=>{let a=h.data;switch(a.type){case"rpc-call":{await n.waitReady;let{callId:y,method:l,args:R}=a;try{let f=await o[l](...R);s.postMessage({type:"rpc-return",callId:y,result:f})}catch(f){console.error(f),s.postMessage({type:"rpc-error",callId:y,error:{message:f.message}})}break}}}),s.postMessage({type:"connected"})}function X(g,n){let e=null,r=null,i=`pglite-tab-close:${g}`;return q(i).then(()=>{r&&n.exec("ROLLBACK"),e?.(),r?.()}),{async getDebugLevel(){return n.debug},async close(){await n.close()},async execProtocol(s){let{messages:o,data:h}=await n.execProtocol(s);if(h.byteLength!==h.buffer.byteLength){let a=new ArrayBuffer(h.byteLength),y=new Uint8Array(a);return y.set(h),{messages:o,data:y}}else return{messages:o,data:h}},async execProtocolRaw(s){let o=await n.execProtocolRaw(s);if(o.byteLength!==o.buffer.byteLength){let h=new ArrayBuffer(o.byteLength),a=new Uint8Array(h);return a.set(o),a}else return o},async dumpDataDir(){return await n.dumpDataDir()},async syncToFs(){return await n.syncToFs()},async _handleBlob(s){return await n._handleBlob(s)},async _getWrittenBlob(){return await n._getWrittenBlob()},async _cleanupBlob(){return await n._cleanupBlob()},async _checkReady(){return await n._checkReady()},async _acquireQueryLock(){return new Promise(s=>{n._runExclusiveQuery(()=>new Promise(o=>{e=o,s()}))})},async _releaseQueryLock(){e?.(),e=null},async _acquireTransactionLock(){return new Promise(s=>{n._runExclusiveTransaction(()=>new Promise(o=>{r=o,s()}))})},async _releaseTransactionLock(){r?.(),r=null}}}var U=class extends Error{constructor(){super("Leader changed, pending operation in indeterminate state")}};async function q(g){let n;return await new Promise(e=>{navigator.locks.request(g,()=>new Promise(r=>{n=r,e()}))}),n}export{U as LeaderChangedError,H as PGliteWorker,se as worker};
//# sourceMappingURL=index.js.map