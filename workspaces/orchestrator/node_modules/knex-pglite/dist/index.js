"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/* eslint-disable @typescript-eslint/no-explicit-any */
const pglite_1 = require("@electric-sql/pglite");
// eslint-disable-next-line @typescript-eslint/no-require-imports
const Client_PG = require("knex/lib/dialects/postgres/index.js");
class ClientPGLiteImpl extends Client_PG {
    constructor(config) {
        super(Object.assign(Object.assign({}, config), { 
            // Enforce a single connection:
            pool: { min: 1, max: 1 } }));
        if (config.pool) {
            throw new Error("PGlite is single user/connection. Pool cannot be configured.");
        }
    }
    _driver() {
        var _a, _b, _c, _d, _e;
        const config = this.config;
        this.pglite =
            (_b = (_a = config.connection) === null || _a === void 0 ? void 0 : _a.pglite) !== null && _b !== void 0 ? _b : new pglite_1.PGlite((_d = (_c = config.connection) === null || _c === void 0 ? void 0 : _c["filename"]) !== null && _d !== void 0 ? _d : (_e = config.connection) === null || _e === void 0 ? void 0 : _e["connectionString"]);
    }
    _acquireOnlyConnection() {
        return __awaiter(this, void 0, void 0, function* () {
            const connection = this.pglite;
            yield connection.waitReady;
            return connection;
        });
    }
    destroyRawConnection(connection) {
        return __awaiter(this, void 0, void 0, function* () {
            // There is only one connection, if this one goes shut down the database
            yield connection.close();
        });
    }
    setSchemaSearchPath(connection, searchPath) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            let path = searchPath || this.searchPath;
            if (!path) {
                return true;
            }
            if (!Array.isArray(path) && typeof path !== "string") {
                throw new TypeError(`knex: Expected searchPath to be Array/String, got: ${typeof path}`);
            }
            if (typeof path === "string") {
                if (path.includes(",")) {
                    const parts = path.split(",");
                    const arraySyntax = `[${parts
                        .map((searchPath) => `'${searchPath}'`)
                        .join(", ")}]`;
                    (_b = (_a = this.logger).warn) === null || _b === void 0 ? void 0 : _b.call(_a, `Detected comma in searchPath "${path}".` +
                        `If you are trying to specify multiple schemas, use Array syntax: ${arraySyntax}`);
                }
                path = [path];
            }
            path = path.map((schemaName) => `"${schemaName}"`).join(",");
            yield connection.query(`set search_path to ${path}`);
            return true;
        });
    }
    checkVersion(connection) {
        return __awaiter(this, void 0, void 0, function* () {
            const resp = yield connection.query("select version();");
            return this._parseVersion(resp.rows[0].version);
        });
    }
    _query(connection, obj) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!obj.sql)
                throw new Error("The query is empty");
            const response = yield connection.query(obj.sql, obj.bindings, obj.options);
            obj.response = response;
            return obj;
        });
    }
    processResponse(obj, runner) {
        var _a, _b;
        const response = Object.assign(Object.assign({}, obj.response), { rowCount: obj.response.affectedRows, command: (_b = (_a = obj.method) === null || _a === void 0 ? void 0 : _a.toUpperCase()) !== null && _b !== void 0 ? _b : "" });
        return super.processResponse(Object.assign(Object.assign({}, obj), { response }), runner);
    }
    _stream(connection, obj, stream) {
        return new Promise((resolver, rejecter) => {
            stream.on("error", rejecter);
            stream.on("end", resolver);
            return this._query(connection, obj)
                .then((obj) => obj.response.rows)
                .then((rows) => rows.forEach((row) => stream.write(row)))
                .catch((err) => {
                stream.emit("error", err);
            })
                .then(() => {
                stream.end();
            });
        });
    }
}
const ClientPGLite = ClientPGLiteImpl;
module.exports = ClientPGLite;
//# sourceMappingURL=index.js.map