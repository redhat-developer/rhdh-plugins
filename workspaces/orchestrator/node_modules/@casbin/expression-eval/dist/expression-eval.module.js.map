{"version":3,"file":"expression-eval.module.js","sources":["../index.ts"],"sourcesContent":["import jsep from 'jsep';\n\n/**\n * Evaluation code from JSEP project, under MIT License.\n * Copyright (c) 2013 Stephen Oney, http://jsep.from.so/\n */\n\n// Default operator precedence from https://github.com/EricSmekens/jsep/blob/master/src/jsep.js#L55\nconst DEFAULT_PRECEDENCE = {\n  '||': 1,\n  '&&': 2,\n  '|': 3,\n  '^': 4,\n  '&': 5,\n  '==': 6,\n  '!=': 6,\n  '===': 6,\n  '!==': 6,\n  '<': 7,\n  '>': 7,\n  '<=': 7,\n  '>=': 7,\n  '<<': 8,\n  '>>': 8,\n  '>>>': 8,\n  '+': 9,\n  '-': 9,\n  '*': 10,\n  '/': 10,\n  '%': 10\n};\n\nconst binops = {\n  '||': function (a, b) { return a || b; },\n  '&&': function (a, b) { return a && b; },\n  '|': function (a, b) { return a | b; },\n  '^': function (a, b) { return a ^ b; },\n  '&': function (a, b) { return a & b; },\n  '==': function (a, b) { return a == b; }, // jshint ignore:line\n  '!=': function (a, b) { return a != b; }, // jshint ignore:line\n  '===': function (a, b) { return a === b; },\n  '!==': function (a, b) { return a !== b; },\n  '<': function (a, b) { return a < b; },\n  '>': function (a, b) { return a > b; },\n  '<=': function (a, b) { return a <= b; },\n  '>=': function (a, b) { return a >= b; },\n  '<<': function (a, b) { return a << b; },\n  '>>': function (a, b) { return a >> b; },\n  '>>>': function (a, b) { return a >>> b; },\n  '+': function (a, b) { return a + b; },\n  '-': function (a, b) { return a - b; },\n  '*': function (a, b) { return a * b; },\n  '/': function (a, b) { return a / b; },\n  '%': function (a, b) { return a % b; }\n};\n\nconst unops = {\n  '-': function (a) { return -a; },\n  '+': function (a) { return +a; },\n  '~': function (a) { return ~a; },\n  '!': function (a) { return !a; },\n};\n\ndeclare type operand = number | string;\ndeclare type unaryCallback = (a: operand) => operand;\ndeclare type binaryCallback = (a: operand, b: operand) => operand;\n\ntype AnyExpression = jsep.ArrayExpression\n  | jsep.BinaryExpression\n  | jsep.MemberExpression\n  | jsep.CallExpression\n  | jsep.ConditionalExpression\n  | jsep.Identifier\n  | jsep.Literal\n  | jsep.LogicalExpression\n  | jsep.ThisExpression\n  | jsep.UnaryExpression;\n\nfunction evaluateArray(list, context) {\n  return list.map(function (v) { return evaluate(v, context); });\n}\n\nasync function evaluateArrayAsync(list, context) {\n  const res = await Promise.all(list.map((v) => evalAsync(v, context)));\n  return res;\n}\n\nfunction evaluateMember(node: jsep.MemberExpression, context: object) {\n  const object = evaluate(node.object, context);\n  let key: string;\n  if (node.computed) {\n    key = evaluate(node.property, context);\n  } else {\n    key = (node.property as jsep.Identifier).name;\n  }\n  if (/^__proto__|prototype|constructor$/.test(key)) {\n    throw Error(`Access to member \"${key}\" disallowed.`);\n  }\n  return [object, object[key]];\n}\n\nasync function evaluateMemberAsync(node: jsep.MemberExpression, context: object) {\n  const object = await evalAsync(node.object, context);\n  let key: string;\n  if (node.computed) {\n    key = await evalAsync(node.property, context);\n  } else {\n    key = (node.property as jsep.Identifier).name;\n  }\n  if (/^__proto__|prototype|constructor$/.test(key)) {\n    throw Error(`Access to member \"${key}\" disallowed.`);\n  }\n  return [object, object[key]];\n}\n\nfunction evaluate(_node: jsep.Expression, context: object) {\n\n  const node = _node as AnyExpression;\n\n  switch (node.type) {\n\n    case 'ArrayExpression':\n      return evaluateArray(node.elements, context);\n\n    case 'BinaryExpression':\n      return binops[node.operator](evaluate(node.left, context), evaluate(node.right, context));\n\n    case 'CallExpression': {\n      let caller, fn, assign;\n      if (node.callee.type === 'MemberExpression') {\n        assign = evaluateMember(node.callee as jsep.MemberExpression, context);\n        caller = assign[0];\n        fn = assign[1];\n      } else {\n        fn = evaluate(node.callee, context);\n      }\n      if (typeof fn !== 'function') { return undefined; }\n      return fn.apply(caller, evaluateArray(node.arguments, context));\n    }\n\n    case 'ConditionalExpression':\n      return evaluate(node.test, context)\n        ? evaluate(node.consequent, context)\n        : evaluate(node.alternate, context);\n\n    case 'Identifier':\n      return context[node.name];\n\n    case 'Literal':\n      return node.value;\n\n    case 'LogicalExpression':\n      const leftValue = evaluate(node.left, context);\n      if (node.operator === '||' && leftValue) {\n        return leftValue;\n      } else if (node.operator === '&&' && !leftValue) {\n        return leftValue;\n      }\n      return binops[node.operator](leftValue, evaluate(node.right, context));\n\n    case 'MemberExpression':\n      return evaluateMember(node, context)[1];\n\n    case 'ThisExpression':\n      return context;\n\n    case 'UnaryExpression':\n      return unops[node.operator](evaluate(node.argument, context));\n\n    default:\n      return undefined;\n  }\n\n}\n\nasync function evalAsync(_node: jsep.Expression, context: object) {\n\n  const node = _node as AnyExpression;\n\n  // Brackets used for some case blocks here, to avoid edge cases related to variable hoisting.\n  // See: https://stackoverflow.com/questions/57759348/const-and-let-variable-shadowing-in-a-switch-statement\n  switch (node.type) {\n\n    case 'ArrayExpression':\n      return await evaluateArrayAsync(node.elements, context);\n\n    case 'BinaryExpression': {\n      const [left, right] = await Promise.all([\n        evalAsync(node.left, context),\n        evalAsync(node.right, context)\n      ]);\n      return binops[node.operator](left, right);\n    }\n\n    case 'CallExpression': {\n      let caller, fn, assign;\n      if (node.callee.type === 'MemberExpression') {\n        assign = await evaluateMemberAsync(node.callee as jsep.MemberExpression, context);\n        caller = assign[0];\n        fn = assign[1];\n      } else {\n        fn = await evalAsync(node.callee, context);\n      }\n      if (typeof fn !== 'function') {\n        return undefined;\n      }\n      return await fn.apply(\n        caller,\n        await evaluateArrayAsync(node.arguments, context)\n      );\n    }\n\n    case 'ConditionalExpression':\n      return (await evalAsync(node.test, context))\n        ? await evalAsync(node.consequent, context)\n        : await evalAsync(node.alternate, context);\n\n    case 'Identifier':\n      return context[node.name];\n\n    case 'Literal':\n      return node.value;\n\n    case 'LogicalExpression': {\n      if (node.operator === '||') {\n        const left = await evalAsync(node.left, context);\n        if (left) {\n          return left;\n        }\n        return await evalAsync(node.right, context);\n      } else if (node.operator === '&&') {\n        const left = await evalAsync(node.left, context);\n        if (!left) {\n          return left;\n        }\n        return await evalAsync(node.right, context);\n      }\n\n      const [left, right] = await Promise.all([\n        evalAsync(node.left, context),\n        evalAsync(node.right, context)\n      ]);\n\n      return binops[node.operator](left, right);\n    }\n\n    case 'MemberExpression':\n      return (await evaluateMemberAsync(node, context))[1];\n\n    case 'ThisExpression':\n      return context;\n\n    case 'UnaryExpression':\n      return unops[node.operator](await evalAsync(node.argument, context));\n\n    default:\n      return undefined;\n  }\n}\n\nfunction compile(expression: string | jsep.Expression): (context: object) => any {\n  return evaluate.bind(null, jsep(expression));\n}\n\nfunction compileAsync(expression: string | jsep.Expression): (context: object) => Promise<any> {\n  return evalAsync.bind(null, jsep(expression));\n}\n\n// Added functions to inject Custom Unary Operators (and override existing ones)\nfunction addUnaryOp(operator: string, _function: unaryCallback): void {\n  jsep.addUnaryOp(operator);\n  unops[operator] = _function;\n}\n\n// Added functions to inject Custom Binary Operators (and override existing ones)\nfunction addBinaryOp(operator: string, precedence_or_fn: number | binaryCallback, _function: binaryCallback): void {\n  if (_function) {\n    jsep.addBinaryOp(operator, precedence_or_fn as number);\n    binops[operator] = _function;\n  } else {\n    jsep.addBinaryOp(operator, DEFAULT_PRECEDENCE[operator] || 1);\n    binops[operator] = precedence_or_fn;\n  }\n}\n\nexport {\n  jsep as parse,\n  evaluate as eval,\n  evalAsync,\n  compile,\n  compileAsync,\n  addUnaryOp,\n  addBinaryOp\n};\n"],"names":["evalAsync","_node","context","_exit","node","type","Promise","resolve","evaluateArrayAsync","elements","all","left","right","then","_ref","binops","operator","_temp4","caller","fn","assign","_fn","_apply","apply","_caller","arguments","_evaluateArrayAsync2","call","_temp3","callee","evaluateMemberAsync","_evaluateMemberAsync","_evalAsync2","test","_evalAsync3","consequent","alternate","name","value","_temp6","_result","_ref2","_temp5","_await$evalAsync","_await$evalAsync2","_evaluateMemberAsync2","_node$operator2","unops","argument","_evalAsync5","undefined","e","reject","object","_temp2","key","Error","_temp","computed","property","_evalAsync","list","map","v","DEFAULT_PRECEDENCE","a","b","evaluateArray","evaluate","evaluateMember","leftValue","compile","expression","bind","jsep","compileAsync","addUnaryOp","_function","addBinaryOp","precedence_or_fn"],"mappings":"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"}