{"version":3,"sources":["../../src/worker/index.ts"],"sourcesContent":["import type {\n  DebugLevel,\n  ExecProtocolResult,\n  Extensions,\n  PGliteInterface,\n  PGliteInterfaceExtensions,\n  PGliteOptions,\n  Transaction,\n} from '../interface.js'\nimport type { PGlite } from '../pglite.js'\nimport { BasePGlite } from '../base.js'\nimport { toPostgresName, uuid } from '../utils.js'\nimport { DumpTarCompressionOptions } from '../fs/tarUtils.js'\nimport { BackendMessage } from '@electric-sql/pg-protocol/messages'\n\nexport type PGliteWorkerOptions<E extends Extensions = Extensions> =\n  PGliteOptions<E> & {\n    meta?: any\n    id?: string\n  }\n\nexport class PGliteWorker\n  extends BasePGlite\n  implements PGliteInterface, AsyncDisposable\n{\n  #initPromise: Promise<void>\n  #debug: DebugLevel = 0\n\n  #ready = false\n  #closed = false\n  #isLeader = false\n\n  #eventTarget = new EventTarget()\n\n  #tabId: string\n\n  #connected = false\n\n  #workerProcess: Worker\n  #workerID?: string\n  #workerHerePromise?: Promise<void>\n  #workerReadyPromise?: Promise<void>\n\n  #broadcastChannel?: BroadcastChannel\n  #tabChannel?: BroadcastChannel\n  #releaseTabCloseLock?: () => void\n\n  #notifyListeners = new Map<string, Set<(payload: string) => void>>()\n  #globalNotifyListeners = new Set<(channel: string, payload: string) => void>()\n\n  #extensions: Extensions\n  #extensionsClose: Array<() => Promise<void>> = []\n\n  constructor(worker: Worker, options?: PGliteWorkerOptions) {\n    super()\n    this.#workerProcess = worker\n    this.#tabId = uuid()\n    this.#extensions = options?.extensions ?? {}\n\n    this.#workerHerePromise = new Promise<void>((resolve) => {\n      this.#workerProcess.addEventListener(\n        'message',\n        (event) => {\n          if (event.data.type === 'here') {\n            resolve()\n          } else {\n            throw new Error('Invalid message')\n          }\n        },\n        { once: true },\n      )\n    })\n\n    this.#workerReadyPromise = new Promise<void>((resolve) => {\n      const callback = (event: MessageEvent<any>) => {\n        if (event.data.type === 'ready') {\n          this.#workerID = event.data.id\n          this.#workerProcess.removeEventListener('message', callback)\n          resolve()\n        }\n      }\n      this.#workerProcess.addEventListener('message', callback)\n    })\n\n    this.#initPromise = this.#init(options)\n  }\n\n  /**\n   * Create a new PGlite instance with extensions on the Typescript interface\n   * This also awaits the instance to be ready before resolving\n   * (The main constructor does enable extensions, however due to the limitations\n   * of Typescript, the extensions are not available on the instance interface)\n   * @param worker The worker to use\n   * @param options Optional options\n   * @returns A promise that resolves to the PGlite instance when it's ready.\n   */\n  static async create<O extends PGliteWorkerOptions>(\n    worker: Worker,\n    options?: O,\n  ): Promise<PGliteWorker & PGliteInterfaceExtensions<O['extensions']>> {\n    const pg = new PGliteWorker(worker, options)\n    await pg.#initPromise\n    return pg as PGliteWorker & PGliteInterfaceExtensions<O['extensions']>\n  }\n\n  async #init(options: PGliteWorkerOptions = {}) {\n    // Setup the extensions\n    for (const [extName, ext] of Object.entries(this.#extensions)) {\n      if (ext instanceof URL) {\n        throw new Error(\n          'URL extensions are not supported on the client side of a worker',\n        )\n      } else {\n        const extRet = await ext.setup(this, {}, true)\n        if (extRet.emscriptenOpts) {\n          console.warn(\n            `PGlite extension ${extName} returned emscriptenOpts, these are not supported on the client side of a worker`,\n          )\n        }\n        if (extRet.namespaceObj) {\n          const instance = this as any\n          instance[extName] = extRet.namespaceObj\n        }\n        if (extRet.bundlePath) {\n          console.warn(\n            `PGlite extension ${extName} returned bundlePath, this is not supported on the client side of a worker`,\n          )\n        }\n        if (extRet.init) {\n          await extRet.init()\n        }\n        if (extRet.close) {\n          this.#extensionsClose.push(extRet.close)\n        }\n      }\n    }\n\n    // Wait for the worker let us know it's here\n    await this.#workerHerePromise\n\n    // Send the worker the options\n    const { extensions: _, ...workerOptions } = options\n    this.#workerProcess.postMessage({\n      type: 'init',\n      options: workerOptions,\n    })\n\n    // Wait for the worker let us know it's ready\n    await this.#workerReadyPromise\n\n    // Acquire the tab close lock, this is released then the tab, or this\n    // PGliteWorker instance, is closed\n    const tabCloseLockId = `pglite-tab-close:${this.#tabId}`\n    this.#releaseTabCloseLock = await acquireLock(tabCloseLockId)\n\n    // Start the broadcast channel used to communicate with tabs and leader election\n    const broadcastChannelId = `pglite-broadcast:${this.#workerID}`\n    this.#broadcastChannel = new BroadcastChannel(broadcastChannelId)\n\n    // Start the tab channel used to communicate with the leader directly\n    const tabChannelId = `pglite-tab:${this.#tabId}`\n    this.#tabChannel = new BroadcastChannel(tabChannelId)\n\n    this.#broadcastChannel.addEventListener('message', async (event) => {\n      if (event.data.type === 'leader-here') {\n        this.#connected = false\n        this.#eventTarget.dispatchEvent(new Event('leader-change'))\n        this.#leaderNotifyLoop()\n      } else if (event.data.type === 'notify') {\n        this.#receiveNotification(event.data.channel, event.data.payload)\n      }\n    })\n\n    this.#tabChannel.addEventListener('message', async (event) => {\n      if (event.data.type === 'connected') {\n        this.#connected = true\n        this.#eventTarget.dispatchEvent(new Event('connected'))\n        this.#debug = await this.#rpc('getDebugLevel')\n        this.#ready = true\n      }\n    })\n\n    this.#workerProcess.addEventListener('message', async (event) => {\n      if (event.data.type === 'leader-now') {\n        this.#isLeader = true\n        this.#eventTarget.dispatchEvent(new Event('leader-change'))\n      }\n    })\n\n    this.#leaderNotifyLoop()\n\n    // Init array types\n    // We don't await this as it will result in a deadlock\n    // It immediately takes out the transaction lock as so another query\n    this._initArrayTypes()\n  }\n\n  async #leaderNotifyLoop() {\n    if (!this.#connected) {\n      this.#broadcastChannel!.postMessage({\n        type: 'tab-here',\n        id: this.#tabId,\n      })\n      setTimeout(() => this.#leaderNotifyLoop(), 16)\n    }\n  }\n\n  async #rpc<Method extends WorkerRpcMethod>(\n    method: Method,\n    ...args: Parameters<WorkerApi[Method]>\n  ): Promise<ReturnType<WorkerApi[Method]>> {\n    const callId = uuid()\n    const message: WorkerRpcCall<Method> = {\n      type: 'rpc-call',\n      callId,\n      method,\n      args,\n    }\n    this.#tabChannel!.postMessage(message)\n    return await new Promise<ReturnType<WorkerApi[Method]>>(\n      (resolve, reject) => {\n        const listener = (event: MessageEvent) => {\n          if (event.data.callId !== callId) return\n          cleanup()\n          const message: WorkerRpcResponse<Method> = event.data\n          if (message.type === 'rpc-return') {\n            resolve(message.result)\n          } else if (message.type === 'rpc-error') {\n            const error = new Error(message.error.message)\n            Object.assign(error, message.error)\n            reject(error)\n          } else {\n            reject(new Error('Invalid message'))\n          }\n        }\n        const leaderChangeListener = () => {\n          // If the leader changes, throw an error to reject the promise\n          cleanup()\n          reject(new LeaderChangedError())\n        }\n        const cleanup = () => {\n          this.#tabChannel!.removeEventListener('message', listener)\n          this.#eventTarget.removeEventListener(\n            'leader-change',\n            leaderChangeListener,\n          )\n        }\n        this.#eventTarget.addEventListener(\n          'leader-change',\n          leaderChangeListener,\n        )\n        this.#tabChannel!.addEventListener('message', listener)\n      },\n    )\n  }\n\n  get waitReady() {\n    return new Promise<void>((resolve) => {\n      this.#initPromise.then(() => {\n        if (!this.#connected) {\n          resolve(\n            new Promise<void>((resolve) => {\n              this.#eventTarget.addEventListener('connected', () => {\n                resolve()\n              })\n            }),\n          )\n        } else {\n          resolve()\n        }\n      })\n    })\n  }\n\n  get debug() {\n    return this.#debug\n  }\n\n  /**\n   * The ready state of the database\n   */\n  get ready() {\n    return this.#ready\n  }\n\n  /**\n   * The closed state of the database\n   */\n  get closed() {\n    return this.#closed\n  }\n\n  /**\n   * The leader state of this tab\n   */\n  get isLeader() {\n    return this.#isLeader\n  }\n\n  /**\n   * Close the database\n   * @returns Promise that resolves when the connection to shared PGlite is closed\n   */\n  async close() {\n    if (this.#closed) {\n      return\n    }\n    this.#closed = true\n    this.#broadcastChannel?.close()\n    this.#tabChannel?.close()\n    this.#releaseTabCloseLock?.()\n    this.#workerProcess.terminate()\n  }\n\n  /**\n   * Close the database when the object exits scope\n   * Stage 3 ECMAScript Explicit Resource Management\n   * https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-2.html#using-declarations-and-explicit-resource-management\n   */\n  async [Symbol.asyncDispose]() {\n    await this.close()\n  }\n\n  /**\n   * Execute a postgres wire protocol message directly without wrapping the response.\n   * Only use if `execProtocol()` doesn't suite your needs.\n   *\n   * **Warning:** This bypasses PGlite's protocol wrappers that manage error/notice messages,\n   * transactions, and notification listeners. Only use if you need to bypass these wrappers and\n   * don't intend to use the above features.\n   *\n   * @param message The postgres wire protocol message to execute\n   * @returns The direct message data response produced by Postgres\n   */\n  async execProtocolRaw(message: Uint8Array): Promise<Uint8Array> {\n    return (await this.#rpc('execProtocolRaw', message)) as Uint8Array\n  }\n\n  /**\n   * Execute a postgres wire protocol message\n   * @param message The postgres wire protocol message to execute\n   * @returns The result of the query\n   */\n  async execProtocol(message: Uint8Array): Promise<ExecProtocolResult> {\n    return await this.#rpc('execProtocol', message)\n  }\n\n  /**\n   * Execute a postgres wire protocol message\n   * @param message The postgres wire protocol message to execute\n   * @returns The result of the query\n   */\n  async execProtocolStream(message: Uint8Array): Promise<BackendMessage[]> {\n    return await this.#rpc('execProtocolStream', message)\n  }\n\n  /**\n   * Sync the database to the filesystem\n   * @returns Promise that resolves when the database is synced to the filesystem\n   */\n  async syncToFs() {\n    await this.#rpc('syncToFs')\n  }\n\n  /**\n   * Listen for a notification\n   * @param channel The channel to listen on\n   * @param callback The callback to call when a notification is received\n   */\n  async listen(\n    channel: string,\n    callback: (payload: string) => void,\n    tx?: Transaction,\n  ): Promise<() => Promise<void>> {\n    const pgChannel = toPostgresName(channel)\n    const pg = tx ?? this\n    if (!this.#notifyListeners.has(pgChannel)) {\n      this.#notifyListeners.set(pgChannel, new Set())\n    }\n    this.#notifyListeners.get(pgChannel)!.add(callback)\n    await pg.exec(`LISTEN ${channel}`)\n    return async (tx?: Transaction) => {\n      await this.unlisten(pgChannel, callback, tx)\n    }\n  }\n\n  /**\n   * Stop listening for a notification\n   * @param channel The channel to stop listening on\n   * @param callback The callback to remove\n   */\n  async unlisten(\n    channel: string,\n    callback?: (payload: string) => void,\n    tx?: Transaction,\n  ): Promise<void> {\n    await this.waitReady\n    const pg = tx ?? this\n    if (callback) {\n      this.#notifyListeners.get(channel)?.delete(callback)\n    } else {\n      this.#notifyListeners.delete(channel)\n    }\n    if (this.#notifyListeners.get(channel)?.size === 0) {\n      // As we currently have a dedicated worker we can just unlisten\n      await pg.exec(`UNLISTEN ${channel}`)\n    }\n  }\n\n  /**\n   * Listen to notifications\n   * @param callback The callback to call when a notification is received\n   */\n  onNotification(callback: (channel: string, payload: string) => void) {\n    this.#globalNotifyListeners.add(callback)\n    return () => {\n      this.#globalNotifyListeners.delete(callback)\n    }\n  }\n\n  /**\n   * Stop listening to notifications\n   * @param callback The callback to remove\n   */\n  offNotification(callback: (channel: string, payload: string) => void) {\n    this.#globalNotifyListeners.delete(callback)\n  }\n\n  #receiveNotification(channel: string, payload: string) {\n    const listeners = this.#notifyListeners.get(channel)\n    if (listeners) {\n      for (const listener of listeners) {\n        queueMicrotask(() => listener(payload))\n      }\n    }\n    for (const listener of this.#globalNotifyListeners) {\n      queueMicrotask(() => listener(channel, payload))\n    }\n  }\n\n  async dumpDataDir(\n    compression?: DumpTarCompressionOptions,\n  ): Promise<File | Blob> {\n    return (await this.#rpc('dumpDataDir', compression)) as File | Blob\n  }\n\n  onLeaderChange(callback: () => void) {\n    this.#eventTarget.addEventListener('leader-change', callback)\n    return () => {\n      this.#eventTarget.removeEventListener('leader-change', callback)\n    }\n  }\n\n  offLeaderChange(callback: () => void) {\n    this.#eventTarget.removeEventListener('leader-change', callback)\n  }\n\n  async _handleBlob(blob?: File | Blob): Promise<void> {\n    await this.#rpc('_handleBlob', blob)\n  }\n\n  async _getWrittenBlob(): Promise<File | Blob | undefined> {\n    return await this.#rpc('_getWrittenBlob')\n  }\n\n  async _cleanupBlob(): Promise<void> {\n    await this.#rpc('_cleanupBlob')\n  }\n\n  async _checkReady() {\n    await this.waitReady\n  }\n\n  async _runExclusiveQuery<T>(fn: () => Promise<T>): Promise<T> {\n    await this.#rpc('_acquireQueryLock')\n    try {\n      return await fn()\n    } finally {\n      await this.#rpc('_releaseQueryLock')\n    }\n  }\n\n  async _runExclusiveTransaction<T>(fn: () => Promise<T>): Promise<T> {\n    await this.#rpc('_acquireTransactionLock')\n    try {\n      return await fn()\n    } finally {\n      await this.#rpc('_releaseTransactionLock')\n    }\n  }\n}\n\nexport interface WorkerOptions {\n  init: (options: Exclude<PGliteWorkerOptions, 'extensions'>) => Promise<PGlite>\n}\n\nexport async function worker({ init }: WorkerOptions) {\n  // Send a message to the main thread to let it know we are here\n  postMessage({ type: 'here' })\n\n  // Await the main thread to send us the options\n  const options = await new Promise<Exclude<PGliteWorkerOptions, 'extensions'>>(\n    (resolve) => {\n      addEventListener(\n        'message',\n        (event) => {\n          if (event.data.type === 'init') {\n            resolve(event.data.options)\n          }\n        },\n        { once: true },\n      )\n    },\n  )\n\n  // ID for this multi-tab worker - this is used to identify the group of workers\n  // that are trying to elect a leader for a shared PGlite instance.\n  // It defaults to the URL of the worker, and the dataDir if provided\n  // but can be overridden by the options.\n  const id = options.id ?? `${import.meta.url}:${options.dataDir ?? ''}`\n\n  // Let the main thread know we are ready\n  postMessage({ type: 'ready', id })\n\n  const electionLockId = `pglite-election-lock:${id}`\n  const broadcastChannelId = `pglite-broadcast:${id}`\n  const broadcastChannel = new BroadcastChannel(broadcastChannelId)\n  const connectedTabs = new Set<string>()\n\n  // Await the main lock which is used to elect the leader\n  // We don't release this lock, its automatically released when the worker or\n  // tab is closed\n  await acquireLock(electionLockId)\n\n  // Now we are the leader, start the worker\n  const dbPromise = init(options)\n\n  // Start listening for messages from tabs\n  broadcastChannel.onmessage = async (event) => {\n    const msg = event.data\n    switch (msg.type) {\n      case 'tab-here':\n        // A new tab has joined,\n        connectTab(msg.id, await dbPromise, connectedTabs)\n        break\n    }\n  }\n\n  // Notify the other tabs that we are the leader\n  broadcastChannel.postMessage({ type: 'leader-here', id })\n\n  // Let the main thread know we are the leader\n  postMessage({ type: 'leader-now' })\n\n  const db = await dbPromise\n\n  // Listen for notifications and broadcast them to all tabs\n  db.onNotification((channel, payload) => {\n    broadcastChannel.postMessage({ type: 'notify', channel, payload })\n  })\n}\n\nfunction connectTab(tabId: string, pg: PGlite, connectedTabs: Set<string>) {\n  if (connectedTabs.has(tabId)) {\n    return\n  }\n  connectedTabs.add(tabId)\n  const tabChannelId = `pglite-tab:${tabId}`\n  const tabCloseLockId = `pglite-tab-close:${tabId}`\n  const tabChannel = new BroadcastChannel(tabChannelId)\n\n  // Use a tab close lock to unsubscribe the tab\n  navigator.locks.request(tabCloseLockId, () => {\n    return new Promise<void>((resolve) => {\n      // The tab has been closed, unsubscribe the tab broadcast channel\n      tabChannel.close()\n      connectedTabs.delete(tabId)\n      resolve()\n    })\n  })\n\n  const api = makeWorkerApi(tabId, pg)\n\n  tabChannel.addEventListener('message', async (event) => {\n    const msg = event.data\n    switch (msg.type) {\n      case 'rpc-call': {\n        await pg.waitReady\n        const { callId, method, args } = msg as WorkerRpcCall<WorkerRpcMethod>\n        try {\n          // @ts-ignore no apparent reason why it fails\n          const result = (await api[method](...args)) as WorkerRpcResult<\n            typeof method\n          >['result']\n          tabChannel.postMessage({\n            type: 'rpc-return',\n            callId,\n            result,\n          } satisfies WorkerRpcResult<typeof method>)\n        } catch (error) {\n          console.error(error)\n          tabChannel.postMessage({\n            type: 'rpc-error',\n            callId,\n            error: { message: (error as Error).message },\n          } satisfies WorkerRpcError)\n        }\n        break\n      }\n    }\n  })\n\n  // Send a message to the tab to let it know it's connected\n  tabChannel.postMessage({ type: 'connected' })\n}\n\nfunction makeWorkerApi(tabId: string, db: PGlite) {\n  let queryLockRelease: (() => void) | null = null\n  let transactionLockRelease: (() => void) | null = null\n\n  // If the tab is closed and it is holding a lock, release the the locks\n  // and rollback any pending transactions\n  const tabCloseLockId = `pglite-tab-close:${tabId}`\n  acquireLock(tabCloseLockId).then(() => {\n    if (transactionLockRelease) {\n      // rollback any pending transactions\n      db.exec('ROLLBACK')\n    }\n    queryLockRelease?.()\n    transactionLockRelease?.()\n  })\n\n  return {\n    async getDebugLevel() {\n      return db.debug\n    },\n    async close() {\n      await db.close()\n    },\n    async execProtocol(message: Uint8Array) {\n      const { messages, data } = await db.execProtocol(message)\n      if (data.byteLength !== data.buffer.byteLength) {\n        const buffer = new ArrayBuffer(data.byteLength)\n        const dataCopy = new Uint8Array(buffer)\n        dataCopy.set(data)\n        return { messages, data: dataCopy }\n      } else {\n        return { messages, data }\n      }\n    },\n    async execProtocolStream(message: Uint8Array) {\n      const messages = await db.execProtocolStream(message)\n      return messages\n    },\n    async execProtocolRaw(message: Uint8Array) {\n      const result = await db.execProtocolRaw(message)\n      if (result.byteLength !== result.buffer.byteLength) {\n        // The data is a slice of a larger buffer, this is potentially the whole\n        // memory of the WASM module. We copy it to a new Uint8Array and return that.\n        const buffer = new ArrayBuffer(result.byteLength)\n        const resultCopy = new Uint8Array(buffer)\n        resultCopy.set(result)\n        return resultCopy\n      } else {\n        return result\n      }\n    },\n    async dumpDataDir(compression?: DumpTarCompressionOptions) {\n      return await db.dumpDataDir(compression)\n    },\n    async syncToFs() {\n      return await db.syncToFs()\n    },\n    async _handleBlob(blob?: File | Blob) {\n      return await db._handleBlob(blob)\n    },\n    async _getWrittenBlob() {\n      return await db._getWrittenBlob()\n    },\n    async _cleanupBlob() {\n      return await db._cleanupBlob()\n    },\n    async _checkReady() {\n      return await db._checkReady()\n    },\n    async _acquireQueryLock() {\n      return new Promise<void>((resolve) => {\n        db._runExclusiveQuery(() => {\n          return new Promise<void>((release) => {\n            queryLockRelease = release\n            resolve()\n          })\n        })\n      })\n    },\n    async _releaseQueryLock() {\n      queryLockRelease?.()\n      queryLockRelease = null\n    },\n    async _acquireTransactionLock() {\n      return new Promise<void>((resolve) => {\n        db._runExclusiveTransaction(() => {\n          return new Promise<void>((release) => {\n            transactionLockRelease = release\n            resolve()\n          })\n        })\n      })\n    },\n    async _releaseTransactionLock() {\n      transactionLockRelease?.()\n      transactionLockRelease = null\n    },\n  }\n}\n\nexport class LeaderChangedError extends Error {\n  constructor() {\n    super('Leader changed, pending operation in indeterminate state')\n  }\n}\n\nasync function acquireLock(lockId: string) {\n  let release\n  await new Promise<void>((resolve) => {\n    navigator.locks.request(lockId, () => {\n      return new Promise<void>((releaseCallback) => {\n        release = releaseCallback\n        resolve()\n      })\n    })\n  })\n  return release\n}\n\ntype WorkerApi = ReturnType<typeof makeWorkerApi>\n\ntype WorkerRpcMethod = keyof WorkerApi\n\ntype WorkerRpcCall<Method extends WorkerRpcMethod> = {\n  type: 'rpc-call'\n  callId: string\n  method: Method\n  args: Parameters<WorkerApi[Method]>\n}\n\ntype WorkerRpcResult<Method extends WorkerRpcMethod> = {\n  type: 'rpc-return'\n  callId: string\n  result: ReturnType<WorkerApi[Method]>\n}\n\ntype WorkerRpcError = {\n  type: 'rpc-error'\n  callId: string\n  error: any\n}\n\ntype WorkerRpcResponse<Method extends WorkerRpcMethod> =\n  | WorkerRpcResult<Method>\n  | WorkerRpcError\n"],"mappings":"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","names":["init_esm_shims","_initPromise","_debug","_ready","_closed","_isLeader","_eventTarget","_tabId","_connected","_workerProcess","_workerID","_workerHerePromise","_workerReadyPromise","_broadcastChannel","_tabChannel","_releaseTabCloseLock","_notifyListeners","_globalNotifyListeners","_extensions","_extensionsClose","_PGliteWorker_instances","init_fn","leaderNotifyLoop_fn","rpc_fn","receiveNotification_fn","_PGliteWorker","BasePGlite","worker","options","__privateAdd","__privateSet","uuid","resolve","__privateGet","event","callback","__privateMethod","pg","_a","message","channel","tx","pgChannel","toPostgresName","compression","blob","fn","extName","ext","extRet","instance","_","workerOptions","tabCloseLockId","acquireLock","broadcastChannelId","tabChannelId","method","args","callId","reject","listener","cleanup","error","leaderChangeListener","LeaderChangedError","payload","listeners","PGliteWorker","init","id","electionLockId","broadcastChannel","connectedTabs","dbPromise","msg","connectTab","tabId","tabChannel","api","makeWorkerApi","result","db","queryLockRelease","transactionLockRelease","messages","data","buffer","dataCopy","resultCopy","release","lockId","releaseCallback"]}