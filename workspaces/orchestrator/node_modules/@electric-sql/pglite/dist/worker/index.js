import{a as j}from"../chunk-F2DQ4FIK.js";import{u as U,x as z}from"../chunk-3WWIVTCY.js";import"../chunk-F4GETNPB.js";import{e as t,f as p,g as u,h,j as Q}from"../chunk-QY3QWFKW.js";Q();var W,T,C,M,B,w,x,L,P,_,A,O,E,v,G,k,b,I,$,c,K,D,g,J,q=class q extends j{constructor(e,r){super();p(this,c);p(this,W);p(this,T,0);p(this,C,!1);p(this,M,!1);p(this,B,!1);p(this,w,new EventTarget);p(this,x);p(this,L,!1);p(this,P);p(this,_);p(this,A);p(this,O);p(this,E);p(this,v);p(this,G);p(this,k,new Map);p(this,b,new Set);p(this,I);p(this,$,[]);u(this,P,e),u(this,x,U()),u(this,I,r?.extensions??{}),u(this,A,new Promise(a=>{t(this,P).addEventListener("message",s=>{if(s.data.type==="here")a();else throw new Error("Invalid message")},{once:!0})})),u(this,O,new Promise(a=>{let s=n=>{n.data.type==="ready"&&(u(this,_,n.data.id),t(this,P).removeEventListener("message",s),a())};t(this,P).addEventListener("message",s)})),u(this,W,h(this,c,K).call(this,r))}static async create(e,r){let a=new q(e,r);return await t(a,W),a}get waitReady(){return new Promise(e=>{t(this,W).then(()=>{t(this,L)?e():e(new Promise(r=>{t(this,w).addEventListener("connected",()=>{r()})}))})})}get debug(){return t(this,T)}get ready(){return t(this,C)}get closed(){return t(this,M)}get isLeader(){return t(this,B)}async close(){var e;t(this,M)||(u(this,M,!0),t(this,E)?.close(),t(this,v)?.close(),(e=t(this,G))==null||e.call(this),t(this,P).terminate())}async[Symbol.asyncDispose](){await this.close()}async execProtocolRaw(e){return await h(this,c,g).call(this,"execProtocolRaw",e)}async execProtocol(e){return await h(this,c,g).call(this,"execProtocol",e)}async execProtocolStream(e){return await h(this,c,g).call(this,"execProtocolStream",e)}async syncToFs(){await h(this,c,g).call(this,"syncToFs")}async listen(e,r,a){let s=z(e),n=a??this;return t(this,k).has(s)||t(this,k).set(s,new Set),t(this,k).get(s).add(r),await n.exec(`LISTEN ${e}`),async l=>{await this.unlisten(s,r,l)}}async unlisten(e,r,a){await this.waitReady;let s=a??this;r?t(this,k).get(e)?.delete(r):t(this,k).delete(e),t(this,k).get(e)?.size===0&&await s.exec(`UNLISTEN ${e}`)}onNotification(e){return t(this,b).add(e),()=>{t(this,b).delete(e)}}offNotification(e){t(this,b).delete(e)}async dumpDataDir(e){return await h(this,c,g).call(this,"dumpDataDir",e)}onLeaderChange(e){return t(this,w).addEventListener("leader-change",e),()=>{t(this,w).removeEventListener("leader-change",e)}}offLeaderChange(e){t(this,w).removeEventListener("leader-change",e)}async _handleBlob(e){await h(this,c,g).call(this,"_handleBlob",e)}async _getWrittenBlob(){return await h(this,c,g).call(this,"_getWrittenBlob")}async _cleanupBlob(){await h(this,c,g).call(this,"_cleanupBlob")}async _checkReady(){await this.waitReady}async _runExclusiveQuery(e){await h(this,c,g).call(this,"_acquireQueryLock");try{return await e()}finally{await h(this,c,g).call(this,"_releaseQueryLock")}}async _runExclusiveTransaction(e){await h(this,c,g).call(this,"_acquireTransactionLock");try{return await e()}finally{await h(this,c,g).call(this,"_releaseTransactionLock")}}};W=new WeakMap,T=new WeakMap,C=new WeakMap,M=new WeakMap,B=new WeakMap,w=new WeakMap,x=new WeakMap,L=new WeakMap,P=new WeakMap,_=new WeakMap,A=new WeakMap,O=new WeakMap,E=new WeakMap,v=new WeakMap,G=new WeakMap,k=new WeakMap,b=new WeakMap,I=new WeakMap,$=new WeakMap,c=new WeakSet,K=async function(e={}){for(let[o,y]of Object.entries(t(this,I))){if(y instanceof URL)throw new Error("URL extensions are not supported on the client side of a worker");{let d=await y.setup(this,{},!0);if(d.emscriptenOpts&&console.warn(`PGlite extension ${o} returned emscriptenOpts, these are not supported on the client side of a worker`),d.namespaceObj){let R=this;R[o]=d.namespaceObj}d.bundlePath&&console.warn(`PGlite extension ${o} returned bundlePath, this is not supported on the client side of a worker`),d.init&&await d.init(),d.close&&t(this,$).push(d.close)}}await t(this,A);let{extensions:r,...a}=e;t(this,P).postMessage({type:"init",options:a}),await t(this,O);let s=`pglite-tab-close:${t(this,x)}`;u(this,G,await N(s));let n=`pglite-broadcast:${t(this,_)}`;u(this,E,new BroadcastChannel(n));let l=`pglite-tab:${t(this,x)}`;u(this,v,new BroadcastChannel(l)),t(this,E).addEventListener("message",async o=>{o.data.type==="leader-here"?(u(this,L,!1),t(this,w).dispatchEvent(new Event("leader-change")),h(this,c,D).call(this)):o.data.type==="notify"&&h(this,c,J).call(this,o.data.channel,o.data.payload)}),t(this,v).addEventListener("message",async o=>{o.data.type==="connected"&&(u(this,L,!0),t(this,w).dispatchEvent(new Event("connected")),u(this,T,await h(this,c,g).call(this,"getDebugLevel")),u(this,C,!0))}),t(this,P).addEventListener("message",async o=>{o.data.type==="leader-now"&&(u(this,B,!0),t(this,w).dispatchEvent(new Event("leader-change")))}),h(this,c,D).call(this),this._initArrayTypes()},D=async function(){t(this,L)||(t(this,E).postMessage({type:"tab-here",id:t(this,x)}),setTimeout(()=>h(this,c,D).call(this),16))},g=async function(e,...r){let a=U(),s={type:"rpc-call",callId:a,method:e,args:r};return t(this,v).postMessage(s),await new Promise((n,l)=>{let o=R=>{if(R.data.callId!==a)return;d();let f=R.data;if(f.type==="rpc-return")n(f.result);else if(f.type==="rpc-error"){let F=new Error(f.error.message);Object.assign(F,f.error),l(F)}else l(new Error("Invalid message"))},y=()=>{d(),l(new S)},d=()=>{t(this,v).removeEventListener("message",o),t(this,w).removeEventListener("leader-change",y)};t(this,w).addEventListener("leader-change",y),t(this,v).addEventListener("message",o)})},J=function(e,r){let a=t(this,k).get(e);if(a)for(let s of a)queueMicrotask(()=>s(r));for(let s of t(this,b))queueMicrotask(()=>s(e,r))};var H=q;async function se({init:m}){postMessage({type:"here"});let i=await new Promise(y=>{addEventListener("message",d=>{d.data.type==="init"&&y(d.data.options)},{once:!0})}),e=i.id??`${import.meta.url}:${i.dataDir??""}`;postMessage({type:"ready",id:e});let r=`pglite-election-lock:${e}`,a=`pglite-broadcast:${e}`,s=new BroadcastChannel(a),n=new Set;await N(r);let l=m(i);s.onmessage=async y=>{let d=y.data;switch(d.type){case"tab-here":V(d.id,await l,n);break}},s.postMessage({type:"leader-here",id:e}),postMessage({type:"leader-now"}),(await l).onNotification((y,d)=>{s.postMessage({type:"notify",channel:y,payload:d})})}function V(m,i,e){if(e.has(m))return;e.add(m);let r=`pglite-tab:${m}`,a=`pglite-tab-close:${m}`,s=new BroadcastChannel(r);navigator.locks.request(a,()=>new Promise(l=>{s.close(),e.delete(m),l()}));let n=X(m,i);s.addEventListener("message",async l=>{let o=l.data;switch(o.type){case"rpc-call":{await i.waitReady;let{callId:y,method:d,args:R}=o;try{let f=await n[d](...R);s.postMessage({type:"rpc-return",callId:y,result:f})}catch(f){console.error(f),s.postMessage({type:"rpc-error",callId:y,error:{message:f.message}})}break}}}),s.postMessage({type:"connected"})}function X(m,i){let e=null,r=null,a=`pglite-tab-close:${m}`;return N(a).then(()=>{r&&i.exec("ROLLBACK"),e?.(),r?.()}),{async getDebugLevel(){return i.debug},async close(){await i.close()},async execProtocol(s){let{messages:n,data:l}=await i.execProtocol(s);if(l.byteLength!==l.buffer.byteLength){let o=new ArrayBuffer(l.byteLength),y=new Uint8Array(o);return y.set(l),{messages:n,data:y}}else return{messages:n,data:l}},async execProtocolStream(s){return await i.execProtocolStream(s)},async execProtocolRaw(s){let n=await i.execProtocolRaw(s);if(n.byteLength!==n.buffer.byteLength){let l=new ArrayBuffer(n.byteLength),o=new Uint8Array(l);return o.set(n),o}else return n},async dumpDataDir(s){return await i.dumpDataDir(s)},async syncToFs(){return await i.syncToFs()},async _handleBlob(s){return await i._handleBlob(s)},async _getWrittenBlob(){return await i._getWrittenBlob()},async _cleanupBlob(){return await i._cleanupBlob()},async _checkReady(){return await i._checkReady()},async _acquireQueryLock(){return new Promise(s=>{i._runExclusiveQuery(()=>new Promise(n=>{e=n,s()}))})},async _releaseQueryLock(){e?.(),e=null},async _acquireTransactionLock(){return new Promise(s=>{i._runExclusiveTransaction(()=>new Promise(n=>{r=n,s()}))})},async _releaseTransactionLock(){r?.(),r=null}}}var S=class extends Error{constructor(){super("Leader changed, pending operation in indeterminate state")}};async function N(m){let i;return await new Promise(e=>{navigator.locks.request(m,()=>new Promise(r=>{i=r,e()}))}),i}export{S as LeaderChangedError,H as PGliteWorker,se as worker};
//# sourceMappingURL=index.js.map