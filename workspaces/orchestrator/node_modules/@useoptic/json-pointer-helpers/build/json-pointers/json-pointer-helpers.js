"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const minimatch_1 = require("minimatch");
const escape = (str) => str.replace(/~/g, '~0').replace(/\//g, '~1');
const unescape = (str) => str.replace(/~0/g, '~').replace(/~1/g, '/');
const parse = (pointer) => pointer.split('/').slice(1).map(unescape);
const compile = (parts) => parts.length > 0 ? '/' + parts.map(escape).join('/') : '';
const get = (obj, pointer) => {
    const tokens = Array.isArray(pointer) ? pointer : parse(pointer);
    for (const token of tokens) {
        if (!(typeof obj == 'object' && token in obj)) {
            throw new Error('Invalid reference token: ' + token);
        }
        obj = obj[token];
    }
    return obj;
};
function append(pointer, ...property) {
    const parsed = parse(pointer.toString());
    return compile([...parsed, ...property]);
}
function pop(pointer) {
    const parsed = parse(pointer.toString());
    parsed.pop();
    return compile([...parsed]);
}
function splitParentChild(pointer) {
    const parsed = parse(pointer.toString());
    const key = parsed.pop();
    return [compile([...parsed]), key || '', pointer];
}
function unescapeUriSafePointer(inputFromApiToolkit) {
    return decodeURIComponent(inputFromApiToolkit);
}
function relative(pointer, from) {
    const targetDecoded = parse(pointer);
    const fromDecoded = parse(from);
    if (fromDecoded.length > targetDecoded.length)
        throw new Error(`${pointer} can not be relative to ${from}`);
    const parent = targetDecoded.slice(0, fromDecoded.length);
    if (JSON.stringify(parent) !== JSON.stringify(fromDecoded)) {
        throw new Error(`${pointer} can not be relative to ${from} -- need same lineage`);
    }
    return compile(targetDecoded.slice(fromDecoded.length));
}
function startsWith(pointer, pattern, options = { exact: false }) {
    const components = parse(pointer);
    const sliced = components.slice(0, pattern.length);
    if (!(sliced.length >= pattern.length)) {
        return false;
    }
    return sliced.every((comp, index) => !options.exact ? (0, minimatch_1.minimatch)(comp, pattern[index]) : comp === pattern[index]);
}
function matches(pointer, pattern) {
    const components = parse(pointer);
    if (components.length !== pattern.length) {
        return false;
    }
    return components.every((comp, index) => (0, minimatch_1.minimatch)(comp, pattern[index]));
}
function endsWith(pointer, pattern, options = { exact: false }) {
    const components = parse(pointer);
    const sliced = components.slice(components.length - pattern.length);
    if (!(sliced.length >= pattern.length)) {
        return false;
    }
    return sliced.every((comp, index) => !options.exact ? (0, minimatch_1.minimatch)(comp, pattern[index]) : comp === pattern[index]);
}
function tryGet(input, pointer) {
    try {
        const value = get(input, pointer);
        return { match: true, value };
    }
    catch (e) {
        return { match: false, error: e.message };
    }
}
function join(leading, trailing) {
    return compile([...parse(leading), ...parse(trailing)]);
}
exports.default = {
    append,
    escape,
    unescape,
    pop,
    decode: parse,
    join,
    splitParentChild,
    unescapeUriSafePointer,
    get,
    tryGet,
    compile,
    relative,
    startsWith,
    matches,
    endsWith,
};
//# sourceMappingURL=json-pointer-helpers.js.map