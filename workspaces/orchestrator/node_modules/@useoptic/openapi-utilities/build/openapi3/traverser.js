"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OpenApiV3Traverser = exports.getLocation = exports.getRaw = exports.OAS3 = void 0;
const json_pointer_helpers_1 = require("@useoptic/json-pointer-helpers");
const openapi_types_1 = require("openapi-types");
exports.OAS3 = {
    isObjectType(type) {
        return (type === 'object' || (Array.isArray(type) && type.includes('object')));
    },
    isArrayType(type) {
        return type === 'array' || (Array.isArray(type) && type.includes('array'));
    },
};
const getReadableLocation = (jsonPath) => json_pointer_helpers_1.jsonPointerHelpers.decode(jsonPath).join(' > ');
const isNotReferenceObject = (maybeReference) => {
    return !('$ref' in maybeReference);
};
const isObject = (value) => {
    return typeof value === 'object' && !Array.isArray(value) && value !== null;
};
function getRaw(spec, fact) {
    return json_pointer_helpers_1.jsonPointerHelpers.get(spec, fact.location.jsonPath);
}
exports.getRaw = getRaw;
function getLocation(fact) {
    const parts = json_pointer_helpers_1.jsonPointerHelpers.decode(fact.location.jsonPath);
    if (fact.type === 'specification') {
        return {};
    }
    else if (fact.type === 'path') {
        const [, pathPattern] = parts;
        return {
            pathPattern,
        };
    }
    else if (fact.type === 'operation' ||
        fact.type === 'request-header' ||
        fact.type === 'request-query' ||
        fact.type === 'request-cookie' ||
        fact.type === 'request-path' ||
        fact.type === 'requestBody') {
        const [, pathPattern, method] = parts;
        return {
            pathPattern,
            method,
        };
    }
    else if (fact.type === 'body') {
        // 'paths', {pathPattern}, {method}, 'requestBody', 'content', {contentType}
        // OR
        // 'paths', {pathPattern}, {method}, 'responses', {statusCode}, content', {contentType}
        const isResponse = parts[3] === 'responses';
        if (isResponse) {
            const [, pathPattern, method, , statusCode, , contentType] = parts;
            return {
                location: 'response',
                pathPattern,
                method,
                statusCode,
                contentType,
            };
        }
        else {
            const [, pathPattern, method, , , contentType] = parts;
            return {
                location: 'request',
                pathPattern,
                method,
                contentType,
            };
        }
    }
    else if (fact.type === 'body-example' || fact.type === 'body-examples') {
        const isResponse = parts[3] === 'responses';
        if (isResponse) {
            const [, pathPattern, method, , statusCode, , contentType, ...trail] = parts;
            return {
                location: 'response',
                pathPattern,
                method,
                statusCode,
                contentType,
                trail,
            };
        }
        else {
            const [, pathPattern, method, , , contentType, ...trail] = parts;
            return {
                location: 'request',
                pathPattern,
                method,
                contentType,
                trail,
            };
        }
    }
    else if (fact.type === 'field') {
        const isResponse = parts[3] === 'responses';
        if (isResponse) {
            const [, pathPattern, method, , statusCode, , contentType, ...trail] = parts;
            return {
                location: 'response',
                pathPattern,
                method,
                statusCode,
                contentType,
                trail,
            };
        }
        else {
            const [, pathPattern, method, , , contentType, ...trail] = parts;
            return {
                location: 'request',
                pathPattern,
                method,
                contentType,
                trail,
            };
        }
    }
    else if (fact.type === 'response') {
        const [, pathPattern, method, , statusCode] = parts;
        return {
            pathPattern,
            method,
            statusCode,
        };
    }
    else if (fact.type === 'response-header') {
        const [, pathPattern, method, , statusCode, , name] = parts;
        return {
            pathPattern,
            method,
            statusCode,
            headerName: name,
        };
    }
    return {};
}
exports.getLocation = getLocation;
class OpenApiV3Traverser {
    constructor() {
        this.format = 'openapi3';
        this.input = undefined;
        this.warnings = [];
    }
    traverse(input) {
        this.input = input;
    }
    *facts() {
        if (!this.input || this.input['x-optic-ci-empty-spec'] === true)
            return;
        yield {
            location: {
                jsonPath: '',
            },
            type: 'specification',
        };
        for (let [pathPattern, paths] of Object.entries(this.input.paths || {})) {
            const traverser = this;
            yield {
                location: {
                    jsonPath: json_pointer_helpers_1.jsonPointerHelpers.append('', 'paths', pathPattern),
                },
                type: 'path',
            };
            const traverseIfPresent = function* (method) {
                const pathObject = paths?.[method];
                if (pathObject) {
                    yield* traverser.traverseOperations(pathObject, method, pathPattern);
                }
            };
            yield* traverseIfPresent(openapi_types_1.OpenAPIV3.HttpMethods.GET);
            yield* traverseIfPresent(openapi_types_1.OpenAPIV3.HttpMethods.PATCH);
            yield* traverseIfPresent(openapi_types_1.OpenAPIV3.HttpMethods.POST);
            yield* traverseIfPresent(openapi_types_1.OpenAPIV3.HttpMethods.PUT);
            yield* traverseIfPresent(openapi_types_1.OpenAPIV3.HttpMethods.DELETE);
            yield* traverseIfPresent(openapi_types_1.OpenAPIV3.HttpMethods.HEAD);
            yield* traverseIfPresent(openapi_types_1.OpenAPIV3.HttpMethods.OPTIONS);
        }
        if (this.input.components && this.input.components.schemas) {
            for (let [name, schema] of Object.entries(this.input.components.schemas)) {
                yield* this.traverseComponentSchema(schema, name);
            }
        }
    }
    *traverseOperations(operation, method, pathPattern) {
        const jsonPath = json_pointer_helpers_1.jsonPointerHelpers.append('', 'paths', pathPattern, method);
        yield {
            location: {
                jsonPath: jsonPath,
            },
            type: 'operation',
        };
        yield* this.traverseParameters(operation, json_pointer_helpers_1.jsonPointerHelpers.append(jsonPath, 'parameters'), pathPattern);
        const requestBody = operation.requestBody;
        if (requestBody) {
            if (!isObject(requestBody)) {
                this.warnings.push(`Expected an object at: ${getReadableLocation(json_pointer_helpers_1.jsonPointerHelpers.append(jsonPath, 'requestBody'))}, found ${requestBody}`);
            }
            else if (isNotReferenceObject(requestBody)) {
                for (let [contentType, body] of Object.entries(requestBody.content || {}))
                    yield* this.traverseBody(body, contentType, json_pointer_helpers_1.jsonPointerHelpers.append(jsonPath, 'requestBody', 'content', contentType));
                yield {
                    location: {
                        jsonPath: json_pointer_helpers_1.jsonPointerHelpers.append(jsonPath, 'requestBody'),
                    },
                    type: 'requestBody',
                };
            }
            else {
                this.warnings.push(`Expected a flattened spec, found a reference at: ${getReadableLocation(json_pointer_helpers_1.jsonPointerHelpers.append(jsonPath, 'requestBody'))}`);
            }
        }
        for (let [statusCode, response] of Object.entries(operation.responses || {})) {
            const nextJsonPath = json_pointer_helpers_1.jsonPointerHelpers.append(jsonPath, 'responses', statusCode);
            if (!isObject(response)) {
                this.warnings.push(`Expected an object at: ${getReadableLocation(nextJsonPath)}, found ${response}`);
            }
            else if (isNotReferenceObject(response)) {
                yield* this.traverseResponse(response, nextJsonPath);
            }
            else {
                this.warnings.push(`Expected a flattened spec, found a reference at: ${getReadableLocation(nextJsonPath)}`);
            }
        }
    }
    *traverseResponse(response, jsonPath) {
        yield* this.traverseResponseHeaders(response, jsonPath);
        for (let [contentType, body] of Object.entries(response.content || {})) {
            yield* this.traverseBody(body, contentType, json_pointer_helpers_1.jsonPointerHelpers.append(jsonPath, 'content', contentType));
        }
        yield {
            location: {
                jsonPath,
            },
            type: 'response',
        };
    }
    *traverseParameters(operation, jsonPath, operationPath) {
        if (operation.parameters) {
            for (let [i, parameter] of Object.entries(operation.parameters)) {
                const nextJsonPath = json_pointer_helpers_1.jsonPointerHelpers.append(jsonPath, i);
                if (!isObject(parameter)) {
                    this.warnings.push(`Expected an object at: ${getReadableLocation(nextJsonPath)}, found ${parameter}`);
                }
                else if (isNotReferenceObject(parameter)) {
                    switch (parameter.in) {
                        case 'query':
                        case 'header':
                        case 'path':
                        case 'cookie':
                            yield {
                                location: {
                                    jsonPath: nextJsonPath,
                                },
                                type: `request-${parameter.in}`,
                            };
                    }
                }
                else {
                    this.warnings.push(`Expected a flattened spec, found a reference at: ${getReadableLocation(nextJsonPath)}`);
                }
            }
        }
        const sharedParametersPointer = json_pointer_helpers_1.jsonPointerHelpers.compile([
            'paths',
            operationPath,
            'parameters',
        ]);
        const sharedParameters = json_pointer_helpers_1.jsonPointerHelpers.tryGet(this.input, sharedParametersPointer);
        if (sharedParameters.match) {
            const shared = sharedParameters.value;
            for (let [i, parameter] of Object.entries(shared)) {
                const nextJsonPath = json_pointer_helpers_1.jsonPointerHelpers.append(sharedParametersPointer, i.toString());
                switch (parameter.in) {
                    case 'query':
                    case 'header':
                    case 'path':
                    case 'cookie':
                        yield {
                            location: {
                                jsonPath: nextJsonPath,
                            },
                            type: `request-${parameter.in}`,
                        };
                }
            }
        }
    }
    *traverseResponseHeaders(response, jsonPath) {
        if (response.headers) {
            for (let [name, header] of Object.entries(response.headers)) {
                const nextJsonPath = json_pointer_helpers_1.jsonPointerHelpers.append(jsonPath, 'headers', name);
                if (!isObject(header)) {
                    this.warnings.push(`Expected an object at: ${getReadableLocation(nextJsonPath)}, found ${header}`);
                }
                else if (isNotReferenceObject(header)) {
                    yield {
                        location: { jsonPath: nextJsonPath },
                        type: 'response-header',
                    };
                }
                else {
                    this.warnings.push(`Expected a flattened spec, found a reference at: ${getReadableLocation(nextJsonPath)}`);
                }
            }
        }
    }
    *traverseBody(body, contentType, jsonPath) {
        const { schema, examples, example } = body;
        if (schema) {
            const nextJsonPath = json_pointer_helpers_1.jsonPointerHelpers.append(jsonPath, 'schema');
            if (!isObject(schema)) {
                this.warnings.push(`Expected an object at: ${getReadableLocation(nextJsonPath)}, found ${schema}`);
            }
            else if (isNotReferenceObject(schema)) {
                yield {
                    location: {
                        jsonPath: jsonPath,
                    },
                    type: 'body',
                };
                yield* this.traverseSchema(schema, nextJsonPath);
            }
            else {
                this.warnings.push(`Expected a flattened spec, found a reference at: ${getReadableLocation(nextJsonPath)}`);
            }
        }
        if (examples) {
            yield {
                location: {
                    jsonPath: json_pointer_helpers_1.jsonPointerHelpers.append(jsonPath, 'examples'),
                },
                type: 'body-examples',
            };
            for (let [name, example] of Object.entries(examples)) {
                const nextJsonPath = json_pointer_helpers_1.jsonPointerHelpers.append(jsonPath, 'examples', name);
                if (!isObject(example)) {
                    this.warnings.push(`Expected an object at: ${getReadableLocation(nextJsonPath)}, found ${example}`);
                }
                else if (isNotReferenceObject(example)) {
                    yield {
                        location: {
                            jsonPath: nextJsonPath,
                        },
                        type: 'body-example',
                    };
                }
                else {
                    this.warnings.push(`Expected a flattened spec, found a reference at: ${getReadableLocation(nextJsonPath)}`);
                }
            }
        }
        if (example) {
            yield {
                location: {
                    jsonPath: json_pointer_helpers_1.jsonPointerHelpers.append(jsonPath, 'example'),
                },
                type: 'body-example',
            };
        }
    }
    *traverseField(schema, jsonPath) {
        yield {
            location: {
                jsonPath,
            },
            type: 'field',
        };
        yield* this.traverseSchema(schema, jsonPath);
    }
    *traverseSchema(schema, jsonPath) {
        if (schema.oneOf || schema.anyOf || schema.allOf) {
            const schemas = [
                { branchType: 'oneOf', schemas: schema.oneOf },
                { branchType: 'anyOf', schemas: schema.anyOf },
                { branchType: 'allOf', schemas: schema.allOf },
            ].flatMap(({ branchType, schemas }) => {
                if (!schemas)
                    schemas = [];
                return schemas.map((schema, branchIndex) => ({
                    branchType,
                    branchIndex,
                    branchSchema: schema,
                }));
            });
            for (let { branchType, branchIndex, branchSchema } of schemas) {
                const newJsonPath = json_pointer_helpers_1.jsonPointerHelpers.append(jsonPath, branchType, '' + branchIndex);
                if (!isObject(branchSchema)) {
                    this.warnings.push(`Expected an object at: ${getReadableLocation(newJsonPath)}, found ${branchSchema}`);
                }
                else if (isNotReferenceObject(branchSchema)) {
                    yield* this.traverseSchema(branchSchema, newJsonPath);
                }
                else {
                    this.warnings.push(`Expected a flattened spec, found a reference at: ${getReadableLocation(newJsonPath)}`);
                }
            }
        }
        if (exports.OAS3.isObjectType(schema.type)) {
            for (let [key, fieldSchema] of Object.entries(schema.properties || {})) {
                const nextJsonPath = json_pointer_helpers_1.jsonPointerHelpers.append(jsonPath, 'properties', key);
                if (!isObject(fieldSchema)) {
                    this.warnings.push(`Expected an object at: ${getReadableLocation(jsonPath)}, nextJsonPath ${fieldSchema}`);
                }
                else if (isNotReferenceObject(fieldSchema)) {
                    yield* this.traverseField(fieldSchema, nextJsonPath);
                }
                else {
                    this.warnings.push(`Expected a flattened spec, found a reference at: ${getReadableLocation(nextJsonPath)}`);
                }
            }
        }
        if (exports.OAS3.isArrayType(schema.type)) {
            const arrayItems = schema.items;
            const nextJsonPath = json_pointer_helpers_1.jsonPointerHelpers.append(jsonPath, 'items');
            if (!isObject(arrayItems)) {
                this.warnings.push(`Expected an object at: ${getReadableLocation(nextJsonPath)}, found ${arrayItems}`);
            }
            else if (isNotReferenceObject(arrayItems)) {
                yield* this.traverseSchema(arrayItems, nextJsonPath);
            }
            else {
                this.warnings.push(`Expected a flattened spec, found a reference at: ${getReadableLocation(nextJsonPath)}`);
            }
        }
    }
    *traverseComponentSchema(schema, schemaName) {
        const jsonPath = json_pointer_helpers_1.jsonPointerHelpers.append('', 'components', 'schemas', schemaName);
        const nextJsonPath = json_pointer_helpers_1.jsonPointerHelpers.append(jsonPath, 'example');
        if (!isObject(schema)) {
            this.warnings.push(`Expected an object at: ${getReadableLocation(nextJsonPath)}, found ${schema}`);
        }
        else if (isNotReferenceObject(schema)) {
            if (schema.example) {
                yield {
                    location: {
                        jsonPath: nextJsonPath,
                    },
                    type: 'component-schema-example',
                };
            }
        }
        else {
            this.warnings.push(`Expected a flattened spec, found a reference at: ${getReadableLocation(nextJsonPath)}`);
        }
    }
}
exports.OpenApiV3Traverser = OpenApiV3Traverser;
//# sourceMappingURL=traverser.js.map