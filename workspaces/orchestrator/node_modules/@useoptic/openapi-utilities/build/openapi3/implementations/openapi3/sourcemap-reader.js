"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSourcemapLink = exports.sourcemapReader = exports.resolveJsonPointerInYamlAst = void 0;
const YAML = __importStar(require("yaml-ast-parser"));
const yaml_ast_parser_1 = require("yaml-ast-parser");
const json_pointer_helpers_1 = require("@useoptic/json-pointer-helpers");
const is_url_1 = __importDefault(require("is-url"));
const url_join_1 = __importDefault(require("url-join"));
const chalk_1 = __importDefault(require("chalk"));
const path_1 = __importDefault(require("path"));
function resolveJsonPointerInYamlAst(node, // root ast
pointer) {
    const decoded = json_pointer_helpers_1.jsonPointerHelpers.decode(pointer);
    const isEmpty = decoded.length === 0 || (decoded.length === 1 && decoded[0] === '');
    if (isEmpty)
        return node;
    const found = decoded.reduce((current, path) => {
        if (!current)
            return undefined;
        const node = current.key ? current.value : current;
        const isNumericalKey = !isNaN(Number(path)) && node.hasOwnProperty('items');
        if (isNumericalKey) {
            return node.items[Number(path)];
        }
        else {
            const field = node.mappings.find((i) => i.key.value === path);
            return field;
        }
    }, node);
    return found;
}
exports.resolveJsonPointerInYamlAst = resolveJsonPointerInYamlAst;
function sourcemapReader(sourcemap) {
    const filesToYamlNode = sourcemap.files.reduce((acc, file) => ({
        ...acc,
        [file.path]: YAML.safeLoad(file.contents),
    }), {});
    const rootFileNumber = sourcemap.files.find((i) => i.path === sourcemap.rootFilePath).index;
    const findFile = (jsonPathFromRoot) => {
        const fileResult = findFilePosition(jsonPathFromRoot);
        if (!fileResult)
            return undefined;
        const file = sourcemap.files.find((i) => i.path === fileResult.filePath);
        const node = resolveJsonPointerInYamlAst(filesToYamlNode[file.path], fileResult.startsAt);
        if (node)
            return {
                filePath: file.path,
                astNode: node,
                contents: file.contents,
                startsAt: fileResult.startsAt,
            };
    };
    const findFilePosition = (jsonPathFromRoot) => {
        const decoded = json_pointer_helpers_1.jsonPointerHelpers.decode(jsonPathFromRoot);
        let cursor = {
            currentFile: rootFileNumber,
            pathInRoot: [],
            pathInCurrentFile: [],
        };
        decoded.forEach((component) => {
            const path = json_pointer_helpers_1.jsonPointerHelpers.compile([
                ...cursor.pathInCurrentFile,
                component,
            ]);
            cursor.pathInRoot.push(component);
            const hitRef = sourcemap.refMappings[path];
            if (hitRef) {
                const [file, startingPath] = hitRef;
                cursor.currentFile = file;
                cursor.pathInCurrentFile = json_pointer_helpers_1.jsonPointerHelpers.decode(startingPath);
            }
            else {
                cursor.pathInCurrentFile.push(component);
            }
        });
        const file = sourcemap.files.find((i) => i.index === cursor.currentFile);
        const cursorPath = cursor.pathInCurrentFile[0] === ''
            ? cursor.pathInCurrentFile.slice(1)
            : cursor.pathInCurrentFile;
        const pathInFile = json_pointer_helpers_1.jsonPointerHelpers.compile(cursorPath);
        return {
            filePath: file.path,
            startsAt: pathInFile,
        };
    };
    const findFileAndLines = (jsonPathFromRoot) => {
        const lookupResult = findFile(jsonPathFromRoot);
        if (lookupResult) {
            const astNode = lookupResult.astNode;
            const contents = lookupResult.contents;
            const [startPosition, endPosition] = astNodesToStartEndPosition(astNode);
            const { startLine, endLine } = positionToLine(contents, startPosition, endPosition);
            const result = {
                filePath: lookupResult.filePath,
                startLine,
                endLine,
                startPosition: startPosition,
                endPosition: endPosition,
            };
            return result;
        }
    };
    const findLinesForAstAndContents = (astNode, contents) => {
        const [startPosition, endPosition] = astNodesToStartEndPosition(astNode);
        const { startLine, endLine } = positionToLine(contents, startPosition, endPosition);
        const result = {
            startLine,
            endLine,
            startPosition: startPosition,
            endPosition: endPosition,
        };
        return result;
    };
    return {
        findFile,
        findFilePosition,
        findFileAndLines,
        findLinesForAstAndContents,
    };
}
exports.sourcemapReader = sourcemapReader;
//////////////////////////////////////////////////////////
function positionToLine(contents, start, end) {
    const startLine = (contents.substring(0, start).match(/\n/g) || '').length + 1;
    const endLine = (contents.substring(start, end).match(/\n/g) || '').length + startLine;
    const lines = contents.split(/\r\n|\r|\n/);
    const preview = lines.slice(startLine - 1, endLine).join('\n');
    return {
        startLine,
        endLine,
        preview,
    };
}
function astNodesToStartEndPosition(astNode) {
    try {
        switch (astNode.kind) {
            case yaml_ast_parser_1.Kind.MAP: {
                const map = astNode;
                const end = map.value.mappings[map.value.mappings.length - 1]?.endPosition ||
                    astNode.endPosition;
                return [map.startPosition, end];
            }
            case yaml_ast_parser_1.Kind.SEQ: {
                const seq = astNode;
                const end = seq.items[seq.items.length - 1]?.endPosition || astNode.endPosition;
                return [seq.startPosition, end];
            }
            default:
                return [astNode.startPosition, astNode.endPosition];
        }
    }
    catch {
        return [astNode.startPosition, astNode.endPosition];
    }
}
function getSourcemapLink(sourcemap, options = {}) {
    if ((0, is_url_1.default)(sourcemap.filePath)) {
        return `${chalk_1.default.underline(sourcemap.filePath)} line ${sourcemap.startLine}`;
    }
    else if (options.ciProvider) {
        const pathFromRoot = path_1.default.relative(options.root, sourcemap.filePath);
        return options.ciProvider === 'github'
            ? (0, url_join_1.default)(options.remote, 'tree', options.sha, `${pathFromRoot}#L${sourcemap.startLine}`)
            : (0, url_join_1.default)(options.remote, '-/blob', options.sha, `${pathFromRoot}#L${sourcemap.startLine}`);
    }
    else {
        const relativePath = path_1.default.relative(process.cwd(), sourcemap.filePath);
        return chalk_1.default.underline(`${relativePath}:${sourcemap.startLine}:${sourcemap.startPosition}`);
    }
}
exports.getSourcemapLink = getSourcemapLink;
//# sourceMappingURL=sourcemap-reader.js.map