"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OpenAPITraverser = exports.normalizeOpenApiPath = void 0;
const types_1 = require("../../sdk/types");
const ts_invariant_1 = __importDefault(require("ts-invariant"));
const json_pointer_helpers_1 = require("@useoptic/json-pointer-helpers");
const openapi_types_1 = require("openapi-types");
const traverser_1 = require("../../traverser");
function normalizeOpenApiPath(path) {
    return path
        .split('/')
        .map((pathComponent) => {
        if (pathComponent.startsWith('{') && pathComponent.endsWith('}')) {
            return '{}';
        }
        return pathComponent;
    })
        .join('/');
}
exports.normalizeOpenApiPath = normalizeOpenApiPath;
const getReadableLocation = (jsonPath) => json_pointer_helpers_1.jsonPointerHelpers.decode(jsonPath).join(' > ');
const isNotReferenceObject = (maybeReference) => {
    return !('$ref' in maybeReference);
};
const isObject = (value) => {
    return typeof value === 'object' && !Array.isArray(value) && value !== null;
};
// TODO deprecate this usage of facts
// This is currently used by the rule runner
class OpenAPITraverser {
    constructor() {
        this.format = 'openapi3';
        this.input = undefined;
        this.warnings = [];
    }
    traverse(input) {
        this.input = input;
    }
    *facts() {
        if (!this.input)
            return;
        yield* this.onSpecification(this.input);
        for (let [pathPattern, paths] of Object.entries(this.input.paths || {})) {
            const traverser = this;
            const traverseIfPresent = function* (method) {
                const pathObject = paths?.[method];
                if (pathObject) {
                    yield* traverser.traverseOperations(pathObject, method, pathPattern, {
                        method: method,
                        path: pathPattern,
                    });
                }
            };
            yield* traverseIfPresent(openapi_types_1.OpenAPIV3.HttpMethods.GET);
            yield* traverseIfPresent(openapi_types_1.OpenAPIV3.HttpMethods.PATCH);
            yield* traverseIfPresent(openapi_types_1.OpenAPIV3.HttpMethods.POST);
            yield* traverseIfPresent(openapi_types_1.OpenAPIV3.HttpMethods.PUT);
            yield* traverseIfPresent(openapi_types_1.OpenAPIV3.HttpMethods.DELETE);
            yield* traverseIfPresent(openapi_types_1.OpenAPIV3.HttpMethods.HEAD);
            yield* traverseIfPresent(openapi_types_1.OpenAPIV3.HttpMethods.OPTIONS);
        }
        if (this.input.components && this.input.components.schemas) {
            for (let [name, schema] of Object.entries(this.input.components.schemas)) {
                yield* this.traverseComponentSchema(schema, name);
            }
        }
    }
    *traverseOperations(operation, method, pathPattern, location) {
        const jsonPath = json_pointer_helpers_1.jsonPointerHelpers.append('', 'paths', pathPattern, method);
        this.checkJsonTrail(jsonPath, operation);
        const normalizedPath = normalizeOpenApiPath(pathPattern);
        const conceptualPath = ['operations', normalizedPath, method];
        yield this.onOperation(operation, pathPattern, method, jsonPath, conceptualPath, location);
        yield* this.traverseParameters(operation, json_pointer_helpers_1.jsonPointerHelpers.append(jsonPath, 'parameters'), [...conceptualPath, 'parameters'], location);
        const requestBody = operation.requestBody;
        if (requestBody) {
            if (!isObject(requestBody)) {
                this.warnings.push(`Expected an object at: ${getReadableLocation(json_pointer_helpers_1.jsonPointerHelpers.append(jsonPath, 'requestBody'))}, found ${requestBody}`);
            }
            else if (isNotReferenceObject(requestBody)) {
                for (let [contentType, body] of Object.entries(requestBody.content || {}))
                    yield* this.traverseBody(body, contentType, json_pointer_helpers_1.jsonPointerHelpers.append(jsonPath, 'requestBody', 'content', contentType), [...conceptualPath, contentType], { ...location, inRequest: { body: { contentType } } });
                yield this.onRequest(requestBody, json_pointer_helpers_1.jsonPointerHelpers.append(jsonPath, 'requestBody'), [...conceptualPath, 'requestBody'], { ...location, inRequest: {} });
            }
            else {
                this.warnings.push(`Expected a flattened spec, found a reference at: ${getReadableLocation(json_pointer_helpers_1.jsonPointerHelpers.append(jsonPath, 'requestBody'))}`);
            }
        }
        for (let [statusCode, response] of Object.entries(operation.responses || {})) {
            const nextJsonPath = json_pointer_helpers_1.jsonPointerHelpers.append(jsonPath, 'responses', statusCode);
            if (!isObject(response)) {
                this.warnings.push(`Expected an object at: ${getReadableLocation(nextJsonPath)}, found ${response}`);
            }
            else if (isNotReferenceObject(response)) {
                yield* this.traverseResponse(response, statusCode, nextJsonPath, [...conceptualPath, 'responses', statusCode], { ...location, inResponse: { statusCode } });
            }
            else {
                this.warnings.push(`Expected a flattened spec, found a reference at: ${getReadableLocation(nextJsonPath)}`);
            }
        }
    }
    *traverseResponse(response, statusCode, jsonPath, conceptualPath, location) {
        yield* this.traverseResponseHeaders(response, jsonPath, conceptualPath, location);
        this.checkJsonTrail(jsonPath, response);
        for (let [contentType, body] of Object.entries(response.content || {})) {
            yield* this.traverseBody(body, contentType, json_pointer_helpers_1.jsonPointerHelpers.append(jsonPath, 'content', contentType), [...conceptualPath, contentType], {
                ...location,
                inResponse: {
                    statusCode: location.inResponse.statusCode,
                    body: { contentType },
                },
            });
        }
        yield this.onResponse(response, statusCode, jsonPath, conceptualPath, location);
    }
    *traverseParameters(operation, jsonPath, conceptualPath, location) {
        const locationForParameter = (parameter) => {
            let paramLocation;
            if (parameter.in === 'query') {
                paramLocation = { ...location, inRequest: { query: parameter.name } };
            }
            else if (parameter.in === 'header') {
                paramLocation = {
                    ...location,
                    inRequest: { header: parameter.name },
                };
            }
            else if (parameter.in === 'path') {
                paramLocation = { ...location, inRequest: { path: parameter.name } };
            }
            else if (parameter.in === 'cookie') {
                paramLocation = { ...location, inRequest: { cookie: parameter.name } };
            }
            else {
                this.warnings.push('Found a parameter that was not handled');
                return;
            }
            return paramLocation;
        };
        if (operation.parameters) {
            this.checkJsonTrail(jsonPath, operation.parameters);
            for (let [i, parameter] of Object.entries(operation.parameters)) {
                const nextJsonPath = json_pointer_helpers_1.jsonPointerHelpers.append(jsonPath, i);
                if (!isObject(parameter)) {
                    this.warnings.push(`Expected an object at: ${getReadableLocation(nextJsonPath)}, found ${parameter}`);
                }
                else if (isNotReferenceObject(parameter)) {
                    const location = locationForParameter(parameter);
                    if (location) {
                        let fact = this.onRequestParameter(parameter, nextJsonPath, [...conceptualPath, parameter.in, parameter.name], location);
                        if (fact)
                            yield fact;
                    }
                }
                else {
                    this.warnings.push(`Expected a flattened spec, found a reference at: ${getReadableLocation(nextJsonPath)}`);
                }
            }
        }
        const sharedParametersPointer = json_pointer_helpers_1.jsonPointerHelpers.compile([
            'paths',
            location.path,
            'parameters',
        ]);
        const sharedParameters = json_pointer_helpers_1.jsonPointerHelpers.tryGet(this.input, sharedParametersPointer);
        if (sharedParameters.match) {
            const shared = sharedParameters.value;
            for (let [i, parameter] of Object.entries(shared)) {
                const location = locationForParameter(parameter);
                if (location) {
                    let fact = this.onRequestParameter(parameter, json_pointer_helpers_1.jsonPointerHelpers.append(sharedParametersPointer, i.toString()), [...conceptualPath, parameter.in, parameter.name], location);
                    if (fact)
                        yield fact;
                }
            }
        }
    }
    onRequestParameter(parameter, jsonPath, conceptualPath, location) {
        this.checkJsonTrail(jsonPath, parameter);
        const value = {
            ...parameter,
        };
        switch (parameter.in) {
            case 'query':
                return {
                    location: {
                        jsonPath,
                        conceptualPath,
                        kind: types_1.OpenApiKind.QueryParameter,
                        conceptualLocation: location,
                    },
                    value,
                };
            case 'header':
                return {
                    location: {
                        jsonPath,
                        conceptualPath,
                        kind: types_1.OpenApiKind.HeaderParameter,
                        conceptualLocation: location,
                    },
                    value,
                };
            case 'path':
                return {
                    location: {
                        jsonPath,
                        conceptualPath,
                        kind: types_1.OpenApiKind.PathParameter,
                        conceptualLocation: location,
                    },
                    value,
                };
            case 'cookie':
                return {
                    location: {
                        jsonPath,
                        conceptualPath,
                        kind: types_1.OpenApiKind.CookieParameter,
                        conceptualLocation: location,
                    },
                    value,
                };
        }
    }
    *traverseResponseHeaders(response, jsonPath, conceptualPath, location) {
        if (response.headers) {
            for (let [name, header] of Object.entries(response.headers)) {
                const nextJsonPath = json_pointer_helpers_1.jsonPointerHelpers.append(jsonPath, 'headers', name);
                if (!isObject(header)) {
                    this.warnings.push(`Expected an object at: ${getReadableLocation(nextJsonPath)}, found ${header}`);
                }
                else if (isNotReferenceObject(header)) {
                    yield this.onResponseHeader(name, header, nextJsonPath, [...conceptualPath, 'headers', name], {
                        ...location,
                        inResponse: {
                            statusCode: location.inResponse.statusCode,
                            header: name,
                        },
                    });
                }
                else {
                    this.warnings.push(`Expected a flattened spec, found a reference at: ${getReadableLocation(nextJsonPath)}`);
                }
            }
        }
    }
    onResponseHeader(name, header, jsonPath, conceptualPath, location) {
        this.checkJsonTrail(jsonPath, header);
        const value = {
            name,
            ...header,
        };
        return {
            location: {
                jsonPath,
                conceptualPath,
                kind: types_1.OpenApiKind.ResponseHeader,
                conceptualLocation: location,
            },
            value,
        };
    }
    *traverseBody(body, contentType, jsonPath, conceptualPath, location) {
        this.checkJsonTrail(jsonPath, body);
        const { schema, examples, example } = body;
        if (schema) {
            const nextJsonPath = json_pointer_helpers_1.jsonPointerHelpers.append(jsonPath, 'schema');
            if (!isObject(schema)) {
                this.warnings.push(`Expected an object at: ${getReadableLocation(nextJsonPath)}, found ${schema}`);
            }
            else if (isNotReferenceObject(schema)) {
                yield this.onSchema(schema, nextJsonPath, conceptualPath, {
                    ...location,
                    jsonSchemaTrail: [],
                    context: {
                        type: 'body',
                    },
                });
                yield this.onContentForBody(schema, contentType, jsonPath, conceptualPath, location);
                yield* this.traverseSchema(schema, nextJsonPath, conceptualPath, {
                    ...location,
                    jsonSchemaTrail: [],
                });
            }
            else {
                this.warnings.push(`Expected a flattened spec, found a reference at: ${getReadableLocation(nextJsonPath)}`);
            }
        }
        if (examples) {
            for (let [name, example] of Object.entries(examples)) {
                const nextJsonPath = json_pointer_helpers_1.jsonPointerHelpers.append(jsonPath, 'examples', name);
                if (!isObject(example)) {
                    this.warnings.push(`Expected an object at: ${getReadableLocation(nextJsonPath)}, found ${example}`);
                }
                else if (isNotReferenceObject(example)) {
                    yield this.onBodyExample(example, contentType, nextJsonPath, [...conceptualPath, 'examples', name], { ...location, name }, name);
                }
                else {
                    this.warnings.push(`Expected a flattened spec, found a reference at: ${getReadableLocation(nextJsonPath)}`);
                }
            }
        }
        if (example) {
            yield this.onBodyExample({ value: example }, contentType, json_pointer_helpers_1.jsonPointerHelpers.append(jsonPath, 'example'), [...conceptualPath, 'example'], { ...location, singular: true });
        }
    }
    *traverseField(key, schema, required, jsonPath, conceptualPath, location) {
        this.checkJsonTrail(jsonPath, schema);
        yield this.onSchema(schema, jsonPath, conceptualPath, {
            ...location,
            context: {
                type: 'field',
                key,
                required,
            },
        });
        yield this.onField(key, schema, required, jsonPath, conceptualPath, location);
        yield* this.traverseSchema(schema, jsonPath, conceptualPath, location);
    }
    *traverseSchema(schema, jsonPath, conceptualPath, location) {
        this.checkJsonTrail(jsonPath, schema);
        if (schema.oneOf || schema.anyOf || schema.allOf) {
            const schemas = [
                { branchType: 'oneOf', schemas: schema.oneOf },
                { branchType: 'anyOf', schemas: schema.anyOf },
                { branchType: 'allOf', schemas: schema.allOf },
            ].flatMap(({ branchType, schemas }) => {
                if (!schemas)
                    schemas = [];
                return schemas.map((schema, branchIndex) => ({
                    branchType,
                    branchIndex,
                    branchSchema: schema,
                }));
            });
            for (let { branchType, branchIndex, branchSchema } of schemas) {
                const newJsonPath = json_pointer_helpers_1.jsonPointerHelpers.append(jsonPath, branchType, '' + branchIndex);
                const newConceptualPath = [
                    ...conceptualPath,
                    branchType,
                    '' + branchIndex,
                ];
                if (!isObject(branchSchema)) {
                    this.warnings.push(`Expected an object at: ${getReadableLocation(newJsonPath)}, found ${branchSchema}`);
                }
                else if (isNotReferenceObject(branchSchema)) {
                    yield this.onSchema(branchSchema, newJsonPath, newConceptualPath, {
                        ...location,
                        context: { type: branchType },
                    });
                    yield* this.traverseSchema(branchSchema, newJsonPath, newConceptualPath, location);
                }
                else {
                    this.warnings.push(`Expected a flattened spec, found a reference at: ${getReadableLocation(newJsonPath)}`);
                }
            }
        }
        if (traverser_1.OAS3.isObjectType(schema.type)) {
            for (let [key, fieldSchema] of Object.entries(schema.properties || {})) {
                const nextJsonPath = json_pointer_helpers_1.jsonPointerHelpers.append(jsonPath, 'properties', key);
                if (!isObject(fieldSchema)) {
                    this.warnings.push(`Expected an object at: ${getReadableLocation(jsonPath)}, nextJsonPath ${fieldSchema}`);
                }
                else if (isNotReferenceObject(fieldSchema)) {
                    yield* this.traverseField(key, fieldSchema, (schema.required || []).includes(key), nextJsonPath, [...conceptualPath, key], {
                        ...location,
                        jsonSchemaTrail: [...(location.jsonSchemaTrail || []), key],
                    });
                }
                else {
                    this.warnings.push(`Expected a flattened spec, found a reference at: ${getReadableLocation(nextJsonPath)}`);
                }
            }
        }
        if (traverser_1.OAS3.isArrayType(schema.type)) {
            const arrayItems = schema.items;
            const nextJsonPath = json_pointer_helpers_1.jsonPointerHelpers.append(jsonPath, 'items');
            if (!isObject(arrayItems)) {
                this.warnings.push(`Expected an object at: ${getReadableLocation(nextJsonPath)}, found ${arrayItems}`);
            }
            else if (isNotReferenceObject(arrayItems)) {
                const nextConceptualPath = [...conceptualPath, 'items'];
                const nextLocation = {
                    ...location,
                    jsonSchemaTrail: [...(location.jsonSchemaTrail || []), 'items'],
                };
                yield this.onSchema(arrayItems, nextJsonPath, nextConceptualPath, {
                    ...nextLocation,
                    context: { type: 'array' },
                });
                yield* this.traverseSchema(arrayItems, nextJsonPath, nextConceptualPath, nextLocation);
            }
            else {
                this.warnings.push(`Expected a flattened spec, found a reference at: ${getReadableLocation(nextJsonPath)}`);
            }
        }
    }
    *traverseComponentSchema(schema, schemaName) {
        const jsonPath = json_pointer_helpers_1.jsonPointerHelpers.append('', 'components', 'schemas', schemaName);
        const conceptualPath = json_pointer_helpers_1.jsonPointerHelpers.decode(jsonPath);
        const conceptualLocation = { inComponentSchema: { schemaName } };
        const nextJsonPath = json_pointer_helpers_1.jsonPointerHelpers.append(jsonPath, 'example');
        if (!isObject(schema)) {
            this.warnings.push(`Expected an object at: ${getReadableLocation(nextJsonPath)}, found ${schema}`);
        }
        else if (isNotReferenceObject(schema)) {
            this.checkJsonTrail(jsonPath, schema);
            if (schema.example) {
                yield this.onComponentSchemaExample(schema.example, nextJsonPath, [...conceptualPath, 'example'], conceptualLocation);
            }
        }
        else {
            this.warnings.push(`Expected a flattened spec, found a reference at: ${getReadableLocation(nextJsonPath)}`);
        }
    }
    ///////////////////////////////////////////////////////////////////////////////////
    *onSpecification(specification) {
        yield {
            location: {
                jsonPath: '',
                conceptualPath: [],
                conceptualLocation: {},
                kind: types_1.OpenApiKind.Specification,
            },
            value: this.getSpecificationFact(specification),
        };
    }
    getSpecificationFact(specification) {
        const { paths, components, ...specificationFact } = specification;
        return specificationFact;
    }
    getSchemaFact(schema) {
        const hasNullableSet = 'nullable' in schema && Boolean(schema.nullable);
        const baseSchema = (() => {
            if (schema.type === 'array') {
                const { items, required, properties, 
                // @ts-ignore
                nullable, ...schemaFact } = schema;
                return schemaFact;
            }
            else {
                const { required, properties, 
                // @ts-ignore
                nullable, ...schemaFact } = schema;
                return schemaFact;
            }
        })();
        const typeOverride = (() => {
            if (hasNullableSet && typeof baseSchema.type === 'string') {
                return [baseSchema.type, 'null'];
            }
            else if (hasNullableSet && !baseSchema.type) {
                return ['null'];
            }
            return baseSchema.type;
        })();
        if (typeOverride)
            return { ...baseSchema, type: typeOverride };
        return baseSchema;
    }
    onContentForBody(schema, contentType, jsonPath, conceptualPath, location) {
        const flatSchema = this.getSchemaFact(schema);
        const value = {
            contentType,
            flatSchema,
        };
        return {
            location: {
                jsonPath,
                conceptualPath,
                kind: types_1.OpenApiKind.Body,
                conceptualLocation: location,
            },
            value,
        };
    }
    onSchema(schema, jsonPath, conceptualPath, location) {
        const flatSchema = this.getSchemaFact(schema);
        return {
            value: {
                flatSchema,
            },
            location: {
                jsonPath,
                conceptualPath,
                conceptualLocation: location,
                kind: types_1.OpenApiKind.Schema,
            },
        };
    }
    onBodyExample(example, contentType, jsonPath, conceptualPath, conceptualLocation, name) {
        return {
            value: {
                contentType,
                name,
                ...example,
            },
            location: {
                jsonPath,
                conceptualPath,
                kind: types_1.OpenApiKind.BodyExample,
                conceptualLocation,
            },
        };
    }
    onField(key, schema, required, jsonPath, conceptualPath, location) {
        this.checkJsonTrail(jsonPath, schema);
        const flatSchema = this.getSchemaFact(schema);
        const value = {
            key,
            flatSchema,
            required,
        };
        return {
            location: {
                jsonPath,
                conceptualPath,
                kind: types_1.OpenApiKind.Field,
                conceptualLocation: location,
            },
            value,
        };
    }
    getOperationFact(operation) {
        const { parameters, requestBody, responses, ...operationFact } = operation;
        return operationFact;
    }
    onOperation(operation, pathPattern, method, jsonPath, conceptualPath, location) {
        this.checkJsonTrail(jsonPath, operation);
        const flatOperation = this.getOperationFact(operation);
        const value = {
            ...flatOperation,
            method,
            pathPattern,
        };
        return {
            location: {
                jsonPath,
                conceptualPath,
                kind: types_1.OpenApiKind.Operation,
                conceptualLocation: location,
            },
            value,
        };
    }
    onRequest(request, jsonPath, conceptualPath, location) {
        this.checkJsonTrail(jsonPath, request);
        const flatRequest = this.getRequestFact(request);
        const value = {
            ...flatRequest,
        };
        return {
            location: {
                jsonPath,
                conceptualPath,
                kind: types_1.OpenApiKind.Request,
                conceptualLocation: location,
            },
            value,
        };
    }
    getRequestFact(request) {
        const { content, ...requestFact } = request;
        return requestFact;
    }
    onResponse(response, statusCode, jsonPath, conceptualPath, location) {
        this.checkJsonTrail(jsonPath, response);
        const flatResponse = this.getResponseFact(response);
        const value = {
            ...flatResponse,
            statusCode,
        };
        return {
            location: {
                jsonPath,
                conceptualPath,
                kind: types_1.OpenApiKind.Response,
                conceptualLocation: location,
            },
            value,
        };
    }
    getResponseFact(response) {
        const { headers, content, ...responseFact } = response;
        return responseFact;
    }
    onComponentSchemaExample(example, jsonPath, conceptualPath, conceptualLocation) {
        return {
            value: example,
            location: {
                jsonPath,
                conceptualPath,
                kind: types_1.OpenApiKind.ComponentSchemaExample,
                conceptualLocation,
            },
        };
    }
    // helper
    checkJsonTrail(jsonPath, mustShareIdentity) {
        (0, ts_invariant_1.default)(json_pointer_helpers_1.jsonPointerHelpers.get(this.input, jsonPath.toString()) === mustShareIdentity, `json trail is not being set properly at ${jsonPath}`);
    }
}
exports.OpenAPITraverser = OpenAPITraverser;
//# sourceMappingURL=openapi-traverser.js.map