"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.groupDiffsByEndpoint = exports.GroupedDiffs = exports.getEndpointRules = exports.getEndpointDiffs = exports.typeofV3Diffs = void 0;
const json_pointer_helpers_1 = require("@useoptic/json-pointer-helpers");
const openapi_types_1 = require("openapi-types");
const diff_1 = require("../diff/diff");
const json_path_interpreters_1 = require("./json-path-interpreters");
const traverser_1 = require("./traverser");
const id_1 = require("../utilities/id");
const openapi_traverser_1 = require("./implementations/openapi3/openapi-traverser");
function constructTree(spec) {
    const traverser = new traverser_1.OpenApiV3Traverser();
    traverser.traverse(spec);
    return (0, json_path_interpreters_1.constructFactTree)([...traverser.facts()]);
}
function typeofV3Diffs(diffs) {
    for (const diff of diffs) {
        if (diff.trail === '') {
            return (0, diff_1.typeofDiff)(diff);
        }
    }
    return diffs.length > 0 ? 'changed' : null;
}
exports.typeofV3Diffs = typeofV3Diffs;
function getEndpointDiffs(endpoint) {
    const items = [
        ...endpoint.diffs,
        ...endpoint.request.diffs,
        ...[
            ...Object.values(endpoint.queryParameters),
            ...Object.values(endpoint.cookieParameters),
            ...Object.values(endpoint.pathParameters),
            ...Object.values(endpoint.headerParameters),
        ].flatMap((r) => r.diffs),
    ];
    for (const content of Object.values(endpoint.request.contents)) {
        items.push(...content.examples.diffs);
        items.push(...Object.values(content.fields).flatMap((r) => r.diffs));
    }
    for (const response of Object.values(endpoint.responses)) {
        items.push(...response.diffs, ...Object.values(response.headers).flatMap((r) => r.diffs));
        for (const content of Object.values(response.contents)) {
            items.push(...content.examples.diffs);
            items.push(...Object.values(content.fields).flatMap((r) => r.diffs));
        }
    }
    return items;
}
exports.getEndpointDiffs = getEndpointDiffs;
function getEndpointRules(endpoint) {
    const items = [
        ...endpoint.rules,
        ...endpoint.request.rules,
        ...[
            ...Object.values(endpoint.queryParameters),
            ...Object.values(endpoint.cookieParameters),
            ...Object.values(endpoint.pathParameters),
            ...Object.values(endpoint.headerParameters),
        ].flatMap((r) => r.rules),
    ];
    for (const content of Object.values(endpoint.request.contents)) {
        items.push(...content.examples.rules);
        items.push(...Object.values(content.fields).flatMap((r) => r.rules));
    }
    for (const response of Object.values(endpoint.responses)) {
        items.push(...response.rules, ...Object.values(response.headers).flatMap((r) => r.rules));
        for (const content of Object.values(response.contents)) {
            items.push(...content.examples.rules);
            items.push(...Object.values(content.fields).flatMap((r) => r.rules));
        }
    }
    return items;
}
exports.getEndpointRules = getEndpointRules;
class GroupedDiffs {
    constructor() {
        this.endpoints = {};
        this.specification = { diffs: [], rules: [] };
        this.unmatched = { diffs: [], rules: [] };
    }
    getOrSetEndpoint(e) {
        const endpointId = (0, id_1.getEndpointId)({
            path: (0, openapi_traverser_1.normalizeOpenApiPath)(e.path),
            method: e.method,
        });
        if (this.endpoints[endpointId]) {
            return this.endpoints[endpointId];
        }
        else {
            const { path, method } = e;
            const endpoint = {
                method: method.toUpperCase(),
                path,
                diffs: [],
                rules: [],
                queryParameters: {},
                pathParameters: {},
                cookieParameters: {},
                headerParameters: {},
                request: {
                    diffs: [],
                    rules: [],
                    contents: {},
                },
                responses: {},
            };
            this.endpoints[endpointId] = endpoint;
            return endpoint;
        }
    }
    getOrSetRequestBody(e, contentType) {
        const endpoint = this.getOrSetEndpoint(e);
        if (endpoint.request.contents[contentType]) {
            return endpoint.request.contents[contentType];
        }
        else {
            const requestBody = {
                fields: {},
                examples: { diffs: [], rules: [] },
            };
            endpoint.request.contents[contentType] = requestBody;
            return requestBody;
        }
    }
    getOrSetResponse(e, statusCode) {
        const endpoint = this.getOrSetEndpoint(e);
        if (endpoint.responses[statusCode]) {
            return endpoint.responses[statusCode];
        }
        else {
            const response = {
                diffs: [],
                rules: [],
                headers: {},
                contents: {},
            };
            endpoint.responses[statusCode] = response;
            return response;
        }
    }
    getOrSetResponseBody(e, statusCode, contentType) {
        const response = this.getOrSetResponse(e, statusCode);
        if (response.contents[contentType]) {
            return response.contents[contentType];
        }
        else {
            const responseBody = {
                fields: {},
                examples: { diffs: [], rules: [] },
            };
            response.contents[contentType] = responseBody;
            return responseBody;
        }
    }
}
exports.GroupedDiffs = GroupedDiffs;
function getParameterName(spec, pointer) {
    // /paths/path/method/parameters/n
    const parts = json_pointer_helpers_1.jsonPointerHelpers.decode(pointer);
    const basePointer = parts[2] === 'parameters'
        ? json_pointer_helpers_1.jsonPointerHelpers.compile(parts.slice(0, 4))
        : json_pointer_helpers_1.jsonPointerHelpers.compile(parts.slice(0, 5));
    const raw = json_pointer_helpers_1.jsonPointerHelpers.get(spec, basePointer);
    return raw.name;
}
function normalizeRequiredDiff(spec, fact, pointers) {
    const trailParts = json_pointer_helpers_1.jsonPointerHelpers.decode(pointers.trail);
    const maybeBaseRequiredPath = fact.type === 'body' && trailParts[1] === 'required'
        ? json_pointer_helpers_1.jsonPointerHelpers.append(fact.location.jsonPath, 'schema')
        : fact.type === 'field' && trailParts[0] === 'required'
            ? fact.location.jsonPath
            : null;
    const location = (0, traverser_1.getLocation)(fact);
    if (!maybeBaseRequiredPath) {
        return null;
    }
    const expectAnArray = (fact.type === 'body' && trailParts.length === 2) ||
        (fact.type === 'field' && trailParts.length === 1);
    const expectAString = (fact.type === 'body' && trailParts.length === 3) ||
        (fact.type === 'field' && trailParts.length === 2);
    // fetch the required keys
    const raw = json_pointer_helpers_1.jsonPointerHelpers.get(spec, pointers.absolute);
    const bodyPath = fact.location.jsonPath.replace('trail' in location ? json_pointer_helpers_1.jsonPointerHelpers.compile(location.trail) : '', '');
    // Here we'll need to check if the required added is valid and maybe fan out keys to add
    if ((Array.isArray(raw) && expectAnArray) ||
        (typeof raw === 'string' && expectAString)) {
        const keysToTest = Array.isArray(raw)
            ? raw.filter((k) => typeof k === 'string')
            : [raw];
        return keysToTest
            .map((k) => json_pointer_helpers_1.jsonPointerHelpers.append(maybeBaseRequiredPath, 'properties', k))
            .filter((p) => json_pointer_helpers_1.jsonPointerHelpers.tryGet(spec, p).match)
            .map((p) => json_pointer_helpers_1.jsonPointerHelpers.relative(p, bodyPath));
    }
    else {
        return [];
    }
}
function groupDiffsByEndpoint(specs, diffs, rules) {
    const fromTree = constructTree(specs.from);
    const toTree = constructTree(specs.to);
    const grouped = new GroupedDiffs();
    const diffsAndRulesToAdd = [];
    for (const diff of diffs) {
        const fact = diff.after !== undefined
            ? (0, json_path_interpreters_1.getFactForJsonPath)(diff.after, toTree)
            : (0, json_path_interpreters_1.getFactForJsonPath)(diff.before, fromTree);
        const isComponentDiff = /^\/components/i.test(diff.after ?? diff.before);
        if (fact && !isComponentDiff) {
            const specToFetchFrom = diff.after !== undefined ? specs.to : specs.from;
            const trail = json_pointer_helpers_1.jsonPointerHelpers.relative(diff.after ?? diff.before, fact.location.jsonPath);
            const diffToAdd = { ...diff, trail, change: (0, diff_1.typeofDiff)(diff) };
            diffsAndRulesToAdd.push({
                type: 'diffs',
                item: diffToAdd,
                spec: specToFetchFrom,
                fact,
            });
        }
        else {
            const diffToAdd = {
                ...diff,
                trail: diff.after ?? diff.before,
                change: (0, diff_1.typeofDiff)(diff),
            };
            grouped.unmatched.diffs.push(diffToAdd);
        }
    }
    for (const rule of rules) {
        const fact = rule.location.spec === 'after'
            ? (0, json_path_interpreters_1.getFactForJsonPath)(rule.location.jsonPath, toTree)
            : (0, json_path_interpreters_1.getFactForJsonPath)(rule.location.jsonPath, fromTree);
        const isComponentDiff = /^\/components/i.test(rule.location.jsonPath);
        if (fact && !isComponentDiff) {
            const trail = json_pointer_helpers_1.jsonPointerHelpers.relative(rule.location.jsonPath, fact.location.jsonPath);
            const specToFetchFrom = rule.location.spec === 'after' ? specs.to : specs.from;
            diffsAndRulesToAdd.push({
                type: 'rules',
                item: {
                    ...rule,
                    trail,
                },
                spec: specToFetchFrom,
                fact,
            });
        }
        else {
            const ruleToAdd = { ...rule, trail: rule.location.jsonPath };
            grouped.unmatched.rules.push(ruleToAdd);
        }
    }
    for (const node of diffsAndRulesToAdd) {
        const { fact, item, type, spec: specToFetchFrom } = node;
        if (fact.type === 'specification') {
            type === 'diffs'
                ? grouped.specification.diffs.push(item)
                : grouped.specification.rules.push(item);
        }
        else if (fact.type === 'path') {
            // We have a path fact, but we don't want to have to keep looking up each diff, so we'll "convert" the raw diff
            // and just emit endpoint diffs
            if (type === 'diffs') {
                const { pathPattern } = (0, traverser_1.getLocation)(fact);
                if (item.before !== undefined && item.after === undefined) {
                    const rawPathObject = json_pointer_helpers_1.jsonPointerHelpers.get(specs.from, item.before);
                    if (typeof rawPathObject !== 'object' || rawPathObject === null)
                        continue;
                    for (const method of Object.keys(rawPathObject)) {
                        if (Object.values(openapi_types_1.OpenAPIV3.HttpMethods).includes(method)) {
                            const newDiff = {
                                before: json_pointer_helpers_1.jsonPointerHelpers.append(item.before, method),
                                trail: '',
                                change: 'removed',
                            };
                            const endpoint = grouped.getOrSetEndpoint({
                                path: pathPattern,
                                method,
                            });
                            endpoint.diffs.push(newDiff);
                        }
                    }
                }
                else if (item.before === undefined && item.after !== undefined) {
                    const rawPathObject = json_pointer_helpers_1.jsonPointerHelpers.get(specs.to, item.after);
                    if (typeof rawPathObject !== 'object' || rawPathObject === null)
                        continue;
                    for (const method of Object.keys(rawPathObject)) {
                        if (Object.values(openapi_types_1.OpenAPIV3.HttpMethods).includes(method)) {
                            const newDiff = {
                                after: json_pointer_helpers_1.jsonPointerHelpers.append(item.after, method),
                                trail: '',
                                change: 'added',
                            };
                            const endpoint = grouped.getOrSetEndpoint({
                                path: pathPattern,
                                method,
                            });
                            endpoint.diffs.push(newDiff);
                        }
                    }
                }
            }
        }
        else if (fact.type === 'operation') {
            const { pathPattern, method } = (0, traverser_1.getLocation)(fact);
            const endpoint = grouped.getOrSetEndpoint({ path: pathPattern, method });
            type === 'diffs' ? endpoint.diffs.push(item) : endpoint.rules.push(item);
        }
        else if (fact.type === 'request-header' ||
            fact.type === 'request-query' ||
            fact.type === 'request-cookie' ||
            fact.type === 'request-path') {
            const parameter = fact.type === 'request-header'
                ? 'headerParameters'
                : fact.type === 'request-query'
                    ? 'queryParameters'
                    : fact.type === 'request-cookie'
                        ? 'cookieParameters'
                        : 'pathParameters';
            const { pathPattern, method } = (0, traverser_1.getLocation)(fact);
            const endpoint = grouped.getOrSetEndpoint({ path: pathPattern, method });
            const name = getParameterName(specToFetchFrom, fact.location.jsonPath);
            if (endpoint[parameter][name]) {
                type === 'diffs'
                    ? endpoint[parameter][name].diffs.push(item)
                    : endpoint[parameter][name].rules.push(item);
            }
            else {
                if (type === 'diffs') {
                    endpoint[parameter][name] = { diffs: [item], rules: [] };
                }
                else {
                    endpoint[parameter][name] = { diffs: [], rules: [item] };
                }
            }
        }
        else if (fact.type === 'requestBody') {
            const { pathPattern, method } = (0, traverser_1.getLocation)(fact);
            const endpoint = grouped.getOrSetEndpoint({ path: pathPattern, method });
            type === 'diffs'
                ? endpoint.request.diffs.push(item)
                : endpoint.request.rules.push(item);
        }
        else if (fact.type === 'response') {
            const { pathPattern, method, statusCode } = (0, traverser_1.getLocation)(fact);
            const response = grouped.getOrSetResponse({ path: pathPattern, method }, statusCode);
            type === 'diffs' ? response.diffs.push(item) : response.rules.push(item);
        }
        else if (fact.type === 'response-header') {
            const { pathPattern, method, statusCode, headerName } = (0, traverser_1.getLocation)(fact);
            const response = grouped.getOrSetResponse({ path: pathPattern, method }, statusCode);
            if (response.headers[headerName]) {
                type === 'diffs'
                    ? response.headers[headerName].diffs.push(item)
                    : response.headers[headerName].rules.push(item);
            }
            else {
                if (type === 'diffs') {
                    response.headers[headerName] = { diffs: [item], rules: [] };
                }
                else {
                    response.headers[headerName] = { diffs: [], rules: [item] };
                }
            }
        }
        else if (fact.type === 'body-example' || fact.type === 'body-examples') {
            const location = (0, traverser_1.getLocation)(fact);
            if (type === 'diffs') {
                item.trail = json_pointer_helpers_1.jsonPointerHelpers.join(json_pointer_helpers_1.jsonPointerHelpers.compile(location.trail), item.trail);
            }
            const body = location.location === 'request'
                ? grouped.getOrSetRequestBody({ path: location.pathPattern, method: location.method }, location.contentType)
                : grouped.getOrSetResponseBody({ path: location.pathPattern, method: location.method }, location.statusCode, location.contentType);
            type === 'diffs'
                ? body.examples.diffs.push(item)
                : body.examples.rules.push(item);
        }
        else if (fact.type === 'body' || fact.type === 'field') {
            const location = (0, traverser_1.getLocation)(fact);
            const body = location.location === 'request'
                ? grouped.getOrSetRequestBody({
                    path: location.pathPattern,
                    method: location.method,
                }, location.contentType)
                : grouped.getOrSetResponseBody({
                    path: location.pathPattern,
                    method: location.method,
                }, location.statusCode, location.contentType);
            let fieldKeys;
            if (type === 'diffs') {
                fieldKeys = normalizeRequiredDiff(specToFetchFrom, fact, {
                    absolute: item.after ?? item.before,
                    trail: item.trail,
                }) ?? [
                    'trail' in location ? json_pointer_helpers_1.jsonPointerHelpers.compile(location.trail) : '',
                ];
            }
            else {
                fieldKeys = normalizeRequiredDiff(specToFetchFrom, fact, {
                    absolute: item.location.jsonPath,
                    trail: item.trail,
                }) ?? [
                    'trail' in location ? json_pointer_helpers_1.jsonPointerHelpers.compile(location.trail) : '',
                ];
            }
            for (const fieldKey of fieldKeys) {
                if (body.fields[fieldKey]) {
                    type === 'diffs'
                        ? body.fields[fieldKey].diffs.push(item)
                        : body.fields[fieldKey].rules.push(item);
                }
                else {
                    if (type === 'diffs') {
                        body.fields[fieldKey] = { diffs: [item], rules: [] };
                    }
                    else {
                        body.fields[fieldKey] = { diffs: [], rules: [item] };
                    }
                }
            }
        }
    }
    return grouped;
}
exports.groupDiffsByEndpoint = groupDiffsByEndpoint;
//# sourceMappingURL=group-diff.js.map