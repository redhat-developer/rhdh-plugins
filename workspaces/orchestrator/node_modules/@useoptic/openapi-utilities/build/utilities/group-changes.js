"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.groupChangesAndRules = void 0;
const types_1 = require("../openapi3/sdk/types");
const isType_1 = require("../openapi3/sdk/isType");
const compare_changes_by_path_1 = require("./compare-changes-by-path");
const id_1 = require("./id");
const createEmptyOpenApiChange = (endpoint) => ({
    headers: { hasRules: false, changes: new Map() },
    pathParameters: { hasRules: false, changes: new Map() },
    queryParameters: { hasRules: false, changes: new Map() },
    cookieParameters: { hasRules: false, changes: new Map() },
    request: {
        change: null,
        hasRules: false,
        bodyChanges: new Map(),
    },
    responses: new Map(),
    hasRules: false,
    change: null,
    method: endpoint.method,
    path: endpoint.path,
});
const createEmptyResponseChange = (statusCode) => ({
    change: null,
    hasRules: false,
    contentTypes: new Map(),
    headers: { hasRules: false, changes: new Map() },
    statusCode,
});
const createEmptyBodyChange = (location) => ({
    bodyChange: null,
    hasRules: false,
    fieldChanges: [],
    exampleChanges: [],
    location,
});
function findFieldBodyFact(facts, fieldLocation) {
    const { path, method } = fieldLocation.conceptualLocation;
    if ('inRequest' in fieldLocation.conceptualLocation) {
        const { contentType } = fieldLocation.conceptualLocation.inRequest.body;
        return facts.find((fact) => {
            const isBodyFact = (0, isType_1.isFactVariant)(fact, types_1.OpenApiKind.Body);
            const isMatchingOperation = 'path' in fact.location.conceptualLocation &&
                fact.location.conceptualLocation.path === path &&
                fact.location.conceptualLocation.method === method;
            if (!isBodyFact || !isMatchingOperation) {
                return false;
            }
            const conceptualLocation = fact.location.conceptualLocation;
            return ('inRequest' in conceptualLocation &&
                conceptualLocation.inRequest.body.contentType === contentType);
        });
    }
    else {
        // in the response
        const { statusCode, body: { contentType }, } = fieldLocation.conceptualLocation.inResponse;
        return facts.find((fact) => {
            const isBodyFact = (0, isType_1.isFactVariant)(fact, types_1.OpenApiKind.Body);
            const isMatchingOperation = 'path' in fact.location.conceptualLocation &&
                fact.location.conceptualLocation.path === path &&
                fact.location.conceptualLocation.method === method;
            if (!isBodyFact || !isMatchingOperation) {
                return false;
            }
            const conceptualLocation = fact.location.conceptualLocation;
            return ('inResponse' in conceptualLocation &&
                conceptualLocation.inResponse.body.contentType === contentType &&
                conceptualLocation.inResponse.statusCode === statusCode);
        });
    }
}
const groupChangesAndRules = ({ toFacts, changes, rules, }) => {
    const sortedChanges = [...changes].sort(compare_changes_by_path_1.compareChangesByPath);
    const specification = { changes: [], hasRules: false };
    const groupedChanges = new Map();
    for (const change of sortedChanges) {
        if ((0, isType_1.isChangeVariant)(change, types_1.OpenApiKind.Specification)) {
            specification.changes.push(change);
            continue;
        }
        const path = change.location.conceptualLocation
            .path;
        const method = change.location.conceptualLocation.method;
        if (!path || !method)
            continue;
        const endpointId = (0, id_1.getEndpointId)({ path, method });
        const maybeEndpointChange = groupedChanges.get(endpointId);
        const endpointChange = maybeEndpointChange || createEmptyOpenApiChange({ path, method });
        if ((0, isType_1.isChangeVariant)(change, types_1.OpenApiKind.Operation)) {
            endpointChange.change = change;
        }
        else if ((0, isType_1.isChangeVariant)(change, types_1.OpenApiKind.Body)) {
            if ('inResponse' in change.location.conceptualLocation) {
                const { statusCode, body: { contentType }, } = change.location.conceptualLocation.inResponse;
                const responseChange = endpointChange.responses.get(statusCode) ||
                    createEmptyResponseChange(statusCode);
                const responseBody = responseChange.contentTypes.get(contentType) ||
                    createEmptyBodyChange(change.location);
                responseBody.bodyChange = change;
                responseChange.contentTypes.set(contentType, responseBody);
                endpointChange.responses.set(statusCode, responseChange);
            }
            else {
                // this is a request body
                const { body: { contentType }, } = change.location.conceptualLocation.inRequest;
                const requestBody = endpointChange.request.bodyChanges.get(contentType) ||
                    createEmptyBodyChange(change.location);
                requestBody.bodyChange = change;
                endpointChange.request.bodyChanges.set(contentType, requestBody);
            }
        }
        else if ((0, isType_1.isChangeVariant)(change, types_1.OpenApiKind.PathParameter)) {
            const pathKey = change.location.conceptualLocation.inRequest.path;
            endpointChange.pathParameters.changes.set(pathKey, change);
        }
        else if ((0, isType_1.isChangeVariant)(change, types_1.OpenApiKind.QueryParameter)) {
            const queryKey = change.location.conceptualLocation.inRequest.query;
            endpointChange.queryParameters.changes.set(queryKey, change);
        }
        else if ((0, isType_1.isChangeVariant)(change, types_1.OpenApiKind.CookieParameter)) {
            const cookieKey = change.location.conceptualLocation.inRequest.cookie;
            endpointChange.cookieParameters.changes.set(cookieKey, change);
        }
        else if ((0, isType_1.isChangeVariant)(change, types_1.OpenApiKind.HeaderParameter)) {
            const headerKey = change.location.conceptualLocation.inRequest.header;
            endpointChange.headers.changes.set(headerKey, change);
        }
        else if ((0, isType_1.isChangeVariant)(change, types_1.OpenApiKind.ResponseHeader)) {
            const { statusCode, header } = change.location.conceptualLocation.inResponse;
            const responseChange = endpointChange.responses.get(statusCode) ||
                createEmptyResponseChange(statusCode);
            responseChange.headers.changes.set(header, change);
            endpointChange.responses.set(statusCode, responseChange);
        }
        else if ((0, isType_1.isChangeVariant)(change, types_1.OpenApiKind.Response)) {
            const { statusCode } = change.location.conceptualLocation.inResponse;
            const responseChange = endpointChange.responses.get(statusCode) ||
                createEmptyResponseChange(statusCode);
            responseChange.change = change;
            endpointChange.responses.set(statusCode, responseChange);
        }
        else if ((0, isType_1.isChangeVariant)(change, types_1.OpenApiKind.Field)) {
            if ('inResponse' in change.location.conceptualLocation) {
                const { statusCode, body: { contentType }, } = change.location.conceptualLocation.inResponse;
                const responseChange = endpointChange.responses.get(statusCode) ||
                    createEmptyResponseChange(statusCode);
                const responseBody = responseChange.contentTypes.get(contentType) ||
                    createEmptyBodyChange(findFieldBodyFact(toFacts, change.location).location);
                responseBody.fieldChanges.push(change);
                responseChange.contentTypes.set(contentType, responseBody);
                endpointChange.responses.set(statusCode, responseChange);
            }
            else {
                const { body: { contentType }, } = change.location.conceptualLocation.inRequest;
                const requestBody = endpointChange.request.bodyChanges.get(contentType) ||
                    createEmptyBodyChange(findFieldBodyFact(toFacts, change.location).location);
                requestBody.fieldChanges.push(change);
                endpointChange.request.bodyChanges.set(contentType, requestBody);
            }
        }
        else if ((0, isType_1.isChangeVariant)(change, types_1.OpenApiKind.Request)) {
            endpointChange.request.change = change;
        }
        else if ((0, isType_1.isChangeVariant)(change, types_1.OpenApiKind.BodyExample)) {
            if ('inResponse' in change.location.conceptualLocation) {
                const { statusCode, body: { contentType }, } = change.location.conceptualLocation.inResponse;
                const responseChange = endpointChange.responses.get(statusCode) ||
                    createEmptyResponseChange(statusCode);
                const responseBody = responseChange.contentTypes.get(contentType) ||
                    createEmptyBodyChange(findFieldBodyFact(toFacts, change.location).location);
                responseBody.exampleChanges.push(change);
                responseChange.contentTypes.set(contentType, responseBody);
                endpointChange.responses.set(statusCode, responseChange);
            }
            else {
                const { body: { contentType }, } = change.location.conceptualLocation.inRequest;
                const requestBody = endpointChange.request.bodyChanges.get(contentType) ||
                    createEmptyBodyChange(findFieldBodyFact(toFacts, change.location).location);
                requestBody.exampleChanges.push(change);
                endpointChange.request.bodyChanges.set(contentType, requestBody);
            }
        }
        groupedChanges.set(endpointId, endpointChange);
    }
    for (const rule of rules) {
        if ((0, isType_1.isFactOrChangeVariant)(rule.change, types_1.OpenApiKind.Specification)) {
            specification.hasRules = true;
            continue;
        }
        const path = rule.change.location.conceptualLocation.path;
        const method = rule.change.location.conceptualLocation.method;
        if (!path || !method)
            continue;
        const endpointId = (0, id_1.getEndpointId)({ path, method });
        const maybeEndpoint = groupedChanges.get(endpointId);
        const endpoint = maybeEndpoint || createEmptyOpenApiChange({ path, method });
        if ((0, isType_1.isFactOrChangeVariant)(rule.change, types_1.OpenApiKind.Operation)) {
            endpoint.hasRules = true;
        }
        else if ((0, isType_1.isFactOrChangeVariant)(rule.change, types_1.OpenApiKind.PathParameter)) {
            endpoint.pathParameters.hasRules = true;
        }
        else if ((0, isType_1.isFactOrChangeVariant)(rule.change, types_1.OpenApiKind.QueryParameter)) {
            endpoint.queryParameters.hasRules = true;
        }
        else if ((0, isType_1.isFactOrChangeVariant)(rule.change, types_1.OpenApiKind.CookieParameter)) {
            endpoint.cookieParameters.hasRules = true;
        }
        else if ((0, isType_1.isFactOrChangeVariant)(rule.change, types_1.OpenApiKind.HeaderParameter)) {
            endpoint.headers.hasRules = true;
        }
        else if ((0, isType_1.isFactOrChangeVariant)(rule.change, types_1.OpenApiKind.Request)) {
            endpoint.request.hasRules = true;
        }
        else if ((0, isType_1.isFactOrChangeVariant)(rule.change, types_1.OpenApiKind.Response)) {
            const { statusCode } = rule.change.location.conceptualLocation.inResponse;
            const responseChange = endpoint.responses.get(statusCode) ||
                createEmptyResponseChange(statusCode);
            responseChange.hasRules = true;
            endpoint.responses.set(statusCode, responseChange);
        }
        else if ((0, isType_1.isFactOrChangeVariant)(rule.change, types_1.OpenApiKind.ResponseHeader)) {
            const { statusCode } = rule.change.location.conceptualLocation.inResponse;
            const responseChange = endpoint.responses.get(statusCode) ||
                createEmptyResponseChange(statusCode);
            responseChange.headers.hasRules = true;
            endpoint.responses.set(statusCode, responseChange);
        }
        else if ((0, isType_1.isFactOrChangeVariant)(rule.change, types_1.OpenApiKind.Field) ||
            (0, isType_1.isFactOrChangeVariant)(rule.change, types_1.OpenApiKind.Body) ||
            (0, isType_1.isFactOrChangeVariant)(rule.change, types_1.OpenApiKind.BodyExample)) {
            if ('inResponse' in rule.change.location.conceptualLocation) {
                const { statusCode, body: { contentType }, } = rule.change.location.conceptualLocation.inResponse;
                const responseChange = endpoint.responses.get(statusCode) ||
                    createEmptyResponseChange(statusCode);
                const responseBody = responseChange.contentTypes.get(contentType) ||
                    createEmptyBodyChange(findFieldBodyFact(toFacts, rule.change.location).location);
                responseBody.hasRules = true;
                responseChange.contentTypes.set(contentType, responseBody);
                endpoint.responses.set(statusCode, responseChange);
            }
            else {
                const { body: { contentType }, } = rule.change.location.conceptualLocation.inRequest;
                const requestBody = endpoint.request.bodyChanges.get(contentType) ||
                    createEmptyBodyChange(findFieldBodyFact(toFacts, rule.change.location).location);
                requestBody.hasRules = true;
                endpoint.request.bodyChanges.set(contentType, requestBody);
            }
        }
    }
    return {
        specification,
        changesByEndpoint: groupedChanges,
    };
};
exports.groupChangesAndRules = groupChangesAndRules;
//# sourceMappingURL=group-changes.js.map