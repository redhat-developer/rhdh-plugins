"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getEndpointsChanges = void 0;
const json_pointer_helpers_1 = require("@useoptic/json-pointer-helpers");
const flat_openapi_types_1 = require("../flat-openapi-types");
const getChangeType = (diff) => {
    return diff.after && diff.before
        ? 'changed'
        : diff.after
            ? 'added'
            : 'removed';
};
const isPathChange = (segments) => segments[0] === 'paths';
const isPathExactChange = (segments) => isPathChange(segments) && segments.length === 2;
const isMethodChange = (segments) => isPathChange(segments) &&
    segments.length >= 3 &&
    segments[2].toUpperCase() in flat_openapi_types_1.HttpMethods;
const isMethodExactChange = (segments) => isMethodChange(segments) && segments.length === 3;
const isRequestChange = (segments) => isMethodChange(segments) && segments[3] === 'requestBody';
const isResponseChange = (segments) => isMethodChange(segments) && segments[3] === 'responses';
const isResponseContentChange = (segments) => isResponseChange(segments) && segments[5] === 'content';
const isMethodParameterChange = (segments) => isMethodChange(segments) && segments[3] === 'parameters';
const getParameterValue = (segements, spec) => {
    return json_pointer_helpers_1.jsonPointerHelpers.get(spec, segements);
};
const isExampleChange = (segments) => segments.some((s, ix) => (s === 'example' || s === 'examples') &&
    (segments[ix - 1] === 'items' ||
        segments[ix - 1] === 'components' ||
        segments[ix - 1] === 'schemas' ||
        segments[ix - 1] === 'schema' ||
        segments[ix - 2] === 'content' ||
        segments[ix - 2] === 'schemas' ||
        segments[ix - 2] === 'properties'));
const polymorphicKeywords = ['anyOf', 'oneOf', 'allOf'];
const removePolymorphicPaths = (segments, offset = 0) => {
    const subIx = segments
        .slice(offset)
        .findIndex((s) => polymorphicKeywords.indexOf(s) > -1);
    if (subIx < 0)
        return segments;
    const ix = subIx + offset;
    if (!isNaN(Number(segments[ix + 1]))) {
        return removePolymorphicPaths(segments.slice(0, ix).concat(segments.slice(ix + 2)), ix);
    }
    else
        return removePolymorphicPaths(segments, ix + 1);
};
function getEndpointsChanges(baseSpec, headSpec, diffs) {
    const paths = new Map();
    const getChangeDescription = (segments, spec, fullSegments, changeType) => {
        const isPolymorphicExact = polymorphicKeywords.indexOf(segments[segments.length - 2]) > -1 &&
            !isNaN(Number(segments[segments.length - 1]));
        let outPaths = removePolymorphicPaths(segments.filter((s) => ['schema', 'properties', 'content', 'paths'].indexOf(s) < 0));
        if (isPolymorphicExact) {
            const polymorphicValue = json_pointer_helpers_1.jsonPointerHelpers.get(spec, fullSegments);
            const path = outPaths.map((s) => `\`${s}\``).join('.');
            const valueType = polymorphicValue?.type;
            const typeLabel = valueType ? ` of type \`${valueType}\`` : '';
            const polymorphicType = segments[segments.length - 2];
            return changeType === 'added'
                ? `added an item${typeLabel} to ${path} \`${polymorphicType}\` values`
                : `removed an item${typeLabel} from ${path} \`${polymorphicType}\` values`;
        }
        else if (outPaths[outPaths.length - 2] === 'required' &&
            !isNaN(Number(outPaths[outPaths.length - 1]))) {
            const requiredProperty = json_pointer_helpers_1.jsonPointerHelpers.get(spec, fullSegments);
            const label = changeType === 'added' ? 'is now required' : 'is no longer required';
            return (outPaths
                .slice(0, -2)
                .concat(requiredProperty)
                .map((s) => `\`${s}\``)
                .join('.') + ` ${label}`);
        }
        else if (outPaths[outPaths.length - 2] === 'enum' &&
            !isNaN(Number(outPaths[outPaths.length - 1]))) {
            const enumValue = json_pointer_helpers_1.jsonPointerHelpers.get(spec, fullSegments);
            const path = outPaths
                .slice(0, -2)
                .map((s) => `\`${s}\``)
                .join('.');
            return changeType === 'added'
                ? `added support for new value \`${enumValue}\` on enum ${path}`
                : `removed support for value \`${enumValue}\` from enum ${path}`;
        }
        else if (segments[segments.length - 2] === 'properties') {
            const path = outPaths.map((s) => `\`${s}\``).join('.');
            if (changeType === 'added' || changeType === 'removed') {
                return `${changeType} support for ${path} property`;
            }
            else
                return `changed ${path} property`;
        }
        else {
            const value = json_pointer_helpers_1.jsonPointerHelpers.get(spec, fullSegments);
            const changePreview = changeType === 'changed' &&
                typeof value === 'string' &&
                ['type', 'format'].indexOf(segments[segments.length - 1]) > -1
                ? ` to \`${value}\``
                : ``;
            return `${changeType} ${outPaths
                .map((s) => `\`${s}\``)
                .join('.')}${changePreview}`;
        }
    };
    const getParameterChange = (segments, changeType, spec) => {
        const param = getParameterValue(segments.slice(0, 5), changeType === 'removed' ? baseSpec : headSpec);
        return changeType === 'added' || changeType === 'removed'
            ? `${changeType} \`${param?.name}\` ${param?.in} parameter`
            : `\`${param?.name}\` ${param?.in} parameter: ${getChangeDescription(segments.slice(5), spec, segments, changeType)}`;
    };
    const getRequestBodyChange = (segments, changeType, spec) => {
        let changeDescription = getChangeDescription(segments.slice(6), spec, segments, changeType);
        changeDescription = changeDescription ? `: ${changeDescription}` : '';
        return `\`requestBody\`${changeDescription}`;
    };
    const getResponseChange = (segments, changeType, spec) => {
        if (isResponseContentChange(segments)) {
            let changeDescription = getChangeDescription(segments.slice(Math.min(7, segments.length - 1)), spec, segments, changeType);
            changeDescription = changeDescription ? `: ${changeDescription}` : '';
            return `\`${segments[4]}\` response${changeDescription}`;
        }
        else {
            let changeDescription = getChangeDescription(segments.slice(5), spec, segments, changeType);
            changeDescription = changeDescription ? `: ${changeDescription}` : '';
            return `\`${segments[4]}\` response${changeDescription}`;
        }
    };
    const getChange = (segments, changeType, spec) => {
        return isRequestChange(segments)
            ? getRequestBodyChange(segments, changeType, spec)
            : isResponseChange(segments)
                ? getResponseChange(segments, changeType, spec)
                : isMethodParameterChange(segments)
                    ? getParameterChange(segments, changeType, spec)
                    : isMethodExactChange(segments)
                        ? `${changeType}`
                        : ``;
    };
    for (const diff of diffs) {
        const changeType = getChangeType(diff);
        const segments = changeType === 'removed'
            ? json_pointer_helpers_1.jsonPointerHelpers.decode(diff.before)
            : json_pointer_helpers_1.jsonPointerHelpers.decode(diff.after);
        if (isPathExactChange(segments)) {
            const path = json_pointer_helpers_1.jsonPointerHelpers.get(changeType === 'removed' ? baseSpec : headSpec, segments);
            const methods = [];
            for (const method in flat_openapi_types_1.HttpMethods) {
                if (method.toLowerCase() in path) {
                    methods.push(method);
                }
            }
            for (const method of methods) {
                diffs.push({
                    ...diff,
                    ...(diff.before ? { before: diff.before + `/${method}` } : {}),
                    ...(diff.after ? { after: diff.after + `/${method}` } : {}),
                });
            }
            continue;
        }
        if (!isMethodChange(segments))
            continue;
        if (isExampleChange(segments))
            continue;
        const [, path, method] = segments;
        if (!paths.get(path))
            paths.set(path, new Map());
        const prevPath = paths.get(path);
        const prevMethod = prevPath.get(method) ?? new Set();
        const spec = changeType === 'removed' ? baseSpec : headSpec;
        const change = getChange(segments, changeType, spec);
        if (change)
            prevMethod.add(change);
        prevPath.set(method, prevMethod);
    }
    const endpointChanges = [];
    for (const [path, methods] of paths.entries()) {
        for (const [method, changes] of methods.entries()) {
            if (!changes.size)
                continue;
            endpointChanges.push({
                method,
                path,
                changes,
            });
        }
    }
    return endpointChanges;
}
exports.getEndpointsChanges = getEndpointsChanges;
//# sourceMappingURL=changelog.js.map